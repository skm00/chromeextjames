/*! For license information please see editor.js.LICENSE.txt */
function resizeImage(dataUrl, scale, callback) {
	const img = new Image();
	img.src = dataUrl;

	img.onload = () => {
		// Create a canvas to resize the image
		const canvas = document.createElement("canvas");
		const ctx = canvas.getContext("2d");

		// Set canvas dimensions based on the scale
		canvas.width = img.width * scale;
		canvas.height = img.height * scale;

		// Draw the resized image on the canvas
		ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

		// Convert the canvas to a data URL
		const resizedDataUrl = canvas.toDataURL("image/png", 0.6); // Adjust quality if needed
		callback(resizedDataUrl);
	};

	img.onerror = (error) => {
		console.error("Error resizing image:", error);
	};
}

function dataURLToBlob(dataURL) {
	const [header, base64Data] = dataURL.split(',');

	const binaryData = atob(base64Data);
	const buffer = new ArrayBuffer(binaryData.length);
	const view = new Uint8Array(buffer);

	for (let i = 0; i < binaryData.length; i++) {
		view[i] = binaryData.charCodeAt(i);
	}

	const mimeType = header.split(':')[1].split(';')[0];
	return new Blob([buffer], {
		type: mimeType
	});
}


 
 
 
 

(() => {
	var t = {
			438: (t, e, n) => {
				var r, i, o, a, s, l, c, u, h, f, d, p, g, v, m, y, b = b || {
					version: "5.3.0"
				};
				if (e.fabric = b, "undefined" != typeof document && "undefined" != typeof window) document instanceof("undefined" != typeof HTMLDocument ? HTMLDocument : Document) ? b.document = document : b.document = document.implementation.createHTMLDocument(""), b.window = window;
				else {
					var x = new(n(960).JSDOM)(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), {
						features: {
							FetchExternalResources: ["img"]
						},
						resources: "usable"
					}).window;
					b.document = x.document, b.jsdomImplForWrapper = n(759).implForWrapper, b.nodeCanvas = n(272).Canvas, b.window = x, DOMParser = b.window.DOMParser
				}

				function w(t, e) {
					var n = t.canvas,
						r = e.targetCanvas,
						i = r.getContext("2d");
					i.translate(0, r.height), i.scale(1, -1);
					var o = n.height - r.height;
					i.drawImage(n, 0, o, r.width, r.height, 0, 0, r.width, r.height)
				}

				function C(t, e) {
					var n = e.targetCanvas.getContext("2d"),
						r = e.destinationWidth,
						i = e.destinationHeight,
						o = r * i * 4,
						a = new Uint8Array(this.imageBuffer, 0, o),
						s = new Uint8ClampedArray(this.imageBuffer, 0, o);
					t.readPixels(0, 0, r, i, t.RGBA, t.UNSIGNED_BYTE, a);
					var l = new ImageData(s, r, i);
					n.putImageData(l, 0, 0)
				}
				b.isTouchSupported = "ontouchstart" in b.window || "ontouchstart" in b.document || b.window && b.window.navigator && b.window.navigator.maxTouchPoints > 0, b.isLikelyNode = "undefined" != typeof Buffer && "undefined" == typeof window, b.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], b.DPI = 96, b.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", b.commaWsp = "(?:\\s+,?\\s*|,\\s*)", b.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi, b.reNonWord = /[ \n\.,;!\?\-]/, b.fontPaths = {}, b.iMatrix = [1, 0, 0, 1, 0, 0], b.svgNS = "http://www.w3.org/2000/svg", b.perfLimitSizeTotal = 2097152, b.maxCacheSideLimit = 4096, b.minCacheSideLimit = 256, b.charWidthsCache = {}, b.textureSize = 2048, b.disableStyleCopyPaste = !1, b.enableGLFiltering = !0, b.devicePixelRatio = b.window.devicePixelRatio || b.window.webkitDevicePixelRatio || b.window.mozDevicePixelRatio || 1, b.browserShadowBlurConstant = 1, b.arcToSegmentsCache = {}, b.boundsOfCurveCache = {}, b.cachesBoundsOfCurve = !0, b.forceGLPutImageData = !1, b.initFilterBackend = function() {
						return b.enableGLFiltering && b.isWebglSupported && b.isWebglSupported(b.textureSize) ? (console.log("max texture size: " + b.maxTextureSize), new b.WebglFilterBackend({
							tileSize: b.textureSize
						})) : b.Canvas2dFilterBackend ? new b.Canvas2dFilterBackend : void 0
					}, "undefined" != typeof document && "undefined" != typeof window && (window.fabric = b),
					function() {
						function t(t, e) {
							if (this.__eventListeners[t]) {
								var n = this.__eventListeners[t];
								e ? n[n.indexOf(e)] = !1 : b.util.array.fill(n, !1)
							}
						}

						function e(t, e) {
							var n = function() {
								e.apply(this, arguments), this.off(t, n)
							}.bind(this);
							this.on(t, n)
						}
						b.Observable = {
							fire: function(t, e) {
								if (!this.__eventListeners) return this;
								var n = this.__eventListeners[t];
								if (!n) return this;
								for (var r = 0, i = n.length; r < i; r++) n[r] && n[r].call(this, e || {});
								return this.__eventListeners[t] = n.filter((function(t) {
									return !1 !== t
								})), this
							},
							on: function(t, e) {
								if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length)
									for (var n in t) this.on(n, t[n]);
								else this.__eventListeners[t] || (this.__eventListeners[t] = []), this.__eventListeners[t].push(e);
								return this
							},
							once: function(t, n) {
								if (1 === arguments.length)
									for (var r in t) e.call(this, r, t[r]);
								else e.call(this, t, n);
								return this
							},
							off: function(e, n) {
								if (!this.__eventListeners) return this;
								if (0 === arguments.length)
									for (e in this.__eventListeners) t.call(this, e);
								else if (1 === arguments.length && "object" == typeof arguments[0])
									for (var r in e) t.call(this, r, e[r]);
								else t.call(this, e, n);
								return this
							}
						}
					}(), b.Collection = {
						_objects: [],
						add: function() {
							if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded)
								for (var t = 0, e = arguments.length; t < e; t++) this._onObjectAdded(arguments[t]);
							return this.renderOnAddRemove && this.requestRenderAll(), this
						},
						insertAt: function(t, e, n) {
							var r = this._objects;
							return n ? r[e] = t : r.splice(e, 0, t), this._onObjectAdded && this._onObjectAdded(t), this.renderOnAddRemove && this.requestRenderAll(), this
						},
						remove: function() {
							for (var t, e = this._objects, n = !1, r = 0, i = arguments.length; r < i; r++) - 1 !== (t = e.indexOf(arguments[r])) && (n = !0, e.splice(t, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[r]));
							return this.renderOnAddRemove && n && this.requestRenderAll(), this
						},
						forEachObject: function(t, e) {
							for (var n = this.getObjects(), r = 0, i = n.length; r < i; r++) t.call(e, n[r], r, n);
							return this
						},
						getObjects: function(t) {
							return void 0 === t ? this._objects.concat() : this._objects.filter((function(e) {
								return e.type === t
							}))
						},
						item: function(t) {
							return this._objects[t]
						},
						isEmpty: function() {
							return 0 === this._objects.length
						},
						size: function() {
							return this._objects.length
						},
						contains: function(t, e) {
							return this._objects.indexOf(t) > -1 || !!e && this._objects.some((function(e) {
								return "function" == typeof e.contains && e.contains(t, !0)
							}))
						},
						complexity: function() {
							return this._objects.reduce((function(t, e) {
								return t + (e.complexity ? e.complexity() : 0)
							}), 0)
						}
					}, b.CommonMethods = {
						_setOptions: function(t) {
							for (var e in t) this.set(e, t[e])
						},
						_initGradient: function(t, e) {
							!t || !t.colorStops || t instanceof b.Gradient || this.set(e, new b.Gradient(t))
						},
						_initPattern: function(t, e, n) {
							!t || !t.source || t instanceof b.Pattern ? n && n() : this.set(e, new b.Pattern(t, n))
						},
						_setObject: function(t) {
							for (var e in t) this._set(e, t[e])
						},
						set: function(t, e) {
							return "object" == typeof t ? this._setObject(t) : this._set(t, e), this
						},
						_set: function(t, e) {
							this[t] = e
						},
						toggle: function(t) {
							var e = this.get(t);
							return "boolean" == typeof e && this.set(t, !e), this
						},
						get: function(t) {
							return this[t]
						}
					},
					function(t) {
						var e = Math.sqrt,
							n = Math.atan2,
							r = Math.pow,
							i = Math.PI / 180,
							o = Math.PI / 2;
						b.util = {
							cos: function(t) {
								if (0 === t) return 1;
								switch (t < 0 && (t = -t), t / o) {
									case 1:
									case 3:
										return 0;
									case 2:
										return -1
								}
								return Math.cos(t)
							},
							sin: function(t) {
								if (0 === t) return 0;
								var e = 1;
								switch (t < 0 && (e = -1), t / o) {
									case 1:
										return e;
									case 2:
										return 0;
									case 3:
										return -e
								}
								return Math.sin(t)
							},
							removeFromArray: function(t, e) {
								var n = t.indexOf(e);
								return -1 !== n && t.splice(n, 1), t
							},
							getRandomInt: function(t, e) {
								return Math.floor(Math.random() * (e - t + 1)) + t
							},
							degreesToRadians: function(t) {
								return t * i
							},
							radiansToDegrees: function(t) {
								return t / i
							},
							rotatePoint: function(t, e, n) {
								var r = new b.Point(t.x - e.x, t.y - e.y),
									i = b.util.rotateVector(r, n);
								return new b.Point(i.x, i.y).addEquals(e)
							},
							rotateVector: function(t, e) {
								var n = b.util.sin(e),
									r = b.util.cos(e);
								return {
									x: t.x * r - t.y * n,
									y: t.x * n + t.y * r
								}
							},
							createVector: function(t, e) {
								return new b.Point(e.x - t.x, e.y - t.y)
							},
							calcAngleBetweenVectors: function(t, e) {
								return Math.acos((t.x * e.x + t.y * e.y) / (Math.hypot(t.x, t.y) * Math.hypot(e.x, e.y)))
							},
							getHatVector: function(t) {
								return new b.Point(t.x, t.y).multiply(1 / Math.hypot(t.x, t.y))
							},
							getBisector: function(t, e, n) {
								var r = b.util.createVector(t, e),
									i = b.util.createVector(t, n),
									o = b.util.calcAngleBetweenVectors(r, i),
									a = o * (0 === b.util.calcAngleBetweenVectors(b.util.rotateVector(r, o), i) ? 1 : -1) / 2;
								return {
									vector: b.util.getHatVector(b.util.rotateVector(r, a)),
									angle: o
								}
							},
							projectStrokeOnPoints: function(t, e, n) {
								var r = [],
									i = e.strokeWidth / 2,
									o = e.strokeUniform ? new b.Point(1 / e.scaleX, 1 / e.scaleY) : new b.Point(1, 1),
									a = function(t) {
										var e = i / Math.hypot(t.x, t.y);
										return new b.Point(t.x * e * o.x, t.y * e * o.y)
									};
								return t.length <= 1 || t.forEach((function(s, l) {
									var c, u, h = new b.Point(s.x, s.y);
									0 === l ? (u = t[l + 1], c = n ? a(b.util.createVector(u, h)).addEquals(h) : t[t.length - 1]) : l === t.length - 1 ? (c = t[l - 1], u = n ? a(b.util.createVector(c, h)).addEquals(h) : t[0]) : (c = t[l - 1], u = t[l + 1]);
									var f, d, p = b.util.getBisector(h, c, u),
										g = p.vector,
										v = p.angle;
									if ("miter" === e.strokeLineJoin && (f = -i / Math.sin(v / 2), d = new b.Point(g.x * f * o.x, g.y * f * o.y), Math.hypot(d.x, d.y) / i <= e.strokeMiterLimit)) return r.push(h.add(d)), void r.push(h.subtract(d));
									f = -i * Math.SQRT2, d = new b.Point(g.x * f * o.x, g.y * f * o.y), r.push(h.add(d)), r.push(h.subtract(d))
								})), r
							},
							transformPoint: function(t, e, n) {
								return n ? new b.Point(e[0] * t.x + e[2] * t.y, e[1] * t.x + e[3] * t.y) : new b.Point(e[0] * t.x + e[2] * t.y + e[4], e[1] * t.x + e[3] * t.y + e[5])
							},
							makeBoundingBoxFromPoints: function(t, e) {
								if (e)
									for (var n = 0; n < t.length; n++) t[n] = b.util.transformPoint(t[n], e);
								var r = [t[0].x, t[1].x, t[2].x, t[3].x],
									i = b.util.array.min(r),
									o = b.util.array.max(r) - i,
									a = [t[0].y, t[1].y, t[2].y, t[3].y],
									s = b.util.array.min(a);
								return {
									left: i,
									top: s,
									width: o,
									height: b.util.array.max(a) - s
								}
							},
							invertTransform: function(t) {
								var e = 1 / (t[0] * t[3] - t[1] * t[2]),
									n = [e * t[3], -e * t[1], -e * t[2], e * t[0]],
									r = b.util.transformPoint({
										x: t[4],
										y: t[5]
									}, n, !0);
								return n[4] = -r.x, n[5] = -r.y, n
							},
							toFixed: function(t, e) {
								return parseFloat(Number(t).toFixed(e))
							},
							parseUnit: function(t, e) {
								var n = /\D{0,2}$/.exec(t),
									r = parseFloat(t);
								switch (e || (e = b.Text.DEFAULT_SVG_FONT_SIZE), n[0]) {
									case "mm":
										return r * b.DPI / 25.4;
									case "cm":
										return r * b.DPI / 2.54;
									case "in":
										return r * b.DPI;
									case "pt":
										return r * b.DPI / 72;
									case "pc":
										return r * b.DPI / 72 * 12;
									case "em":
										return r * e;
									default:
										return r
								}
							},
							falseFunction: function() {
								return !1
							},
							getKlass: function(t, e) {
								return t = b.util.string.camelize(t.charAt(0).toUpperCase() + t.slice(1)), b.util.resolveNamespace(e)[t]
							},
							getSvgAttributes: function(t) {
								var e = ["instantiated_by_use", "style", "id", "class"];
								switch (t) {
									case "linearGradient":
										e = e.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
										break;
									case "radialGradient":
										e = e.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
										break;
									case "stop":
										e = e.concat(["offset", "stop-color", "stop-opacity"])
								}
								return e
							},
							resolveNamespace: function(e) {
								if (!e) return b;
								var n, r = e.split("."),
									i = r.length,
									o = t || b.window;
								for (n = 0; n < i; ++n) o = o[r[n]];
								return o
							},
							loadImage: function(t, e, n, r) {
								if (t) {
									var i = b.util.createImage(),
										o = function() {
											e && e.call(n, i, !1), i = i.onload = i.onerror = null
										};
									i.onload = o, i.onerror = function() {
										b.log("Error loading " + i.src), e && e.call(n, null, !0), i = i.onload = i.onerror = null
									}, 0 !== t.indexOf("data") && null != r && (i.crossOrigin = r), "data:image/svg" === t.substring(0, 14) && (i.onload = null, b.util.loadImageInDom(i, o)), i.src = t
								} else e && e.call(n, t)
							},
							loadImageInDom: function(t, e) {
								var n = b.document.createElement("div");
								n.style.width = n.style.height = "1px", n.style.left = n.style.top = "-100%", n.style.position = "absolute", n.appendChild(t), b.document.querySelector("body").appendChild(n), t.onload = function() {
									e(), n.parentNode.removeChild(n), n = null
								}
							},
							enlivenObjects: function(t, e, n, r) {
								var i = [],
									o = 0,
									a = (t = t || []).length;

								function s() {
									++o === a && e && e(i.filter((function(t) {
										return t
									})))
								}
								a ? t.forEach((function(t, e) {
									t && t.type ? b.util.getKlass(t.type, n).fromObject(t, (function(n, o) {
										o || (i[e] = n), r && r(t, n, o), s()
									})) : s()
								})) : e && e(i)
							},
							enlivenObjectEnlivables: function(t, e, n) {
								var r = b.Object.ENLIVEN_PROPS.filter((function(e) {
									return !!t[e]
								}));
								b.util.enlivenObjects(r.map((function(e) {
									return t[e]
								})), (function(t) {
									var i = {};
									r.forEach((function(n, r) {
										i[n] = t[r], e && (e[n] = t[r])
									})), n && n(i)
								}))
							},
							enlivenPatterns: function(t, e) {
								function n() {
									++i === o && e && e(r)
								}
								var r = [],
									i = 0,
									o = (t = t || []).length;
								o ? t.forEach((function(t, e) {
									t && t.source ? new b.Pattern(t, (function(t) {
										r[e] = t, n()
									})) : (r[e] = t, n())
								})) : e && e(r)
							},
							groupSVGElements: function(t, e, n) {
								var r;
								return t && 1 === t.length ? (void 0 !== n && (t[0].sourcePath = n), t[0]) : (e && (e.width && e.height ? e.centerPoint = {
									x: e.width / 2,
									y: e.height / 2
								} : (delete e.width, delete e.height)), r = new b.Group(t, e), void 0 !== n && (r.sourcePath = n), r)
							},
							populateWithProperties: function(t, e, n) {
								if (n && Array.isArray(n))
									for (var r = 0, i = n.length; r < i; r++) n[r] in t && (e[n[r]] = t[n[r]])
							},
							createCanvasElement: function() {
								return b.document.createElement("canvas")
							},
							copyCanvasElement: function(t) {
								var e = b.util.createCanvasElement();
								return e.width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0), e
							},
							toDataURL: function(t, e, n) {
								return t.toDataURL("image/" + e, n)
							},
							createImage: function() {
								return b.document.createElement("img")
							},
							multiplyTransformMatrices: function(t, e, n) {
								return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], n ? 0 : t[0] * e[4] + t[2] * e[5] + t[4], n ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]]
							},
							qrDecompose: function(t) {
								var o = n(t[1], t[0]),
									a = r(t[0], 2) + r(t[1], 2),
									s = e(a),
									l = (t[0] * t[3] - t[2] * t[1]) / s,
									c = n(t[0] * t[2] + t[1] * t[3], a);
								return {
									angle: o / i,
									scaleX: s,
									scaleY: l,
									skewX: c / i,
									skewY: 0,
									translateX: t[4],
									translateY: t[5]
								}
							},
							calcRotateMatrix: function(t) {
								if (!t.angle) return b.iMatrix.concat();
								var e = b.util.degreesToRadians(t.angle),
									n = b.util.cos(e),
									r = b.util.sin(e);
								return [n, r, -r, n, 0, 0]
							},
							calcDimensionsMatrix: function(t) {
								var e = void 0 === t.scaleX ? 1 : t.scaleX,
									n = void 0 === t.scaleY ? 1 : t.scaleY,
									r = [t.flipX ? -e : e, 0, 0, t.flipY ? -n : n, 0, 0],
									i = b.util.multiplyTransformMatrices,
									o = b.util.degreesToRadians;
								return t.skewX && (r = i(r, [1, 0, Math.tan(o(t.skewX)), 1], !0)), t.skewY && (r = i(r, [1, Math.tan(o(t.skewY)), 0, 1], !0)), r
							},
							composeMatrix: function(t) {
								var e = [1, 0, 0, 1, t.translateX || 0, t.translateY || 0],
									n = b.util.multiplyTransformMatrices;
								return t.angle && (e = n(e, b.util.calcRotateMatrix(t))), (1 !== t.scaleX || 1 !== t.scaleY || t.skewX || t.skewY || t.flipX || t.flipY) && (e = n(e, b.util.calcDimensionsMatrix(t))), e
							},
							resetObjectTransform: function(t) {
								t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.rotate(0)
							},
							saveObjectTransform: function(t) {
								return {
									scaleX: t.scaleX,
									scaleY: t.scaleY,
									skewX: t.skewX,
									skewY: t.skewY,
									angle: t.angle,
									left: t.left,
									flipX: t.flipX,
									flipY: t.flipY,
									top: t.top
								}
							},
							isTransparent: function(t, e, n, r) {
								r > 0 && (e > r ? e -= r : e = 0, n > r ? n -= r : n = 0);
								var i, o = !0,
									a = t.getImageData(e, n, 2 * r || 1, 2 * r || 1),
									s = a.data.length;
								for (i = 3; i < s && !1 != (o = a.data[i] <= 0); i += 4);
								return a = null, o
							},
							parsePreserveAspectRatioAttribute: function(t) {
								var e, n = "meet",
									r = t.split(" ");
								return r && r.length && ("meet" !== (n = r.pop()) && "slice" !== n ? (e = n, n = "meet") : r.length && (e = r.pop())), {
									meetOrSlice: n,
									alignX: "none" !== e ? e.slice(1, 4) : "none",
									alignY: "none" !== e ? e.slice(5, 8) : "none"
								}
							},
							clearFabricFontCache: function(t) {
								(t = (t || "").toLowerCase()) ? b.charWidthsCache[t] && delete b.charWidthsCache[t]: b.charWidthsCache = {}
							},
							limitDimsByArea: function(t, e) {
								var n = Math.sqrt(e * t),
									r = Math.floor(e / n);
								return {
									x: Math.floor(n),
									y: r
								}
							},
							capValue: function(t, e, n) {
								return Math.max(t, Math.min(e, n))
							},
							findScaleToFit: function(t, e) {
								return Math.min(e.width / t.width, e.height / t.height)
							},
							findScaleToCover: function(t, e) {
								return Math.max(e.width / t.width, e.height / t.height)
							},
							matrixToSVG: function(t) {
								return "matrix(" + t.map((function(t) {
									return b.util.toFixed(t, b.Object.NUM_FRACTION_DIGITS)
								})).join(" ") + ")"
							},
							removeTransformFromObject: function(t, e) {
								var n = b.util.invertTransform(e),
									r = b.util.multiplyTransformMatrices(n, t.calcOwnMatrix());
								b.util.applyTransformToObject(t, r)
							},
							addTransformToObject: function(t, e) {
								b.util.applyTransformToObject(t, b.util.multiplyTransformMatrices(e, t.calcOwnMatrix()))
							},
							applyTransformToObject: function(t, e) {
								var n = b.util.qrDecompose(e),
									r = new b.Point(n.translateX, n.translateY);
								t.flipX = !1, t.flipY = !1, t.set("scaleX", n.scaleX), t.set("scaleY", n.scaleY), t.skewX = n.skewX, t.skewY = n.skewY, t.angle = n.angle, t.setPositionByOrigin(r, "center", "center")
							},
							sizeAfterTransform: function(t, e, n) {
								var r = t / 2,
									i = e / 2,
									o = [{
										x: -r,
										y: -i
									}, {
										x: r,
										y: -i
									}, {
										x: -r,
										y: i
									}, {
										x: r,
										y: i
									}],
									a = b.util.calcDimensionsMatrix(n),
									s = b.util.makeBoundingBoxFromPoints(o, a);
								return {
									x: s.width,
									y: s.height
								}
							},
							mergeClipPaths: function(t, e) {
								var n = t,
									r = e;
								n.inverted && !r.inverted && (n = e, r = t), b.util.applyTransformToObject(r, b.util.multiplyTransformMatrices(b.util.invertTransform(n.calcTransformMatrix()), r.calcTransformMatrix()));
								var i = n.inverted && r.inverted;
								return i && (n.inverted = r.inverted = !1), new b.Group([n], {
									clipPath: r,
									inverted: i
								})
							},
							hasStyleChanged: function(t, e, n) {
								return n = n || !1, t.fill !== e.fill || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fontSize !== e.fontSize || t.fontFamily !== e.fontFamily || t.fontWeight !== e.fontWeight || t.fontStyle !== e.fontStyle || t.textBackgroundColor !== e.textBackgroundColor || t.deltaY !== e.deltaY || n && (t.overline !== e.overline || t.underline !== e.underline || t.linethrough !== e.linethrough)
							},
							stylesToArray: function(t, e) {
								t = b.util.object.clone(t, !0);
								for (var n = e.split("\n"), r = -1, i = {}, o = [], a = 0; a < n.length; a++)
									if (t[a])
										for (var s = 0; s < n[a].length; s++) {
											r++;
											var l = t[a][s];
											l && Object.keys(l).length > 0 && (b.util.hasStyleChanged(i, l, !0) ? o.push({
												start: r,
												end: r + 1,
												style: l
											}) : o[o.length - 1].end++), i = l || {}
										} else r += n[a].length;
								return o
							},
							stylesFromArray: function(t, e) {
								if (!Array.isArray(t)) return t;
								for (var n = e.split("\n"), r = -1, i = 0, o = {}, a = 0; a < n.length; a++)
									for (var s = 0; s < n[a].length; s++) r++, t[i] && t[i].start <= r && r < t[i].end && (o[a] = o[a] || {}, o[a][s] = Object.assign({}, t[i].style), r === t[i].end - 1 && i++);
								return o
							}
						}
					}(e),
					function() {
						var t = Array.prototype.join,
							e = {
								m: 2,
								l: 2,
								h: 1,
								v: 1,
								c: 6,
								s: 4,
								q: 4,
								t: 2,
								a: 7
							},
							n = {
								m: "l",
								M: "L"
							};

						function r(t, e, n, r, i, o, a, s, l, c, u) {
							var h = b.util.cos(t),
								f = b.util.sin(t),
								d = b.util.cos(e),
								p = b.util.sin(e),
								g = n * i * d - r * o * p + a,
								v = r * i * d + n * o * p + s;
							return ["C", c + l * (-n * i * f - r * o * h), u + l * (-r * i * f + n * o * h), g + l * (n * i * p + r * o * d), v + l * (r * i * p - n * o * d), g, v]
						}

						function i(t, e, n, r) {
							var i = Math.atan2(e, t),
								o = Math.atan2(r, n);
							return o >= i ? o - i : 2 * Math.PI - (i - o)
						}

						function o(t, e, n) {
							for (var o = n[1], a = n[2], s = n[3], l = n[4], c = n[5], u = function(t, e, n, o, a, s, l) {
									var c = Math.PI,
										u = l * c / 180,
										h = b.util.sin(u),
										f = b.util.cos(u),
										d = 0,
										p = 0,
										g = -f * t * .5 - h * e * .5,
										v = -f * e * .5 + h * t * .5,
										m = (n = Math.abs(n)) * n,
										y = (o = Math.abs(o)) * o,
										x = v * v,
										w = g * g,
										C = m * y - m * x - y * w,
										S = 0;
									if (C < 0) {
										var O = Math.sqrt(1 - C / (m * y));
										n *= O, o *= O
									} else S = (a === s ? -1 : 1) * Math.sqrt(C / (m * x + y * w));
									var T = S * n * v / o,
										k = -S * o * g / n,
										F = f * T - h * k + .5 * t,
										P = h * T + f * k + .5 * e,
										j = i(1, 0, (g - T) / n, (v - k) / o),
										A = i((g - T) / n, (v - k) / o, (-g - T) / n, (-v - k) / o);
									0 === s && A > 0 ? A -= 2 * c : 1 === s && A < 0 && (A += 2 * c);
									for (var _ = Math.ceil(Math.abs(A / c * 2)), E = [], D = A / _, M = 8 / 3 * Math.sin(D / 4) * Math.sin(D / 4) / Math.sin(D / 2), I = j + D, R = 0; R < _; R++) E[R] = r(j, I, f, h, n, o, F, P, M, d, p), d = E[R][5], p = E[R][6], j = I, I += D;
									return E
								}(n[6] - t, n[7] - e, o, a, l, c, s), h = 0, f = u.length; h < f; h++) u[h][1] += t, u[h][2] += e, u[h][3] += t, u[h][4] += e, u[h][5] += t, u[h][6] += e;
							return u
						}

						function a(t, e, n, r) {
							return Math.sqrt((n - t) * (n - t) + (r - e) * (r - e))
						}

						function s(t, e, n, r, i, o, a, s) {
							return function(l) {
								var c, u = (c = l) * c * c,
									h = function(t) {
										return 3 * t * t * (1 - t)
									}(l),
									f = function(t) {
										return 3 * t * (1 - t) * (1 - t)
									}(l),
									d = function(t) {
										return (1 - t) * (1 - t) * (1 - t)
									}(l);
								return {
									x: a * u + i * h + n * f + t * d,
									y: s * u + o * h + r * f + e * d
								}
							}
						}

						function l(t, e, n, r, i, o, a, s) {
							return function(l) {
								var c = 1 - l,
									u = 3 * c * c * (n - t) + 6 * c * l * (i - n) + 3 * l * l * (a - i),
									h = 3 * c * c * (r - e) + 6 * c * l * (o - r) + 3 * l * l * (s - o);
								return Math.atan2(h, u)
							}
						}

						function c(t, e, n, r, i, o) {
							return function(a) {
								var s, l = (s = a) * s,
									c = function(t) {
										return 2 * t * (1 - t)
									}(a),
									u = function(t) {
										return (1 - t) * (1 - t)
									}(a);
								return {
									x: i * l + n * c + t * u,
									y: o * l + r * c + e * u
								}
							}
						}

						function u(t, e, n, r, i, o) {
							return function(a) {
								var s = 1 - a,
									l = 2 * s * (n - t) + 2 * a * (i - n),
									c = 2 * s * (r - e) + 2 * a * (o - r);
								return Math.atan2(c, l)
							}
						}

						function h(t, e, n) {
							var r, i, o = {
									x: e,
									y: n
								},
								s = 0;
							for (i = 1; i <= 100; i += 1) r = t(i / 100), s += a(o.x, o.y, r.x, r.y), o = r;
							return s
						}

						function f(t) {
							for (var e, n, r, i, o = 0, f = t.length, d = 0, p = 0, g = 0, v = 0, m = [], y = 0; y < f; y++) {
								switch (r = {
										x: d,
										y: p,
										command: (e = t[y])[0]
									}, e[0]) {
									case "M":
										r.length = 0, g = d = e[1], v = p = e[2];
										break;
									case "L":
										r.length = a(d, p, e[1], e[2]), d = e[1], p = e[2];
										break;
									case "C":
										n = s(d, p, e[1], e[2], e[3], e[4], e[5], e[6]), i = l(d, p, e[1], e[2], e[3], e[4], e[5], e[6]), r.iterator = n, r.angleFinder = i, r.length = h(n, d, p), d = e[5], p = e[6];
										break;
									case "Q":
										n = c(d, p, e[1], e[2], e[3], e[4]), i = u(d, p, e[1], e[2], e[3], e[4]), r.iterator = n, r.angleFinder = i, r.length = h(n, d, p), d = e[3], p = e[4];
										break;
									case "Z":
									case "z":
										r.destX = g, r.destY = v, r.length = a(d, p, g, v), d = g, p = v
								}
								o += r.length, m.push(r)
							}
							return m.push({
								length: o,
								x: d,
								y: p
							}), m
						}
						b.util.joinPath = function(t) {
							return t.map((function(t) {
								return t.join(" ")
							})).join(" ")
						}, b.util.parsePath = function(t) {
							var r, i, o, a, s, l = [],
								c = [],
								u = b.rePathCommand,
								h = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*",
								f = "(" + h + ")" + b.commaWsp,
								d = "([01])" + b.commaWsp + "?",
								p = new RegExp(f + "?" + f + "?" + f + d + d + f + "?(" + h + ")", "g");
							if (!t || !t.match) return l;
							for (var g, v = 0, m = (s = t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi)).length; v < m; v++) {
								a = (r = s[v]).slice(1).trim(), c.length = 0;
								var y = r.charAt(0);
								if (g = [y], "a" === y.toLowerCase())
									for (var x; x = p.exec(a);)
										for (var w = 1; w < x.length; w++) c.push(x[w]);
								else
									for (; o = u.exec(a);) c.push(o[0]);
								w = 0;
								for (var C = c.length; w < C; w++) i = parseFloat(c[w]), isNaN(i) || g.push(i);
								var S = e[y.toLowerCase()],
									O = n[y] || y;
								if (g.length - 1 > S)
									for (var T = 1, k = g.length; T < k; T += S) l.push([y].concat(g.slice(T, T + S))), y = O;
								else l.push(g)
							}
							return l
						}, b.util.makePathSimpler = function(t) {
							var e, n, r, i, a, s, l = 0,
								c = 0,
								u = t.length,
								h = 0,
								f = 0,
								d = [];
							for (n = 0; n < u; ++n) {
								switch (r = !1, (e = t[n].slice(0))[0]) {
									case "l":
										e[0] = "L", e[1] += l, e[2] += c;
									case "L":
										l = e[1], c = e[2];
										break;
									case "h":
										e[1] += l;
									case "H":
										e[0] = "L", e[2] = c, l = e[1];
										break;
									case "v":
										e[1] += c;
									case "V":
										e[0] = "L", c = e[1], e[1] = l, e[2] = c;
										break;
									case "m":
										e[0] = "M", e[1] += l, e[2] += c;
									case "M":
										l = e[1], c = e[2], h = e[1], f = e[2];
										break;
									case "c":
										e[0] = "C", e[1] += l, e[2] += c, e[3] += l, e[4] += c, e[5] += l, e[6] += c;
									case "C":
										a = e[3], s = e[4], l = e[5], c = e[6];
										break;
									case "s":
										e[0] = "S", e[1] += l, e[2] += c, e[3] += l, e[4] += c;
									case "S":
										"C" === i ? (a = 2 * l - a, s = 2 * c - s) : (a = l, s = c), l = e[3], c = e[4], e[0] = "C", e[5] = e[3], e[6] = e[4], e[3] = e[1], e[4] = e[2], e[1] = a, e[2] = s, a = e[3], s = e[4];
										break;
									case "q":
										e[0] = "Q", e[1] += l, e[2] += c, e[3] += l, e[4] += c;
									case "Q":
										a = e[1], s = e[2], l = e[3], c = e[4];
										break;
									case "t":
										e[0] = "T", e[1] += l, e[2] += c;
									case "T":
										"Q" === i ? (a = 2 * l - a, s = 2 * c - s) : (a = l, s = c), e[0] = "Q", l = e[1], c = e[2], e[1] = a, e[2] = s, e[3] = l, e[4] = c;
										break;
									case "a":
										e[0] = "A", e[6] += l, e[7] += c;
									case "A":
										r = !0, d = d.concat(o(l, c, e)), l = e[6], c = e[7];
										break;
									case "z":
									case "Z":
										l = h, c = f
								}
								r || d.push(e), i = e[0]
							}
							return d
						}, b.util.getSmoothPathFromPoints = function(t, e) {
							var n, r = [],
								i = new b.Point(t[0].x, t[0].y),
								o = new b.Point(t[1].x, t[1].y),
								a = t.length,
								s = 1,
								l = 0,
								c = a > 2;
							for (e = e || 0, c && (s = t[2].x < o.x ? -1 : t[2].x === o.x ? 0 : 1, l = t[2].y < o.y ? -1 : t[2].y === o.y ? 0 : 1), r.push(["M", i.x - s * e, i.y - l * e]), n = 1; n < a; n++) {
								if (!i.eq(o)) {
									var u = i.midPointFrom(o);
									r.push(["Q", i.x, i.y, u.x, u.y])
								}
								i = t[n], n + 1 < t.length && (o = t[n + 1])
							}
							return c && (s = i.x > t[n - 2].x ? 1 : i.x === t[n - 2].x ? 0 : -1, l = i.y > t[n - 2].y ? 1 : i.y === t[n - 2].y ? 0 : -1), r.push(["L", i.x + s * e, i.y + l * e]), r
						}, b.util.getPathSegmentsInfo = f, b.util.getBoundsOfCurve = function(e, n, r, i, o, a, s, l) {
							var c;
							if (b.cachesBoundsOfCurve && (c = t.call(arguments), b.boundsOfCurveCache[c])) return b.boundsOfCurveCache[c];
							var u, h, f, d, p, g, v, m, y = Math.sqrt,
								x = Math.min,
								w = Math.max,
								C = Math.abs,
								S = [],
								O = [
									[],
									[]
								];
							h = 6 * e - 12 * r + 6 * o, u = -3 * e + 9 * r - 9 * o + 3 * s, f = 3 * r - 3 * e;
							for (var T = 0; T < 2; ++T)
								if (T > 0 && (h = 6 * n - 12 * i + 6 * a, u = -3 * n + 9 * i - 9 * a + 3 * l, f = 3 * i - 3 * n), C(u) < 1e-12) {
									if (C(h) < 1e-12) continue;
									0 < (d = -f / h) && d < 1 && S.push(d)
								} else(v = h * h - 4 * f * u) < 0 || (0 < (p = (-h + (m = y(v))) / (2 * u)) && p < 1 && S.push(p), 0 < (g = (-h - m) / (2 * u)) && g < 1 && S.push(g));
							for (var k, F, P, j = S.length, A = j; j--;) k = (P = 1 - (d = S[j])) * P * P * e + 3 * P * P * d * r + 3 * P * d * d * o + d * d * d * s, O[0][j] = k, F = P * P * P * n + 3 * P * P * d * i + 3 * P * d * d * a + d * d * d * l, O[1][j] = F;
							O[0][A] = e, O[1][A] = n, O[0][A + 1] = s, O[1][A + 1] = l;
							var _ = [{
								x: x.apply(null, O[0]),
								y: x.apply(null, O[1])
							}, {
								x: w.apply(null, O[0]),
								y: w.apply(null, O[1])
							}];
							return b.cachesBoundsOfCurve && (b.boundsOfCurveCache[c] = _), _
						}, b.util.getPointOnPath = function(t, e, n) {
							n || (n = f(t));
							for (var r = 0; e - n[r].length > 0 && r < n.length - 2;) e -= n[r].length, r++;
							var i, o = n[r],
								s = e / o.length,
								l = o.command,
								c = t[r];
							switch (l) {
								case "M":
									return {
										x: o.x, y: o.y, angle: 0
									};
								case "Z":
								case "z":
									return (i = new b.Point(o.x, o.y).lerp(new b.Point(o.destX, o.destY), s)).angle = Math.atan2(o.destY - o.y, o.destX - o.x), i;
								case "L":
									return (i = new b.Point(o.x, o.y).lerp(new b.Point(c[1], c[2]), s)).angle = Math.atan2(c[2] - o.y, c[1] - o.x), i;
								case "C":
								case "Q":
									return function(t, e) {
										for (var n, r, i, o = 0, s = 0, l = t.iterator, c = {
												x: t.x,
												y: t.y
											}, u = .01, h = t.angleFinder; s < e && u > 1e-4;) n = l(o), i = o, (r = a(c.x, c.y, n.x, n.y)) + s > e ? (o -= u, u /= 2) : (c = n, o += u, s += r);
										return n.angle = h(i), n
									}(o, e)
							}
						}, b.util.transformPath = function(t, e, n) {
							return n && (e = b.util.multiplyTransformMatrices(e, [1, 0, 0, 1, -n.x, -n.y])), t.map((function(t) {
								for (var n = t.slice(0), r = {}, i = 1; i < t.length - 1; i += 2) r.x = t[i], r.y = t[i + 1], r = b.util.transformPoint(r, e), n[i] = r.x, n[i + 1] = r.y;
								return n
							}))
						}
					}(),
					function() {
						var t = Array.prototype.slice;

						function e(t, e, n) {
							if (t && 0 !== t.length) {
								var r = t.length - 1,
									i = e ? t[r][e] : t[r];
								if (e)
									for (; r--;) n(t[r][e], i) && (i = t[r][e]);
								else
									for (; r--;) n(t[r], i) && (i = t[r]);
								return i
							}
						}
						b.util.array = {
							fill: function(t, e) {
								for (var n = t.length; n--;) t[n] = e;
								return t
							},
							invoke: function(e, n) {
								for (var r = t.call(arguments, 2), i = [], o = 0, a = e.length; o < a; o++) i[o] = r.length ? e[o][n].apply(e[o], r) : e[o][n].call(e[o]);
								return i
							},
							min: function(t, n) {
								return e(t, n, (function(t, e) {
									return t < e
								}))
							},
							max: function(t, n) {
								return e(t, n, (function(t, e) {
									return t >= e
								}))
							}
						}
					}(),
					function() {
						function t(e, n, r) {
							if (r)
								if (!b.isLikelyNode && n instanceof Element) e = n;
								else if (n instanceof Array) {
								e = [];
								for (var i = 0, o = n.length; i < o; i++) e[i] = t({}, n[i], r)
							} else if (n && "object" == typeof n)
								for (var a in n) "canvas" === a || "group" === a ? e[a] = null : n.hasOwnProperty(a) && (e[a] = t({}, n[a], r));
							else e = n;
							else
								for (var a in n) e[a] = n[a];
							return e
						}
						b.util.object = {
							extend: t,
							clone: function(e, n) {
								return t({}, e, n)
							}
						}, b.util.object.extend(b.util, b.Observable)
					}(),
					function() {
						function t(t, e) {
							var n = t.charCodeAt(e);
							if (isNaN(n)) return "";
							if (n < 55296 || n > 57343) return t.charAt(e);
							if (55296 <= n && n <= 56319) {
								if (t.length <= e + 1) throw "High surrogate without following low surrogate";
								var r = t.charCodeAt(e + 1);
								if (56320 > r || r > 57343) throw "High surrogate without following low surrogate";
								return t.charAt(e) + t.charAt(e + 1)
							}
							if (0 === e) throw "Low surrogate without preceding high surrogate";
							var i = t.charCodeAt(e - 1);
							if (55296 > i || i > 56319) throw "Low surrogate without preceding high surrogate";
							return !1
						}
						b.util.string = {
							camelize: function(t) {
								return t.replace(/-+(.)?/g, (function(t, e) {
									return e ? e.toUpperCase() : ""
								}))
							},
							capitalize: function(t, e) {
								return t.charAt(0).toUpperCase() + (e ? t.slice(1) : t.slice(1).toLowerCase())
							},
							escapeXml: function(t) {
								return t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
							},
							graphemeSplit: function(e) {
								var n, r = 0,
									i = [];
								for (r = 0; r < e.length; r++) !1 !== (n = t(e, r)) && i.push(n);
								return i
							}
						}
					}(),
					function() {
						var t = Array.prototype.slice,
							e = function() {},
							n = function() {
								for (var t in {
										toString: 1
									})
									if ("toString" === t) return !1;
								return !0
							}(),
							r = function(t, e, r) {
								for (var i in e) i in t.prototype && "function" == typeof t.prototype[i] && (e[i] + "").indexOf("callSuper") > -1 ? t.prototype[i] = function(t) {
									return function() {
										var n = this.constructor.superclass;
										this.constructor.superclass = r;
										var i = e[t].apply(this, arguments);
										if (this.constructor.superclass = n, "initialize" !== t) return i
									}
								}(i) : t.prototype[i] = e[i], n && (e.toString !== Object.prototype.toString && (t.prototype.toString = e.toString), e.valueOf !== Object.prototype.valueOf && (t.prototype.valueOf = e.valueOf))
							};

						function i() {}

						function o(e) {
							for (var n = null, r = this; r.constructor.superclass;) {
								var i = r.constructor.superclass.prototype[e];
								if (r[e] !== i) {
									n = i;
									break
								}
								r = r.constructor.superclass.prototype
							}
							return n ? arguments.length > 1 ? n.apply(this, t.call(arguments, 1)) : n.call(this) : console.log("tried to callSuper " + e + ", method not found in prototype chain", this)
						}
						b.util.createClass = function() {
							var n = null,
								a = t.call(arguments, 0);

							function s() {
								this.initialize.apply(this, arguments)
							}
							"function" == typeof a[0] && (n = a.shift()), s.superclass = n, s.subclasses = [], n && (i.prototype = n.prototype, s.prototype = new i, n.subclasses.push(s));
							for (var l = 0, c = a.length; l < c; l++) r(s, a[l], n);
							return s.prototype.initialize || (s.prototype.initialize = e), s.prototype.constructor = s, s.prototype.callSuper = o, s
						}
					}(), r = !!b.document.createElement("div").attachEvent, i = ["touchstart", "touchmove", "touchend"], b.util.addListener = function(t, e, n, i) {
						t && t.addEventListener(e, n, !r && i)
					}, b.util.removeListener = function(t, e, n, i) {
						t && t.removeEventListener(e, n, !r && i)
					}, b.util.getPointer = function(t) {
						var e = t.target,
							n = b.util.getScrollLeftTop(e),
							r = function(t) {
								var e = t.changedTouches;
								return e && e[0] ? e[0] : t
							}(t);
						return {
							x: r.clientX + n.left,
							y: r.clientY + n.top
						}
					}, b.util.isTouchEvent = function(t) {
						return i.indexOf(t.type) > -1 || "touch" === t.pointerType
					}, a = "string" == typeof(o = b.document.createElement("div")).style.opacity, s = "string" == typeof o.style.filter, l = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, c = function(t) {
						return t
					}, a ? c = function(t, e) {
						return t.style.opacity = e, t
					} : s && (c = function(t, e) {
						var n = t.style;
						return t.currentStyle && !t.currentStyle.hasLayout && (n.zoom = 1), l.test(n.filter) ? (e = e >= .9999 ? "" : "alpha(opacity=" + 100 * e + ")", n.filter = n.filter.replace(l, e)) : n.filter += " alpha(opacity=" + 100 * e + ")", t
					}), b.util.setStyle = function(t, e) {
						var n = t.style;
						if (!n) return t;
						if ("string" == typeof e) return t.style.cssText += ";" + e, e.indexOf("opacity") > -1 ? c(t, e.match(/opacity:\s*(\d?\.?\d*)/)[1]) : t;
						for (var r in e)
							if ("opacity" === r) c(t, e[r]);
							else {
								var i = "float" === r || "cssFloat" === r ? void 0 === n.styleFloat ? "cssFloat" : "styleFloat" : r;
								n.setProperty(i, e[r])
							} return t
					},
					function() {
						var t, e, n, r, i = Array.prototype.slice,
							o = function(t) {
								return i.call(t, 0)
							};
						try {
							t = o(b.document.childNodes) instanceof Array
						} catch (t) {}

						function a(t, e) {
							var n = b.document.createElement(t);
							for (var r in e) "class" === r ? n.className = e[r] : "for" === r ? n.htmlFor = e[r] : n.setAttribute(r, e[r]);
							return n
						}

						function s(t) {
							for (var e = 0, n = 0, r = b.document.documentElement, i = b.document.body || {
									scrollLeft: 0,
									scrollTop: 0
								}; t && (t.parentNode || t.host) && ((t = t.parentNode || t.host) === b.document ? (e = i.scrollLeft || r.scrollLeft || 0, n = i.scrollTop || r.scrollTop || 0) : (e += t.scrollLeft || 0, n += t.scrollTop || 0), 1 !== t.nodeType || "fixed" !== t.style.position););
							return {
								left: e,
								top: n
							}
						}
						t || (o = function(t) {
							for (var e = new Array(t.length), n = t.length; n--;) e[n] = t[n];
							return e
						}), e = b.document.defaultView && b.document.defaultView.getComputedStyle ? function(t, e) {
							var n = b.document.defaultView.getComputedStyle(t, null);
							return n ? n[e] : void 0
						} : function(t, e) {
							var n = t.style[e];
							return !n && t.currentStyle && (n = t.currentStyle[e]), n
						}, n = b.document.documentElement.style, r = "userSelect" in n ? "userSelect" : "MozUserSelect" in n ? "MozUserSelect" : "WebkitUserSelect" in n ? "WebkitUserSelect" : "KhtmlUserSelect" in n ? "KhtmlUserSelect" : "", b.util.makeElementUnselectable = function(t) {
							return void 0 !== t.onselectstart && (t.onselectstart = b.util.falseFunction), r ? t.style[r] = "none" : "string" == typeof t.unselectable && (t.unselectable = "on"), t
						}, b.util.makeElementSelectable = function(t) {
							return void 0 !== t.onselectstart && (t.onselectstart = null), r ? t.style[r] = "" : "string" == typeof t.unselectable && (t.unselectable = ""), t
						}, b.util.setImageSmoothing = function(t, e) {
							t.imageSmoothingEnabled = t.imageSmoothingEnabled || t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled || t.oImageSmoothingEnabled, t.imageSmoothingEnabled = e
						}, b.util.getById = function(t) {
							return "string" == typeof t ? b.document.getElementById(t) : t
						}, b.util.toArray = o, b.util.addClass = function(t, e) {
							t && -1 === (" " + t.className + " ").indexOf(" " + e + " ") && (t.className += (t.className ? " " : "") + e)
						}, b.util.makeElement = a, b.util.wrapElement = function(t, e, n) {
							return "string" == typeof e && (e = a(e, n)), t.parentNode && t.parentNode.replaceChild(e, t), e.appendChild(t), e
						}, b.util.getScrollLeftTop = s, b.util.getElementOffset = function(t) {
							var n, r, i = t && t.ownerDocument,
								o = {
									left: 0,
									top: 0
								},
								a = {
									left: 0,
									top: 0
								},
								l = {
									borderLeftWidth: "left",
									borderTopWidth: "top",
									paddingLeft: "left",
									paddingTop: "top"
								};
							if (!i) return a;
							for (var c in l) a[l[c]] += parseInt(e(t, c), 10) || 0;
							return n = i.documentElement, void 0 !== t.getBoundingClientRect && (o = t.getBoundingClientRect()), r = s(t), {
								left: o.left + r.left - (n.clientLeft || 0) + a.left,
								top: o.top + r.top - (n.clientTop || 0) + a.top
							}
						}, b.util.getNodeCanvas = function(t) {
							var e = b.jsdomImplForWrapper(t);
							return e._canvas || e._image
						}, b.util.cleanUpJsdomNode = function(t) {
							if (b.isLikelyNode) {
								var e = b.jsdomImplForWrapper(t);
								e && (e._image = null, e._canvas = null, e._currentSrc = null, e._attributes = null, e._classList = null)
							}
						}
					}(),
					function() {
						function t() {}
						b.util.request = function(e, n) {
							n || (n = {});
							var r = n.method ? n.method.toUpperCase() : "GET",
								i = n.onComplete || function() {},
								o = new b.window.XMLHttpRequest,
								a = n.body || n.parameters;
							return o.onreadystatechange = function() {
								4 === o.readyState && (i(o), o.onreadystatechange = t)
							}, "GET" === r && (a = null, "string" == typeof n.parameters && (e = function(t, e) {
								return t + (/\?/.test(t) ? "&" : "?") + e
							}(e, n.parameters))), o.open(r, e, !0), "POST" !== r && "PUT" !== r || o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o.send(a), o
						}
					}(), b.log = console.log, b.warn = console.warn,
					function() {
						var t = b.util.object.extend,
							e = b.util.object.clone,
							n = [];

						function r() {
							return !1
						}

						function i(t, e, n, r) {
							return -n * Math.cos(t / r * (Math.PI / 2)) + n + e
						}
						b.util.object.extend(n, {
							cancelAll: function() {
								var t = this.splice(0);
								return t.forEach((function(t) {
									t.cancel()
								})), t
							},
							cancelByCanvas: function(t) {
								if (!t) return [];
								var e = this.filter((function(e) {
									return "object" == typeof e.target && e.target.canvas === t
								}));
								return e.forEach((function(t) {
									t.cancel()
								})), e
							},
							cancelByTarget: function(t) {
								var e = this.findAnimationsByTarget(t);
								return e.forEach((function(t) {
									t.cancel()
								})), e
							},
							findAnimationIndex: function(t) {
								return this.indexOf(this.findAnimation(t))
							},
							findAnimation: function(t) {
								return this.find((function(e) {
									return e.cancel === t
								}))
							},
							findAnimationsByTarget: function(t) {
								return t ? this.filter((function(e) {
									return e.target === t
								})) : []
							}
						});
						var o = b.window.requestAnimationFrame || b.window.webkitRequestAnimationFrame || b.window.mozRequestAnimationFrame || b.window.oRequestAnimationFrame || b.window.msRequestAnimationFrame || function(t) {
								return b.window.setTimeout(t, 1e3 / 60)
							},
							a = b.window.cancelAnimationFrame || b.window.clearTimeout;

						function s() {
							return o.apply(b.window, arguments)
						}
						b.util.animate = function(n) {
							n || (n = {});
							var o, a = !1,
								l = function() {
									var t = b.runningAnimations.indexOf(o);
									return t > -1 && b.runningAnimations.splice(t, 1)[0]
								};
							return o = t(e(n), {
								cancel: function() {
									return a = !0, l()
								},
								currentValue: "startValue" in n ? n.startValue : 0,
								completionRate: 0,
								durationRate: 0
							}), b.runningAnimations.push(o), s((function(t) {
								var e, c = t || +new Date,
									u = n.duration || 500,
									h = c + u,
									f = n.onChange || r,
									d = n.abort || r,
									p = n.onComplete || r,
									g = n.easing || i,
									v = "startValue" in n && n.startValue.length > 0,
									m = "startValue" in n ? n.startValue : 0,
									y = "endValue" in n ? n.endValue : 100,
									b = n.byValue || (v ? m.map((function(t, e) {
										return y[e] - m[e]
									})) : y - m);
								n.onStart && n.onStart(),
									function t(n) {
										var r = (e = n || +new Date) > h ? u : e - c,
											i = r / u,
											x = v ? m.map((function(t, e) {
												return g(r, m[e], b[e], u)
											})) : g(r, m, b, u),
											w = v ? Math.abs((x[0] - m[0]) / b[0]) : Math.abs((x - m) / b);
										if (o.currentValue = v ? x.slice() : x, o.completionRate = w, o.durationRate = i, !a) {
											if (!d(x, w, i)) return e > h ? (o.currentValue = v ? y.slice() : y, o.completionRate = 1, o.durationRate = 1, f(v ? y.slice() : y, 1, 1), p(y, 1, 1), void l()) : (f(x, w, i), void s(t));
											l()
										}
									}(c)
							})), o.cancel
						}, b.util.requestAnimFrame = s, b.util.cancelAnimFrame = function() {
							return a.apply(b.window, arguments)
						}, b.runningAnimations = n
					}(),
					function() {
						function t(t, e, n) {
							var r = "rgba(" + parseInt(t[0] + n * (e[0] - t[0]), 10) + "," + parseInt(t[1] + n * (e[1] - t[1]), 10) + "," + parseInt(t[2] + n * (e[2] - t[2]), 10);
							return (r += "," + (t && e ? parseFloat(t[3] + n * (e[3] - t[3])) : 1)) + ")"
						}
						b.util.animateColor = function(e, n, r, i) {
							var o = new b.Color(e).getSource(),
								a = new b.Color(n).getSource(),
								s = i.onComplete,
								l = i.onChange;
							return i = i || {}, b.util.animate(b.util.object.extend(i, {
								duration: r || 500,
								startValue: o,
								endValue: a,
								byValue: a,
								easing: function(e, n, r, o) {
									return t(n, r, i.colorEasing ? i.colorEasing(e, o) : 1 - Math.cos(e / o * (Math.PI / 2)))
								},
								onComplete: function(e, n, r) {
									if (s) return s(t(a, a, 0), n, r)
								},
								onChange: function(e, n, r) {
									if (l) {
										if (Array.isArray(e)) return l(t(e, e, 0), n, r);
										l(e, n, r)
									}
								}
							}))
						}
					}(),
					function() {
						function t(t, e, n, r) {
							return t < Math.abs(e) ? (t = e, r = n / 4) : r = 0 === e && 0 === t ? n / (2 * Math.PI) * Math.asin(1) : n / (2 * Math.PI) * Math.asin(e / t), {
								a: t,
								c: e,
								p: n,
								s: r
							}
						}

						function e(t, e, n) {
							return t.a * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * n - t.s) * (2 * Math.PI) / t.p)
						}

						function n(t, e, n, i) {
							return n - r(i - t, 0, n, i) + e
						}

						function r(t, e, n, r) {
							return (t /= r) < 1 / 2.75 ? n * (7.5625 * t * t) + e : t < 2 / 2.75 ? n * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? n * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : n * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e
						}
						b.util.ease = {
							easeInQuad: function(t, e, n, r) {
								return n * (t /= r) * t + e
							},
							easeOutQuad: function(t, e, n, r) {
								return -n * (t /= r) * (t - 2) + e
							},
							easeInOutQuad: function(t, e, n, r) {
								return (t /= r / 2) < 1 ? n / 2 * t * t + e : -n / 2 * (--t * (t - 2) - 1) + e
							},
							easeInCubic: function(t, e, n, r) {
								return n * (t /= r) * t * t + e
							},
							easeOutCubic: function(t, e, n, r) {
								return n * ((t = t / r - 1) * t * t + 1) + e
							},
							easeInOutCubic: function(t, e, n, r) {
								return (t /= r / 2) < 1 ? n / 2 * t * t * t + e : n / 2 * ((t -= 2) * t * t + 2) + e
							},
							easeInQuart: function(t, e, n, r) {
								return n * (t /= r) * t * t * t + e
							},
							easeOutQuart: function(t, e, n, r) {
								return -n * ((t = t / r - 1) * t * t * t - 1) + e
							},
							easeInOutQuart: function(t, e, n, r) {
								return (t /= r / 2) < 1 ? n / 2 * t * t * t * t + e : -n / 2 * ((t -= 2) * t * t * t - 2) + e
							},
							easeInQuint: function(t, e, n, r) {
								return n * (t /= r) * t * t * t * t + e
							},
							easeOutQuint: function(t, e, n, r) {
								return n * ((t = t / r - 1) * t * t * t * t + 1) + e
							},
							easeInOutQuint: function(t, e, n, r) {
								return (t /= r / 2) < 1 ? n / 2 * t * t * t * t * t + e : n / 2 * ((t -= 2) * t * t * t * t + 2) + e
							},
							easeInSine: function(t, e, n, r) {
								return -n * Math.cos(t / r * (Math.PI / 2)) + n + e
							},
							easeOutSine: function(t, e, n, r) {
								return n * Math.sin(t / r * (Math.PI / 2)) + e
							},
							easeInOutSine: function(t, e, n, r) {
								return -n / 2 * (Math.cos(Math.PI * t / r) - 1) + e
							},
							easeInExpo: function(t, e, n, r) {
								return 0 === t ? e : n * Math.pow(2, 10 * (t / r - 1)) + e
							},
							easeOutExpo: function(t, e, n, r) {
								return t === r ? e + n : n * (1 - Math.pow(2, -10 * t / r)) + e
							},
							easeInOutExpo: function(t, e, n, r) {
								return 0 === t ? e : t === r ? e + n : (t /= r / 2) < 1 ? n / 2 * Math.pow(2, 10 * (t - 1)) + e : n / 2 * (2 - Math.pow(2, -10 * --t)) + e
							},
							easeInCirc: function(t, e, n, r) {
								return -n * (Math.sqrt(1 - (t /= r) * t) - 1) + e
							},
							easeOutCirc: function(t, e, n, r) {
								return n * Math.sqrt(1 - (t = t / r - 1) * t) + e
							},
							easeInOutCirc: function(t, e, n, r) {
								return (t /= r / 2) < 1 ? -n / 2 * (Math.sqrt(1 - t * t) - 1) + e : n / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e
							},
							easeInElastic: function(n, r, i, o) {
								var a = 0;
								return 0 === n ? r : 1 == (n /= o) ? r + i : (a || (a = .3 * o), -e(t(i, i, a, 1.70158), n, o) + r)
							},
							easeOutElastic: function(e, n, r, i) {
								var o = 0;
								if (0 === e) return n;
								if (1 == (e /= i)) return n + r;
								o || (o = .3 * i);
								var a = t(r, r, o, 1.70158);
								return a.a * Math.pow(2, -10 * e) * Math.sin((e * i - a.s) * (2 * Math.PI) / a.p) + a.c + n
							},
							easeInOutElastic: function(n, r, i, o) {
								var a = 0;
								if (0 === n) return r;
								if (2 == (n /= o / 2)) return r + i;
								a || (a = o * (.3 * 1.5));
								var s = t(i, i, a, 1.70158);
								return n < 1 ? -.5 * e(s, n, o) + r : s.a * Math.pow(2, -10 * (n -= 1)) * Math.sin((n * o - s.s) * (2 * Math.PI) / s.p) * .5 + s.c + r
							},
							easeInBack: function(t, e, n, r, i) {
								return void 0 === i && (i = 1.70158), n * (t /= r) * t * ((i + 1) * t - i) + e
							},
							easeOutBack: function(t, e, n, r, i) {
								return void 0 === i && (i = 1.70158), n * ((t = t / r - 1) * t * ((i + 1) * t + i) + 1) + e
							},
							easeInOutBack: function(t, e, n, r, i) {
								return void 0 === i && (i = 1.70158), (t /= r / 2) < 1 ? n / 2 * (t * t * ((1 + (i *= 1.525)) * t - i)) + e : n / 2 * ((t -= 2) * t * ((1 + (i *= 1.525)) * t + i) + 2) + e
							},
							easeInBounce: n,
							easeOutBounce: r,
							easeInOutBounce: function(t, e, i, o) {
								return t < o / 2 ? .5 * n(2 * t, 0, i, o) + e : .5 * r(2 * t - o, 0, i, o) + .5 * i + e
							}
						}
					}(),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.util.object.clone,
							i = e.util.toFixed,
							o = e.util.parseUnit,
							a = e.util.multiplyTransformMatrices,
							s = {
								cx: "left",
								x: "left",
								r: "radius",
								cy: "top",
								y: "top",
								display: "visible",
								visibility: "visible",
								transform: "transformMatrix",
								"fill-opacity": "fillOpacity",
								"fill-rule": "fillRule",
								"font-family": "fontFamily",
								"font-size": "fontSize",
								"font-style": "fontStyle",
								"font-weight": "fontWeight",
								"letter-spacing": "charSpacing",
								"paint-order": "paintFirst",
								"stroke-dasharray": "strokeDashArray",
								"stroke-dashoffset": "strokeDashOffset",
								"stroke-linecap": "strokeLineCap",
								"stroke-linejoin": "strokeLineJoin",
								"stroke-miterlimit": "strokeMiterLimit",
								"stroke-opacity": "strokeOpacity",
								"stroke-width": "strokeWidth",
								"text-decoration": "textDecoration",
								"text-anchor": "textAnchor",
								opacity: "opacity",
								"clip-path": "clipPath",
								"clip-rule": "clipRule",
								"vector-effect": "strokeUniform",
								"image-rendering": "imageSmoothing"
							},
							l = {
								stroke: "strokeOpacity",
								fill: "fillOpacity"
							},
							c = "font-size",
							u = "clip-path";

						function h(t) {
							return t in s ? s[t] : t
						}

						function f(t, n, r, i) {
							var s, l = Array.isArray(n);
							if ("fill" !== t && "stroke" !== t || "none" !== n) {
								if ("strokeUniform" === t) return "non-scaling-stroke" === n;
								if ("strokeDashArray" === t) n = "none" === n ? null : n.replace(/,/g, " ").split(/\s+/).map(parseFloat);
								else if ("transformMatrix" === t) n = r && r.transformMatrix ? a(r.transformMatrix, e.parseTransformAttribute(n)) : e.parseTransformAttribute(n);
								else if ("visible" === t) n = "none" !== n && "hidden" !== n, r && !1 === r.visible && (n = !1);
								else if ("opacity" === t) n = parseFloat(n), r && void 0 !== r.opacity && (n *= r.opacity);
								else if ("textAnchor" === t) n = "start" === n ? "left" : "end" === n ? "right" : "center";
								else if ("charSpacing" === t) s = o(n, i) / i * 1e3;
								else if ("paintFirst" === t) {
									var c = n.indexOf("fill"),
										u = n.indexOf("stroke");
									n = "fill", (c > -1 && u > -1 && u < c || -1 === c && u > -1) && (n = "stroke")
								} else {
									if ("href" === t || "xlink:href" === t || "font" === t) return n;
									if ("imageSmoothing" === t) return "optimizeQuality" === n;
									s = l ? n.map(o) : o(n, i)
								}
							} else n = "";
							return !l && isNaN(s) ? n : s
						}

						function d(t) {
							return new RegExp("^(" + t.join("|") + ")\\b", "i")
						}

						function p(t, e) {
							var n, r, i, o, a = [];
							for (i = 0, o = e.length; i < o; i++) n = e[i], r = t.getElementsByTagName(n), a = a.concat(Array.prototype.slice.call(r));
							return a
						}

						function g(t, e) {
							var n, r = !0;
							return (n = v(t, e.pop())) && e.length && (r = function(t, e) {
								for (var n, r = !0; t.parentNode && 1 === t.parentNode.nodeType && e.length;) r && (n = e.pop()), r = v(t = t.parentNode, n);
								return 0 === e.length
							}(t, e)), n && r && 0 === e.length
						}

						function v(t, e) {
							var n, r, i = t.nodeName,
								o = t.getAttribute("class"),
								a = t.getAttribute("id");
							if (n = new RegExp("^" + i, "i"), e = e.replace(n, ""), a && e.length && (n = new RegExp("#" + a + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(n, "")), o && e.length)
								for (r = (o = o.split(" ")).length; r--;) n = new RegExp("\\." + o[r] + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(n, "");
							return 0 === e.length
						}

						function m(t, e) {
							var n;
							if (t.getElementById && (n = t.getElementById(e)), n) return n;
							var r, i, o, a = t.getElementsByTagName("*");
							for (i = 0, o = a.length; i < o; i++)
								if (e === (r = a[i]).getAttribute("id")) return r
						}
						e.svgValidTagNamesRegEx = d(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]), e.svgViewBoxElementsRegEx = d(["symbol", "image", "marker", "pattern", "view", "svg"]), e.svgInvalidAncestorsRegEx = d(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]), e.svgValidParentsRegEx = d(["symbol", "g", "a", "svg", "clipPath", "defs"]), e.cssRules = {}, e.gradientDefs = {}, e.clipPaths = {}, e.parseTransformAttribute = function() {
							function t(t, n, r) {
								t[r] = Math.tan(e.util.degreesToRadians(n[0]))
							}
							var n = e.iMatrix,
								r = e.reNum,
								i = e.commaWsp,
								o = "(?:(?:(matrix)\\s*\\(\\s*(" + r + ")" + i + "(" + r + ")" + i + "(" + r + ")" + i + "(" + r + ")" + i + "(" + r + ")" + i + "(" + r + ")\\s*\\))|(?:(translate)\\s*\\(\\s*(" + r + ")(?:" + i + "(" + r + "))?\\s*\\))|(?:(scale)\\s*\\(\\s*(" + r + ")(?:" + i + "(" + r + "))?\\s*\\))|(?:(rotate)\\s*\\(\\s*(" + r + ")(?:" + i + "(" + r + ")" + i + "(" + r + "))?\\s*\\))|(?:(skewX)\\s*\\(\\s*(" + r + ")\\s*\\))|(?:(skewY)\\s*\\(\\s*(" + r + ")\\s*\\)))",
								a = new RegExp("^\\s*(?:(?:" + o + "(?:" + i + "*" + o + ")*)?)\\s*$"),
								s = new RegExp(o, "g");
							return function(r) {
								var i = n.concat(),
									l = [];
								if (!r || r && !a.test(r)) return i;
								r.replace(s, (function(r) {
									var a = new RegExp(o).exec(r).filter((function(t) {
											return !!t
										})),
										s = a[1],
										c = a.slice(2).map(parseFloat);
									switch (s) {
										case "translate":
											! function(t, e) {
												t[4] = e[0], 2 === e.length && (t[5] = e[1])
											}(i, c);
											break;
										case "rotate":
											c[0] = e.util.degreesToRadians(c[0]),
												function(t, n) {
													var r = e.util.cos(n[0]),
														i = e.util.sin(n[0]),
														o = 0,
														a = 0;
													3 === n.length && (o = n[1], a = n[2]), t[0] = r, t[1] = i, t[2] = -i, t[3] = r, t[4] = o - (r * o - i * a), t[5] = a - (i * o + r * a)
												}(i, c);
											break;
										case "scale":
											! function(t, e) {
												var n = e[0],
													r = 2 === e.length ? e[1] : e[0];
												t[0] = n, t[3] = r
											}(i, c);
											break;
										case "skewX":
											t(i, c, 2);
											break;
										case "skewY":
											t(i, c, 1);
											break;
										case "matrix":
											i = c
									}
									l.push(i.concat()), i = n.concat()
								}));
								for (var c = l[0]; l.length > 1;) l.shift(), c = e.util.multiplyTransformMatrices(c, l[0]);
								return c
							}
						}();
						var y = new RegExp("^\\s*(" + e.reNum + "+)\\s*,?\\s*(" + e.reNum + "+)\\s*,?\\s*(" + e.reNum + "+)\\s*,?\\s*(" + e.reNum + "+)\\s*$");

						function b(t) {
							if (!e.svgViewBoxElementsRegEx.test(t.nodeName)) return {};
							var n, r, i, a, s, l, c = t.getAttribute("viewBox"),
								u = 1,
								h = 1,
								f = t.getAttribute("width"),
								d = t.getAttribute("height"),
								p = t.getAttribute("x") || 0,
								g = t.getAttribute("y") || 0,
								v = t.getAttribute("preserveAspectRatio") || "",
								m = !c || !(c = c.match(y)),
								b = !f || !d || "100%" === f || "100%" === d,
								x = m && b,
								w = {},
								C = "",
								S = 0,
								O = 0;
							if (w.width = 0, w.height = 0, w.toBeParsed = x, m && (p || g) && t.parentNode && "#document" !== t.parentNode.nodeName && (C = " translate(" + o(p) + " " + o(g) + ") ", s = (t.getAttribute("transform") || "") + C, t.setAttribute("transform", s), t.removeAttribute("x"), t.removeAttribute("y")), x) return w;
							if (m) return w.width = o(f), w.height = o(d), w;
							if (n = -parseFloat(c[1]), r = -parseFloat(c[2]), i = parseFloat(c[3]), a = parseFloat(c[4]), w.minX = n, w.minY = r, w.viewBoxWidth = i, w.viewBoxHeight = a, b ? (w.width = i, w.height = a) : (w.width = o(f), w.height = o(d), u = w.width / i, h = w.height / a), "none" !== (v = e.util.parsePreserveAspectRatioAttribute(v)).alignX && ("meet" === v.meetOrSlice && (h = u = u > h ? h : u), "slice" === v.meetOrSlice && (h = u = u > h ? u : h), S = w.width - i * u, O = w.height - a * u, "Mid" === v.alignX && (S /= 2), "Mid" === v.alignY && (O /= 2), "Min" === v.alignX && (S = 0), "Min" === v.alignY && (O = 0)), 1 === u && 1 === h && 0 === n && 0 === r && 0 === p && 0 === g) return w;
							if ((p || g) && "#document" !== t.parentNode.nodeName && (C = " translate(" + o(p) + " " + o(g) + ") "), s = C + " matrix(" + u + " 0 0 " + h + " " + (n * u + S) + " " + (r * h + O) + ") ", "svg" === t.nodeName) {
								for (l = t.ownerDocument.createElementNS(e.svgNS, "g"); t.firstChild;) l.appendChild(t.firstChild);
								t.appendChild(l)
							} else(l = t).removeAttribute("x"), l.removeAttribute("y"), s = l.getAttribute("transform") + s;
							return l.setAttribute("transform", s), w
						}

						function x(t, e) {
							var n = "xlink:href",
								r = m(t, e.getAttribute(n).slice(1));
							if (r && r.getAttribute(n) && x(t, r), ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"].forEach((function(t) {
									r && !e.hasAttribute(t) && r.hasAttribute(t) && e.setAttribute(t, r.getAttribute(t))
								})), !e.children.length)
								for (var i = r.cloneNode(!0); i.firstChild;) e.appendChild(i.firstChild);
							e.removeAttribute(n)
						}
						e.parseSVGDocument = function(t, n, i, o) {
							if (t) {
								! function(t) {
									for (var n = p(t, ["use", "svg:use"]), r = 0; n.length && r < n.length;) {
										var i = n[r],
											o = i.getAttribute("xlink:href") || i.getAttribute("href");
										if (null === o) return;
										var a, s, l, c, u = o.slice(1),
											h = i.getAttribute("x") || 0,
											f = i.getAttribute("y") || 0,
											d = m(t, u).cloneNode(!0),
											g = (d.getAttribute("transform") || "") + " translate(" + h + ", " + f + ")",
											v = n.length,
											y = e.svgNS;
										if (b(d), /^svg$/i.test(d.nodeName)) {
											var x = d.ownerDocument.createElementNS(y, "g");
											for (s = 0, c = (l = d.attributes).length; s < c; s++) a = l.item(s), x.setAttributeNS(y, a.nodeName, a.nodeValue);
											for (; d.firstChild;) x.appendChild(d.firstChild);
											d = x
										}
										for (s = 0, c = (l = i.attributes).length; s < c; s++) "x" !== (a = l.item(s)).nodeName && "y" !== a.nodeName && "xlink:href" !== a.nodeName && "href" !== a.nodeName && ("transform" === a.nodeName ? g = a.nodeValue + " " + g : d.setAttribute(a.nodeName, a.nodeValue));
										d.setAttribute("transform", g), d.setAttribute("instantiated_by_use", "1"), d.removeAttribute("id"), i.parentNode.replaceChild(d, i), n.length === v && r++
									}
								}(t);
								var a, s, l = e.Object.__uid++,
									c = b(t),
									u = e.util.toArray(t.getElementsByTagName("*"));
								if (c.crossOrigin = o && o.crossOrigin, c.svgUid = l, 0 === u.length && e.isLikelyNode) {
									var h = [];
									for (a = 0, s = (u = t.selectNodes('//*[name(.)!="svg"]')).length; a < s; a++) h[a] = u[a];
									u = h
								}
								var f = u.filter((function(t) {
									return b(t), e.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:", "")) && ! function(t, e) {
										for (; t && (t = t.parentNode);)
											if (t.nodeName && e.test(t.nodeName.replace("svg:", "")) && !t.getAttribute("instantiated_by_use")) return !0;
										return !1
									}(t, e.svgInvalidAncestorsRegEx)
								}));
								if (!f || f && !f.length) n && n([], {});
								else {
									var d = {};
									u.filter((function(t) {
										return "clipPath" === t.nodeName.replace("svg:", "")
									})).forEach((function(t) {
										var n = t.getAttribute("id");
										d[n] = e.util.toArray(t.getElementsByTagName("*")).filter((function(t) {
											return e.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:", ""))
										}))
									})), e.gradientDefs[l] = e.getGradientDefs(t), e.cssRules[l] = e.getCSSRules(t), e.clipPaths[l] = d, e.parseElements(f, (function(t, r) {
										n && (n(t, c, r, u), delete e.gradientDefs[l], delete e.cssRules[l], delete e.clipPaths[l])
									}), r(c), i, o)
								}
							}
						};
						var w = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + e.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + e.reNum + "))?\\s+(.*)");
						n(e, {
							parseFontDeclaration: function(t, e) {
								var n = t.match(w);
								if (n) {
									var r = n[1],
										i = n[3],
										a = n[4],
										s = n[5],
										l = n[6];
									r && (e.fontStyle = r), i && (e.fontWeight = isNaN(parseFloat(i)) ? i : parseFloat(i)), a && (e.fontSize = o(a)), l && (e.fontFamily = l), s && (e.lineHeight = "normal" === s ? 1 : s)
								}
							},
							getGradientDefs: function(t) {
								var e, n = p(t, ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"]),
									r = 0,
									i = {};
								for (r = n.length; r--;)(e = n[r]).getAttribute("xlink:href") && x(t, e), i[e.getAttribute("id")] = e;
								return i
							},
							parseAttributes: function(t, r, a) {
								if (t) {
									var s, d, p, v = {};
									void 0 === a && (a = t.getAttribute("svgUid")), t.parentNode && e.svgValidParentsRegEx.test(t.parentNode.nodeName) && (v = e.parseAttributes(t.parentNode, r, a));
									var m = r.reduce((function(e, n) {
											return (s = t.getAttribute(n)) && (e[n] = s), e
										}), {}),
										y = n(function(t, n) {
											var r = {};
											for (var i in e.cssRules[n])
												if (g(t, i.split(" ")))
													for (var o in e.cssRules[n][i]) r[o] = e.cssRules[n][i][o];
											return r
										}(t, a), e.parseStyleAttribute(t));
									m = n(m, y), y[u] && t.setAttribute(u, y[u]), d = p = v.fontSize || e.Text.DEFAULT_SVG_FONT_SIZE, m[c] && (m[c] = d = o(m[c], p));
									var b, x, w = {};
									for (var C in m) x = f(b = h(C), m[C], v, d), w[b] = x;
									w && w.font && e.parseFontDeclaration(w.font, w);
									var S = n(v, w);
									return e.svgValidParentsRegEx.test(t.nodeName) ? S : function(t) {
										for (var n in l)
											if (void 0 !== t[l[n]] && "" !== t[n]) {
												if (void 0 === t[n]) {
													if (!e.Object.prototype[n]) continue;
													t[n] = e.Object.prototype[n]
												}
												if (0 !== t[n].indexOf("url(")) {
													var r = new e.Color(t[n]);
													t[n] = r.setAlpha(i(r.getAlpha() * t[l[n]], 2)).toRgba()
												}
											} return t
									}(S)
								}
							},
							parseElements: function(t, n, r, i, o) {
								new e.ElementsParser(t, n, r, i, o).parse()
							},
							parseStyleAttribute: function(t) {
								var e = {},
									n = t.getAttribute("style");
								return n ? ("string" == typeof n ? function(t, e) {
									var n, r;
									t.replace(/;\s*$/, "").split(";").forEach((function(t) {
										var i = t.split(":");
										n = i[0].trim().toLowerCase(), r = i[1].trim(), e[n] = r
									}))
								}(n, e) : function(t, e) {
									var n, r;
									for (var i in t) void 0 !== t[i] && (n = i.toLowerCase(), r = t[i], e[n] = r)
								}(n, e), e) : e
							},
							parsePointsAttribute: function(t) {
								if (!t) return null;
								var e, n, r = [];
								for (e = 0, n = (t = (t = t.replace(/,/g, " ").trim()).split(/\s+/)).length; e < n; e += 2) r.push({
									x: parseFloat(t[e]),
									y: parseFloat(t[e + 1])
								});
								return r
							},
							getCSSRules: function(t) {
								var n, r, i = t.getElementsByTagName("style"),
									o = {};
								for (n = 0, r = i.length; n < r; n++) {
									var a = i[n].textContent;
									"" !== (a = a.replace(/\/\*[\s\S]*?\*\//g, "")).trim() && a.split("}").filter((function(t) {
										return t.trim()
									})).forEach((function(t) {
										var i = t.split("{"),
											a = {},
											s = i[1].trim().split(";").filter((function(t) {
												return t.trim()
											}));
										for (n = 0, r = s.length; n < r; n++) {
											var l = s[n].split(":"),
												c = l[0].trim(),
												u = l[1].trim();
											a[c] = u
										}(t = i[0].trim()).split(",").forEach((function(t) {
											"" !== (t = t.replace(/^svg/i, "").trim()) && (o[t] ? e.util.object.extend(o[t], a) : o[t] = e.util.object.clone(a))
										}))
									}))
								}
								return o
							},
							loadSVGFromURL: function(t, n, r, i) {
								t = t.replace(/^\n\s*/, "").trim(), new e.util.request(t, {
									method: "get",
									onComplete: function(t) {
										var o = t.responseXML;
										if (!o || !o.documentElement) return n && n(null), !1;
										e.parseSVGDocument(o.documentElement, (function(t, e, r, i) {
											n && n(t, e, r, i)
										}), r, i)
									}
								})
							},
							loadSVGFromString: function(t, n, r, i) {
								var o = (new e.window.DOMParser).parseFromString(t.trim(), "text/xml");
								e.parseSVGDocument(o.documentElement, (function(t, e, r, i) {
									n(t, e, r, i)
								}), r, i)
							}
						})
					}(e), b.ElementsParser = function(t, e, n, r, i, o) {
						this.elements = t, this.callback = e, this.options = n, this.reviver = r, this.svgUid = n && n.svgUid || 0, this.parsingOptions = i, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = o
					}, (u = b.ElementsParser.prototype).parse = function() {
						this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects()
					}, u.createObjects = function() {
						var t = this;
						this.elements.forEach((function(e, n) {
							e.setAttribute("svgUid", t.svgUid), t.createObject(e, n)
						}))
					}, u.findTag = function(t) {
						return b[b.util.string.capitalize(t.tagName.replace("svg:", ""))]
					}, u.createObject = function(t, e) {
						var n = this.findTag(t);
						if (n && n.fromElement) try {
							n.fromElement(t, this.createCallback(e, t), this.options)
						} catch (t) {
							b.log(t)
						} else this.checkIfDone()
					}, u.createCallback = function(t, e) {
						var n = this;
						return function(r) {
							var i;
							n.resolveGradient(r, e, "fill"), n.resolveGradient(r, e, "stroke"), r instanceof b.Image && r._originalElement && (i = r.parsePreserveAspectRatioAttribute(e)), r._removeTransformMatrix(i), n.resolveClipPath(r, e), n.reviver && n.reviver(e, r), n.instances[t] = r, n.checkIfDone()
						}
					}, u.extractPropertyDefinition = function(t, e, n) {
						var r = t[e],
							i = this.regexUrl;
						if (i.test(r)) {
							i.lastIndex = 0;
							var o = i.exec(r)[1];
							return i.lastIndex = 0, b[n][this.svgUid][o]
						}
					}, u.resolveGradient = function(t, e, n) {
						var r = this.extractPropertyDefinition(t, n, "gradientDefs");
						if (r) {
							var i = e.getAttribute(n + "-opacity"),
								o = b.Gradient.fromElement(r, t, i, this.options);
							t.set(n, o)
						}
					}, u.createClipPathCallback = function(t, e) {
						return function(t) {
							t._removeTransformMatrix(), t.fillRule = t.clipRule, e.push(t)
						}
					}, u.resolveClipPath = function(t, e) {
						var n, r, i, o, a = this.extractPropertyDefinition(t, "clipPath", "clipPaths");
						if (a) {
							i = [], r = b.util.invertTransform(t.calcTransformMatrix());
							for (var s = a[0].parentNode, l = e; l.parentNode && l.getAttribute("clip-path") !== t.clipPath;) l = l.parentNode;
							l.parentNode.appendChild(s);
							for (var c = 0; c < a.length; c++) n = a[c], this.findTag(n).fromElement(n, this.createClipPathCallback(t, i), this.options);
							a = 1 === i.length ? i[0] : new b.Group(i), o = b.util.multiplyTransformMatrices(r, a.calcTransformMatrix()), a.clipPath && this.resolveClipPath(a, l);
							var u = b.util.qrDecompose(o);
							a.flipX = !1, a.flipY = !1, a.set("scaleX", u.scaleX), a.set("scaleY", u.scaleY), a.angle = u.angle, a.skewX = u.skewX, a.skewY = 0, a.setPositionByOrigin({
								x: u.translateX,
								y: u.translateY
							}, "center", "center"), t.clipPath = a
						} else delete t.clipPath
					}, u.checkIfDone = function() {
						0 == --this.numElements && (this.instances = this.instances.filter((function(t) {
							return null != t
						})), this.callback(this.instances, this.elements))
					},
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});

						function n(t, e) {
							this.x = t, this.y = e
						}
						e.Point ? e.warn("fabric.Point is already defined") : (e.Point = n, n.prototype = {
							type: "point",
							constructor: n,
							add: function(t) {
								return new n(this.x + t.x, this.y + t.y)
							},
							addEquals: function(t) {
								return this.x += t.x, this.y += t.y, this
							},
							scalarAdd: function(t) {
								return new n(this.x + t, this.y + t)
							},
							scalarAddEquals: function(t) {
								return this.x += t, this.y += t, this
							},
							subtract: function(t) {
								return new n(this.x - t.x, this.y - t.y)
							},
							subtractEquals: function(t) {
								return this.x -= t.x, this.y -= t.y, this
							},
							scalarSubtract: function(t) {
								return new n(this.x - t, this.y - t)
							},
							scalarSubtractEquals: function(t) {
								return this.x -= t, this.y -= t, this
							},
							multiply: function(t) {
								return new n(this.x * t, this.y * t)
							},
							multiplyEquals: function(t) {
								return this.x *= t, this.y *= t, this
							},
							divide: function(t) {
								return new n(this.x / t, this.y / t)
							},
							divideEquals: function(t) {
								return this.x /= t, this.y /= t, this
							},
							eq: function(t) {
								return this.x === t.x && this.y === t.y
							},
							lt: function(t) {
								return this.x < t.x && this.y < t.y
							},
							lte: function(t) {
								return this.x <= t.x && this.y <= t.y
							},
							gt: function(t) {
								return this.x > t.x && this.y > t.y
							},
							gte: function(t) {
								return this.x >= t.x && this.y >= t.y
							},
							lerp: function(t, e) {
								return void 0 === e && (e = .5), e = Math.max(Math.min(1, e), 0), new n(this.x + (t.x - this.x) * e, this.y + (t.y - this.y) * e)
							},
							distanceFrom: function(t) {
								var e = this.x - t.x,
									n = this.y - t.y;
								return Math.sqrt(e * e + n * n)
							},
							midPointFrom: function(t) {
								return this.lerp(t)
							},
							min: function(t) {
								return new n(Math.min(this.x, t.x), Math.min(this.y, t.y))
							},
							max: function(t) {
								return new n(Math.max(this.x, t.x), Math.max(this.y, t.y))
							},
							toString: function() {
								return this.x + "," + this.y
							},
							setXY: function(t, e) {
								return this.x = t, this.y = e, this
							},
							setX: function(t) {
								return this.x = t, this
							},
							setY: function(t) {
								return this.y = t, this
							},
							setFromPoint: function(t) {
								return this.x = t.x, this.y = t.y, this
							},
							swap: function(t) {
								var e = this.x,
									n = this.y;
								this.x = t.x, this.y = t.y, t.x = e, t.y = n
							},
							clone: function() {
								return new n(this.x, this.y)
							}
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});

						function n(t) {
							this.status = t, this.points = []
						}
						e.Intersection ? e.warn("fabric.Intersection is already defined") : (e.Intersection = n, e.Intersection.prototype = {
							constructor: n,
							appendPoint: function(t) {
								return this.points.push(t), this
							},
							appendPoints: function(t) {
								return this.points = this.points.concat(t), this
							}
						}, e.Intersection.intersectLineLine = function(t, r, i, o) {
							var a, s = (o.x - i.x) * (t.y - i.y) - (o.y - i.y) * (t.x - i.x),
								l = (r.x - t.x) * (t.y - i.y) - (r.y - t.y) * (t.x - i.x),
								c = (o.y - i.y) * (r.x - t.x) - (o.x - i.x) * (r.y - t.y);
							if (0 !== c) {
								var u = s / c,
									h = l / c;
								0 <= u && u <= 1 && 0 <= h && h <= 1 ? (a = new n("Intersection")).appendPoint(new e.Point(t.x + u * (r.x - t.x), t.y + u * (r.y - t.y))) : a = new n
							} else a = new n(0 === s || 0 === l ? "Coincident" : "Parallel");
							return a
						}, e.Intersection.intersectLinePolygon = function(t, e, r) {
							var i, o, a, s, l = new n,
								c = r.length;
							for (s = 0; s < c; s++) i = r[s], o = r[(s + 1) % c], a = n.intersectLineLine(t, e, i, o), l.appendPoints(a.points);
							return l.points.length > 0 && (l.status = "Intersection"), l
						}, e.Intersection.intersectPolygonPolygon = function(t, e) {
							var r, i = new n,
								o = t.length;
							for (r = 0; r < o; r++) {
								var a = t[r],
									s = t[(r + 1) % o],
									l = n.intersectLinePolygon(a, s, e);
								i.appendPoints(l.points)
							}
							return i.points.length > 0 && (i.status = "Intersection"), i
						}, e.Intersection.intersectPolygonRectangle = function(t, r, i) {
							var o = r.min(i),
								a = r.max(i),
								s = new e.Point(a.x, o.y),
								l = new e.Point(o.x, a.y),
								c = n.intersectLinePolygon(o, s, t),
								u = n.intersectLinePolygon(s, a, t),
								h = n.intersectLinePolygon(a, l, t),
								f = n.intersectLinePolygon(l, o, t),
								d = new n;
							return d.appendPoints(c.points), d.appendPoints(u.points), d.appendPoints(h.points), d.appendPoints(f.points), d.points.length > 0 && (d.status = "Intersection"), d
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});

						function n(t) {
							t ? this._tryParsingColor(t) : this.setSource([0, 0, 0, 1])
						}

						function r(t, e, n) {
							return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
						}
						e.Color ? e.warn("fabric.Color is already defined.") : (e.Color = n, e.Color.prototype = {
							_tryParsingColor: function(t) {
								var e;
								t in n.colorNameMap && (t = n.colorNameMap[t]), "transparent" === t && (e = [255, 255, 255, 0]), e || (e = n.sourceFromHex(t)), e || (e = n.sourceFromRgb(t)), e || (e = n.sourceFromHsl(t)), e || (e = [0, 0, 0, 1]), e && this.setSource(e)
							},
							_rgbToHsl: function(t, n, r) {
								t /= 255, n /= 255, r /= 255;
								var i, o, a, s = e.util.array.max([t, n, r]),
									l = e.util.array.min([t, n, r]);
								if (a = (s + l) / 2, s === l) i = o = 0;
								else {
									var c = s - l;
									switch (o = a > .5 ? c / (2 - s - l) : c / (s + l), s) {
										case t:
											i = (n - r) / c + (n < r ? 6 : 0);
											break;
										case n:
											i = (r - t) / c + 2;
											break;
										case r:
											i = (t - n) / c + 4
									}
									i /= 6
								}
								return [Math.round(360 * i), Math.round(100 * o), Math.round(100 * a)]
							},
							getSource: function() {
								return this._source
							},
							setSource: function(t) {
								this._source = t
							},
							toRgb: function() {
								var t = this.getSource();
								return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")"
							},
							toRgba: function() {
								var t = this.getSource();
								return "rgba(" + t[0] + "," + t[1] + "," + t[2] + "," + t[3] + ")"
							},
							toHsl: function() {
								var t = this.getSource(),
									e = this._rgbToHsl(t[0], t[1], t[2]);
								return "hsl(" + e[0] + "," + e[1] + "%," + e[2] + "%)"
							},
							toHsla: function() {
								var t = this.getSource(),
									e = this._rgbToHsl(t[0], t[1], t[2]);
								return "hsla(" + e[0] + "," + e[1] + "%," + e[2] + "%," + t[3] + ")"
							},
							toHex: function() {
								var t, e, n, r = this.getSource();
								return t = 1 === (t = r[0].toString(16)).length ? "0" + t : t, e = 1 === (e = r[1].toString(16)).length ? "0" + e : e, n = 1 === (n = r[2].toString(16)).length ? "0" + n : n, t.toUpperCase() + e.toUpperCase() + n.toUpperCase()
							},
							toHexa: function() {
								var t, e = this.getSource();
								return t = 1 === (t = (t = Math.round(255 * e[3])).toString(16)).length ? "0" + t : t, this.toHex() + t.toUpperCase()
							},
							getAlpha: function() {
								return this.getSource()[3]
							},
							setAlpha: function(t) {
								var e = this.getSource();
								return e[3] = t, this.setSource(e), this
							},
							toGrayscale: function() {
								var t = this.getSource(),
									e = parseInt((.3 * t[0] + .59 * t[1] + .11 * t[2]).toFixed(0), 10),
									n = t[3];
								return this.setSource([e, e, e, n]), this
							},
							toBlackWhite: function(t) {
								var e = this.getSource(),
									n = (.3 * e[0] + .59 * e[1] + .11 * e[2]).toFixed(0),
									r = e[3];
								return t = t || 127, n = Number(n) < Number(t) ? 0 : 255, this.setSource([n, n, n, r]), this
							},
							overlayWith: function(t) {
								t instanceof n || (t = new n(t));
								var e, r = [],
									i = this.getAlpha(),
									o = this.getSource(),
									a = t.getSource();
								for (e = 0; e < 3; e++) r.push(Math.round(.5 * o[e] + .5 * a[e]));
								return r[3] = i, this.setSource(r), this
							}
						}, e.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, e.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, e.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, e.Color.colorNameMap = {
							aliceblue: "#F0F8FF",
							antiquewhite: "#FAEBD7",
							aqua: "#00FFFF",
							aquamarine: "#7FFFD4",
							azure: "#F0FFFF",
							beige: "#F5F5DC",
							bisque: "#FFE4C4",
							black: "#000000",
							blanchedalmond: "#FFEBCD",
							blue: "#0000FF",
							blueviolet: "#8A2BE2",
							brown: "#A52A2A",
							burlywood: "#DEB887",
							cadetblue: "#5F9EA0",
							chartreuse: "#7FFF00",
							chocolate: "#D2691E",
							coral: "#FF7F50",
							cornflowerblue: "#6495ED",
							cornsilk: "#FFF8DC",
							crimson: "#DC143C",
							cyan: "#00FFFF",
							darkblue: "#00008B",
							darkcyan: "#008B8B",
							darkgoldenrod: "#B8860B",
							darkgray: "#A9A9A9",
							darkgrey: "#A9A9A9",
							darkgreen: "#006400",
							darkkhaki: "#BDB76B",
							darkmagenta: "#8B008B",
							darkolivegreen: "#556B2F",
							darkorange: "#FF8C00",
							darkorchid: "#9932CC",
							darkred: "#8B0000",
							darksalmon: "#E9967A",
							darkseagreen: "#8FBC8F",
							darkslateblue: "#483D8B",
							darkslategray: "#2F4F4F",
							darkslategrey: "#2F4F4F",
							darkturquoise: "#00CED1",
							darkviolet: "#9400D3",
							deeppink: "#FF1493",
							deepskyblue: "#00BFFF",
							dimgray: "#696969",
							dimgrey: "#696969",
							dodgerblue: "#1E90FF",
							firebrick: "#B22222",
							floralwhite: "#FFFAF0",
							forestgreen: "#228B22",
							fuchsia: "#FF00FF",
							gainsboro: "#DCDCDC",
							ghostwhite: "#F8F8FF",
							gold: "#FFD700",
							goldenrod: "#DAA520",
							gray: "#808080",
							grey: "#808080",
							green: "#008000",
							greenyellow: "#ADFF2F",
							honeydew: "#F0FFF0",
							hotpink: "#FF69B4",
							indianred: "#CD5C5C",
							indigo: "#4B0082",
							ivory: "#FFFFF0",
							khaki: "#F0E68C",
							lavender: "#E6E6FA",
							lavenderblush: "#FFF0F5",
							lawngreen: "#7CFC00",
							lemonchiffon: "#FFFACD",
							lightblue: "#ADD8E6",
							lightcoral: "#F08080",
							lightcyan: "#E0FFFF",
							lightgoldenrodyellow: "#FAFAD2",
							lightgray: "#D3D3D3",
							lightgrey: "#D3D3D3",
							lightgreen: "#90EE90",
							lightpink: "#FFB6C1",
							lightsalmon: "#FFA07A",
							lightseagreen: "#20B2AA",
							lightskyblue: "#87CEFA",
							lightslategray: "#778899",
							lightslategrey: "#778899",
							lightsteelblue: "#B0C4DE",
							lightyellow: "#FFFFE0",
							lime: "#00FF00",
							limegreen: "#32CD32",
							linen: "#FAF0E6",
							magenta: "#FF00FF",
							maroon: "#800000",
							mediumaquamarine: "#66CDAA",
							mediumblue: "#0000CD",
							mediumorchid: "#BA55D3",
							mediumpurple: "#9370DB",
							mediumseagreen: "#3CB371",
							mediumslateblue: "#7B68EE",
							mediumspringgreen: "#00FA9A",
							mediumturquoise: "#48D1CC",
							mediumvioletred: "#C71585",
							midnightblue: "#191970",
							mintcream: "#F5FFFA",
							mistyrose: "#FFE4E1",
							moccasin: "#FFE4B5",
							navajowhite: "#FFDEAD",
							navy: "#000080",
							oldlace: "#FDF5E6",
							olive: "#808000",
							olivedrab: "#6B8E23",
							orange: "#FFA500",
							orangered: "#FF4500",
							orchid: "#DA70D6",
							palegoldenrod: "#EEE8AA",
							palegreen: "#98FB98",
							paleturquoise: "#AFEEEE",
							palevioletred: "#DB7093",
							papayawhip: "#FFEFD5",
							peachpuff: "#FFDAB9",
							peru: "#CD853F",
							pink: "#FFC0CB",
							plum: "#DDA0DD",
							powderblue: "#B0E0E6",
							purple: "#800080",
							rebeccapurple: "#663399",
							red: "#FF0000",
							rosybrown: "#BC8F8F",
							royalblue: "#4169E1",
							saddlebrown: "#8B4513",
							salmon: "#FA8072",
							sandybrown: "#F4A460",
							seagreen: "#2E8B57",
							seashell: "#FFF5EE",
							sienna: "#A0522D",
							silver: "#C0C0C0",
							skyblue: "#87CEEB",
							slateblue: "#6A5ACD",
							slategray: "#708090",
							slategrey: "#708090",
							snow: "#FFFAFA",
							springgreen: "#00FF7F",
							steelblue: "#4682B4",
							tan: "#D2B48C",
							teal: "#008080",
							thistle: "#D8BFD8",
							tomato: "#FF6347",
							turquoise: "#40E0D0",
							violet: "#EE82EE",
							wheat: "#F5DEB3",
							white: "#FFFFFF",
							whitesmoke: "#F5F5F5",
							yellow: "#FFFF00",
							yellowgreen: "#9ACD32"
						}, e.Color.fromRgb = function(t) {
							return n.fromSource(n.sourceFromRgb(t))
						}, e.Color.sourceFromRgb = function(t) {
							var e = t.match(n.reRGBa);
							if (e) {
								var r = parseInt(e[1], 10) / (/%$/.test(e[1]) ? 100 : 1) * (/%$/.test(e[1]) ? 255 : 1),
									i = parseInt(e[2], 10) / (/%$/.test(e[2]) ? 100 : 1) * (/%$/.test(e[2]) ? 255 : 1),
									o = parseInt(e[3], 10) / (/%$/.test(e[3]) ? 100 : 1) * (/%$/.test(e[3]) ? 255 : 1);
								return [parseInt(r, 10), parseInt(i, 10), parseInt(o, 10), e[4] ? parseFloat(e[4]) : 1]
							}
						}, e.Color.fromRgba = n.fromRgb, e.Color.fromHsl = function(t) {
							return n.fromSource(n.sourceFromHsl(t))
						}, e.Color.sourceFromHsl = function(t) {
							var e = t.match(n.reHSLa);
							if (e) {
								var i, o, a, s = (parseFloat(e[1]) % 360 + 360) % 360 / 360,
									l = parseFloat(e[2]) / (/%$/.test(e[2]) ? 100 : 1),
									c = parseFloat(e[3]) / (/%$/.test(e[3]) ? 100 : 1);
								if (0 === l) i = o = a = c;
								else {
									var u = c <= .5 ? c * (l + 1) : c + l - c * l,
										h = 2 * c - u;
									i = r(h, u, s + 1 / 3), o = r(h, u, s), a = r(h, u, s - 1 / 3)
								}
								return [Math.round(255 * i), Math.round(255 * o), Math.round(255 * a), e[4] ? parseFloat(e[4]) : 1]
							}
						}, e.Color.fromHsla = n.fromHsl, e.Color.fromHex = function(t) {
							return n.fromSource(n.sourceFromHex(t))
						}, e.Color.sourceFromHex = function(t) {
							if (t.match(n.reHex)) {
								var e = t.slice(t.indexOf("#") + 1),
									r = 3 === e.length || 4 === e.length,
									i = 8 === e.length || 4 === e.length,
									o = r ? e.charAt(0) + e.charAt(0) : e.substring(0, 2),
									a = r ? e.charAt(1) + e.charAt(1) : e.substring(2, 4),
									s = r ? e.charAt(2) + e.charAt(2) : e.substring(4, 6),
									l = i ? r ? e.charAt(3) + e.charAt(3) : e.substring(6, 8) : "FF";
								return [parseInt(o, 16), parseInt(a, 16), parseInt(s, 16), parseFloat((parseInt(l, 16) / 255).toFixed(2))]
							}
						}, e.Color.fromSource = function(t) {
							var e = new n;
							return e.setSource(t), e
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"],
							r = ["ns", "nesw", "ew", "nwse"],
							i = {},
							o = "left",
							a = "top",
							s = "right",
							l = "bottom",
							c = "center",
							u = {
								top: l,
								bottom: a,
								left: s,
								right: o,
								center: c
							},
							h = e.util.radiansToDegrees,
							f = Math.sign || function(t) {
								return (t > 0) - (t < 0) || +t
							};

						function d(t, e) {
							var n = t.angle + h(Math.atan2(e.y, e.x)) + 360;
							return Math.round(n % 360 / 45)
						}

						function p(t, n) {
							var r = n.transform.target,
								i = r.canvas,
								o = e.util.object.clone(n);
							o.target = r, i && i.fire("object:" + t, o), r.fire(t, n)
						}

						function g(t, e) {
							var n = e.canvas,
								r = t[n.uniScaleKey];
							return n.uniformScaling && !r || !n.uniformScaling && r
						}

						function v(t) {
							return t.originX === c && t.originY === c
						}

						function m(t, e, n) {
							var r = t.lockScalingX,
								i = t.lockScalingY;
							return !((!r || !i) && (e || !r && !i || !n) && (!r || "x" !== e) && (!i || "y" !== e))
						}

						function y(t, e, n, r) {
							return {
								e: t,
								transform: e,
								pointer: {
									x: n,
									y: r
								}
							}
						}

						function b(t) {
							return function(e, n, r, i) {
								var o = n.target,
									a = o.getCenterPoint(),
									s = o.translateToOriginPoint(a, n.originX, n.originY),
									l = t(e, n, r, i);
								return o.setPositionByOrigin(s, n.originX, n.originY), l
							}
						}

						function x(t, e) {
							return function(n, r, i, o) {
								var a = e(n, r, i, o);
								return a && p(t, y(n, r, i, o)), a
							}
						}

						function w(t, n, r, i, o) {
							var a = t.target,
								s = a.controls[t.corner],
								l = a.canvas.getZoom(),
								c = a.padding / l,
								u = a.toLocalPoint(new e.Point(i, o), n, r);
							return u.x >= c && (u.x -= c), u.x <= -c && (u.x += c), u.y >= c && (u.y -= c), u.y <= c && (u.y += c), u.x -= s.offsetX, u.y -= s.offsetY, u
						}

						function C(t) {
							return t.flipX !== t.flipY
						}

						function S(t, e, n, r, i) {
							if (0 !== t[e]) {
								var o = i / t._getTransformedDimensions()[r] * t[n];
								t.set(n, o)
							}
						}

						function O(t, e, n, r) {
							var i, c = e.target,
								u = c._getTransformedDimensions(0, c.skewY),
								f = w(e, e.originX, e.originY, n, r),
								d = Math.abs(2 * f.x) - u.x,
								p = c.skewX;
							d < 2 ? i = 0 : (i = h(Math.atan2(d / c.scaleX, u.y / c.scaleY)), e.originX === o && e.originY === l && (i = -i), e.originX === s && e.originY === a && (i = -i), C(c) && (i = -i));
							var g = p !== i;
							if (g) {
								var v = c._getTransformedDimensions().y;
								c.set("skewX", i), S(c, "skewY", "scaleY", "y", v)
							}
							return g
						}

						function T(t, e, n, r) {
							var i, c = e.target,
								u = c._getTransformedDimensions(c.skewX, 0),
								f = w(e, e.originX, e.originY, n, r),
								d = Math.abs(2 * f.y) - u.y,
								p = c.skewY;
							d < 2 ? i = 0 : (i = h(Math.atan2(d / c.scaleY, u.x / c.scaleX)), e.originX === o && e.originY === l && (i = -i), e.originX === s && e.originY === a && (i = -i), C(c) && (i = -i));
							var g = p !== i;
							if (g) {
								var v = c._getTransformedDimensions().x;
								c.set("skewY", i), S(c, "skewX", "scaleX", "x", v)
							}
							return g
						}

						function k(t, e, n, r, i) {
							i = i || {};
							var o, a, s, l, c, h, d = e.target,
								p = d.lockScalingX,
								y = d.lockScalingY,
								b = i.by,
								x = g(t, d),
								C = m(d, b, x),
								S = e.gestureScale;
							if (C) return !1;
							if (S) a = e.scaleX * S, s = e.scaleY * S;
							else {
								if (o = w(e, e.originX, e.originY, n, r), c = "y" !== b ? f(o.x) : 1, h = "x" !== b ? f(o.y) : 1, e.signX || (e.signX = c), e.signY || (e.signY = h), d.lockScalingFlip && (e.signX !== c || e.signY !== h)) return !1;
								if (l = d._getTransformedDimensions(), x && !b) {
									var O = Math.abs(o.x) + Math.abs(o.y),
										T = e.original,
										k = O / (Math.abs(l.x * T.scaleX / d.scaleX) + Math.abs(l.y * T.scaleY / d.scaleY));
									a = T.scaleX * k, s = T.scaleY * k
								} else a = Math.abs(o.x * d.scaleX / l.x), s = Math.abs(o.y * d.scaleY / l.y);
								v(e) && (a *= 2, s *= 2), e.signX !== c && "y" !== b && (e.originX = u[e.originX], a *= -1, e.signX = c), e.signY !== h && "x" !== b && (e.originY = u[e.originY], s *= -1, e.signY = h)
							}
							var F = d.scaleX,
								P = d.scaleY;
							return b ? ("x" === b && d.set("scaleX", a), "y" === b && d.set("scaleY", s)) : (!p && d.set("scaleX", a), !y && d.set("scaleY", s)), F !== d.scaleX || P !== d.scaleY
						}
						i.scaleCursorStyleHandler = function(t, e, r) {
							var i = g(t, r),
								o = "";
							if (0 !== e.x && 0 === e.y ? o = "x" : 0 === e.x && 0 !== e.y && (o = "y"), m(r, o, i)) return "not-allowed";
							var a = d(r, e);
							return n[a] + "-resize"
						}, i.skewCursorStyleHandler = function(t, e, n) {
							var i = "not-allowed";
							if (0 !== e.x && n.lockSkewingY) return i;
							if (0 !== e.y && n.lockSkewingX) return i;
							var o = d(n, e) % 4;
							return r[o] + "-resize"
						}, i.scaleSkewCursorStyleHandler = function(t, e, n) {
							return t[n.canvas.altActionKey] ? i.skewCursorStyleHandler(t, e, n) : i.scaleCursorStyleHandler(t, e, n)
						}, i.rotationWithSnapping = x("rotating", b((function(t, e, n, r) {
							var i = e,
								o = i.target,
								a = o.translateToOriginPoint(o.getCenterPoint(), i.originX, i.originY);
							if (o.lockRotation) return !1;
							var s, l = Math.atan2(i.ey - a.y, i.ex - a.x),
								c = Math.atan2(r - a.y, n - a.x),
								u = h(c - l + i.theta);
							if (o.snapAngle > 0) {
								var f = o.snapAngle,
									d = o.snapThreshold || f,
									p = Math.ceil(u / f) * f,
									g = Math.floor(u / f) * f;
								Math.abs(u - g) < d ? u = g : Math.abs(u - p) < d && (u = p)
							}
							return u < 0 && (u = 360 + u), u %= 360, s = o.angle !== u, o.angle = u, s
						}))), i.scalingEqually = x("scaling", b((function(t, e, n, r) {
							return k(t, e, n, r)
						}))), i.scalingX = x("scaling", b((function(t, e, n, r) {
							return k(t, e, n, r, {
								by: "x"
							})
						}))), i.scalingY = x("scaling", b((function(t, e, n, r) {
							return k(t, e, n, r, {
								by: "y"
							})
						}))), i.scalingYOrSkewingX = function(t, e, n, r) {
							return t[e.target.canvas.altActionKey] ? i.skewHandlerX(t, e, n, r) : i.scalingY(t, e, n, r)
						}, i.scalingXOrSkewingY = function(t, e, n, r) {
							return t[e.target.canvas.altActionKey] ? i.skewHandlerY(t, e, n, r) : i.scalingX(t, e, n, r)
						}, i.changeWidth = x("resizing", b((function(t, e, n, r) {
							var i = e.target,
								o = w(e, e.originX, e.originY, n, r),
								a = i.strokeWidth / (i.strokeUniform ? i.scaleX : 1),
								s = v(e) ? 2 : 1,
								l = i.width,
								c = Math.abs(o.x * s / i.scaleX) - a;
							return i.set("width", Math.max(c, 0)), l !== c
						}))), i.skewHandlerX = function(t, e, n, r) {
							var i, l = e.target,
								u = l.skewX,
								h = e.originY;
							return !l.lockSkewingX && (0 === u ? i = w(e, c, c, n, r).x > 0 ? o : s : (u > 0 && (i = h === a ? o : s), u < 0 && (i = h === a ? s : o), C(l) && (i = i === o ? s : o)), e.originX = i, x("skewing", b(O))(t, e, n, r))
						}, i.skewHandlerY = function(t, e, n, r) {
							var i, s = e.target,
								u = s.skewY,
								h = e.originX;
							return !s.lockSkewingY && (0 === u ? i = w(e, c, c, n, r).y > 0 ? a : l : (u > 0 && (i = h === o ? a : l), u < 0 && (i = h === o ? l : a), C(s) && (i = i === a ? l : a)), e.originY = i, x("skewing", b(T))(t, e, n, r))
						}, i.dragHandler = function(t, e, n, r) {
							var i = e.target,
								o = n - e.offsetX,
								a = r - e.offsetY,
								s = !i.get("lockMovementX") && i.left !== o,
								l = !i.get("lockMovementY") && i.top !== a;
							return s && i.set("left", o), l && i.set("top", a), (s || l) && p("moving", y(t, e, n, r)), s || l
						}, i.scaleOrSkewActionName = function(t, e, n) {
							var r = t[n.canvas.altActionKey];
							return 0 === e.x ? r ? "skewX" : "scaleY" : 0 === e.y ? r ? "skewY" : "scaleX" : void 0
						}, i.rotationStyleHandler = function(t, e, n) {
							return n.lockRotation ? "not-allowed" : e.cursorStyle
						}, i.fireEvent = p, i.wrapWithFixedAnchor = b, i.wrapWithFireEvent = x, i.getLocalPoint = w, e.controlsUtils = i
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.degreesToRadians,
							r = e.controlsUtils;
						r.renderCircleControl = function(t, e, n, r, i) {
							r = r || {};
							var o, a = this.sizeX || r.cornerSize || i.cornerSize,
								s = this.sizeY || r.cornerSize || i.cornerSize,
								l = void 0 !== r.transparentCorners ? r.transparentCorners : i.transparentCorners,
								c = l ? "stroke" : "fill",
								u = !l && (r.cornerStrokeColor || i.cornerStrokeColor),
								h = e,
								f = n;
							t.save(), t.fillStyle = r.cornerColor || i.cornerColor, t.strokeStyle = r.cornerStrokeColor || i.cornerStrokeColor, a > s ? (o = a, t.scale(1, s / a), f = n * a / s) : s > a ? (o = s, t.scale(a / s, 1), h = e * s / a) : o = a, t.lineWidth = 1, t.beginPath(), t.arc(h, f, o / 2, 0, 2 * Math.PI, !1), t[c](), u && t.stroke(), t.restore()
						}, r.renderSquareControl = function(t, e, r, i, o) {
							i = i || {};
							var a = this.sizeX || i.cornerSize || o.cornerSize,
								s = this.sizeY || i.cornerSize || o.cornerSize,
								l = void 0 !== i.transparentCorners ? i.transparentCorners : o.transparentCorners,
								c = l ? "stroke" : "fill",
								u = !l && (i.cornerStrokeColor || o.cornerStrokeColor),
								h = a / 2,
								f = s / 2;
							t.save(), t.fillStyle = i.cornerColor || o.cornerColor, t.strokeStyle = i.cornerStrokeColor || o.cornerStrokeColor, t.lineWidth = 1, t.translate(e, r), t.rotate(n(o.angle)), t[c + "Rect"](-h, -f, a, s), u && t.strokeRect(-h, -f, a, s), t.restore()
						}
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});
						e.Control = function(t) {
							for (var e in t) this[e] = t[e]
						}, e.Control.prototype = {
							visible: !0,
							actionName: "scale",
							angle: 0,
							x: 0,
							y: 0,
							offsetX: 0,
							offsetY: 0,
							sizeX: null,
							sizeY: null,
							touchSizeX: null,
							touchSizeY: null,
							cursorStyle: "crosshair",
							withConnection: !1,
							actionHandler: function() {},
							mouseDownHandler: function() {},
							mouseUpHandler: function() {},
							getActionHandler: function() {
								return this.actionHandler
							},
							getMouseDownHandler: function() {
								return this.mouseDownHandler
							},
							getMouseUpHandler: function() {
								return this.mouseUpHandler
							},
							cursorStyleHandler: function(t, e) {
								return e.cursorStyle
							},
							getActionName: function(t, e) {
								return e.actionName
							},
							getVisibility: function(t, e) {
								var n = t._controlsVisibility;
								return n && void 0 !== n[e] ? n[e] : this.visible
							},
							setVisibility: function(t) {
								this.visible = t
							},
							positionHandler: function(t, n) {
								return e.util.transformPoint({
									x: this.x * t.x + this.offsetX,
									y: this.y * t.y + this.offsetY
								}, n)
							},
							calcCornerCoords: function(t, n, r, i, o) {
								var a, s, l, c, u = o ? this.touchSizeX : this.sizeX,
									h = o ? this.touchSizeY : this.sizeY;
								if (u && h && u !== h) {
									var f = Math.atan2(h, u),
										d = Math.sqrt(u * u + h * h) / 2,
										p = f - e.util.degreesToRadians(t),
										g = Math.PI / 2 - f - e.util.degreesToRadians(t);
									a = d * e.util.cos(p), s = d * e.util.sin(p), l = d * e.util.cos(g), c = d * e.util.sin(g)
								} else d = .7071067812 * (u && h ? u : n), p = e.util.degreesToRadians(45 - t), a = l = d * e.util.cos(p), s = c = d * e.util.sin(p);
								return {
									tl: {
										x: r - c,
										y: i - l
									},
									tr: {
										x: r + a,
										y: i - s
									},
									bl: {
										x: r - a,
										y: i + s
									},
									br: {
										x: r + c,
										y: i + l
									}
								}
							},
							render: function(t, n, r, i, o) {
								"circle" === ((i = i || {}).cornerStyle || o.cornerStyle) ? e.controlsUtils.renderCircleControl.call(this, t, n, r, i, o): e.controlsUtils.renderSquareControl.call(this, t, n, r, i, o)
							}
						}
					}(e),
					function() {
						function t(t, e) {
							var n, r, i, o, a = t.getAttribute("style"),
								s = t.getAttribute("offset") || 0;
							if (s = (s = parseFloat(s) / (/%$/.test(s) ? 100 : 1)) < 0 ? 0 : s > 1 ? 1 : s, a) {
								var l = a.split(/\s*;\s*/);
								for ("" === l[l.length - 1] && l.pop(), o = l.length; o--;) {
									var c = l[o].split(/\s*:\s*/),
										u = c[0].trim(),
										h = c[1].trim();
									"stop-color" === u ? n = h : "stop-opacity" === u && (i = h)
								}
							}
							return n || (n = t.getAttribute("stop-color") || "rgb(0,0,0)"), i || (i = t.getAttribute("stop-opacity")), r = (n = new b.Color(n)).getAlpha(), i = isNaN(parseFloat(i)) ? 1 : parseFloat(i), i *= r * e, {
								offset: s,
								color: n.toRgb(),
								opacity: i
							}
						}
						var e = b.util.object.clone;
						b.Gradient = b.util.createClass({
							offsetX: 0,
							offsetY: 0,
							gradientTransform: null,
							gradientUnits: "pixels",
							type: "linear",
							initialize: function(t) {
								t || (t = {}), t.coords || (t.coords = {});
								var e, n = this;
								Object.keys(t).forEach((function(e) {
									n[e] = t[e]
								})), this.id ? this.id += "_" + b.Object.__uid++ : this.id = b.Object.__uid++, e = {
									x1: t.coords.x1 || 0,
									y1: t.coords.y1 || 0,
									x2: t.coords.x2 || 0,
									y2: t.coords.y2 || 0
								}, "radial" === this.type && (e.r1 = t.coords.r1 || 0, e.r2 = t.coords.r2 || 0), this.coords = e, this.colorStops = t.colorStops.slice()
							},
							addColorStop: function(t) {
								for (var e in t) {
									var n = new b.Color(t[e]);
									this.colorStops.push({
										offset: parseFloat(e),
										color: n.toRgb(),
										opacity: n.getAlpha()
									})
								}
								return this
							},
							toObject: function(t) {
								var e = {
									type: this.type,
									coords: this.coords,
									colorStops: this.colorStops,
									offsetX: this.offsetX,
									offsetY: this.offsetY,
									gradientUnits: this.gradientUnits,
									gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
								};
								return b.util.populateWithProperties(this, e, t), e
							},
							toSVG: function(t, n) {
								var r, i, o, a, s = e(this.coords, !0),
									l = (n = n || {}, e(this.colorStops, !0)),
									c = s.r1 > s.r2,
									u = this.gradientTransform ? this.gradientTransform.concat() : b.iMatrix.concat(),
									h = -this.offsetX,
									f = -this.offsetY,
									d = !!n.additionalTransform,
									p = "pixels" === this.gradientUnits ? "userSpaceOnUse" : "objectBoundingBox";
								if (l.sort((function(t, e) {
										return t.offset - e.offset
									})), "objectBoundingBox" === p ? (h /= t.width, f /= t.height) : (h += t.width / 2, f += t.height / 2), "path" === t.type && "percentage" !== this.gradientUnits && (h -= t.pathOffset.x, f -= t.pathOffset.y), u[4] -= h, u[5] -= f, a = 'id="SVGID_' + this.id + '" gradientUnits="' + p + '"', a += ' gradientTransform="' + (d ? n.additionalTransform + " " : "") + b.util.matrixToSVG(u) + '" ', "linear" === this.type ? o = ["<linearGradient ", a, ' x1="', s.x1, '" y1="', s.y1, '" x2="', s.x2, '" y2="', s.y2, '">\n'] : "radial" === this.type && (o = ["<radialGradient ", a, ' cx="', c ? s.x1 : s.x2, '" cy="', c ? s.y1 : s.y2, '" r="', c ? s.r1 : s.r2, '" fx="', c ? s.x2 : s.x1, '" fy="', c ? s.y2 : s.y1, '">\n']), "radial" === this.type) {
									if (c)
										for ((l = l.concat()).reverse(), r = 0, i = l.length; r < i; r++) l[r].offset = 1 - l[r].offset;
									var g = Math.min(s.r1, s.r2);
									if (g > 0) {
										var v = g / Math.max(s.r1, s.r2);
										for (r = 0, i = l.length; r < i; r++) l[r].offset += v * (1 - l[r].offset)
									}
								}
								for (r = 0, i = l.length; r < i; r++) {
									var m = l[r];
									o.push("<stop ", 'offset="', 100 * m.offset + "%", '" style="stop-color:', m.color, void 0 !== m.opacity ? ";stop-opacity: " + m.opacity : ";", '"/>\n')
								}
								return o.push("linear" === this.type ? "</linearGradient>\n" : "</radialGradient>\n"), o.join("")
							},
							toLive: function(t) {
								var e, n, r, i = b.util.object.clone(this.coords);
								if (this.type) {
									for ("linear" === this.type ? e = t.createLinearGradient(i.x1, i.y1, i.x2, i.y2) : "radial" === this.type && (e = t.createRadialGradient(i.x1, i.y1, i.r1, i.x2, i.y2, i.r2)), n = 0, r = this.colorStops.length; n < r; n++) {
										var o = this.colorStops[n].color,
											a = this.colorStops[n].opacity,
											s = this.colorStops[n].offset;
										void 0 !== a && (o = new b.Color(o).setAlpha(a).toRgba()), e.addColorStop(s, o)
									}
									return e
								}
							}
						}), b.util.object.extend(b.Gradient, {
							fromElement: function(e, n, r, i) {
								var o = parseFloat(r) / (/%$/.test(r) ? 100 : 1);
								o = o < 0 ? 0 : o > 1 ? 1 : o, isNaN(o) && (o = 1);
								var a, s, l, c, u = e.getElementsByTagName("stop"),
									h = "userSpaceOnUse" === e.getAttribute("gradientUnits") ? "pixels" : "percentage",
									f = e.getAttribute("gradientTransform") || "",
									d = [],
									p = 0,
									g = 0;
								for ("linearGradient" === e.nodeName || "LINEARGRADIENT" === e.nodeName ? (a = "linear", s = function(t) {
										return {
											x1: t.getAttribute("x1") || 0,
											y1: t.getAttribute("y1") || 0,
											x2: t.getAttribute("x2") || "100%",
											y2: t.getAttribute("y2") || 0
										}
									}(e)) : (a = "radial", s = function(t) {
										return {
											x1: t.getAttribute("fx") || t.getAttribute("cx") || "50%",
											y1: t.getAttribute("fy") || t.getAttribute("cy") || "50%",
											r1: 0,
											x2: t.getAttribute("cx") || "50%",
											y2: t.getAttribute("cy") || "50%",
											r2: t.getAttribute("r") || "50%"
										}
									}(e)), l = u.length; l--;) d.push(t(u[l], o));
								return c = b.parseTransformAttribute(f),
									function(t, e, n, r) {
										var i, o;
										Object.keys(e).forEach((function(t) {
											"Infinity" === (i = e[t]) ? o = 1: "-Infinity" === i ? o = 0 : (o = parseFloat(e[t], 10), "string" == typeof i && /^(\d+\.\d+)%|(\d+)%$/.test(i) && (o *= .01, "pixels" === r && ("x1" !== t && "x2" !== t && "r2" !== t || (o *= n.viewBoxWidth || n.width), "y1" !== t && "y2" !== t || (o *= n.viewBoxHeight || n.height)))), e[t] = o
										}))
									}(0, s, i, h), "pixels" === h && (p = -n.left, g = -n.top), new b.Gradient({
										id: e.getAttribute("id"),
										type: a,
										coords: s,
										colorStops: d,
										gradientUnits: h,
										gradientTransform: c,
										offsetX: p,
										offsetY: g
									})
							}
						})
					}(),
					function() {
						"use strict";
						var t = b.util.toFixed;
						b.Pattern = b.util.createClass({
							repeat: "repeat",
							offsetX: 0,
							offsetY: 0,
							crossOrigin: "",
							patternTransform: null,
							initialize: function(t, e) {
								if (t || (t = {}), this.id = b.Object.__uid++, this.setOptions(t), !t.source || t.source && "string" != typeof t.source) e && e(this);
								else {
									var n = this;
									this.source = b.util.createImage(), b.util.loadImage(t.source, (function(t, r) {
										n.source = t, e && e(n, r)
									}), null, this.crossOrigin)
								}
							},
							toObject: function(e) {
								var n, r, i = b.Object.NUM_FRACTION_DIGITS;
								return "string" == typeof this.source.src ? n = this.source.src : "object" == typeof this.source && this.source.toDataURL && (n = this.source.toDataURL()), r = {
									type: "pattern",
									source: n,
									repeat: this.repeat,
									crossOrigin: this.crossOrigin,
									offsetX: t(this.offsetX, i),
									offsetY: t(this.offsetY, i),
									patternTransform: this.patternTransform ? this.patternTransform.concat() : null
								}, b.util.populateWithProperties(this, r, e), r
							},
							toSVG: function(t) {
								var e = "function" == typeof this.source ? this.source() : this.source,
									n = e.width / t.width,
									r = e.height / t.height,
									i = this.offsetX / t.width,
									o = this.offsetY / t.height,
									a = "";
								return "repeat-x" !== this.repeat && "no-repeat" !== this.repeat || (r = 1, o && (r += Math.abs(o))), "repeat-y" !== this.repeat && "no-repeat" !== this.repeat || (n = 1, i && (n += Math.abs(i))), e.src ? a = e.src : e.toDataURL && (a = e.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + i + '" y="' + o + '" width="' + n + '" height="' + r + '">\n<image x="0" y="0" width="' + e.width + '" height="' + e.height + '" xlink:href="' + a + '"></image>\n</pattern>\n'
							},
							setOptions: function(t) {
								for (var e in t) this[e] = t[e]
							},
							toLive: function(t) {
								var e = this.source;
								if (!e) return "";
								if (void 0 !== e.src) {
									if (!e.complete) return "";
									if (0 === e.naturalWidth || 0 === e.naturalHeight) return ""
								}
								return t.createPattern(e, this.repeat)
							}
						})
					}(),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.toFixed;
						e.Shadow ? e.warn("fabric.Shadow is already defined.") : (e.Shadow = e.util.createClass({
							color: "rgb(0,0,0)",
							blur: 0,
							offsetX: 0,
							offsetY: 0,
							affectStroke: !1,
							includeDefaultValues: !0,
							nonScaling: !1,
							initialize: function(t) {
								for (var n in "string" == typeof t && (t = this._parseShadow(t)), t) this[n] = t[n];
								this.id = e.Object.__uid++
							},
							_parseShadow: function(t) {
								var n = t.trim(),
									r = e.Shadow.reOffsetsAndBlur.exec(n) || [];
								return {
									color: (n.replace(e.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)").trim(),
									offsetX: parseFloat(r[1], 10) || 0,
									offsetY: parseFloat(r[2], 10) || 0,
									blur: parseFloat(r[3], 10) || 0
								}
							},
							toString: function() {
								return [this.offsetX, this.offsetY, this.blur, this.color].join("px ")
							},
							toSVG: function(t) {
								var r = 40,
									i = 40,
									o = e.Object.NUM_FRACTION_DIGITS,
									a = e.util.rotateVector({
										x: this.offsetX,
										y: this.offsetY
									}, e.util.degreesToRadians(-t.angle)),
									s = new e.Color(this.color);
								return t.width && t.height && (r = 100 * n((Math.abs(a.x) + this.blur) / t.width, o) + 20, i = 100 * n((Math.abs(a.y) + this.blur) / t.height, o) + 20), t.flipX && (a.x *= -1), t.flipY && (a.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + i + '%" height="' + (100 + 2 * i) + '%" x="-' + r + '%" width="' + (100 + 2 * r) + '%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="' + n(this.blur ? this.blur / 2 : 0, o) + '"></feGaussianBlur>\n\t<feOffset dx="' + n(a.x, o) + '" dy="' + n(a.y, o) + '" result="oBlur" ></feOffset>\n\t<feFlood flood-color="' + s.toRgb() + '" flood-opacity="' + s.getAlpha() + '"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n'
							},
							toObject: function() {
								if (this.includeDefaultValues) return {
									color: this.color,
									blur: this.blur,
									offsetX: this.offsetX,
									offsetY: this.offsetY,
									affectStroke: this.affectStroke,
									nonScaling: this.nonScaling
								};
								var t = {},
									n = e.Shadow.prototype;
								return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach((function(e) {
									this[e] !== n[e] && (t[e] = this[e])
								}), this), t
							}
						}), e.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/)
					}(e),
					function() {
						"use strict";
						if (b.StaticCanvas) b.warn("fabric.StaticCanvas is already defined.");
						else {
							var t = b.util.object.extend,
								e = b.util.getElementOffset,
								n = b.util.removeFromArray,
								r = b.util.toFixed,
								i = b.util.transformPoint,
								o = b.util.invertTransform,
								a = b.util.getNodeCanvas,
								s = b.util.createCanvasElement,
								l = new Error("Could not initialize `canvas` element");
							b.StaticCanvas = b.util.createClass(b.CommonMethods, {
								initialize: function(t, e) {
									e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e)
								},
								backgroundColor: "",
								backgroundImage: null,
								overlayColor: "",
								overlayImage: null,
								includeDefaultValues: !0,
								stateful: !1,
								renderOnAddRemove: !0,
								controlsAboveOverlay: !1,
								allowTouchScrolling: !1,
								imageSmoothingEnabled: !0,
								viewportTransform: b.iMatrix.concat(),
								backgroundVpt: !0,
								overlayVpt: !0,
								enableRetinaScaling: !0,
								vptCoords: {},
								skipOffscreen: !0,
								clipPath: void 0,
								_initStatic: function(t, e) {
									var n = this.requestRenderAllBound;
									this._objects = [], this._createLowerCanvas(t), this._initOptions(e), this.interactive || this._initRetinaScaling(), e.overlayImage && this.setOverlayImage(e.overlayImage, n), e.backgroundImage && this.setBackgroundImage(e.backgroundImage, n), e.backgroundColor && this.setBackgroundColor(e.backgroundColor, n), e.overlayColor && this.setOverlayColor(e.overlayColor, n), this.calcOffset()
								},
								_isRetinaScaling: function() {
									return b.devicePixelRatio > 1 && this.enableRetinaScaling
								},
								getRetinaScaling: function() {
									return this._isRetinaScaling() ? Math.max(1, b.devicePixelRatio) : 1
								},
								_initRetinaScaling: function() {
									if (this._isRetinaScaling()) {
										var t = b.devicePixelRatio;
										this.__initRetinaScaling(t, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(t, this.upperCanvasEl, this.contextTop)
									}
								},
								__initRetinaScaling: function(t, e, n) {
									e.setAttribute("width", this.width * t), e.setAttribute("height", this.height * t), n.scale(t, t)
								},
								calcOffset: function() {
									return this._offset = e(this.lowerCanvasEl), this
								},
								setOverlayImage: function(t, e, n) {
									return this.__setBgOverlayImage("overlayImage", t, e, n)
								},
								setBackgroundImage: function(t, e, n) {
									return this.__setBgOverlayImage("backgroundImage", t, e, n)
								},
								setOverlayColor: function(t, e) {
									return this.__setBgOverlayColor("overlayColor", t, e)
								},
								setBackgroundColor: function(t, e) {
									return this.__setBgOverlayColor("backgroundColor", t, e)
								},
								__setBgOverlayImage: function(t, e, n, r) {
									return "string" == typeof e ? b.util.loadImage(e, (function(e, i) {
										if (e) {
											var o = new b.Image(e, r);
											this[t] = o, o.canvas = this
										}
										n && n(e, i)
									}), this, r && r.crossOrigin) : (r && e.setOptions(r), this[t] = e, e && (e.canvas = this), n && n(e, !1)), this
								},
								__setBgOverlayColor: function(t, e, n) {
									return this[t] = e, this._initGradient(e, t), this._initPattern(e, t, n), this
								},
								_createCanvasElement: function() {
									var t = s();
									if (!t) throw l;
									if (t.style || (t.style = {}), void 0 === t.getContext) throw l;
									return t
								},
								_initOptions: function(t) {
									var e = this.lowerCanvasEl;
									this._setOptions(t), this.width = this.width || parseInt(e.width, 10) || 0, this.height = this.height || parseInt(e.height, 10) || 0, this.lowerCanvasEl.style && (e.width = this.width, e.height = this.height, e.style.width = this.width + "px", e.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice())
								},
								_createLowerCanvas: function(t) {
									t && t.getContext ? this.lowerCanvasEl = t : this.lowerCanvasEl = b.util.getById(t) || this._createCanvasElement(), b.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d")
								},
								getWidth: function() {
									return this.width
								},
								getHeight: function() {
									return this.height
								},
								setWidth: function(t, e) {
									return this.setDimensions({
										width: t
									}, e)
								},
								setHeight: function(t, e) {
									return this.setDimensions({
										height: t
									}, e)
								},
								setDimensions: function(t, e) {
									var n;
									for (var r in e = e || {}, t) n = t[r], e.cssOnly || (this._setBackstoreDimension(r, t[r]), n += "px", this.hasLostContext = !0), e.backstoreOnly || this._setCssDimension(r, n);
									return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), e.cssOnly || this.requestRenderAll(), this
								},
								_setBackstoreDimension: function(t, e) {
									return this.lowerCanvasEl[t] = e, this.upperCanvasEl && (this.upperCanvasEl[t] = e), this.cacheCanvasEl && (this.cacheCanvasEl[t] = e), this[t] = e, this
								},
								_setCssDimension: function(t, e) {
									return this.lowerCanvasEl.style[t] = e, this.upperCanvasEl && (this.upperCanvasEl.style[t] = e), this.wrapperEl && (this.wrapperEl.style[t] = e), this
								},
								getZoom: function() {
									return this.viewportTransform[0]
								},
								setViewportTransform: function(t) {
									var e, n, r, i = this._activeObject,
										o = this.backgroundImage,
										a = this.overlayImage;
									for (this.viewportTransform = t, n = 0, r = this._objects.length; n < r; n++)(e = this._objects[n]).group || e.setCoords(!0);
									return i && i.setCoords(), o && o.setCoords(!0), a && a.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this
								},
								zoomToPoint: function(t, e) {
									var n = t,
										r = this.viewportTransform.slice(0);
									t = i(t, o(this.viewportTransform)), r[0] = e, r[3] = e;
									var a = i(t, r);
									return r[4] += n.x - a.x, r[5] += n.y - a.y, this.setViewportTransform(r)
								},
								setZoom: function(t) {
									return this.zoomToPoint(new b.Point(0, 0), t), this
								},
								absolutePan: function(t) {
									var e = this.viewportTransform.slice(0);
									return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e)
								},
								relativePan: function(t) {
									return this.absolutePan(new b.Point(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5]))
								},
								getElement: function() {
									return this.lowerCanvasEl
								},
								_onObjectAdded: function(t) {
									this.stateful && t.setupState(), t._set("canvas", this), t.setCoords(), this.fire("object:added", {
										target: t
									}), t.fire("added")
								},
								_onObjectRemoved: function(t) {
									this.fire("object:removed", {
										target: t
									}), t.fire("removed"), delete t.canvas
								},
								clearContext: function(t) {
									return t.clearRect(0, 0, this.width, this.height), this
								},
								getContext: function() {
									return this.contextContainer
								},
								clear: function() {
									return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this
								},
								renderAll: function() {
									var t = this.contextContainer;
									return this.renderCanvas(t, this._objects), this
								},
								renderAndReset: function() {
									this.isRendering = 0, this.renderAll()
								},
								requestRenderAll: function() {
									return this.isRendering || (this.isRendering = b.util.requestAnimFrame(this.renderAndResetBound)), this
								},
								calcViewportBoundaries: function() {
									var t = {},
										e = this.width,
										n = this.height,
										r = o(this.viewportTransform);
									return t.tl = i({
										x: 0,
										y: 0
									}, r), t.br = i({
										x: e,
										y: n
									}, r), t.tr = new b.Point(t.br.x, t.tl.y), t.bl = new b.Point(t.tl.x, t.br.y), this.vptCoords = t, t
								},
								cancelRequestedRender: function() {
									this.isRendering && (b.util.cancelAnimFrame(this.isRendering), this.isRendering = 0)
								},
								renderCanvas: function(t, e) {
									var n = this.viewportTransform,
										r = this.clipPath;
									this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(t), b.util.setImageSmoothing(t, this.imageSmoothingEnabled), this.fire("before:render", {
										ctx: t
									}), this._renderBackground(t), t.save(), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this._renderObjects(t, e), t.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(t), r && (r.canvas = this, r.shouldCache(), r._transformDone = !0, r.renderCache({
										forClipping: !0
									}), this.drawClipPathOnCanvas(t)), this._renderOverlay(t), this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.fire("after:render", {
										ctx: t
									})
								},
								drawClipPathOnCanvas: function(t) {
									var e = this.viewportTransform,
										n = this.clipPath;
									t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t.globalCompositeOperation = "destination-in", n.transform(t), t.scale(1 / n.zoomX, 1 / n.zoomY), t.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), t.restore()
								},
								_renderObjects: function(t, e) {
									var n, r;
									for (n = 0, r = e.length; n < r; ++n) e[n] && e[n].render(t)
								},
								_renderBackgroundOrOverlay: function(t, e) {
									var n = this[e + "Color"],
										r = this[e + "Image"],
										i = this.viewportTransform,
										o = this[e + "Vpt"];
									if (n || r) {
										if (n) {
											t.save(), t.beginPath(), t.moveTo(0, 0), t.lineTo(this.width, 0), t.lineTo(this.width, this.height), t.lineTo(0, this.height), t.closePath(), t.fillStyle = n.toLive ? n.toLive(t, this) : n, o && t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), t.transform(1, 0, 0, 1, n.offsetX || 0, n.offsetY || 0);
											var a = n.gradientTransform || n.patternTransform;
											a && t.transform(a[0], a[1], a[2], a[3], a[4], a[5]), t.fill(), t.restore()
										}
										r && (t.save(), o && t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), r.render(t), t.restore())
									}
								},
								_renderBackground: function(t) {
									this._renderBackgroundOrOverlay(t, "background")
								},
								_renderOverlay: function(t) {
									this._renderBackgroundOrOverlay(t, "overlay")
								},
								getCenter: function() {
									return {
										top: this.height / 2,
										left: this.width / 2
									}
								},
								getCenterPoint: function() {
									return new b.Point(this.width / 2, this.height / 2)
								},
								centerObjectH: function(t) {
									return this._centerObject(t, new b.Point(this.getCenterPoint().x, t.getCenterPoint().y))
								},
								centerObjectV: function(t) {
									return this._centerObject(t, new b.Point(t.getCenterPoint().x, this.getCenterPoint().y))
								},
								centerObject: function(t) {
									var e = this.getCenterPoint();
									return this._centerObject(t, e)
								},
								viewportCenterObject: function(t) {
									var e = this.getVpCenter();
									return this._centerObject(t, e)
								},
								viewportCenterObjectH: function(t) {
									var e = this.getVpCenter();
									return this._centerObject(t, new b.Point(e.x, t.getCenterPoint().y)), this
								},
								viewportCenterObjectV: function(t) {
									var e = this.getVpCenter();
									return this._centerObject(t, new b.Point(t.getCenterPoint().x, e.y))
								},
								getVpCenter: function() {
									var t = this.getCenterPoint(),
										e = o(this.viewportTransform);
									return i(t, e)
								},
								_centerObject: function(t, e) {
									return t.setPositionByOrigin(e, "center", "center"), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this
								},
								toDatalessJSON: function(t) {
									return this.toDatalessObject(t)
								},
								toObject: function(t) {
									return this._toObjectMethod("toObject", t)
								},
								toDatalessObject: function(t) {
									return this._toObjectMethod("toDatalessObject", t)
								},
								_toObjectMethod: function(e, n) {
									var r = this.clipPath,
										i = {
											version: b.version,
											objects: this._toObjects(e, n)
										};
									return r && !r.excludeFromExport && (i.clipPath = this._toObject(this.clipPath, e, n)), t(i, this.__serializeBgOverlay(e, n)), b.util.populateWithProperties(this, i, n), i
								},
								_toObjects: function(t, e) {
									return this._objects.filter((function(t) {
										return !t.excludeFromExport
									})).map((function(n) {
										return this._toObject(n, t, e)
									}), this)
								},
								_toObject: function(t, e, n) {
									var r;
									this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1);
									var i = t[e](n);
									return this.includeDefaultValues || (t.includeDefaultValues = r), i
								},
								__serializeBgOverlay: function(t, e) {
									var n = {},
										r = this.backgroundImage,
										i = this.overlayImage,
										o = this.backgroundColor,
										a = this.overlayColor;
									return o && o.toObject ? o.excludeFromExport || (n.background = o.toObject(e)) : o && (n.background = o), a && a.toObject ? a.excludeFromExport || (n.overlay = a.toObject(e)) : a && (n.overlay = a), r && !r.excludeFromExport && (n.backgroundImage = this._toObject(r, t, e)), i && !i.excludeFromExport && (n.overlayImage = this._toObject(i, t, e)), n
								},
								svgViewportTransformation: !0,
								toSVG: function(t, e) {
									t || (t = {}), t.reviver = e;
									var n = [];
									return this._setSVGPreamble(n, t), this._setSVGHeader(n, t), this.clipPath && n.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n'), this._setSVGBgOverlayColor(n, "background"), this._setSVGBgOverlayImage(n, "backgroundImage", e), this._setSVGObjects(n, e), this.clipPath && n.push("</g>\n"), this._setSVGBgOverlayColor(n, "overlay"), this._setSVGBgOverlayImage(n, "overlayImage", e), n.push("</svg>"), n.join("")
								},
								_setSVGPreamble: function(t, e) {
									e.suppressPreamble || t.push('<?xml version="1.0" encoding="', e.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n')
								},
								_setSVGHeader: function(t, e) {
									var n, i = e.width || this.width,
										o = e.height || this.height,
										a = 'viewBox="0 0 ' + this.width + " " + this.height + '" ',
										s = b.Object.NUM_FRACTION_DIGITS;
									e.viewBox ? a = 'viewBox="' + e.viewBox.x + " " + e.viewBox.y + " " + e.viewBox.width + " " + e.viewBox.height + '" ' : this.svgViewportTransformation && (n = this.viewportTransform, a = 'viewBox="' + r(-n[4] / n[0], s) + " " + r(-n[5] / n[3], s) + " " + r(this.width / n[0], s) + " " + r(this.height / n[3], s) + '" '), t.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', i, '" ', 'height="', o, '" ', a, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", b.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), "</defs>\n")
								},
								createSVGClipPathMarkup: function(t) {
									var e = this.clipPath;
									return e ? (e.clipPathId = "CLIPPATH_" + b.Object.__uid++, '<clipPath id="' + e.clipPathId + '" >\n' + this.clipPath.toClipPathSVG(t.reviver) + "</clipPath>\n") : ""
								},
								createSVGRefElementsMarkup: function() {
									var t = this;
									return ["background", "overlay"].map((function(e) {
										var n = t[e + "Color"];
										if (n && n.toLive) {
											var r = t[e + "Vpt"],
												i = t.viewportTransform,
												o = {
													width: t.width / (r ? i[0] : 1),
													height: t.height / (r ? i[3] : 1)
												};
											return n.toSVG(o, {
												additionalTransform: r ? b.util.matrixToSVG(i) : ""
											})
										}
									})).join("")
								},
								createSVGFontFacesMarkup: function() {
									var t, e, n, r, i, o, a, s, l = "",
										c = {},
										u = b.fontPaths,
										h = [];
									for (this._objects.forEach((function t(e) {
											h.push(e), e._objects && e._objects.forEach(t)
										})), a = 0, s = h.length; a < s; a++)
										if (e = (t = h[a]).fontFamily, -1 !== t.type.indexOf("text") && !c[e] && u[e] && (c[e] = !0, t.styles))
											for (i in n = t.styles)
												for (o in r = n[i]) !c[e = r[o].fontFamily] && u[e] && (c[e] = !0);
									for (var f in c) l += ["\t\t@font-face {\n", "\t\t\tfont-family: '", f, "';\n", "\t\t\tsrc: url('", u[f], "');\n", "\t\t}\n"].join("");
									return l && (l = ['\t<style type="text/css">', "<![CDATA[\n", l, "]]>", "</style>\n"].join("")), l
								},
								_setSVGObjects: function(t, e) {
									var n, r, i, o = this._objects;
									for (r = 0, i = o.length; r < i; r++)(n = o[r]).excludeFromExport || this._setSVGObject(t, n, e)
								},
								_setSVGObject: function(t, e, n) {
									t.push(e.toSVG(n))
								},
								_setSVGBgOverlayImage: function(t, e, n) {
									this[e] && !this[e].excludeFromExport && this[e].toSVG && t.push(this[e].toSVG(n))
								},
								_setSVGBgOverlayColor: function(t, e) {
									var n = this[e + "Color"],
										r = this.viewportTransform,
										i = this.width,
										o = this.height;
									if (n)
										if (n.toLive) {
											var a = n.repeat,
												s = b.util.invertTransform(r),
												l = this[e + "Vpt"] ? b.util.matrixToSVG(s) : "";
											t.push('<rect transform="' + l + " translate(", i / 2, ",", o / 2, ')"', ' x="', n.offsetX - i / 2, '" y="', n.offsetY - o / 2, '" ', 'width="', "repeat-y" === a || "no-repeat" === a ? n.source.width : i, '" height="', "repeat-x" === a || "no-repeat" === a ? n.source.height : o, '" fill="url(#SVGID_' + n.id + ')"', "></rect>\n")
										} else t.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', n, '"', "></rect>\n")
								},
								sendToBack: function(t) {
									if (!t) return this;
									var e, r, i, o = this._activeObject;
									if (t === o && "activeSelection" === t.type)
										for (e = (i = o._objects).length; e--;) r = i[e], n(this._objects, r), this._objects.unshift(r);
									else n(this._objects, t), this._objects.unshift(t);
									return this.renderOnAddRemove && this.requestRenderAll(), this
								},
								bringToFront: function(t) {
									if (!t) return this;
									var e, r, i, o = this._activeObject;
									if (t === o && "activeSelection" === t.type)
										for (i = o._objects, e = 0; e < i.length; e++) r = i[e], n(this._objects, r), this._objects.push(r);
									else n(this._objects, t), this._objects.push(t);
									return this.renderOnAddRemove && this.requestRenderAll(), this
								},
								sendBackwards: function(t, e) {
									if (!t) return this;
									var r, i, o, a, s, l = this._activeObject,
										c = 0;
									if (t === l && "activeSelection" === t.type)
										for (s = l._objects, r = 0; r < s.length; r++) i = s[r], (o = this._objects.indexOf(i)) > 0 + c && (a = o - 1, n(this._objects, i), this._objects.splice(a, 0, i)), c++;
									else 0 !== (o = this._objects.indexOf(t)) && (a = this._findNewLowerIndex(t, o, e), n(this._objects, t), this._objects.splice(a, 0, t));
									return this.renderOnAddRemove && this.requestRenderAll(), this
								},
								_findNewLowerIndex: function(t, e, n) {
									var r, i;
									if (n) {
										for (r = e, i = e - 1; i >= 0; --i)
											if (t.intersectsWithObject(this._objects[i]) || t.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(t)) {
												r = i;
												break
											}
									} else r = e - 1;
									return r
								},
								bringForward: function(t, e) {
									if (!t) return this;
									var r, i, o, a, s, l = this._activeObject,
										c = 0;
									if (t === l && "activeSelection" === t.type)
										for (r = (s = l._objects).length; r--;) i = s[r], (o = this._objects.indexOf(i)) < this._objects.length - 1 - c && (a = o + 1, n(this._objects, i), this._objects.splice(a, 0, i)), c++;
									else(o = this._objects.indexOf(t)) !== this._objects.length - 1 && (a = this._findNewUpperIndex(t, o, e), n(this._objects, t), this._objects.splice(a, 0, t));
									return this.renderOnAddRemove && this.requestRenderAll(), this
								},
								_findNewUpperIndex: function(t, e, n) {
									var r, i, o;
									if (n) {
										for (r = e, i = e + 1, o = this._objects.length; i < o; ++i)
											if (t.intersectsWithObject(this._objects[i]) || t.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(t)) {
												r = i;
												break
											}
									} else r = e + 1;
									return r
								},
								moveTo: function(t, e) {
									return n(this._objects, t), this._objects.splice(e, 0, t), this.renderOnAddRemove && this.requestRenderAll()
								},
								dispose: function() {
									return this.isRendering && (b.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject((function(t) {
										t.dispose && t.dispose()
									})), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), b.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), b.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this
								},
								toString: function() {
									return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>"
								}
							}), t(b.StaticCanvas.prototype, b.Observable), t(b.StaticCanvas.prototype, b.Collection), t(b.StaticCanvas.prototype, b.DataURLExporter), t(b.StaticCanvas, {
								EMPTY_JSON: '{"objects": [], "background": "white"}',
								supports: function(t) {
									var e = s();
									if (!e || !e.getContext) return null;
									var n = e.getContext("2d");
									return n && "setLineDash" === t ? void 0 !== n.setLineDash : null
								}
							}), b.StaticCanvas.prototype.toJSON = b.StaticCanvas.prototype.toObject, b.isLikelyNode && (b.StaticCanvas.prototype.createPNGStream = function() {
								var t = a(this.lowerCanvasEl);
								return t && t.createPNGStream()
							}, b.StaticCanvas.prototype.createJPEGStream = function(t) {
								var e = a(this.lowerCanvasEl);
								return e && e.createJPEGStream(t)
							})
						}
					}(), b.BaseBrush = b.util.createClass({
						color: "rgb(0, 0, 0)",
						width: 1,
						shadow: null,
						strokeLineCap: "round",
						strokeLineJoin: "round",
						strokeMiterLimit: 10,
						strokeDashArray: null,
						limitedToCanvasSize: !1,
						_setBrushStyles: function(t) {
							t.strokeStyle = this.color, t.lineWidth = this.width, t.lineCap = this.strokeLineCap, t.miterLimit = this.strokeMiterLimit, t.lineJoin = this.strokeLineJoin, t.setLineDash(this.strokeDashArray || [])
						},
						_saveAndTransform: function(t) {
							var e = this.canvas.viewportTransform;
							t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5])
						},
						_setShadow: function() {
							if (this.shadow) {
								var t = this.canvas,
									e = this.shadow,
									n = t.contextTop,
									r = t.getZoom();
								t && t._isRetinaScaling() && (r *= b.devicePixelRatio), n.shadowColor = e.color, n.shadowBlur = e.blur * r, n.shadowOffsetX = e.offsetX * r, n.shadowOffsetY = e.offsetY * r
							}
						},
						needsFullRender: function() {
							return new b.Color(this.color).getAlpha() < 1 || !!this.shadow
						},
						_resetShadow: function() {
							var t = this.canvas.contextTop;
							t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0
						},
						_isOutSideCanvas: function(t) {
							return t.x < 0 || t.x > this.canvas.getWidth() || t.y < 0 || t.y > this.canvas.getHeight()
						}
					}), b.PencilBrush = b.util.createClass(b.BaseBrush, {
						decimate: .4,
						drawStraightLine: !1,
						straightLineKey: "shiftKey",
						initialize: function(t) {
							this.canvas = t, this._points = []
						},
						needsFullRender: function() {
							return this.callSuper("needsFullRender") || this._hasStraightLine
						},
						_drawSegment: function(t, e, n) {
							var r = e.midPointFrom(n);
							return t.quadraticCurveTo(e.x, e.y, r.x, r.y), r
						},
						onMouseDown: function(t, e) {
							this.canvas._isMainEvent(e.e) && (this.drawStraightLine = e.e[this.straightLineKey], this._prepareForDrawing(t), this._captureDrawingPath(t), this._render())
						},
						onMouseMove: function(t, e) {
							if (this.canvas._isMainEvent(e.e) && (this.drawStraightLine = e.e[this.straightLineKey], (!0 !== this.limitedToCanvasSize || !this._isOutSideCanvas(t)) && this._captureDrawingPath(t) && this._points.length > 1))
								if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render();
								else {
									var n = this._points,
										r = n.length,
										i = this.canvas.contextTop;
									this._saveAndTransform(i), this.oldEnd && (i.beginPath(), i.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(i, n[r - 2], n[r - 1], !0), i.stroke(), i.restore()
								}
						},
						onMouseUp: function(t) {
							return !this.canvas._isMainEvent(t.e) || (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1)
						},
						_prepareForDrawing: function(t) {
							var e = new b.Point(t.x, t.y);
							this._reset(), this._addPoint(e), this.canvas.contextTop.moveTo(e.x, e.y)
						},
						_addPoint: function(t) {
							return !(this._points.length > 1 && t.eq(this._points[this._points.length - 1]) || (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(t), 0))
						},
						_reset: function() {
							this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1
						},
						_captureDrawingPath: function(t) {
							var e = new b.Point(t.x, t.y);
							return this._addPoint(e)
						},
						_render: function(t) {
							var e, n, r = this._points[0],
								i = this._points[1];
							if (t = t || this.canvas.contextTop, this._saveAndTransform(t), t.beginPath(), 2 === this._points.length && r.x === i.x && r.y === i.y) {
								var o = this.width / 1e3;
								r = new b.Point(r.x, r.y), i = new b.Point(i.x, i.y), r.x -= o, i.x += o
							}
							for (t.moveTo(r.x, r.y), e = 1, n = this._points.length; e < n; e++) this._drawSegment(t, r, i), r = this._points[e], i = this._points[e + 1];
							t.lineTo(r.x, r.y), t.stroke(), t.restore()
						},
						convertPointsToSVGPath: function(t) {
							var e = this.width / 1e3;
							return b.util.getSmoothPathFromPoints(t, e)
						},
						_isEmptySVGPath: function(t) {
							return "M 0 0 Q 0 0 0 0 L 0 0" === b.util.joinPath(t)
						},
						createPath: function(t) {
							var e = new b.Path(t, {
								fill: null,
								stroke: this.color,
								strokeWidth: this.width,
								strokeLineCap: this.strokeLineCap,
								strokeMiterLimit: this.strokeMiterLimit,
								strokeLineJoin: this.strokeLineJoin,
								strokeDashArray: this.strokeDashArray
							});
							return this.shadow && (this.shadow.affectStroke = !0, e.shadow = new b.Shadow(this.shadow)), e
						},
						decimatePoints: function(t, e) {
							if (t.length <= 2) return t;
							var n, r = this.canvas.getZoom(),
								i = Math.pow(e / r, 2),
								o = t.length - 1,
								a = t[0],
								s = [a];
							for (n = 1; n < o - 1; n++) Math.pow(a.x - t[n].x, 2) + Math.pow(a.y - t[n].y, 2) >= i && (a = t[n], s.push(a));
							return s.push(t[o]), s
						},
						_finalizeAndAddPath: function() {
							this.canvas.contextTop.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
							var t = this.convertPointsToSVGPath(this._points);
							if (this._isEmptySVGPath(t)) this.canvas.requestRenderAll();
							else {
								var e = this.createPath(t);
								this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", {
									path: e
								}), this.canvas.add(e), this.canvas.requestRenderAll(), e.setCoords(), this._resetShadow(), this.canvas.fire("path:created", {
									path: e
								})
							}
						}
					}), b.CircleBrush = b.util.createClass(b.BaseBrush, {
						width: 10,
						initialize: function(t) {
							this.canvas = t, this.points = []
						},
						drawDot: function(t) {
							var e = this.addPoint(t),
								n = this.canvas.contextTop;
							this._saveAndTransform(n), this.dot(n, e), n.restore()
						},
						dot: function(t, e) {
							t.fillStyle = e.fill, t.beginPath(), t.arc(e.x, e.y, e.radius, 0, 2 * Math.PI, !1), t.closePath(), t.fill()
						},
						onMouseDown: function(t) {
							this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t)
						},
						_render: function() {
							var t, e, n = this.canvas.contextTop,
								r = this.points;
							for (this._saveAndTransform(n), t = 0, e = r.length; t < e; t++) this.dot(n, r[t]);
							n.restore()
						},
						onMouseMove: function(t) {
							!0 === this.limitedToCanvasSize && this._isOutSideCanvas(t) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(t), this._render()) : this.drawDot(t))
						},
						onMouseUp: function() {
							var t, e, n = this.canvas.renderOnAddRemove;
							this.canvas.renderOnAddRemove = !1;
							var r = [];
							for (t = 0, e = this.points.length; t < e; t++) {
								var i = this.points[t],
									o = new b.Circle({
										radius: i.radius,
										left: i.x,
										top: i.y,
										originX: "center",
										originY: "center",
										fill: i.fill
									});
								this.shadow && (o.shadow = new b.Shadow(this.shadow)), r.push(o)
							}
							var a = new b.Group(r);
							a.canvas = this.canvas, this.canvas.fire("before:path:created", {
								path: a
							}), this.canvas.add(a), this.canvas.fire("path:created", {
								path: a
							}), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = n, this.canvas.requestRenderAll()
						},
						addPoint: function(t) {
							var e = new b.Point(t.x, t.y),
								n = b.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2,
								r = new b.Color(this.color).setAlpha(b.util.getRandomInt(0, 100) / 100).toRgba();
							return e.radius = n, e.fill = r, this.points.push(e), e
						}
					}), b.SprayBrush = b.util.createClass(b.BaseBrush, {
						width: 10,
						density: 20,
						dotWidth: 1,
						dotWidthVariance: 1,
						randomOpacity: !1,
						optimizeOverlapping: !0,
						initialize: function(t) {
							this.canvas = t, this.sprayChunks = []
						},
						onMouseDown: function(t) {
							this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t), this.render(this.sprayChunkPoints)
						},
						onMouseMove: function(t) {
							!0 === this.limitedToCanvasSize && this._isOutSideCanvas(t) || (this.addSprayChunk(t), this.render(this.sprayChunkPoints))
						},
						onMouseUp: function() {
							var t = this.canvas.renderOnAddRemove;
							this.canvas.renderOnAddRemove = !1;
							for (var e = [], n = 0, r = this.sprayChunks.length; n < r; n++)
								for (var i = this.sprayChunks[n], o = 0, a = i.length; o < a; o++) {
									var s = new b.Rect({
										width: i[o].width,
										height: i[o].width,
										left: i[o].x + 1,
										top: i[o].y + 1,
										originX: "center",
										originY: "center",
										fill: this.color
									});
									e.push(s)
								}
							this.optimizeOverlapping && (e = this._getOptimizedRects(e));
							var l = new b.Group(e);
							this.shadow && l.set("shadow", new b.Shadow(this.shadow)), this.canvas.fire("before:path:created", {
								path: l
							}), this.canvas.add(l), this.canvas.fire("path:created", {
								path: l
							}), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.requestRenderAll()
						},
						_getOptimizedRects: function(t) {
							var e, n, r, i = {};
							for (n = 0, r = t.length; n < r; n++) i[e = t[n].left + "" + t[n].top] || (i[e] = t[n]);
							var o = [];
							for (e in i) o.push(i[e]);
							return o
						},
						render: function(t) {
							var e, n, r = this.canvas.contextTop;
							for (r.fillStyle = this.color, this._saveAndTransform(r), e = 0, n = t.length; e < n; e++) {
								var i = t[e];
								void 0 !== i.opacity && (r.globalAlpha = i.opacity), r.fillRect(i.x, i.y, i.width, i.width)
							}
							r.restore()
						},
						_render: function() {
							var t, e, n = this.canvas.contextTop;
							for (n.fillStyle = this.color, this._saveAndTransform(n), t = 0, e = this.sprayChunks.length; t < e; t++) this.render(this.sprayChunks[t]);
							n.restore()
						},
						addSprayChunk: function(t) {
							this.sprayChunkPoints = [];
							var e, n, r, i, o = this.width / 2;
							for (i = 0; i < this.density; i++) {
								e = b.util.getRandomInt(t.x - o, t.x + o), n = b.util.getRandomInt(t.y - o, t.y + o), r = this.dotWidthVariance ? b.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth;
								var a = new b.Point(e, n);
								a.width = r, this.randomOpacity && (a.opacity = b.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(a)
							}
							this.sprayChunks.push(this.sprayChunkPoints)
						}
					}), b.PatternBrush = b.util.createClass(b.PencilBrush, {
						getPatternSrc: function() {
							var t = b.util.createCanvasElement(),
								e = t.getContext("2d");
							return t.width = t.height = 25, e.fillStyle = this.color, e.beginPath(), e.arc(10, 10, 10, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), t
						},
						getPatternSrcFunction: function() {
							return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"')
						},
						getPattern: function(t) {
							return t.createPattern(this.source || this.getPatternSrc(), "repeat")
						},
						_setBrushStyles: function(t) {
							this.callSuper("_setBrushStyles", t), t.strokeStyle = this.getPattern(t)
						},
						createPath: function(t) {
							var e = this.callSuper("createPath", t),
								n = e._getLeftTopCoords().scalarAdd(e.strokeWidth / 2);
							return e.stroke = new b.Pattern({
								source: this.source || this.getPatternSrcFunction(),
								offsetX: -n.x,
								offsetY: -n.y
							}), e
						}
					}),
					function() {
						var t = b.util.getPointer,
							e = b.util.degreesToRadians,
							n = b.util.isTouchEvent;
						for (var r in b.Canvas = b.util.createClass(b.StaticCanvas, {
								initialize: function(t, e) {
									e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e), this._initInteractive(), this._createCacheCanvas()
								},
								uniformScaling: !0,
								uniScaleKey: "shiftKey",
								centeredScaling: !1,
								centeredRotation: !1,
								centeredKey: "altKey",
								altActionKey: "shiftKey",
								interactive: !0,
								selection: !0,
								selectionKey: "shiftKey",
								altSelectionKey: null,
								selectionColor: "rgba(100, 100, 255, 0.3)",
								selectionDashArray: [],
								selectionBorderColor: "rgba(255, 255, 255, 0.3)",
								selectionLineWidth: 1,
								selectionFullyContained: !1,
								hoverCursor: "move",
								moveCursor: "move",
								defaultCursor: "default",
								freeDrawingCursor: "crosshair",
								notAllowedCursor: "not-allowed",
								containerClass: "canvas-container",
								perPixelTargetFind: !1,
								targetFindTolerance: 0,
								skipTargetFind: !1,
								isDrawingMode: !1,
								preserveObjectStacking: !1,
								snapAngle: 0,
								snapThreshold: null,
								stopContextMenu: !1,
								fireRightClick: !1,
								fireMiddleClick: !1,
								targets: [],
								enablePointerEvents: !1,
								_hoveredTarget: null,
								_hoveredTargets: [],
								_initInteractive: function() {
									this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = b.PencilBrush && new b.PencilBrush(this), this.calcOffset()
								},
								_chooseObjectsToRender: function() {
									var t, e, n, r = this.getActiveObjects();
									if (r.length > 0 && !this.preserveObjectStacking) {
										e = [], n = [];
										for (var i = 0, o = this._objects.length; i < o; i++) t = this._objects[i], -1 === r.indexOf(t) ? e.push(t) : n.push(t);
										r.length > 1 && (this._activeObject._objects = n), e.push.apply(e, n)
									} else e = this._objects;
									return e
								},
								renderAll: function() {
									!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1);
									var t = this.contextContainer;
									return this.renderCanvas(t, this._chooseObjectsToRender()), this
								},
								renderTopLayer: function(t) {
									t.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0), t.restore()
								},
								renderTop: function() {
									var t = this.contextTop;
									return this.clearContext(t), this.renderTopLayer(t), this.fire("after:render"), this
								},
								_normalizePointer: function(t, e) {
									var n = t.calcTransformMatrix(),
										r = b.util.invertTransform(n),
										i = this.restorePointerVpt(e);
									return b.util.transformPoint(i, r)
								},
								isTargetTransparent: function(t, e, n) {
									if (t.shouldCache() && t._cacheCanvas && t !== this._activeObject) {
										var r = this._normalizePointer(t, {
												x: e,
												y: n
											}),
											i = Math.max(t.cacheTranslationX + r.x * t.zoomX, 0),
											o = Math.max(t.cacheTranslationY + r.y * t.zoomY, 0);
										return b.util.isTransparent(t._cacheContext, Math.round(i), Math.round(o), this.targetFindTolerance)
									}
									var a = this.contextCache,
										s = t.selectionBackgroundColor,
										l = this.viewportTransform;
									return t.selectionBackgroundColor = "", this.clearContext(a), a.save(), a.transform(l[0], l[1], l[2], l[3], l[4], l[5]), t.render(a), a.restore(), t.selectionBackgroundColor = s, b.util.isTransparent(a, e, n, this.targetFindTolerance)
								},
								_isSelectionKeyPressed: function(t) {
									return Array.isArray(this.selectionKey) ? !!this.selectionKey.find((function(e) {
										return !0 === t[e]
									})) : t[this.selectionKey]
								},
								_shouldClearSelection: function(t, e) {
									var n = this.getActiveObjects(),
										r = this._activeObject;
									return !e || e && r && n.length > 1 && -1 === n.indexOf(e) && r !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && r && r !== e
								},
								_shouldCenterTransform: function(t, e, n) {
									var r;
									if (t) return "scale" === e || "scaleX" === e || "scaleY" === e || "resizing" === e ? r = this.centeredScaling || t.centeredScaling : "rotate" === e && (r = this.centeredRotation || t.centeredRotation), r ? !n : n
								},
								_getOriginFromCorner: function(t, e) {
									var n = {
										x: t.originX,
										y: t.originY
									};
									return "ml" === e || "tl" === e || "bl" === e ? n.x = "right" : "mr" !== e && "tr" !== e && "br" !== e || (n.x = "left"), "tl" === e || "mt" === e || "tr" === e ? n.y = "bottom" : "bl" !== e && "mb" !== e && "br" !== e || (n.y = "top"), n
								},
								_getActionFromCorner: function(t, e, n, r) {
									if (!e || !t) return "drag";
									var i = r.controls[e];
									return i.getActionName(n, i, r)
								},
								_setupCurrentTransform: function(t, n, r) {
									if (n) {
										var i = this.getPointer(t),
											o = n.__corner,
											a = n.controls[o],
											s = r && o ? a.getActionHandler(t, n, a) : b.controlsUtils.dragHandler,
											l = this._getActionFromCorner(r, o, t, n),
											c = this._getOriginFromCorner(n, o),
											u = t[this.centeredKey],
											h = {
												target: n,
												action: l,
												actionHandler: s,
												corner: o,
												scaleX: n.scaleX,
												scaleY: n.scaleY,
												skewX: n.skewX,
												skewY: n.skewY,
												offsetX: i.x - n.left,
												offsetY: i.y - n.top,
												originX: c.x,
												originY: c.y,
												ex: i.x,
												ey: i.y,
												lastX: i.x,
												lastY: i.y,
												theta: e(n.angle),
												width: n.width * n.scaleX,
												shiftKey: t.shiftKey,
												altKey: u,
												original: b.util.saveObjectTransform(n)
											};
										this._shouldCenterTransform(n, l, u) && (h.originX = "center", h.originY = "center"), h.original.originX = c.x, h.original.originY = c.y, this._currentTransform = h, this._beforeTransform(t)
									}
								},
								setCursor: function(t) {
									this.upperCanvasEl.style.cursor = t
								},
								_drawSelection: function(t) {
									var e = this._groupSelector,
										n = new b.Point(e.ex, e.ey),
										r = b.util.transformPoint(n, this.viewportTransform),
										i = new b.Point(e.ex + e.left, e.ey + e.top),
										o = b.util.transformPoint(i, this.viewportTransform),
										a = Math.min(r.x, o.x),
										s = Math.min(r.y, o.y),
										l = Math.max(r.x, o.x),
										c = Math.max(r.y, o.y),
										u = this.selectionLineWidth / 2;
									this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(a, s, l - a, c - s)), this.selectionLineWidth && this.selectionBorderColor && (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, a += u, s += u, l -= u, c -= u, b.Object.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(a, s, l - a, c - s))
								},
								findTarget: function(t, e) {
									if (!this.skipTargetFind) {
										var r, i, o = this.getPointer(t, !0),
											a = this._activeObject,
											s = this.getActiveObjects(),
											l = n(t),
											c = s.length > 1 && !e || 1 === s.length;
										if (this.targets = [], c && a._findTargetCorner(o, l)) return a;
										if (s.length > 1 && !e && a === this._searchPossibleTargets([a], o)) return a;
										if (1 === s.length && a === this._searchPossibleTargets([a], o)) {
											if (!this.preserveObjectStacking) return a;
											r = a, i = this.targets, this.targets = []
										}
										var u = this._searchPossibleTargets(this._objects, o);
										return t[this.altSelectionKey] && u && r && u !== r && (u = r, this.targets = i), u
									}
								},
								_checkTarget: function(t, e, n) {
									if (e && e.visible && e.evented && e.containsPoint(t)) {
										if (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing) return !0;
										if (!this.isTargetTransparent(e, n.x, n.y)) return !0
									}
								},
								_searchPossibleTargets: function(t, e) {
									for (var n, r, i = t.length; i--;) {
										var o = t[i],
											a = o.group ? this._normalizePointer(o.group, e) : e;
										if (this._checkTarget(a, o, e)) {
											(n = t[i]).subTargetCheck && n instanceof b.Group && (r = this._searchPossibleTargets(n._objects, e)) && this.targets.push(r);
											break
										}
									}
									return n
								},
								restorePointerVpt: function(t) {
									return b.util.transformPoint(t, b.util.invertTransform(this.viewportTransform))
								},
								getPointer: function(e, n) {
									if (this._absolutePointer && !n) return this._absolutePointer;
									if (this._pointer && n) return this._pointer;
									var r, i = t(e),
										o = this.upperCanvasEl,
										a = o.getBoundingClientRect(),
										s = a.width || 0,
										l = a.height || 0;
									s && l || ("top" in a && "bottom" in a && (l = Math.abs(a.top - a.bottom)), "right" in a && "left" in a && (s = Math.abs(a.right - a.left))), this.calcOffset(), i.x = i.x - this._offset.left, i.y = i.y - this._offset.top, n || (i = this.restorePointerVpt(i));
									var c = this.getRetinaScaling();
									return 1 !== c && (i.x /= c, i.y /= c), r = 0 === s || 0 === l ? {
										width: 1,
										height: 1
									} : {
										width: o.width / s,
										height: o.height / l
									}, {
										x: i.x * r.width,
										y: i.y * r.height
									}
								},
								_createUpperCanvas: function() {
									var t = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""),
										e = this.lowerCanvasEl,
										n = this.upperCanvasEl;
									n ? n.className = "" : (n = this._createCanvasElement(), this.upperCanvasEl = n), b.util.addClass(n, "upper-canvas " + t), this.wrapperEl.appendChild(n), this._copyCanvasStyle(e, n), this._applyCanvasStyle(n), this.contextTop = n.getContext("2d")
								},
								getTopContext: function() {
									return this.contextTop
								},
								_createCacheCanvas: function() {
									this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d")
								},
								_initWrapperElement: function() {
									this.wrapperEl = b.util.wrapElement(this.lowerCanvasEl, "div", {
										class: this.containerClass
									}), b.util.setStyle(this.wrapperEl, {
										width: this.width + "px",
										height: this.height + "px",
										position: "relative"
									}), b.util.makeElementUnselectable(this.wrapperEl)
								},
								_applyCanvasStyle: function(t) {
									var e = this.width || t.width,
										n = this.height || t.height;
									b.util.setStyle(t, {
										position: "absolute",
										width: e + "px",
										height: n + "px",
										left: 0,
										top: 0,
										"touch-action": this.allowTouchScrolling ? "manipulation" : "none",
										"-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none"
									}), t.width = e, t.height = n, b.util.makeElementUnselectable(t)
								},
								_copyCanvasStyle: function(t, e) {
									e.style.cssText = t.style.cssText
								},
								getSelectionContext: function() {
									return this.contextTop
								},
								getSelectionElement: function() {
									return this.upperCanvasEl
								},
								getActiveObject: function() {
									return this._activeObject
								},
								getActiveObjects: function() {
									var t = this._activeObject;
									return t ? "activeSelection" === t.type && t._objects ? t._objects.slice(0) : [t] : []
								},
								_onObjectRemoved: function(t) {
									t === this._activeObject && (this.fire("before:selection:cleared", {
										target: t
									}), this._discardActiveObject(), this.fire("selection:cleared", {
										target: t
									}), t.fire("deselected")), t === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", t)
								},
								_fireSelectionEvents: function(t, e) {
									var n = !1,
										r = this.getActiveObjects(),
										i = [],
										o = [];
									t.forEach((function(t) {
										-1 === r.indexOf(t) && (n = !0, t.fire("deselected", {
											e,
											target: t
										}), o.push(t))
									})), r.forEach((function(r) {
										-1 === t.indexOf(r) && (n = !0, r.fire("selected", {
											e,
											target: r
										}), i.push(r))
									})), t.length > 0 && r.length > 0 ? n && this.fire("selection:updated", {
										e,
										selected: i,
										deselected: o
									}) : r.length > 0 ? this.fire("selection:created", {
										e,
										selected: i
									}) : t.length > 0 && this.fire("selection:cleared", {
										e,
										deselected: o
									})
								},
								setActiveObject: function(t, e) {
									var n = this.getActiveObjects();
									return this._setActiveObject(t, e), this._fireSelectionEvents(n, e), this
								},
								_setActiveObject: function(t, e) {
									return this._activeObject !== t && !!this._discardActiveObject(e, t) && !t.onSelect({
										e
									}) && (this._activeObject = t, !0)
								},
								_discardActiveObject: function(t, e) {
									var n = this._activeObject;
									if (n) {
										if (n.onDeselect({
												e: t,
												object: e
											})) return !1;
										this._activeObject = null
									}
									return !0
								},
								discardActiveObject: function(t) {
									var e = this.getActiveObjects(),
										n = this.getActiveObject();
									return e.length && this.fire("before:selection:cleared", {
										target: n,
										e: t
									}), this._discardActiveObject(t), this._fireSelectionEvents(e, t), this
								},
								dispose: function() {
									var t = this.wrapperEl;
									return this.removeListeners(), t.removeChild(this.upperCanvasEl), t.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach(function(t) {
										b.util.cleanUpJsdomNode(this[t]), this[t] = void 0
									}.bind(this)), t.parentNode && t.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, b.StaticCanvas.prototype.dispose.call(this), this
								},
								clear: function() {
									return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear")
								},
								drawControls: function(t) {
									var e = this._activeObject;
									e && e._renderControls(t)
								},
								_toObject: function(t, e, n) {
									var r = this._realizeGroupTransformOnObject(t),
										i = this.callSuper("_toObject", t, e, n);
									return this._unwindGroupTransformOnObject(t, r), i
								},
								_realizeGroupTransformOnObject: function(t) {
									if (t.group && "activeSelection" === t.group.type && this._activeObject === t.group) {
										var e = {};
										return ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"].forEach((function(n) {
											e[n] = t[n]
										})), b.util.addTransformToObject(t, this._activeObject.calcOwnMatrix()), e
									}
									return null
								},
								_unwindGroupTransformOnObject: function(t, e) {
									e && t.set(e)
								},
								_setSVGObject: function(t, e, n) {
									var r = this._realizeGroupTransformOnObject(e);
									this.callSuper("_setSVGObject", t, e, n), this._unwindGroupTransformOnObject(e, r)
								},
								setViewportTransform: function(t) {
									this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), b.StaticCanvas.prototype.setViewportTransform.call(this, t)
								}
							}), b.StaticCanvas) "prototype" !== r && (b.Canvas[r] = b.StaticCanvas[r])
					}(),
					function() {
						var t = b.util.addListener,
							e = b.util.removeListener,
							n = {
								passive: !1
							};

						function r(t, e) {
							return t.button && t.button === e - 1
						}
						b.util.object.extend(b.Canvas.prototype, {
							mainTouchId: null,
							_initEventListeners: function() {
								this.removeListeners(), this._bindEvents(), this.addOrRemove(t, "add")
							},
							_getEventPrefix: function() {
								return this.enablePointerEvents ? "pointer" : "mouse"
							},
							addOrRemove: function(t, e) {
								var r = this.upperCanvasEl,
									i = this._getEventPrefix();
								t(b.window, "resize", this._onResize), t(r, i + "down", this._onMouseDown), t(r, i + "move", this._onMouseMove, n), t(r, i + "out", this._onMouseOut), t(r, i + "enter", this._onMouseEnter), t(r, "wheel", this._onMouseWheel), t(r, "contextmenu", this._onContextMenu), t(r, "dblclick", this._onDoubleClick), t(r, "dragover", this._onDragOver), t(r, "dragenter", this._onDragEnter), t(r, "dragleave", this._onDragLeave), t(r, "drop", this._onDrop), this.enablePointerEvents || t(r, "touchstart", this._onTouchStart, n), "undefined" != typeof eventjs && e in eventjs && (eventjs[e](r, "gesture", this._onGesture), eventjs[e](r, "drag", this._onDrag), eventjs[e](r, "orientation", this._onOrientationChange), eventjs[e](r, "shake", this._onShake), eventjs[e](r, "longpress", this._onLongPress))
							},
							removeListeners: function() {
								this.addOrRemove(e, "remove");
								var t = this._getEventPrefix();
								e(b.document, t + "up", this._onMouseUp), e(b.document, "touchend", this._onTouchEnd, n), e(b.document, t + "move", this._onMouseMove, n), e(b.document, "touchmove", this._onMouseMove, n)
							},
							_bindEvents: function() {
								this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0)
							},
							_onGesture: function(t, e) {
								this.__onTransformGesture && this.__onTransformGesture(t, e)
							},
							_onDrag: function(t, e) {
								this.__onDrag && this.__onDrag(t, e)
							},
							_onMouseWheel: function(t) {
								this.__onMouseWheel(t)
							},
							_onMouseOut: function(t) {
								var e = this._hoveredTarget;
								this.fire("mouse:out", {
									target: e,
									e: t
								}), this._hoveredTarget = null, e && e.fire("mouseout", {
									e: t
								});
								var n = this;
								this._hoveredTargets.forEach((function(r) {
									n.fire("mouse:out", {
										target: e,
										e: t
									}), r && e.fire("mouseout", {
										e: t
									})
								})), this._hoveredTargets = []
							},
							_onMouseEnter: function(t) {
								this._currentTransform || this.findTarget(t) || (this.fire("mouse:over", {
									target: null,
									e: t
								}), this._hoveredTarget = null, this._hoveredTargets = [])
							},
							_onOrientationChange: function(t, e) {
								this.__onOrientationChange && this.__onOrientationChange(t, e)
							},
							_onShake: function(t, e) {
								this.__onShake && this.__onShake(t, e)
							},
							_onLongPress: function(t, e) {
								this.__onLongPress && this.__onLongPress(t, e)
							},
							_onDragOver: function(t) {
								t.preventDefault();
								var e = this._simpleEventHandler("dragover", t);
								this._fireEnterLeaveEvents(e, t)
							},
							_onDrop: function(t) {
								return this._simpleEventHandler("drop:before", t), this._simpleEventHandler("drop", t)
							},
							_onContextMenu: function(t) {
								return this.stopContextMenu && (t.stopPropagation(), t.preventDefault()), !1
							},
							_onDoubleClick: function(t) {
								this._cacheTransformEventData(t), this._handleEvent(t, "dblclick"), this._resetTransformEventData(t)
							},
							getPointerId: function(t) {
								var e = t.changedTouches;
								return e ? e[0] && e[0].identifier : this.enablePointerEvents ? t.pointerId : -1
							},
							_isMainEvent: function(t) {
								return !0 === t.isPrimary || !1 !== t.isPrimary && ("touchend" === t.type && 0 === t.touches.length || !t.changedTouches || t.changedTouches[0].identifier === this.mainTouchId)
							},
							_onTouchStart: function(r) {
								r.preventDefault(), null === this.mainTouchId && (this.mainTouchId = this.getPointerId(r)), this.__onMouseDown(r), this._resetTransformEventData();
								var i = this.upperCanvasEl,
									o = this._getEventPrefix();
								t(b.document, "touchend", this._onTouchEnd, n), t(b.document, "touchmove", this._onMouseMove, n), e(i, o + "down", this._onMouseDown)
							},
							_onMouseDown: function(r) {
								this.__onMouseDown(r), this._resetTransformEventData();
								var i = this.upperCanvasEl,
									o = this._getEventPrefix();
								e(i, o + "move", this._onMouseMove, n), t(b.document, o + "up", this._onMouseUp), t(b.document, o + "move", this._onMouseMove, n)
							},
							_onTouchEnd: function(r) {
								if (!(r.touches.length > 0)) {
									this.__onMouseUp(r), this._resetTransformEventData(), this.mainTouchId = null;
									var i = this._getEventPrefix();
									e(b.document, "touchend", this._onTouchEnd, n), e(b.document, "touchmove", this._onMouseMove, n);
									var o = this;
									this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout((function() {
										t(o.upperCanvasEl, i + "down", o._onMouseDown), o._willAddMouseDown = 0
									}), 400)
								}
							},
							_onMouseUp: function(r) {
								this.__onMouseUp(r), this._resetTransformEventData();
								var i = this.upperCanvasEl,
									o = this._getEventPrefix();
								this._isMainEvent(r) && (e(b.document, o + "up", this._onMouseUp), e(b.document, o + "move", this._onMouseMove, n), t(i, o + "move", this._onMouseMove, n))
							},
							_onMouseMove: function(t) {
								!this.allowTouchScrolling && t.preventDefault && t.preventDefault(), this.__onMouseMove(t)
							},
							_onResize: function() {
								this.calcOffset()
							},
							_shouldRender: function(t) {
								var e = this._activeObject;
								return !!(!!e != !!t || e && t && e !== t) || (e && e.isEditing, !1)
							},
							__onMouseUp: function(t) {
								var e, n = this._currentTransform,
									i = this._groupSelector,
									o = !1,
									a = !i || 0 === i.left && 0 === i.top;
								if (this._cacheTransformEventData(t), e = this._target, this._handleEvent(t, "up:before"), r(t, 3)) this.fireRightClick && this._handleEvent(t, "up", 3, a);
								else {
									if (r(t, 2)) return this.fireMiddleClick && this._handleEvent(t, "up", 2, a), void this._resetTransformEventData();
									if (this.isDrawingMode && this._isCurrentlyDrawing) this._onMouseUpInDrawingMode(t);
									else if (this._isMainEvent(t)) {
										if (n && (this._finalizeCurrentTransform(t), o = n.actionPerformed), !a) {
											var s = e === this._activeObject;
											this._maybeGroupObjects(t), o || (o = this._shouldRender(e) || !s && e === this._activeObject)
										}
										var l, c;
										if (e) {
											if (l = e._findTargetCorner(this.getPointer(t, !0), b.util.isTouchEvent(t)), e.selectable && e !== this._activeObject && "up" === e.activeOn) this.setActiveObject(e, t), o = !0;
											else {
												var u = e.controls[l],
													h = u && u.getMouseUpHandler(t, e, u);
												h && h(t, n, (c = this.getPointer(t)).x, c.y)
											}
											e.isMoving = !1
										}
										if (n && (n.target !== e || n.corner !== l)) {
											var f = n.target && n.target.controls[n.corner],
												d = f && f.getMouseUpHandler(t, e, u);
											c = c || this.getPointer(t), d && d(t, n, c.x, c.y)
										}
										this._setCursorFromEvent(t, e), this._handleEvent(t, "up", 1, a), this._groupSelector = null, this._currentTransform = null, e && (e.__corner = 0), o ? this.requestRenderAll() : a || this.renderTop()
									}
								}
							},
							_simpleEventHandler: function(t, e) {
								var n = this.findTarget(e),
									r = this.targets,
									i = {
										e,
										target: n,
										subTargets: r
									};
								if (this.fire(t, i), n && n.fire(t, i), !r) return n;
								for (var o = 0; o < r.length; o++) r[o].fire(t, i);
								return n
							},
							_handleEvent: function(t, e, n, r) {
								var i = this._target,
									o = this.targets || [],
									a = {
										e: t,
										target: i,
										subTargets: o,
										button: n || 1,
										isClick: r || !1,
										pointer: this._pointer,
										absolutePointer: this._absolutePointer,
										transform: this._currentTransform
									};
								"up" === e && (a.currentTarget = this.findTarget(t), a.currentSubTargets = this.targets), this.fire("mouse:" + e, a), i && i.fire("mouse" + e, a);
								for (var s = 0; s < o.length; s++) o[s].fire("mouse" + e, a)
							},
							_finalizeCurrentTransform: function(t) {
								var e = this._currentTransform,
									n = e.target,
									r = {
										e: t,
										target: n,
										transform: e,
										action: e.action
									};
								n._scaling && (n._scaling = !1), n.setCoords(), (e.actionPerformed || this.stateful && n.hasStateChanged()) && this._fire("modified", r)
							},
							_onMouseDownInDrawingMode: function(t) {
								this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(t).requestRenderAll();
								var e = this.getPointer(t);
								this.freeDrawingBrush.onMouseDown(e, {
									e: t,
									pointer: e
								}), this._handleEvent(t, "down")
							},
							_onMouseMoveInDrawingMode: function(t) {
								if (this._isCurrentlyDrawing) {
									var e = this.getPointer(t);
									this.freeDrawingBrush.onMouseMove(e, {
										e: t,
										pointer: e
									})
								}
								this.setCursor(this.freeDrawingCursor), this._handleEvent(t, "move")
							},
							_onMouseUpInDrawingMode: function(t) {
								var e = this.getPointer(t);
								this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({
									e: t,
									pointer: e
								}), this._handleEvent(t, "up")
							},
							__onMouseDown: function(t) {
								this._cacheTransformEventData(t), this._handleEvent(t, "down:before");
								var e = this._target;
								if (r(t, 3)) this.fireRightClick && this._handleEvent(t, "down", 3);
								else if (r(t, 2)) this.fireMiddleClick && this._handleEvent(t, "down", 2);
								else if (this.isDrawingMode) this._onMouseDownInDrawingMode(t);
								else if (this._isMainEvent(t) && !this._currentTransform) {
									var n = this._pointer;
									this._previousPointer = n;
									var i = this._shouldRender(e),
										o = this._shouldGroup(t, e);
									if (this._shouldClearSelection(t, e) ? this.discardActiveObject(t) : o && (this._handleGrouping(t, e), e = this._activeObject), !this.selection || e && (e.selectable || e.isEditing || e === this._activeObject) || (this._groupSelector = {
											ex: this._absolutePointer.x,
											ey: this._absolutePointer.y,
											top: 0,
											left: 0
										}), e) {
										var a = e === this._activeObject;
										e.selectable && "down" === e.activeOn && this.setActiveObject(e, t);
										var s = e._findTargetCorner(this.getPointer(t, !0), b.util.isTouchEvent(t));
										if (e.__corner = s, e === this._activeObject && (s || !o)) {
											this._setupCurrentTransform(t, e, a);
											var l = e.controls[s],
												c = (n = this.getPointer(t), l && l.getMouseDownHandler(t, e, l));
											c && c(t, this._currentTransform, n.x, n.y)
										}
									}
									this._handleEvent(t, "down"), (i || o) && this.requestRenderAll()
								}
							},
							_resetTransformEventData: function() {
								this._target = null, this._pointer = null, this._absolutePointer = null
							},
							_cacheTransformEventData: function(t) {
								this._resetTransformEventData(), this._pointer = this.getPointer(t, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t) || null
							},
							_beforeTransform: function(t) {
								var e = this._currentTransform;
								this.stateful && e.target.saveState(), this.fire("before:transform", {
									e: t,
									transform: e
								})
							},
							__onMouseMove: function(t) {
								var e, n;
								if (this._handleEvent(t, "move:before"), this._cacheTransformEventData(t), this.isDrawingMode) this._onMouseMoveInDrawingMode(t);
								else if (this._isMainEvent(t)) {
									var r = this._groupSelector;
									r ? (n = this._absolutePointer, r.left = n.x - r.ex, r.top = n.y - r.ey, this.renderTop()) : this._currentTransform ? this._transformObject(t) : (e = this.findTarget(t) || null, this._setCursorFromEvent(t, e), this._fireOverOutEvents(e, t)), this._handleEvent(t, "move"), this._resetTransformEventData()
								}
							},
							_fireOverOutEvents: function(t, e) {
								var n = this._hoveredTarget,
									r = this._hoveredTargets,
									i = this.targets,
									o = Math.max(r.length, i.length);
								this.fireSyntheticInOutEvents(t, e, {
									oldTarget: n,
									evtOut: "mouseout",
									canvasEvtOut: "mouse:out",
									evtIn: "mouseover",
									canvasEvtIn: "mouse:over"
								});
								for (var a = 0; a < o; a++) this.fireSyntheticInOutEvents(i[a], e, {
									oldTarget: r[a],
									evtOut: "mouseout",
									evtIn: "mouseover"
								});
								this._hoveredTarget = t, this._hoveredTargets = this.targets.concat()
							},
							_fireEnterLeaveEvents: function(t, e) {
								var n = this._draggedoverTarget,
									r = this._hoveredTargets,
									i = this.targets,
									o = Math.max(r.length, i.length);
								this.fireSyntheticInOutEvents(t, e, {
									oldTarget: n,
									evtOut: "dragleave",
									evtIn: "dragenter"
								});
								for (var a = 0; a < o; a++) this.fireSyntheticInOutEvents(i[a], e, {
									oldTarget: r[a],
									evtOut: "dragleave",
									evtIn: "dragenter"
								});
								this._draggedoverTarget = t
							},
							fireSyntheticInOutEvents: function(t, e, n) {
								var r, i, o, a = n.oldTarget,
									s = a !== t,
									l = n.canvasEvtIn,
									c = n.canvasEvtOut;
								s && (r = {
									e,
									target: t,
									previousTarget: a
								}, i = {
									e,
									target: a,
									nextTarget: t
								}), o = t && s, a && s && (c && this.fire(c, i), a.fire(n.evtOut, i)), o && (l && this.fire(l, r), t.fire(n.evtIn, r))
							},
							__onMouseWheel: function(t) {
								this._cacheTransformEventData(t), this._handleEvent(t, "wheel"), this._resetTransformEventData()
							},
							_transformObject: function(t) {
								var e = this.getPointer(t),
									n = this._currentTransform;
								n.reset = !1, n.shiftKey = t.shiftKey, n.altKey = t[this.centeredKey], this._performTransformAction(t, n, e), n.actionPerformed && this.requestRenderAll()
							},
							_performTransformAction: function(t, e, n) {
								var r = n.x,
									i = n.y,
									o = e.action,
									a = !1,
									s = e.actionHandler;
								s && (a = s(t, e, r, i)), "drag" === o && a && (e.target.isMoving = !0, this.setCursor(e.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || a
							},
							_fire: b.controlsUtils.fireEvent,
							_setCursorFromEvent: function(t, e) {
								if (!e) return this.setCursor(this.defaultCursor), !1;
								var n = e.hoverCursor || this.hoverCursor,
									r = this._activeObject && "activeSelection" === this._activeObject.type ? this._activeObject : null,
									i = (!r || !r.contains(e)) && e._findTargetCorner(this.getPointer(t, !0));
								i ? this.setCursor(this.getCornerCursor(i, e, t)) : (e.subTargetCheck && this.targets.concat().reverse().map((function(t) {
									n = t.hoverCursor || n
								})), this.setCursor(n))
							},
							getCornerCursor: function(t, e, n) {
								var r = e.controls[t];
								return r.cursorStyleHandler(n, r, e)
							}
						})
					}(), h = Math.min, f = Math.max, b.util.object.extend(b.Canvas.prototype, {
						_shouldGroup: function(t, e) {
							var n = this._activeObject;
							return n && this._isSelectionKeyPressed(t) && e && e.selectable && this.selection && (n !== e || "activeSelection" === n.type) && !e.onSelect({
								e: t
							})
						},
						_handleGrouping: function(t, e) {
							var n = this._activeObject;
							n.__corner || (e !== n || (e = this.findTarget(t, !0)) && e.selectable) && (n && "activeSelection" === n.type ? this._updateActiveSelection(e, t) : this._createActiveSelection(e, t))
						},
						_updateActiveSelection: function(t, e) {
							var n = this._activeObject,
								r = n._objects.slice(0);
							n.contains(t) ? (n.removeWithUpdate(t), this._hoveredTarget = t, this._hoveredTargets = this.targets.concat(), 1 === n.size() && this._setActiveObject(n.item(0), e)) : (n.addWithUpdate(t), this._hoveredTarget = n, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(r, e)
						},
						_createActiveSelection: function(t, e) {
							var n = this.getActiveObjects(),
								r = this._createGroup(t);
							this._hoveredTarget = r, this._setActiveObject(r, e), this._fireSelectionEvents(n, e)
						},
						_createGroup: function(t) {
							var e = this._objects,
								n = e.indexOf(this._activeObject) < e.indexOf(t) ? [this._activeObject, t] : [t, this._activeObject];
							return this._activeObject.isEditing && this._activeObject.exitEditing(), new b.ActiveSelection(n, {
								canvas: this
							})
						},
						_groupSelectedObjects: function(t) {
							var e, n = this._collectObjects(t);
							1 === n.length ? this.setActiveObject(n[0], t) : n.length > 1 && (e = new b.ActiveSelection(n.reverse(), {
								canvas: this
							}), this.setActiveObject(e, t))
						},
						_collectObjects: function(t) {
							for (var e, n = [], r = this._groupSelector.ex, i = this._groupSelector.ey, o = r + this._groupSelector.left, a = i + this._groupSelector.top, s = new b.Point(h(r, o), h(i, a)), l = new b.Point(f(r, o), f(i, a)), c = !this.selectionFullyContained, u = r === o && i === a, d = this._objects.length; d-- && !((e = this._objects[d]) && e.selectable && e.visible && (c && e.intersectsWithRect(s, l, !0) || e.isContainedWithinRect(s, l, !0) || c && e.containsPoint(s, null, !0) || c && e.containsPoint(l, null, !0)) && (n.push(e), u)););
							return n.length > 1 && (n = n.filter((function(e) {
								return !e.onSelect({
									e: t
								})
							}))), n
						},
						_maybeGroupObjects: function(t) {
							this.selection && this._groupSelector && this._groupSelectedObjects(t), this.setCursor(this.defaultCursor), this._groupSelector = null
						}
					}), b.util.object.extend(b.StaticCanvas.prototype, {
						toDataURL: function(t) {
							t || (t = {});
							var e = t.format || "png",
								n = t.quality || 1,
								r = (t.multiplier || 1) * (t.enableRetinaScaling ? this.getRetinaScaling() : 1),
								i = this.toCanvasElement(r, t);
							return b.util.toDataURL(i, e, n)
						},
						toCanvasElement: function(t, e) {
							t = t || 1;
							var n = ((e = e || {}).width || this.width) * t,
								r = (e.height || this.height) * t,
								i = this.getZoom(),
								o = this.width,
								a = this.height,
								s = i * t,
								l = this.viewportTransform,
								c = (l[4] - (e.left || 0)) * t,
								u = (l[5] - (e.top || 0)) * t,
								h = this.interactive,
								f = [s, 0, 0, s, c, u],
								d = this.enableRetinaScaling,
								p = b.util.createCanvasElement(),
								g = this.contextTop;
							return p.width = n, p.height = r, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = f, this.width = n, this.height = r, this.calcViewportBoundaries(), this.renderCanvas(p.getContext("2d"), this._objects), this.viewportTransform = l, this.width = o, this.height = a, this.calcViewportBoundaries(), this.interactive = h, this.enableRetinaScaling = d, this.contextTop = g, p
						}
					}), b.util.object.extend(b.StaticCanvas.prototype, {
						loadFromJSON: function(t, e, n) {
							if (t) {
								var r = "string" == typeof t ? JSON.parse(t) : b.util.object.clone(t),
									i = this,
									o = r.clipPath,
									a = this.renderOnAddRemove;
								return this.renderOnAddRemove = !1, delete r.clipPath, this._enlivenObjects(r.objects, (function(t) {
									i.clear(), i._setBgOverlay(r, (function() {
										o ? i._enlivenObjects([o], (function(n) {
											i.clipPath = n[0], i.__setupCanvas.call(i, r, t, a, e)
										})) : i.__setupCanvas.call(i, r, t, a, e)
									}))
								}), n), this
							}
						},
						__setupCanvas: function(t, e, n, r) {
							var i = this;
							e.forEach((function(t, e) {
								i.insertAt(t, e)
							})), this.renderOnAddRemove = n, delete t.objects, delete t.backgroundImage, delete t.overlayImage, delete t.background, delete t.overlay, this._setOptions(t), this.renderAll(), r && r()
						},
						_setBgOverlay: function(t, e) {
							var n = {
								backgroundColor: !1,
								overlayColor: !1,
								backgroundImage: !1,
								overlayImage: !1
							};
							if (t.backgroundImage || t.overlayImage || t.background || t.overlay) {
								var r = function() {
									n.backgroundImage && n.overlayImage && n.backgroundColor && n.overlayColor && e && e()
								};
								this.__setBgOverlay("backgroundImage", t.backgroundImage, n, r), this.__setBgOverlay("overlayImage", t.overlayImage, n, r), this.__setBgOverlay("backgroundColor", t.background, n, r), this.__setBgOverlay("overlayColor", t.overlay, n, r)
							} else e && e()
						},
						__setBgOverlay: function(t, e, n, r) {
							var i = this;
							if (!e) return n[t] = !0, void(r && r());
							"backgroundImage" === t || "overlayImage" === t ? b.util.enlivenObjects([e], (function(e) {
								i[t] = e[0], n[t] = !0, r && r()
							})) : this["set" + b.util.string.capitalize(t, !0)](e, (function() {
								n[t] = !0, r && r()
							}))
						},
						_enlivenObjects: function(t, e, n) {
							t && 0 !== t.length ? b.util.enlivenObjects(t, (function(t) {
								e && e(t)
							}), null, n) : e && e([])
						},
						_toDataURL: function(t, e) {
							this.clone((function(n) {
								e(n.toDataURL(t))
							}))
						},
						_toDataURLWithMultiplier: function(t, e, n) {
							this.clone((function(r) {
								n(r.toDataURLWithMultiplier(t, e))
							}))
						},
						clone: function(t, e) {
							var n = JSON.stringify(this.toJSON(e));
							this.cloneWithoutData((function(e) {
								e.loadFromJSON(n, (function() {
									t && t(e)
								}))
							}))
						},
						cloneWithoutData: function(t) {
							var e = b.util.createCanvasElement();
							e.width = this.width, e.height = this.height;
							var n = new b.Canvas(e);
							this.backgroundImage ? (n.setBackgroundImage(this.backgroundImage.src, (function() {
								n.renderAll(), t && t(n)
							})), n.backgroundImageOpacity = this.backgroundImageOpacity, n.backgroundImageStretch = this.backgroundImageStretch) : t && t(n)
						}
					}),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.util.object.clone,
							i = e.util.toFixed,
							o = e.util.string.capitalize,
							a = e.util.degreesToRadians,
							s = !e.isLikelyNode;
						e.Object || (e.Object = e.util.createClass(e.CommonMethods, {
							type: "object",
							originX: "left",
							originY: "top",
							top: 0,
							left: 0,
							width: 0,
							height: 0,
							scaleX: 1,
							scaleY: 1,
							flipX: !1,
							flipY: !1,
							opacity: 1,
							angle: 0,
							skewX: 0,
							skewY: 0,
							cornerSize: 13,
							touchCornerSize: 24,
							transparentCorners: !0,
							hoverCursor: null,
							moveCursor: null,
							padding: 0,
							borderColor: "rgb(178,204,255)",
							borderDashArray: null,
							cornerColor: "rgb(178,204,255)",
							cornerStrokeColor: null,
							cornerStyle: "rect",
							cornerDashArray: null,
							centeredScaling: !1,
							centeredRotation: !0,
							fill: "rgb(0,0,0)",
							fillRule: "nonzero",
							globalCompositeOperation: "source-over",
							backgroundColor: "",
							selectionBackgroundColor: "",
							stroke: null,
							strokeWidth: 1,
							strokeDashArray: null,
							strokeDashOffset: 0,
							strokeLineCap: "butt",
							strokeLineJoin: "miter",
							strokeMiterLimit: 4,
							shadow: null,
							borderOpacityWhenMoving: .4,
							borderScaleFactor: 1,
							minScaleLimit: 0,
							selectable: !0,
							evented: !0,
							visible: !0,
							hasControls: !0,
							hasBorders: !0,
							perPixelTargetFind: !1,
							includeDefaultValues: !0,
							lockMovementX: !1,
							lockMovementY: !1,
							lockRotation: !1,
							lockScalingX: !1,
							lockScalingY: !1,
							lockSkewingX: !1,
							lockSkewingY: !1,
							lockScalingFlip: !1,
							excludeFromExport: !1,
							objectCaching: s,
							statefullCache: !1,
							noScaleCache: !0,
							strokeUniform: !1,
							dirty: !0,
							__corner: 0,
							paintFirst: "fill",
							activeOn: "down",
							stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),
							cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),
							colorProperties: "fill stroke backgroundColor".split(" "),
							clipPath: void 0,
							inverted: !1,
							absolutePositioned: !1,
							initialize: function(t) {
								t && this.setOptions(t)
							},
							_createCacheCanvas: function() {
								this._cacheProperties = {}, this._cacheCanvas = e.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0
							},
							_limitCacheSize: function(t) {
								var n = e.perfLimitSizeTotal,
									r = t.width,
									i = t.height,
									o = e.maxCacheSideLimit,
									a = e.minCacheSideLimit;
								if (r <= o && i <= o && r * i <= n) return r < a && (t.width = a), i < a && (t.height = a), t;
								var s = r / i,
									l = e.util.limitDimsByArea(s, n),
									c = e.util.capValue,
									u = c(a, l.x, o),
									h = c(a, l.y, o);
								return r > u && (t.zoomX /= r / u, t.width = u, t.capped = !0), i > h && (t.zoomY /= i / h, t.height = h, t.capped = !0), t
							},
							_getCacheCanvasDimensions: function() {
								var t = this.getTotalObjectScaling(),
									e = this._getTransformedDimensions(0, 0),
									n = e.x * t.scaleX / this.scaleX,
									r = e.y * t.scaleY / this.scaleY;
								return {
									width: n + 2,
									height: r + 2,
									zoomX: t.scaleX,
									zoomY: t.scaleY,
									x: n,
									y: r
								}
							},
							_updateCacheCanvas: function() {
								var t = this.canvas;
								if (this.noScaleCache && t && t._currentTransform) {
									var n = t._currentTransform.target,
										r = t._currentTransform.action;
									if (this === n && r.slice && "scale" === r.slice(0, 5)) return !1
								}
								var i, o, a = this._cacheCanvas,
									s = this._limitCacheSize(this._getCacheCanvasDimensions()),
									l = e.minCacheSideLimit,
									c = s.width,
									u = s.height,
									h = s.zoomX,
									f = s.zoomY,
									d = c !== this.cacheWidth || u !== this.cacheHeight,
									p = this.zoomX !== h || this.zoomY !== f,
									g = d || p,
									v = 0,
									m = 0,
									y = !1;
								if (d) {
									var b = this._cacheCanvas.width,
										x = this._cacheCanvas.height,
										w = c > b || u > x;
									y = w || (c < .9 * b || u < .9 * x) && b > l && x > l, w && !s.capped && (c > l || u > l) && (v = .1 * c, m = .1 * u)
								}
								return this instanceof e.Text && this.path && (g = !0, y = !0, v += this.getHeightOfLine(0) * this.zoomX, m += this.getHeightOfLine(0) * this.zoomY), !!g && (y ? (a.width = Math.ceil(c + v), a.height = Math.ceil(u + m)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, a.width, a.height)), i = s.x / 2, o = s.y / 2, this.cacheTranslationX = Math.round(a.width / 2 - i) + i, this.cacheTranslationY = Math.round(a.height / 2 - o) + o, this.cacheWidth = c, this.cacheHeight = u, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(h, f), this.zoomX = h, this.zoomY = f, !0)
							},
							setOptions: function(t) {
								this._setOptions(t), this._initGradient(t.fill, "fill"), this._initGradient(t.stroke, "stroke"), this._initPattern(t.fill, "fill"), this._initPattern(t.stroke, "stroke")
							},
							transform: function(t) {
								var e = this.group && !this.group._transformDone || this.group && this.canvas && t === this.canvas.contextTop,
									n = this.calcTransformMatrix(!e);
								t.transform(n[0], n[1], n[2], n[3], n[4], n[5])
							},
							toObject: function(t) {
								var n = e.Object.NUM_FRACTION_DIGITS,
									r = {
										type: this.type,
										version: e.version,
										originX: this.originX,
										originY: this.originY,
										left: i(this.left, n),
										top: i(this.top, n),
										width: i(this.width, n),
										height: i(this.height, n),
										fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,
										stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,
										strokeWidth: i(this.strokeWidth, n),
										strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
										strokeLineCap: this.strokeLineCap,
										strokeDashOffset: this.strokeDashOffset,
										strokeLineJoin: this.strokeLineJoin,
										strokeUniform: this.strokeUniform,
										strokeMiterLimit: i(this.strokeMiterLimit, n),
										scaleX: i(this.scaleX, n),
										scaleY: i(this.scaleY, n),
										angle: i(this.angle, n),
										flipX: this.flipX,
										flipY: this.flipY,
										opacity: i(this.opacity, n),
										shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,
										visible: this.visible,
										backgroundColor: this.backgroundColor,
										fillRule: this.fillRule,
										paintFirst: this.paintFirst,
										globalCompositeOperation: this.globalCompositeOperation,
										skewX: i(this.skewX, n),
										skewY: i(this.skewY, n)
									};
								return this.clipPath && !this.clipPath.excludeFromExport && (r.clipPath = this.clipPath.toObject(t), r.clipPath.inverted = this.clipPath.inverted, r.clipPath.absolutePositioned = this.clipPath.absolutePositioned), e.util.populateWithProperties(this, r, t), this.includeDefaultValues || (r = this._removeDefaultValues(r)), r
							},
							toDatalessObject: function(t) {
								return this.toObject(t)
							},
							_removeDefaultValues: function(t) {
								var n = e.util.getKlass(t.type).prototype;
								return n.stateProperties.forEach((function(e) {
									"left" !== e && "top" !== e && (t[e] === n[e] && delete t[e], Array.isArray(t[e]) && Array.isArray(n[e]) && 0 === t[e].length && 0 === n[e].length && delete t[e])
								})), t
							},
							toString: function() {
								return "#<fabric." + o(this.type) + ">"
							},
							getObjectScaling: function() {
								if (!this.group) return {
									scaleX: this.scaleX,
									scaleY: this.scaleY
								};
								var t = e.util.qrDecompose(this.calcTransformMatrix());
								return {
									scaleX: Math.abs(t.scaleX),
									scaleY: Math.abs(t.scaleY)
								}
							},
							getTotalObjectScaling: function() {
								var t = this.getObjectScaling(),
									e = t.scaleX,
									n = t.scaleY;
								if (this.canvas) {
									var r = this.canvas.getZoom(),
										i = this.canvas.getRetinaScaling();
									e *= r * i, n *= r * i
								}
								return {
									scaleX: e,
									scaleY: n
								}
							},
							getObjectOpacity: function() {
								var t = this.opacity;
								return this.group && (t *= this.group.getObjectOpacity()), t
							},
							_set: function(t, n) {
								var r = "scaleX" === t || "scaleY" === t,
									i = this[t] !== n,
									o = !1;
								return r && (n = this._constrainScale(n)), "scaleX" === t && n < 0 ? (this.flipX = !this.flipX, n *= -1) : "scaleY" === t && n < 0 ? (this.flipY = !this.flipY, n *= -1) : "shadow" !== t || !n || n instanceof e.Shadow ? "dirty" === t && this.group && this.group.set("dirty", n) : n = new e.Shadow(n), this[t] = n, i && (o = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(t) > -1 ? (this.dirty = !0, o && this.group.set("dirty", !0)) : o && this.stateProperties.indexOf(t) > -1 && this.group.set("dirty", !0)), this
							},
							setOnGroup: function() {},
							getViewportTransform: function() {
								return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e.iMatrix.concat()
							},
							isNotVisible: function() {
								return 0 === this.opacity || !this.width && !this.height && 0 === this.strokeWidth || !this.visible
							},
							render: function(t) {
								this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(t), this.objectCaching && this.statefullCache && this.saveState({
									propertySet: "cacheProperties"
								})), t.restore())
							},
							renderCache: function(t) {
								t = t || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({
									propertySet: "cacheProperties"
								}), this.drawObject(this._cacheContext, t.forClipping), this.dirty = !1)
							},
							_removeCacheCanvas: function() {
								this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0
							},
							hasStroke: function() {
								return this.stroke && "transparent" !== this.stroke && 0 !== this.strokeWidth
							},
							hasFill: function() {
								return this.fill && "transparent" !== this.fill
							},
							needsItsOwnCache: function() {
								return !("stroke" !== this.paintFirst || !this.hasFill() || !this.hasStroke() || "object" != typeof this.shadow) || !!this.clipPath
							},
							shouldCache: function() {
								return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching
							},
							willDrawShadow: function() {
								return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY)
							},
							drawClipPathOnCache: function(t, n) {
								if (t.save(), n.inverted ? t.globalCompositeOperation = "destination-out" : t.globalCompositeOperation = "destination-in", n.absolutePositioned) {
									var r = e.util.invertTransform(this.calcTransformMatrix());
									t.transform(r[0], r[1], r[2], r[3], r[4], r[5])
								}
								n.transform(t), t.scale(1 / n.zoomX, 1 / n.zoomY), t.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), t.restore()
							},
							drawObject: function(t, e) {
								var n = this.fill,
									r = this.stroke;
								e ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t)) : this._renderBackground(t), this._render(t), this._drawClipPath(t, this.clipPath), this.fill = n, this.stroke = r
							},
							_drawClipPath: function(t, e) {
								e && (e.canvas = this.canvas, e.shouldCache(), e._transformDone = !0, e.renderCache({
									forClipping: !0
								}), this.drawClipPathOnCache(t, e))
							},
							drawCacheOnCanvas: function(t) {
								t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY)
							},
							isCacheDirty: function(t) {
								if (this.isNotVisible()) return !1;
								if (this._cacheCanvas && this._cacheContext && !t && this._updateCacheCanvas()) return !0;
								if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
									if (this._cacheCanvas && this._cacheContext && !t) {
										var e = this.cacheWidth / this.zoomX,
											n = this.cacheHeight / this.zoomY;
										this._cacheContext.clearRect(-e / 2, -n / 2, e, n)
									}
									return !0
								}
								return !1
							},
							_renderBackground: function(t) {
								if (this.backgroundColor) {
									var e = this._getNonTransformedDimensions();
									t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t)
								}
							},
							_setOpacity: function(t) {
								this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity
							},
							_setStrokeStyles: function(t, e) {
								var n = e.stroke;
								n && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineDashOffset = e.strokeDashOffset, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, n.toLive ? "percentage" === n.gradientUnits || n.gradientTransform || n.patternTransform ? this._applyPatternForTransformedGradient(t, n) : (t.strokeStyle = n.toLive(t, this), this._applyPatternGradientTransform(t, n)) : t.strokeStyle = e.stroke)
							},
							_setFillStyles: function(t, e) {
								var n = e.fill;
								n && (n.toLive ? (t.fillStyle = n.toLive(t, this), this._applyPatternGradientTransform(t, e.fill)) : t.fillStyle = n)
							},
							_setClippingProperties: function(t) {
								t.globalAlpha = 1, t.strokeStyle = "transparent", t.fillStyle = "#000000"
							},
							_setLineDash: function(t, e) {
								e && 0 !== e.length && (1 & e.length && e.push.apply(e, e), t.setLineDash(e))
							},
							_renderControls: function(t, n) {
								var r, i, o, s = this.getViewportTransform(),
									l = this.calcTransformMatrix();
								i = void 0 !== (n = n || {}).hasBorders ? n.hasBorders : this.hasBorders, o = void 0 !== n.hasControls ? n.hasControls : this.hasControls, l = e.util.multiplyTransformMatrices(s, l), r = e.util.qrDecompose(l), t.save(), t.translate(r.translateX, r.translateY), t.lineWidth = 1 * this.borderScaleFactor, this.group || (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (r.angle -= 180), t.rotate(a(this.group ? r.angle : this.angle)), n.forActiveSelection || this.group ? i && this.drawBordersInGroup(t, r, n) : i && this.drawBorders(t, n), o && this.drawControls(t, n), t.restore()
							},
							_setShadow: function(t) {
								if (this.shadow) {
									var n, r = this.shadow,
										i = this.canvas,
										o = i && i.viewportTransform[0] || 1,
										a = i && i.viewportTransform[3] || 1;
									n = r.nonScaling ? {
										scaleX: 1,
										scaleY: 1
									} : this.getObjectScaling(), i && i._isRetinaScaling() && (o *= e.devicePixelRatio, a *= e.devicePixelRatio), t.shadowColor = r.color, t.shadowBlur = r.blur * e.browserShadowBlurConstant * (o + a) * (n.scaleX + n.scaleY) / 4, t.shadowOffsetX = r.offsetX * o * n.scaleX, t.shadowOffsetY = r.offsetY * a * n.scaleY
								}
							},
							_removeShadow: function(t) {
								this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0)
							},
							_applyPatternGradientTransform: function(t, e) {
								if (!e || !e.toLive) return {
									offsetX: 0,
									offsetY: 0
								};
								var n = e.gradientTransform || e.patternTransform,
									r = -this.width / 2 + e.offsetX || 0,
									i = -this.height / 2 + e.offsetY || 0;
								return "percentage" === e.gradientUnits ? t.transform(this.width, 0, 0, this.height, r, i) : t.transform(1, 0, 0, 1, r, i), n && t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), {
									offsetX: r,
									offsetY: i
								}
							},
							_renderPaintInOrder: function(t) {
								"stroke" === this.paintFirst ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t))
							},
							_render: function() {},
							_renderFill: function(t) {
								this.fill && (t.save(), this._setFillStyles(t, this), "evenodd" === this.fillRule ? t.fill("evenodd") : t.fill(), t.restore())
							},
							_renderStroke: function(t) {
								if (this.stroke && 0 !== this.strokeWidth) {
									if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this.strokeUniform && this.group) {
										var e = this.getObjectScaling();
										t.scale(1 / e.scaleX, 1 / e.scaleY)
									} else this.strokeUniform && t.scale(1 / this.scaleX, 1 / this.scaleY);
									this._setLineDash(t, this.strokeDashArray), this._setStrokeStyles(t, this), t.stroke(), t.restore()
								}
							},
							_applyPatternForTransformedGradient: function(t, n) {
								var r, i = this._limitCacheSize(this._getCacheCanvasDimensions()),
									o = e.util.createCanvasElement(),
									a = this.canvas.getRetinaScaling(),
									s = i.x / this.scaleX / a,
									l = i.y / this.scaleY / a;
								o.width = s, o.height = l, (r = o.getContext("2d")).beginPath(), r.moveTo(0, 0), r.lineTo(s, 0), r.lineTo(s, l), r.lineTo(0, l), r.closePath(), r.translate(s / 2, l / 2), r.scale(i.zoomX / this.scaleX / a, i.zoomY / this.scaleY / a), this._applyPatternGradientTransform(r, n), r.fillStyle = n.toLive(t), r.fill(), t.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t.scale(a * this.scaleX / i.zoomX, a * this.scaleY / i.zoomY), t.strokeStyle = r.createPattern(o, "no-repeat")
							},
							_findCenterFromElement: function() {
								return {
									x: this.left + this.width / 2,
									y: this.top + this.height / 2
								}
							},
							_assignTransformMatrixProps: function() {
								if (this.transformMatrix) {
									var t = e.util.qrDecompose(this.transformMatrix);
									this.flipX = !1, this.flipY = !1, this.set("scaleX", t.scaleX), this.set("scaleY", t.scaleY), this.angle = t.angle, this.skewX = t.skewX, this.skewY = 0
								}
							},
							_removeTransformMatrix: function(t) {
								var n = this._findCenterFromElement();
								this.transformMatrix && (this._assignTransformMatrixProps(), n = e.util.transformPoint(n, this.transformMatrix)), this.transformMatrix = null, t && (this.scaleX *= t.scaleX, this.scaleY *= t.scaleY, this.cropX = t.cropX, this.cropY = t.cropY, n.x += t.offsetLeft, n.y += t.offsetTop, this.width = t.width, this.height = t.height), this.setPositionByOrigin(n, "center", "center")
							},
							clone: function(t, n) {
								var r = this.toObject(n);
								this.constructor.fromObject ? this.constructor.fromObject(r, t) : e.Object._fromObject("Object", r, t)
							},
							cloneAsImage: function(t, n) {
								var r = this.toCanvasElement(n);
								return t && t(new e.Image(r)), this
							},
							toCanvasElement: function(t) {
								t || (t = {});
								var n = e.util,
									r = n.saveObjectTransform(this),
									i = this.group,
									o = this.shadow,
									a = Math.abs,
									s = (t.multiplier || 1) * (t.enableRetinaScaling ? e.devicePixelRatio : 1);
								delete this.group, t.withoutTransform && n.resetObjectTransform(this), t.withoutShadow && (this.shadow = null);
								var l, c, u, h, f = e.util.createCanvasElement(),
									d = this.getBoundingRect(!0, !0),
									p = this.shadow,
									g = {
										x: 0,
										y: 0
									};
								p && (c = p.blur, l = p.nonScaling ? {
									scaleX: 1,
									scaleY: 1
								} : this.getObjectScaling(), g.x = 2 * Math.round(a(p.offsetX) + c) * a(l.scaleX), g.y = 2 * Math.round(a(p.offsetY) + c) * a(l.scaleY)), u = d.width + g.x, h = d.height + g.y, f.width = Math.ceil(u), f.height = Math.ceil(h);
								var v = new e.StaticCanvas(f, {
									enableRetinaScaling: !1,
									renderOnAddRemove: !1,
									skipOffscreen: !1
								});
								"jpeg" === t.format && (v.backgroundColor = "#fff"), this.setPositionByOrigin(new e.Point(v.width / 2, v.height / 2), "center", "center");
								var m = this.canvas;
								v.add(this);
								var y = v.toCanvasElement(s || 1, t);
								return this.shadow = o, this.set("canvas", m), i && (this.group = i), this.set(r).setCoords(), v._objects = [], v.dispose(), v = null, y
							},
							toDataURL: function(t) {
								return t || (t = {}), e.util.toDataURL(this.toCanvasElement(t), t.format || "png", t.quality || 1)
							},
							isType: function(t) {
								return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === t
							},
							complexity: function() {
								return 1
							},
							toJSON: function(t) {
								return this.toObject(t)
							},
							rotate: function(t) {
								var e = ("center" !== this.originX || "center" !== this.originY) && this.centeredRotation;
								return e && this._setOriginToCenter(), this.set("angle", t), e && this._resetOrigin(), this
							},
							centerH: function() {
								return this.canvas && this.canvas.centerObjectH(this), this
							},
							viewportCenterH: function() {
								return this.canvas && this.canvas.viewportCenterObjectH(this), this
							},
							centerV: function() {
								return this.canvas && this.canvas.centerObjectV(this), this
							},
							viewportCenterV: function() {
								return this.canvas && this.canvas.viewportCenterObjectV(this), this
							},
							center: function() {
								return this.canvas && this.canvas.centerObject(this), this
							},
							viewportCenter: function() {
								return this.canvas && this.canvas.viewportCenterObject(this), this
							},
							getLocalPointer: function(t, n) {
								n = n || this.canvas.getPointer(t);
								var r = new e.Point(n.x, n.y),
									i = this._getLeftTopCoords();
								return this.angle && (r = e.util.rotatePoint(r, i, a(-this.angle))), {
									x: r.x - i.x,
									y: r.y - i.y
								}
							},
							_setupCompositeOperation: function(t) {
								this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation)
							},
							dispose: function() {
								e.runningAnimations && e.runningAnimations.cancelByTarget(this)
							}
						}), e.util.createAccessors && e.util.createAccessors(e.Object), n(e.Object.prototype, e.Observable), e.Object.NUM_FRACTION_DIGITS = 2, e.Object.ENLIVEN_PROPS = ["clipPath"], e.Object._fromObject = function(t, n, i, o) {
							var a = e[t];
							n = r(n, !0), e.util.enlivenPatterns([n.fill, n.stroke], (function(t) {
								void 0 !== t[0] && (n.fill = t[0]), void 0 !== t[1] && (n.stroke = t[1]), e.util.enlivenObjectEnlivables(n, n, (function() {
									var t = o ? new a(n[o], n) : new a(n);
									i && i(t)
								}))
							}))
						}, e.Object.__uid = 0)
					}(e), v = b.util.degreesToRadians, m = {
						left: -.5,
						center: 0,
						right: .5
					}, y = {
						top: -.5,
						center: 0,
						bottom: .5
					}, b.util.object.extend(b.Object.prototype, {
						translateToGivenOrigin: function(t, e, n, r, i) {
							var o, a, s, l = t.x,
								c = t.y;
							return "string" == typeof e ? e = m[e] : e -= .5, "string" == typeof r ? r = m[r] : r -= .5, "string" == typeof n ? n = y[n] : n -= .5, "string" == typeof i ? i = y[i] : i -= .5, a = i - n, ((o = r - e) || a) && (s = this._getTransformedDimensions(), l = t.x + o * s.x, c = t.y + a * s.y), new b.Point(l, c)
						},
						translateToCenterPoint: function(t, e, n) {
							var r = this.translateToGivenOrigin(t, e, n, "center", "center");
							return this.angle ? b.util.rotatePoint(r, t, v(this.angle)) : r
						},
						translateToOriginPoint: function(t, e, n) {
							var r = this.translateToGivenOrigin(t, "center", "center", e, n);
							return this.angle ? b.util.rotatePoint(r, t, v(this.angle)) : r
						},
						getCenterPoint: function() {
							var t = new b.Point(this.left, this.top);
							return this.translateToCenterPoint(t, this.originX, this.originY)
						},
						getPointByOrigin: function(t, e) {
							var n = this.getCenterPoint();
							return this.translateToOriginPoint(n, t, e)
						},
						toLocalPoint: function(t, e, n) {
							var r, i, o = this.getCenterPoint();
							return r = void 0 !== e && void 0 !== n ? this.translateToGivenOrigin(o, "center", "center", e, n) : new b.Point(this.left, this.top), i = new b.Point(t.x, t.y), this.angle && (i = b.util.rotatePoint(i, o, -v(this.angle))), i.subtractEquals(r)
						},
						setPositionByOrigin: function(t, e, n) {
							var r = this.translateToCenterPoint(t, e, n),
								i = this.translateToOriginPoint(r, this.originX, this.originY);
							this.set("left", i.x), this.set("top", i.y)
						},
						adjustPosition: function(t) {
							var e, n, r = v(this.angle),
								i = this.getScaledWidth(),
								o = b.util.cos(r) * i,
								a = b.util.sin(r) * i;
							e = "string" == typeof this.originX ? m[this.originX] : this.originX - .5, n = "string" == typeof t ? m[t] : t - .5, this.left += o * (n - e), this.top += a * (n - e), this.setCoords(), this.originX = t
						},
						_setOriginToCenter: function() {
							this._originalOriginX = this.originX, this._originalOriginY = this.originY;
							var t = this.getCenterPoint();
							this.originX = "center", this.originY = "center", this.left = t.x, this.top = t.y
						},
						_resetOrigin: function() {
							var t = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);
							this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = t.x, this.top = t.y, this._originalOriginX = null, this._originalOriginY = null
						},
						_getLeftTopCoords: function() {
							return this.translateToOriginPoint(this.getCenterPoint(), "left", "top")
						}
					}),
					function() {
						var t = b.util,
							e = t.degreesToRadians,
							n = t.multiplyTransformMatrices,
							r = t.transformPoint;
						t.object.extend(b.Object.prototype, {
							oCoords: null,
							aCoords: null,
							lineCoords: null,
							ownMatrixCache: null,
							matrixCache: null,
							controls: {},
							_getCoords: function(t, e) {
								return e ? t ? this.calcACoords() : this.calcLineCoords() : (this.aCoords && this.lineCoords || this.setCoords(!0), t ? this.aCoords : this.lineCoords)
							},
							getCoords: function(t, e) {
								return n = this._getCoords(t, e), [new b.Point(n.tl.x, n.tl.y), new b.Point(n.tr.x, n.tr.y), new b.Point(n.br.x, n.br.y), new b.Point(n.bl.x, n.bl.y)];
								var n
							},
							intersectsWithRect: function(t, e, n, r) {
								var i = this.getCoords(n, r);
								return "Intersection" === b.Intersection.intersectPolygonRectangle(i, t, e).status
							},
							intersectsWithObject: function(t, e, n) {
								return "Intersection" === b.Intersection.intersectPolygonPolygon(this.getCoords(e, n), t.getCoords(e, n)).status || t.isContainedWithinObject(this, e, n) || this.isContainedWithinObject(t, e, n)
							},
							isContainedWithinObject: function(t, e, n) {
								for (var r = this.getCoords(e, n), i = e ? t.aCoords : t.lineCoords, o = 0, a = t._getImageLines(i); o < 4; o++)
									if (!t.containsPoint(r[o], a)) return !1;
								return !0
							},
							isContainedWithinRect: function(t, e, n, r) {
								var i = this.getBoundingRect(n, r);
								return i.left >= t.x && i.left + i.width <= e.x && i.top >= t.y && i.top + i.height <= e.y
							},
							containsPoint: function(t, e, n, r) {
								var i = this._getCoords(n, r),
									o = (e = e || this._getImageLines(i), this._findCrossPoints(t, e));
								return 0 !== o && o % 2 == 1
							},
							isOnScreen: function(t) {
								if (!this.canvas) return !1;
								var e = this.canvas.vptCoords.tl,
									n = this.canvas.vptCoords.br;
								return !!this.getCoords(!0, t).some((function(t) {
									return t.x <= n.x && t.x >= e.x && t.y <= n.y && t.y >= e.y
								})) || !!this.intersectsWithRect(e, n, !0, t) || this._containsCenterOfCanvas(e, n, t)
							},
							_containsCenterOfCanvas: function(t, e, n) {
								var r = {
									x: (t.x + e.x) / 2,
									y: (t.y + e.y) / 2
								};
								return !!this.containsPoint(r, null, !0, n)
							},
							isPartiallyOnScreen: function(t) {
								if (!this.canvas) return !1;
								var e = this.canvas.vptCoords.tl,
									n = this.canvas.vptCoords.br;
								return !!this.intersectsWithRect(e, n, !0, t) || this.getCoords(!0, t).every((function(t) {
									return (t.x >= n.x || t.x <= e.x) && (t.y >= n.y || t.y <= e.y)
								})) && this._containsCenterOfCanvas(e, n, t)
							},
							_getImageLines: function(t) {
								return {
									topline: {
										o: t.tl,
										d: t.tr
									},
									rightline: {
										o: t.tr,
										d: t.br
									},
									bottomline: {
										o: t.br,
										d: t.bl
									},
									leftline: {
										o: t.bl,
										d: t.tl
									}
								}
							},
							_findCrossPoints: function(t, e) {
								var n, r, i, o = 0;
								for (var a in e)
									if (!((i = e[a]).o.y < t.y && i.d.y < t.y || i.o.y >= t.y && i.d.y >= t.y || (i.o.x === i.d.x && i.o.x >= t.x ? r = i.o.x : (n = (i.d.y - i.o.y) / (i.d.x - i.o.x), r = -(t.y - 0 * t.x - (i.o.y - n * i.o.x)) / (0 - n)), r >= t.x && (o += 1), 2 !== o))) break;
								return o
							},
							getBoundingRect: function(e, n) {
								var r = this.getCoords(e, n);
								return t.makeBoundingBoxFromPoints(r)
							},
							getScaledWidth: function() {
								return this._getTransformedDimensions().x
							},
							getScaledHeight: function() {
								return this._getTransformedDimensions().y
							},
							_constrainScale: function(t) {
								return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : 0 === t ? 1e-4 : t
							},
							scale: function(t) {
								return this._set("scaleX", t), this._set("scaleY", t), this.setCoords()
							},
							scaleToWidth: function(t, e) {
								var n = this.getBoundingRect(e).width / this.getScaledWidth();
								return this.scale(t / this.width / n)
							},
							scaleToHeight: function(t, e) {
								var n = this.getBoundingRect(e).height / this.getScaledHeight();
								return this.scale(t / this.height / n)
							},
							calcLineCoords: function() {
								var n = this.getViewportTransform(),
									i = this.padding,
									o = e(this.angle),
									a = t.cos(o) * i,
									s = t.sin(o) * i,
									l = a + s,
									c = a - s,
									u = this.calcACoords(),
									h = {
										tl: r(u.tl, n),
										tr: r(u.tr, n),
										bl: r(u.bl, n),
										br: r(u.br, n)
									};
								return i && (h.tl.x -= c, h.tl.y -= l, h.tr.x += l, h.tr.y -= c, h.bl.x -= l, h.bl.y += c, h.br.x += c, h.br.y += l), h
							},
							calcOCoords: function() {
								var t = this._calcRotateMatrix(),
									e = this._calcTranslateMatrix(),
									r = this.getViewportTransform(),
									i = n(r, e),
									o = n(i, t),
									a = (o = n(o, [1 / r[0], 0, 0, 1 / r[3], 0, 0]), this._calculateCurrentDimensions()),
									s = {};
								return this.forEachControl((function(t, e, n) {
									s[e] = t.positionHandler(a, o, n)
								})), s
							},
							calcACoords: function() {
								var t = this._calcRotateMatrix(),
									e = this._calcTranslateMatrix(),
									i = n(e, t),
									o = this._getTransformedDimensions(),
									a = o.x / 2,
									s = o.y / 2;
								return {
									tl: r({
										x: -a,
										y: -s
									}, i),
									tr: r({
										x: a,
										y: -s
									}, i),
									bl: r({
										x: -a,
										y: s
									}, i),
									br: r({
										x: a,
										y: s
									}, i)
								}
							},
							setCoords: function(t) {
								return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), t || (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords()), this
							},
							_calcRotateMatrix: function() {
								return t.calcRotateMatrix(this)
							},
							_calcTranslateMatrix: function() {
								var t = this.getCenterPoint();
								return [1, 0, 0, 1, t.x, t.y]
							},
							transformMatrixKey: function(t) {
								var e = "_",
									n = "";
								return !t && this.group && (n = this.group.transformMatrixKey(t) + e), n + this.top + e + this.left + e + this.scaleX + e + this.scaleY + e + this.skewX + e + this.skewY + e + this.angle + e + this.originX + e + this.originY + e + this.width + e + this.height + e + this.strokeWidth + this.flipX + this.flipY
							},
							calcTransformMatrix: function(t) {
								var e = this.calcOwnMatrix();
								if (t || !this.group) return e;
								var r = this.transformMatrixKey(t),
									i = this.matrixCache || (this.matrixCache = {});
								return i.key === r ? i.value : (this.group && (e = n(this.group.calcTransformMatrix(!1), e)), i.key = r, i.value = e, e)
							},
							calcOwnMatrix: function() {
								var e = this.transformMatrixKey(!0),
									n = this.ownMatrixCache || (this.ownMatrixCache = {});
								if (n.key === e) return n.value;
								var r = this._calcTranslateMatrix(),
									i = {
										angle: this.angle,
										translateX: r[4],
										translateY: r[5],
										scaleX: this.scaleX,
										scaleY: this.scaleY,
										skewX: this.skewX,
										skewY: this.skewY,
										flipX: this.flipX,
										flipY: this.flipY
									};
								return n.key = e, n.value = t.composeMatrix(i), n.value
							},
							_getNonTransformedDimensions: function() {
								var t = this.strokeWidth;
								return {
									x: this.width + t,
									y: this.height + t
								}
							},
							_getTransformedDimensions: function(e, n) {
								void 0 === e && (e = this.skewX), void 0 === n && (n = this.skewY);
								var r, i, o, a = 0 === e && 0 === n;
								if (this.strokeUniform ? (i = this.width, o = this.height) : (i = (r = this._getNonTransformedDimensions()).x, o = r.y), a) return this._finalizeDimensions(i * this.scaleX, o * this.scaleY);
								var s = t.sizeAfterTransform(i, o, {
									scaleX: this.scaleX,
									scaleY: this.scaleY,
									skewX: e,
									skewY: n
								});
								return this._finalizeDimensions(s.x, s.y)
							},
							_finalizeDimensions: function(t, e) {
								return this.strokeUniform ? {
									x: t + this.strokeWidth,
									y: e + this.strokeWidth
								} : {
									x: t,
									y: e
								}
							},
							_calculateCurrentDimensions: function() {
								var t = this.getViewportTransform(),
									e = this._getTransformedDimensions();
								return r(e, t, !0).scalarAdd(2 * this.padding)
							}
						})
					}(), b.util.object.extend(b.Object.prototype, {
						sendToBack: function() {
							return this.group ? b.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this
						},
						bringToFront: function() {
							return this.group ? b.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this
						},
						sendBackwards: function(t) {
							return this.group ? b.StaticCanvas.prototype.sendBackwards.call(this.group, this, t) : this.canvas && this.canvas.sendBackwards(this, t), this
						},
						bringForward: function(t) {
							return this.group ? b.StaticCanvas.prototype.bringForward.call(this.group, this, t) : this.canvas && this.canvas.bringForward(this, t), this
						},
						moveTo: function(t) {
							return this.group && "activeSelection" !== this.group.type ? b.StaticCanvas.prototype.moveTo.call(this.group, this, t) : this.canvas && this.canvas.moveTo(this, t), this
						}
					}),
					function() {
						function t(t, e) {
							if (e) {
								if (e.toLive) return t + ": url(#SVGID_" + e.id + "); ";
								var n = new b.Color(e),
									r = t + ": " + n.toRgb() + "; ",
									i = n.getAlpha();
								return 1 !== i && (r += t + "-opacity: " + i.toString() + "; "), r
							}
							return t + ": none; "
						}
						var e = b.util.toFixed;
						b.util.object.extend(b.Object.prototype, {
							getSvgStyles: function(e) {
								var n = this.fillRule ? this.fillRule : "nonzero",
									r = this.strokeWidth ? this.strokeWidth : "0",
									i = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none",
									o = this.strokeDashOffset ? this.strokeDashOffset : "0",
									a = this.strokeLineCap ? this.strokeLineCap : "butt",
									s = this.strokeLineJoin ? this.strokeLineJoin : "miter",
									l = this.strokeMiterLimit ? this.strokeMiterLimit : "4",
									c = void 0 !== this.opacity ? this.opacity : "1",
									u = this.visible ? "" : " visibility: hidden;",
									h = e ? "" : this.getSvgFilter(),
									f = t("fill", this.fill);
								return [t("stroke", this.stroke), "stroke-width: ", r, "; ", "stroke-dasharray: ", i, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", o, "; ", "stroke-linejoin: ", s, "; ", "stroke-miterlimit: ", l, "; ", f, "fill-rule: ", n, "; ", "opacity: ", c, ";", h, u].join("")
							},
							getSvgSpanStyles: function(e, n) {
								var r = "; ",
									i = e.fontFamily ? "font-family: " + (-1 === e.fontFamily.indexOf("'") && -1 === e.fontFamily.indexOf('"') ? "'" + e.fontFamily + "'" : e.fontFamily) + r : "",
									o = e.strokeWidth ? "stroke-width: " + e.strokeWidth + r : "",
									a = e.fontSize ? "font-size: " + e.fontSize + "px" + r : "",
									s = e.fontStyle ? "font-style: " + e.fontStyle + r : "",
									l = e.fontWeight ? "font-weight: " + e.fontWeight + r : "",
									c = e.fill ? t("fill", e.fill) : "",
									u = e.stroke ? t("stroke", e.stroke) : "",
									h = this.getSvgTextDecoration(e);
								return h && (h = "text-decoration: " + h + r), [u, o, i, a, s, l, h, c, e.deltaY ? "baseline-shift: " + -e.deltaY + "; " : "", n ? "white-space: pre; " : ""].join("")
							},
							getSvgTextDecoration: function(t) {
								return ["overline", "underline", "line-through"].filter((function(e) {
									return t[e.replace("-", "")]
								})).join(" ")
							},
							getSvgFilter: function() {
								return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : ""
							},
							getSvgCommons: function() {
								return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("")
							},
							getSvgTransform: function(t, e) {
								var n = t ? this.calcTransformMatrix() : this.calcOwnMatrix();
								return 'transform="' + b.util.matrixToSVG(n) + (e || "") + '" '
							},
							_setSVGBg: function(t) {
								if (this.backgroundColor) {
									var n = b.Object.NUM_FRACTION_DIGITS;
									t.push("\t\t<rect ", this._getFillAttributes(this.backgroundColor), ' x="', e(-this.width / 2, n), '" y="', e(-this.height / 2, n), '" width="', e(this.width, n), '" height="', e(this.height, n), '"></rect>\n')
								}
							},
							toSVG: function(t) {
								return this._createBaseSVGMarkup(this._toSVG(t), {
									reviver: t
								})
							},
							toClipPathSVG: function(t) {
								return "\t" + this._createBaseClipPathSVGMarkup(this._toSVG(t), {
									reviver: t
								})
							},
							_createBaseClipPathSVGMarkup: function(t, e) {
								var n = (e = e || {}).reviver,
									r = e.additionalTransform || "",
									i = [this.getSvgTransform(!0, r), this.getSvgCommons()].join(""),
									o = t.indexOf("COMMON_PARTS");
								return t[o] = i, n ? n(t.join("")) : t.join("")
							},
							_createBaseSVGMarkup: function(t, e) {
								var n, r, i = (e = e || {}).noStyle,
									o = e.reviver,
									a = i ? "" : 'style="' + this.getSvgStyles() + '" ',
									s = e.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "",
									l = this.clipPath,
									c = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "",
									u = l && l.absolutePositioned,
									h = this.stroke,
									f = this.fill,
									d = this.shadow,
									p = [],
									g = t.indexOf("COMMON_PARTS"),
									v = e.additionalTransform;
								return l && (l.clipPathId = "CLIPPATH_" + b.Object.__uid++, r = '<clipPath id="' + l.clipPathId + '" >\n' + l.toClipPathSVG(o) + "</clipPath>\n"), u && p.push("<g ", s, this.getSvgCommons(), " >\n"), p.push("<g ", this.getSvgTransform(!1), u ? "" : s + this.getSvgCommons(), " >\n"), n = [a, c, i ? "" : this.addPaintOrder(), " ", v ? 'transform="' + v + '" ' : ""].join(""), t[g] = n, f && f.toLive && p.push(f.toSVG(this)), h && h.toLive && p.push(h.toSVG(this)), d && p.push(d.toSVG(this)), l && p.push(r), p.push(t.join("")), p.push("</g>\n"), u && p.push("</g>\n"), o ? o(p.join("")) : p.join("")
							},
							addPaintOrder: function() {
								return "fill" !== this.paintFirst ? ' paint-order="' + this.paintFirst + '" ' : ""
							}
						})
					}(),
					function() {
						var t = b.util.object.extend,
							e = "stateProperties";

						function n(e, n, r) {
							var i = {};
							r.forEach((function(t) {
								i[t] = e[t]
							})), t(e[n], i, !0)
						}

						function r(t, e, n) {
							if (t === e) return !0;
							if (Array.isArray(t)) {
								if (!Array.isArray(e) || t.length !== e.length) return !1;
								for (var i = 0, o = t.length; i < o; i++)
									if (!r(t[i], e[i])) return !1;
								return !0
							}
							if (t && "object" == typeof t) {
								var a, s = Object.keys(t);
								if (!e || "object" != typeof e || !n && s.length !== Object.keys(e).length) return !1;
								for (i = 0, o = s.length; i < o; i++)
									if ("canvas" !== (a = s[i]) && "group" !== a && !r(t[a], e[a])) return !1;
								return !0
							}
						}
						b.util.object.extend(b.Object.prototype, {
							hasStateChanged: function(t) {
								var n = "_" + (t = t || e);
								return Object.keys(this[n]).length < this[t].length || !r(this[n], this, !0)
							},
							saveState: function(t) {
								var r = t && t.propertySet || e,
									i = "_" + r;
								return this[i] ? (n(this, i, this[r]), t && t.stateProperties && n(this, i, t.stateProperties), this) : this.setupState(t)
							},
							setupState: function(t) {
								var n = (t = t || {}).propertySet || e;
								return t.propertySet = n, this["_" + n] = {}, this.saveState(t), this
							}
						})
					}(),
					function() {
						var t = b.util.degreesToRadians;
						b.util.object.extend(b.Object.prototype, {
							_findTargetCorner: function(t, e) {
								if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1;
								var n, r, i, o = t.x,
									a = t.y,
									s = Object.keys(this.oCoords),
									l = s.length - 1;
								for (this.__corner = 0; l >= 0; l--)
									if (i = s[l], this.isControlVisible(i) && (r = this._getImageLines(e ? this.oCoords[i].touchCorner : this.oCoords[i].corner), 0 !== (n = this._findCrossPoints({
											x: o,
											y: a
										}, r)) && n % 2 == 1)) return this.__corner = i, i;
								return !1
							},
							forEachControl: function(t) {
								for (var e in this.controls) t(this.controls[e], e, this)
							},
							_setCornerCoords: function() {
								var t = this.oCoords;
								for (var e in t) {
									var n = this.controls[e];
									t[e].corner = n.calcCornerCoords(this.angle, this.cornerSize, t[e].x, t[e].y, !1), t[e].touchCorner = n.calcCornerCoords(this.angle, this.touchCornerSize, t[e].x, t[e].y, !0)
								}
							},
							drawSelectionBackground: function(e) {
								if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this;
								e.save();
								var n = this.getCenterPoint(),
									r = this._calculateCurrentDimensions(),
									i = this.canvas.viewportTransform;
								return e.translate(n.x, n.y), e.scale(1 / i[0], 1 / i[3]), e.rotate(t(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-r.x / 2, -r.y / 2, r.x, r.y), e.restore(), this
							},
							drawBorders: function(t, e) {
								e = e || {};
								var n = this._calculateCurrentDimensions(),
									r = this.borderScaleFactor,
									i = n.x + r,
									o = n.y + r,
									a = void 0 !== e.hasControls ? e.hasControls : this.hasControls,
									s = !1;
								return t.save(), t.strokeStyle = e.borderColor || this.borderColor, this._setLineDash(t, e.borderDashArray || this.borderDashArray), t.strokeRect(-i / 2, -o / 2, i, o), a && (t.beginPath(), this.forEachControl((function(e, n, r) {
									e.withConnection && e.getVisibility(r, n) && (s = !0, t.moveTo(e.x * i, e.y * o), t.lineTo(e.x * i + e.offsetX, e.y * o + e.offsetY))
								})), s && t.stroke()), t.restore(), this
							},
							drawBordersInGroup: function(t, e, n) {
								n = n || {};
								var r = b.util.sizeAfterTransform(this.width, this.height, e),
									i = this.strokeWidth,
									o = this.strokeUniform,
									a = this.borderScaleFactor,
									s = r.x + i * (o ? this.canvas.getZoom() : e.scaleX) + a,
									l = r.y + i * (o ? this.canvas.getZoom() : e.scaleY) + a;
								return t.save(), this._setLineDash(t, n.borderDashArray || this.borderDashArray), t.strokeStyle = n.borderColor || this.borderColor, t.strokeRect(-s / 2, -l / 2, s, l), t.restore(), this
							},
							drawControls: function(t, e) {
								e = e || {}, t.save();
								var n, r, i = this.canvas.getRetinaScaling();
								return t.setTransform(i, 0, 0, i, 0, 0), t.strokeStyle = t.fillStyle = e.cornerColor || this.cornerColor, this.transparentCorners || (t.strokeStyle = e.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(t, e.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (n = this.group.calcTransformMatrix()), this.forEachControl((function(i, o, a) {
									r = a.oCoords[o], i.getVisibility(a, o) && (n && (r = b.util.transformPoint(r, n)), i.render(t, r.x, r.y, e, a))
								})), t.restore(), this
							},
							isControlVisible: function(t) {
								return this.controls[t] && this.controls[t].getVisibility(this, t)
							},
							setControlVisible: function(t, e) {
								return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t] = e, this
							},
							setControlsVisibility: function(t) {
								for (var e in t || (t = {}), t) this.setControlVisible(e, t[e]);
								return this
							},
							onDeselect: function() {},
							onSelect: function() {}
						})
					}(), b.util.object.extend(b.StaticCanvas.prototype, {
						FX_DURATION: 500,
						fxCenterObjectH: function(t, e) {
							var n = function() {},
								r = (e = e || {}).onComplete || n,
								i = e.onChange || n,
								o = this;
							return b.util.animate({
								target: this,
								startValue: t.left,
								endValue: this.getCenterPoint().x,
								duration: this.FX_DURATION,
								onChange: function(e) {
									t.set("left", e), o.requestRenderAll(), i()
								},
								onComplete: function() {
									t.setCoords(), r()
								}
							})
						},
						fxCenterObjectV: function(t, e) {
							var n = function() {},
								r = (e = e || {}).onComplete || n,
								i = e.onChange || n,
								o = this;
							return b.util.animate({
								target: this,
								startValue: t.top,
								endValue: this.getCenterPoint().y,
								duration: this.FX_DURATION,
								onChange: function(e) {
									t.set("top", e), o.requestRenderAll(), i()
								},
								onComplete: function() {
									t.setCoords(), r()
								}
							})
						},
						fxRemove: function(t, e) {
							var n = function() {},
								r = (e = e || {}).onComplete || n,
								i = e.onChange || n,
								o = this;
							return b.util.animate({
								target: this,
								startValue: t.opacity,
								endValue: 0,
								duration: this.FX_DURATION,
								onChange: function(e) {
									t.set("opacity", e), o.requestRenderAll(), i()
								},
								onComplete: function() {
									o.remove(t), r()
								}
							})
						}
					}), b.util.object.extend(b.Object.prototype, {
						animate: function() {
							if (arguments[0] && "object" == typeof arguments[0]) {
								var t, e, n = [],
									r = [];
								for (t in arguments[0]) n.push(t);
								for (var i = 0, o = n.length; i < o; i++) t = n[i], e = i !== o - 1, r.push(this._animate(t, arguments[0][t], arguments[1], e));
								return r
							}
							return this._animate.apply(this, arguments)
						},
						_animate: function(t, e, n, r) {
							var i, o = this;
							e = e.toString(), n = n ? b.util.object.clone(n) : {}, ~t.indexOf(".") && (i = t.split("."));
							var a = o.colorProperties.indexOf(t) > -1 || i && o.colorProperties.indexOf(i[1]) > -1,
								s = i ? this.get(i[0])[i[1]] : this.get(t);
							"from" in n || (n.from = s), a || (e = ~e.indexOf("=") ? s + parseFloat(e.replace("=", "")) : parseFloat(e));
							var l = {
								target: this,
								startValue: n.from,
								endValue: e,
								byValue: n.by,
								easing: n.easing,
								duration: n.duration,
								abort: n.abort && function(t, e, r) {
									return n.abort.call(o, t, e, r)
								},
								onChange: function(e, a, s) {
									i ? o[i[0]][i[1]] = e : o.set(t, e), r || n.onChange && n.onChange(e, a, s)
								},
								onComplete: function(t, e, i) {
									r || (o.setCoords(), n.onComplete && n.onComplete(t, e, i))
								}
							};
							return a ? b.util.animateColor(l.startValue, l.endValue, l.duration, l) : b.util.animate(l)
						}
					}),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.util.object.clone,
							i = {
								x1: 1,
								x2: 1,
								y1: 1,
								y2: 1
							};

						function o(t, e) {
							var n = t.origin,
								r = t.axis1,
								i = t.axis2,
								o = t.dimension,
								a = e.nearest,
								s = e.center,
								l = e.farthest;
							return function() {
								switch (this.get(n)) {
									case a:
										return Math.min(this.get(r), this.get(i));
									case s:
										return Math.min(this.get(r), this.get(i)) + .5 * this.get(o);
									case l:
										return Math.max(this.get(r), this.get(i))
								}
							}
						}
						e.Line ? e.warn("fabric.Line is already defined") : (e.Line = e.util.createClass(e.Object, {
							type: "line",
							x1: 0,
							y1: 0,
							x2: 0,
							y2: 0,
							cacheProperties: e.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"),
							initialize: function(t, e) {
								t || (t = [0, 0, 0, 0]), this.callSuper("initialize", e), this.set("x1", t[0]), this.set("y1", t[1]), this.set("x2", t[2]), this.set("y2", t[3]), this._setWidthHeight(e)
							},
							_setWidthHeight: function(t) {
								t || (t = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in t ? t.left : this._getLeftToOriginX(), this.top = "top" in t ? t.top : this._getTopToOriginY()
							},
							_set: function(t, e) {
								return this.callSuper("_set", t, e), void 0 !== i[t] && this._setWidthHeight(), this
							},
							_getLeftToOriginX: o({
								origin: "originX",
								axis1: "x1",
								axis2: "x2",
								dimension: "width"
							}, {
								nearest: "left",
								center: "center",
								farthest: "right"
							}),
							_getTopToOriginY: o({
								origin: "originY",
								axis1: "y1",
								axis2: "y2",
								dimension: "height"
							}, {
								nearest: "top",
								center: "center",
								farthest: "bottom"
							}),
							_render: function(t) {
								t.beginPath();
								var e = this.calcLinePoints();
								t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.lineWidth = this.strokeWidth;
								var n = t.strokeStyle;
								t.strokeStyle = this.stroke || t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = n
							},
							_findCenterFromElement: function() {
								return {
									x: (this.x1 + this.x2) / 2,
									y: (this.y1 + this.y2) / 2
								}
							},
							toObject: function(t) {
								return n(this.callSuper("toObject", t), this.calcLinePoints())
							},
							_getNonTransformedDimensions: function() {
								var t = this.callSuper("_getNonTransformedDimensions");
								return "butt" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t
							},
							calcLinePoints: function() {
								var t = this.x1 <= this.x2 ? -1 : 1,
									e = this.y1 <= this.y2 ? -1 : 1,
									n = t * this.width * .5,
									r = e * this.height * .5;
								return {
									x1: n,
									x2: t * this.width * -.5,
									y1: r,
									y2: e * this.height * -.5
								}
							},
							_toSVG: function() {
								var t = this.calcLinePoints();
								return ["<line ", "COMMON_PARTS", 'x1="', t.x1, '" y1="', t.y1, '" x2="', t.x2, '" y2="', t.y2, '" />\n']
							}
						}), e.Line.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), e.Line.fromElement = function(t, r, i) {
							i = i || {};
							var o = e.parseAttributes(t, e.Line.ATTRIBUTE_NAMES),
								a = [o.x1 || 0, o.y1 || 0, o.x2 || 0, o.y2 || 0];
							r(new e.Line(a, n(o, i)))
						}, e.Line.fromObject = function(t, n) {
							var i = r(t, !0);
							i.points = [t.x1, t.y1, t.x2, t.y2], e.Object._fromObject("Line", i, (function(t) {
								delete t.points, n && n(t)
							}), "points")
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.degreesToRadians;
						e.Circle ? e.warn("fabric.Circle is already defined.") : (e.Circle = e.util.createClass(e.Object, {
							type: "circle",
							radius: 0,
							startAngle: 0,
							endAngle: 360,
							cacheProperties: e.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"),
							_set: function(t, e) {
								return this.callSuper("_set", t, e), "radius" === t && this.setRadius(e), this
							},
							toObject: function(t) {
								return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(t))
							},
							_toSVG: function() {
								var t, r = (this.endAngle - this.startAngle) % 360;
								if (0 === r) t = ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', this.radius, '" />\n'];
								else {
									var i = n(this.startAngle),
										o = n(this.endAngle),
										a = this.radius;
									t = ['<path d="M ' + e.util.cos(i) * a + " " + e.util.sin(i) * a, " A " + a + " " + a, " 0 ", +(r > 180 ? "1" : "0") + " 1", " " + e.util.cos(o) * a + " " + e.util.sin(o) * a, '" ', "COMMON_PARTS", " />\n"]
								}
								return t
							},
							_render: function(t) {
								t.beginPath(), t.arc(0, 0, this.radius, n(this.startAngle), n(this.endAngle), !1), this._renderPaintInOrder(t)
							},
							getRadiusX: function() {
								return this.get("radius") * this.get("scaleX")
							},
							getRadiusY: function() {
								return this.get("radius") * this.get("scaleY")
							},
							setRadius: function(t) {
								return this.radius = t, this.set("width", 2 * t).set("height", 2 * t)
							}
						}), e.Circle.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), e.Circle.fromElement = function(t, n) {
							var r, i = e.parseAttributes(t, e.Circle.ATTRIBUTE_NAMES);
							if (!("radius" in (r = i) && r.radius >= 0)) throw new Error("value of `r` attribute is required and can not be negative");
							i.left = (i.left || 0) - i.radius, i.top = (i.top || 0) - i.radius, n(new e.Circle(i))
						}, e.Circle.fromObject = function(t, n) {
							e.Object._fromObject("Circle", t, n)
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});
						e.Triangle ? e.warn("fabric.Triangle is already defined") : (e.Triangle = e.util.createClass(e.Object, {
							type: "triangle",
							width: 100,
							height: 100,
							_render: function(t) {
								var e = this.width / 2,
									n = this.height / 2;
								t.beginPath(), t.moveTo(-e, n), t.lineTo(0, -n), t.lineTo(e, n), t.closePath(), this._renderPaintInOrder(t)
							},
							_toSVG: function() {
								var t = this.width / 2,
									e = this.height / 2;
								return ["<polygon ", "COMMON_PARTS", 'points="', [-t + " " + e, "0 " + -e, t + " " + e].join(","), '" />']
							}
						}), e.Triangle.fromObject = function(t, n) {
							return e.Object._fromObject("Triangle", t, n)
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = 2 * Math.PI;
						e.Ellipse ? e.warn("fabric.Ellipse is already defined.") : (e.Ellipse = e.util.createClass(e.Object, {
							type: "ellipse",
							rx: 0,
							ry: 0,
							cacheProperties: e.Object.prototype.cacheProperties.concat("rx", "ry"),
							initialize: function(t) {
								this.callSuper("initialize", t), this.set("rx", t && t.rx || 0), this.set("ry", t && t.ry || 0)
							},
							_set: function(t, e) {
								switch (this.callSuper("_set", t, e), t) {
									case "rx":
										this.rx = e, this.set("width", 2 * e);
										break;
									case "ry":
										this.ry = e, this.set("height", 2 * e)
								}
								return this
							},
							getRx: function() {
								return this.get("rx") * this.get("scaleX")
							},
							getRy: function() {
								return this.get("ry") * this.get("scaleY")
							},
							toObject: function(t) {
								return this.callSuper("toObject", ["rx", "ry"].concat(t))
							},
							_toSVG: function() {
								return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, '" />\n']
							},
							_render: function(t) {
								t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, n, !1), t.restore(), this._renderPaintInOrder(t)
							}
						}), e.Ellipse.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), e.Ellipse.fromElement = function(t, n) {
							var r = e.parseAttributes(t, e.Ellipse.ATTRIBUTE_NAMES);
							r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, n(new e.Ellipse(r))
						}, e.Ellipse.fromObject = function(t, n) {
							e.Object._fromObject("Ellipse", t, n)
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend;
						e.Rect ? e.warn("fabric.Rect is already defined") : (e.Rect = e.util.createClass(e.Object, {
							stateProperties: e.Object.prototype.stateProperties.concat("rx", "ry"),
							type: "rect",
							rx: 0,
							ry: 0,
							cacheProperties: e.Object.prototype.cacheProperties.concat("rx", "ry"),
							initialize: function(t) {
								this.callSuper("initialize", t), this._initRxRy()
							},
							_initRxRy: function() {
								this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry)
							},
							_render: function(t) {
								var e = this.rx ? Math.min(this.rx, this.width / 2) : 0,
									n = this.ry ? Math.min(this.ry, this.height / 2) : 0,
									r = this.width,
									i = this.height,
									o = -this.width / 2,
									a = -this.height / 2,
									s = 0 !== e || 0 !== n,
									l = .4477152502;
								t.beginPath(), t.moveTo(o + e, a), t.lineTo(o + r - e, a), s && t.bezierCurveTo(o + r - l * e, a, o + r, a + l * n, o + r, a + n), t.lineTo(o + r, a + i - n), s && t.bezierCurveTo(o + r, a + i - l * n, o + r - l * e, a + i, o + r - e, a + i), t.lineTo(o + e, a + i), s && t.bezierCurveTo(o + l * e, a + i, o, a + i - l * n, o, a + i - n), t.lineTo(o, a + n), s && t.bezierCurveTo(o, a + l * n, o + l * e, a, o + e, a), t.closePath(), this._renderPaintInOrder(t)
							},
							toObject: function(t) {
								return this.callSuper("toObject", ["rx", "ry"].concat(t))
							},
							_toSVG: function() {
								return ["<rect ", "COMMON_PARTS", 'x="', -this.width / 2, '" y="', -this.height / 2, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, '" />\n']
							}
						}), e.Rect.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), e.Rect.fromElement = function(t, r, i) {
							if (!t) return r(null);
							i = i || {};
							var o = e.parseAttributes(t, e.Rect.ATTRIBUTE_NAMES);
							o.left = o.left || 0, o.top = o.top || 0, o.height = o.height || 0, o.width = o.width || 0;
							var a = new e.Rect(n(i ? e.util.object.clone(i) : {}, o));
							a.visible = a.visible && a.width > 0 && a.height > 0, r(a)
						}, e.Rect.fromObject = function(t, n) {
							return e.Object._fromObject("Rect", t, n)
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.util.array.min,
							i = e.util.array.max,
							o = e.util.toFixed,
							a = e.util.projectStrokeOnPoints;
						e.Polyline ? e.warn("fabric.Polyline is already defined") : (e.Polyline = e.util.createClass(e.Object, {
							type: "polyline",
							points: null,
							exactBoundingBox: !1,
							cacheProperties: e.Object.prototype.cacheProperties.concat("points"),
							initialize: function(t, e) {
								e = e || {}, this.points = t || [], this.callSuper("initialize", e), this._setPositionDimensions(e)
							},
							_projectStrokeOnPoints: function() {
								return a(this.points, this, !0)
							},
							_setPositionDimensions: function(t) {
								var e, n = this._calcDimensions(t),
									r = this.exactBoundingBox ? this.strokeWidth : 0;
								this.width = n.width - r, this.height = n.height - r, t.fromSVG || (e = this.translateToGivenOrigin({
									x: n.left - this.strokeWidth / 2 + r / 2,
									y: n.top - this.strokeWidth / 2 + r / 2
								}, "left", "top", this.originX, this.originY)), void 0 === t.left && (this.left = t.fromSVG ? n.left : e.x), void 0 === t.top && (this.top = t.fromSVG ? n.top : e.y), this.pathOffset = {
									x: n.left + this.width / 2 + r / 2,
									y: n.top + this.height / 2 + r / 2
								}
							},
							_calcDimensions: function() {
								var t = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points,
									e = r(t, "x") || 0,
									n = r(t, "y") || 0;
								return {
									left: e,
									top: n,
									width: (i(t, "x") || 0) - e,
									height: (i(t, "y") || 0) - n
								}
							},
							toObject: function(t) {
								return n(this.callSuper("toObject", t), {
									points: this.points.concat()
								})
							},
							_toSVG: function() {
								for (var t = [], n = this.pathOffset.x, r = this.pathOffset.y, i = e.Object.NUM_FRACTION_DIGITS, a = 0, s = this.points.length; a < s; a++) t.push(o(this.points[a].x - n, i), ",", o(this.points[a].y - r, i), " ");
								return ["<" + this.type + " ", "COMMON_PARTS", 'points="', t.join(""), '" />\n']
							},
							commonRender: function(t) {
								var e, n = this.points.length,
									r = this.pathOffset.x,
									i = this.pathOffset.y;
								if (!n || isNaN(this.points[n - 1].y)) return !1;
								t.beginPath(), t.moveTo(this.points[0].x - r, this.points[0].y - i);
								for (var o = 0; o < n; o++) e = this.points[o], t.lineTo(e.x - r, e.y - i);
								return !0
							},
							_render: function(t) {
								this.commonRender(t) && this._renderPaintInOrder(t)
							},
							complexity: function() {
								return this.get("points").length
							}
						}), e.Polyline.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polyline.fromElementGenerator = function(t) {
							return function(r, i, o) {
								if (!r) return i(null);
								o || (o = {});
								var a = e.parsePointsAttribute(r.getAttribute("points")),
									s = e.parseAttributes(r, e[t].ATTRIBUTE_NAMES);
								s.fromSVG = !0, i(new e[t](a, n(s, o)))
							}
						}, e.Polyline.fromElement = e.Polyline.fromElementGenerator("Polyline"), e.Polyline.fromObject = function(t, n) {
							return e.Object._fromObject("Polyline", t, n, "points")
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.projectStrokeOnPoints;
						e.Polygon ? e.warn("fabric.Polygon is already defined") : (e.Polygon = e.util.createClass(e.Polyline, {
							type: "polygon",
							_projectStrokeOnPoints: function() {
								return n(this.points, this)
							},
							_render: function(t) {
								this.commonRender(t) && (t.closePath(), this._renderPaintInOrder(t))
							}
						}), e.Polygon.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polygon.fromElement = e.Polyline.fromElementGenerator("Polygon"), e.Polygon.fromObject = function(t, n) {
							e.Object._fromObject("Polygon", t, n, "points")
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.array.min,
							r = e.util.array.max,
							i = e.util.object.extend,
							o = e.util.object.clone,
							a = e.util.toFixed;
						e.Path ? e.warn("fabric.Path is already defined") : (e.Path = e.util.createClass(e.Object, {
							type: "path",
							path: null,
							cacheProperties: e.Object.prototype.cacheProperties.concat("path", "fillRule"),
							stateProperties: e.Object.prototype.stateProperties.concat("path"),
							initialize: function(t, e) {
								delete(e = o(e || {})).path, this.callSuper("initialize", e), this._setPath(t || [], e)
							},
							_setPath: function(t, n) {
								this.path = e.util.makePathSimpler(Array.isArray(t) ? t : e.util.parsePath(t)), e.Polyline.prototype._setPositionDimensions.call(this, n || {})
							},
							_renderPathCommands: function(t) {
								var e, n = 0,
									r = 0,
									i = 0,
									o = 0,
									a = 0,
									s = 0,
									l = -this.pathOffset.x,
									c = -this.pathOffset.y;
								t.beginPath();
								for (var u = 0, h = this.path.length; u < h; ++u) switch ((e = this.path[u])[0]) {
									case "L":
										i = e[1], o = e[2], t.lineTo(i + l, o + c);
										break;
									case "M":
										n = i = e[1], r = o = e[2], t.moveTo(i + l, o + c);
										break;
									case "C":
										i = e[5], o = e[6], a = e[3], s = e[4], t.bezierCurveTo(e[1] + l, e[2] + c, a + l, s + c, i + l, o + c);
										break;
									case "Q":
										t.quadraticCurveTo(e[1] + l, e[2] + c, e[3] + l, e[4] + c), i = e[3], o = e[4], a = e[1], s = e[2];
										break;
									case "z":
									case "Z":
										i = n, o = r, t.closePath()
								}
							},
							_render: function(t) {
								this._renderPathCommands(t), this._renderPaintInOrder(t)
							},
							toString: function() {
								return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>"
							},
							toObject: function(t) {
								return i(this.callSuper("toObject", t), {
									path: this.path.map((function(t) {
										return t.slice()
									}))
								})
							},
							toDatalessObject: function(t) {
								var e = this.toObject(["sourcePath"].concat(t));
								return e.sourcePath && delete e.path, e
							},
							_toSVG: function() {
								return ["<path ", "COMMON_PARTS", 'd="', e.util.joinPath(this.path), '" stroke-linecap="round" ', "/>\n"]
							},
							_getOffsetTransform: function() {
								var t = e.Object.NUM_FRACTION_DIGITS;
								return " translate(" + a(-this.pathOffset.x, t) + ", " + a(-this.pathOffset.y, t) + ")"
							},
							toClipPathSVG: function(t) {
								var e = this._getOffsetTransform();
								return "\t" + this._createBaseClipPathSVGMarkup(this._toSVG(), {
									reviver: t,
									additionalTransform: e
								})
							},
							toSVG: function(t) {
								var e = this._getOffsetTransform();
								return this._createBaseSVGMarkup(this._toSVG(), {
									reviver: t,
									additionalTransform: e
								})
							},
							complexity: function() {
								return this.path.length
							},
							_calcDimensions: function() {
								for (var t, i, o = [], a = [], s = 0, l = 0, c = 0, u = 0, h = 0, f = this.path.length; h < f; ++h) {
									switch ((t = this.path[h])[0]) {
										case "L":
											c = t[1], u = t[2], i = [];
											break;
										case "M":
											s = c = t[1], l = u = t[2], i = [];
											break;
										case "C":
											i = e.util.getBoundsOfCurve(c, u, t[1], t[2], t[3], t[4], t[5], t[6]), c = t[5], u = t[6];
											break;
										case "Q":
											i = e.util.getBoundsOfCurve(c, u, t[1], t[2], t[1], t[2], t[3], t[4]), c = t[3], u = t[4];
											break;
										case "z":
										case "Z":
											c = s, u = l
									}
									i.forEach((function(t) {
										o.push(t.x), a.push(t.y)
									})), o.push(c), a.push(u)
								}
								var d = n(o) || 0,
									p = n(a) || 0;
								return {
									left: d,
									top: p,
									width: (r(o) || 0) - d,
									height: (r(a) || 0) - p
								}
							}
						}), e.Path.fromObject = function(t, n) {
							if ("string" == typeof t.sourcePath) {
								var r = t.sourcePath;
								e.loadSVGFromURL(r, (function(r) {
									var i = r[0];
									i.setOptions(t), t.clipPath ? e.util.enlivenObjects([t.clipPath], (function(t) {
										i.clipPath = t[0], n && n(i)
									})) : n && n(i)
								}))
							} else e.Object._fromObject("Path", t, n, "path")
						}, e.Path.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(["d"]), e.Path.fromElement = function(t, n, r) {
							var o = e.parseAttributes(t, e.Path.ATTRIBUTE_NAMES);
							o.fromSVG = !0, n(new e.Path(o.d, i(o, r)))
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.array.min,
							r = e.util.array.max;
						e.Group || (e.Group = e.util.createClass(e.Object, e.Collection, {
							type: "group",
							strokeWidth: 0,
							subTargetCheck: !1,
							cacheProperties: [],
							useSetOnGroup: !1,
							initialize: function(t, e, n) {
								e = e || {}, this._objects = [], n && this.callSuper("initialize", e), this._objects = t || [];
								for (var r = this._objects.length; r--;) this._objects[r].group = this;
								if (n) this._updateObjectsACoords();
								else {
									var i = e && e.centerPoint;
									void 0 !== e.originX && (this.originX = e.originX), void 0 !== e.originY && (this.originY = e.originY), i || this._calcBounds(), this._updateObjectsCoords(i), delete e.centerPoint, this.callSuper("initialize", e)
								}
								this.setCoords()
							},
							_updateObjectsACoords: function() {
								for (var t = this._objects.length; t--;) this._objects[t].setCoords(!0)
							},
							_updateObjectsCoords: function(t) {
								t = t || this.getCenterPoint();
								for (var e = this._objects.length; e--;) this._updateObjectCoords(this._objects[e], t)
							},
							_updateObjectCoords: function(t, e) {
								var n = t.left,
									r = t.top;
								t.set({
									left: n - e.x,
									top: r - e.y
								}), t.group = this, t.setCoords(!0)
							},
							toString: function() {
								return "#<fabric.Group: (" + this.complexity() + ")>"
							},
							addWithUpdate: function(t) {
								var n = !!this.group;
								return this._restoreObjectsState(), e.util.resetObjectTransform(this), t && (n && e.util.removeTransformFromObject(t, this.group.calcTransformMatrix()), this._objects.push(t), t.group = this, t._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, n ? this.group.addWithUpdate() : this.setCoords(), this
							},
							removeWithUpdate: function(t) {
								return this._restoreObjectsState(), e.util.resetObjectTransform(this), this.remove(t), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this
							},
							_onObjectAdded: function(t) {
								this.dirty = !0, t.group = this, t._set("canvas", this.canvas)
							},
							_onObjectRemoved: function(t) {
								this.dirty = !0, delete t.group
							},
							_set: function(t, n) {
								var r = this._objects.length;
								if (this.useSetOnGroup)
									for (; r--;) this._objects[r].setOnGroup(t, n);
								if ("canvas" === t)
									for (; r--;) this._objects[r]._set(t, n);
								e.Object.prototype._set.call(this, t, n)
							},
							toObject: function(t) {
								var n = this.includeDefaultValues,
									r = this._objects.filter((function(t) {
										return !t.excludeFromExport
									})).map((function(e) {
										var r = e.includeDefaultValues;
										e.includeDefaultValues = n;
										var i = e.toObject(t);
										return e.includeDefaultValues = r, i
									})),
									i = e.Object.prototype.toObject.call(this, t);
								return i.objects = r, i
							},
							toDatalessObject: function(t) {
								var n, r = this.sourcePath;
								if (r) n = r;
								else {
									var i = this.includeDefaultValues;
									n = this._objects.map((function(e) {
										var n = e.includeDefaultValues;
										e.includeDefaultValues = i;
										var r = e.toDatalessObject(t);
										return e.includeDefaultValues = n, r
									}))
								}
								var o = e.Object.prototype.toDatalessObject.call(this, t);
								return o.objects = n, o
							},
							render: function(t) {
								this._transformDone = !0, this.callSuper("render", t), this._transformDone = !1
							},
							shouldCache: function() {
								var t = e.Object.prototype.shouldCache.call(this);
								if (t)
									for (var n = 0, r = this._objects.length; n < r; n++)
										if (this._objects[n].willDrawShadow()) return this.ownCaching = !1, !1;
								return t
							},
							willDrawShadow: function() {
								if (e.Object.prototype.willDrawShadow.call(this)) return !0;
								for (var t = 0, n = this._objects.length; t < n; t++)
									if (this._objects[t].willDrawShadow()) return !0;
								return !1
							},
							isOnACache: function() {
								return this.ownCaching || this.group && this.group.isOnACache()
							},
							drawObject: function(t) {
								for (var e = 0, n = this._objects.length; e < n; e++) this._objects[e].render(t);
								this._drawClipPath(t, this.clipPath)
							},
							isCacheDirty: function(t) {
								if (this.callSuper("isCacheDirty", t)) return !0;
								if (!this.statefullCache) return !1;
								for (var e = 0, n = this._objects.length; e < n; e++)
									if (this._objects[e].isCacheDirty(!0)) {
										if (this._cacheCanvas) {
											var r = this.cacheWidth / this.zoomX,
												i = this.cacheHeight / this.zoomY;
											this._cacheContext.clearRect(-r / 2, -i / 2, r, i)
										}
										return !0
									} return !1
							},
							_restoreObjectsState: function() {
								var t = this.calcOwnMatrix();
								return this._objects.forEach((function(n) {
									e.util.addTransformToObject(n, t), delete n.group, n.setCoords()
								})), this
							},
							destroy: function() {
								return this._objects.forEach((function(t) {
									t.set("dirty", !0)
								})), this._restoreObjectsState()
							},
							dispose: function() {
								this.callSuper("dispose"), this.forEachObject((function(t) {
									t.dispose && t.dispose()
								})), this._objects = []
							},
							toActiveSelection: function() {
								if (this.canvas) {
									var t = this._objects,
										n = this.canvas;
									this._objects = [];
									var r = this.toObject();
									delete r.objects;
									var i = new e.ActiveSelection([]);
									return i.set(r), i.type = "activeSelection", n.remove(this), t.forEach((function(t) {
										t.group = i, t.dirty = !0, n.add(t)
									})), i.canvas = n, i._objects = t, n._activeObject = i, i.setCoords(), i
								}
							},
							ungroupOnCanvas: function() {
								return this._restoreObjectsState()
							},
							setObjectsCoords: function() {
								return this.forEachObject((function(t) {
									t.setCoords(!0)
								})), this
							},
							_calcBounds: function(t) {
								for (var e, n, r, i, o = [], a = [], s = ["tr", "br", "bl", "tl"], l = 0, c = this._objects.length, u = s.length; l < c; ++l) {
									for (r = (e = this._objects[l]).calcACoords(), i = 0; i < u; i++) n = s[i], o.push(r[n].x), a.push(r[n].y);
									e.aCoords = r
								}
								this._getBounds(o, a, t)
							},
							_getBounds: function(t, i, o) {
								var a = new e.Point(n(t), n(i)),
									s = new e.Point(r(t), r(i)),
									l = a.y || 0,
									c = a.x || 0,
									u = s.x - a.x || 0,
									h = s.y - a.y || 0;
								this.width = u, this.height = h, o || this.setPositionByOrigin({
									x: c,
									y: l
								}, "left", "top")
							},
							_toSVG: function(t) {
								for (var e = ["<g ", "COMMON_PARTS", " >\n"], n = 0, r = this._objects.length; n < r; n++) e.push("\t\t", this._objects[n].toSVG(t));
								return e.push("</g>\n"), e
							},
							getSvgStyles: function() {
								var t = void 0 !== this.opacity && 1 !== this.opacity ? "opacity: " + this.opacity + ";" : "",
									e = this.visible ? "" : " visibility: hidden;";
								return [t, this.getSvgFilter(), e].join("")
							},
							toClipPathSVG: function(t) {
								for (var e = [], n = 0, r = this._objects.length; n < r; n++) e.push("\t", this._objects[n].toClipPathSVG(t));
								return this._createBaseClipPathSVGMarkup(e, {
									reviver: t
								})
							}
						}), e.Group.fromObject = function(t, n) {
							var r = t.objects,
								i = e.util.object.clone(t, !0);
							delete i.objects, "string" != typeof r ? e.util.enlivenObjects(r, (function(r) {
								e.util.enlivenObjectEnlivables(t, i, (function() {
									n && n(new e.Group(r, i, !0))
								}))
							})) : e.loadSVGFromURL(r, (function(o) {
								var a = e.util.groupSVGElements(o, t, r),
									s = i.clipPath;
								delete i.clipPath, a.set(i), s ? e.util.enlivenObjects([s], (function(t) {
									a.clipPath = t[0], n && n(a)
								})) : n && n(a)
							}))
						})
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});
						e.ActiveSelection || (e.ActiveSelection = e.util.createClass(e.Group, {
							type: "activeSelection",
							initialize: function(t, n) {
								n = n || {}, this._objects = t || [];
								for (var r = this._objects.length; r--;) this._objects[r].group = this;
								n.originX && (this.originX = n.originX), n.originY && (this.originY = n.originY), this._calcBounds(), this._updateObjectsCoords(), e.Object.prototype.initialize.call(this, n), this.setCoords()
							},
							toGroup: function() {
								var t = this._objects.concat();
								this._objects = [];
								var n = e.Object.prototype.toObject.call(this),
									r = new e.Group([]);
								if (delete n.type, r.set(n), t.forEach((function(t) {
										t.canvas.remove(t), t.group = r
									})), r._objects = t, !this.canvas) return r;
								var i = this.canvas;
								return i.add(r), i._activeObject = r, r.setCoords(), r
							},
							onDeselect: function() {
								return this.destroy(), !1
							},
							toString: function() {
								return "#<fabric.ActiveSelection: (" + this.complexity() + ")>"
							},
							shouldCache: function() {
								return !1
							},
							isOnACache: function() {
								return !1
							},
							_renderControls: function(t, e, n) {
								t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", t, e), void 0 === (n = n || {}).hasControls && (n.hasControls = !1), n.forActiveSelection = !0;
								for (var r = 0, i = this._objects.length; r < i; r++) this._objects[r]._renderControls(t, n);
								t.restore()
							}
						}), e.ActiveSelection.fromObject = function(t, n) {
							e.util.enlivenObjects(t.objects, (function(r) {
								delete t.objects, n && n(new e.ActiveSelection(r, t, !0))
							}))
						})
					}(e),
					function(t) {
						"use strict";
						var e = b.util.object.extend;
						t.fabric || (t.fabric = {}), t.fabric.Image ? b.warn("fabric.Image is already defined.") : (b.Image = b.util.createClass(b.Object, {
							type: "image",
							strokeWidth: 0,
							srcFromAttribute: !1,
							_lastScaleX: 1,
							_lastScaleY: 1,
							_filterScalingX: 1,
							_filterScalingY: 1,
							minimumScaleTrigger: .5,
							stateProperties: b.Object.prototype.stateProperties.concat("cropX", "cropY"),
							cacheProperties: b.Object.prototype.cacheProperties.concat("cropX", "cropY"),
							cacheKey: "",
							cropX: 0,
							cropY: 0,
							imageSmoothing: !0,
							initialize: function(t, e) {
								e || (e = {}), this.filters = [], this.cacheKey = "texture" + b.Object.__uid++, this.callSuper("initialize", e), this._initElement(t, e)
							},
							getElement: function() {
								return this._element || {}
							},
							setElement: function(t, e) {
								return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = t, this._originalElement = t, this._initConfig(e), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this
							},
							removeTexture: function(t) {
								var e = b.filterBackend;
								e && e.evictCachesForKey && e.evictCachesForKey(t)
							},
							dispose: function() {
								this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function(t) {
									b.util.cleanUpJsdomNode(this[t]), this[t] = void 0
								}.bind(this))
							},
							getCrossOrigin: function() {
								return this._originalElement && (this._originalElement.crossOrigin || null)
							},
							getOriginalSize: function() {
								var t = this.getElement();
								return {
									width: t.naturalWidth || t.width,
									height: t.naturalHeight || t.height
								}
							},
							_stroke: function(t) {
								if (this.stroke && 0 !== this.strokeWidth) {
									var e = this.width / 2,
										n = this.height / 2;
									t.beginPath(), t.moveTo(-e, -n), t.lineTo(e, -n), t.lineTo(e, n), t.lineTo(-e, n), t.lineTo(-e, -n), t.closePath()
								}
							},
							toObject: function(t) {
								var n = [];
								this.filters.forEach((function(t) {
									t && n.push(t.toObject())
								}));
								var r = e(this.callSuper("toObject", ["cropX", "cropY"].concat(t)), {
									src: this.getSrc(),
									crossOrigin: this.getCrossOrigin(),
									filters: n
								});
								return this.resizeFilter && (r.resizeFilter = this.resizeFilter.toObject()), r
							},
							hasCrop: function() {
								return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height
							},
							_toSVG: function() {
								var t, e = [],
									n = [],
									r = this._element,
									i = -this.width / 2,
									o = -this.height / 2,
									a = "",
									s = "";
								if (!r) return [];
								if (this.hasCrop()) {
									var l = b.Object.__uid++;
									e.push('<clipPath id="imageCrop_' + l + '">\n', '\t<rect x="' + i + '" y="' + o + '" width="' + this.width + '" height="' + this.height + '" />\n', "</clipPath>\n"), a = ' clip-path="url(#imageCrop_' + l + ')" '
								}
								if (this.imageSmoothing || (s = '" image-rendering="optimizeSpeed'), n.push("\t<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(!0), '" x="', i - this.cropX, '" y="', o - this.cropY, '" width="', r.width || r.naturalWidth, '" height="', r.height || r.height, s, '"', a, "></image>\n"), this.stroke || this.strokeDashArray) {
									var c = this.fill;
									this.fill = null, t = ["\t<rect ", 'x="', i, '" y="', o, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n'], this.fill = c
								}
								return "fill" !== this.paintFirst ? e.concat(t, n) : e.concat(n, t)
							},
							getSrc: function(t) {
								var e = t ? this._element : this._originalElement;
								return e ? e.toDataURL ? e.toDataURL() : this.srcFromAttribute ? e.getAttribute("src") : e.src : this.src || ""
							},
							setSrc: function(t, e, n) {
								return b.util.loadImage(t, (function(t, r) {
									this.setElement(t, n), this._setWidthHeight(), e && e(this, r)
								}), this, n && n.crossOrigin), this
							},
							toString: function() {
								return '#<fabric.Image: { src: "' + this.getSrc() + '" }>'
							},
							applyResizeFilters: function() {
								var t = this.resizeFilter,
									e = this.minimumScaleTrigger,
									n = this.getTotalObjectScaling(),
									r = n.scaleX,
									i = n.scaleY,
									o = this._filteredEl || this._originalElement;
								if (this.group && this.set("dirty", !0), !t || r > e && i > e) return this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void(this._lastScaleY = i);
								b.filterBackend || (b.filterBackend = b.initFilterBackend());
								var a = b.util.createCanvasElement(),
									s = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey,
									l = o.width,
									c = o.height;
								a.width = l, a.height = c, this._element = a, this._lastScaleX = t.scaleX = r, this._lastScaleY = t.scaleY = i, b.filterBackend.applyFilters([t], o, l, c, this._element, s), this._filterScalingX = a.width / this._originalElement.width, this._filterScalingY = a.height / this._originalElement.height
							},
							applyFilters: function(t) {
								if (t = (t = t || this.filters || []).filter((function(t) {
										return t && !t.isNeutralState()
									})), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), 0 === t.length) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this;
								var e = this._originalElement,
									n = e.naturalWidth || e.width,
									r = e.naturalHeight || e.height;
								if (this._element === this._originalElement) {
									var i = b.util.createCanvasElement();
									i.width = n, i.height = r, this._element = i, this._filteredEl = i
								} else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, n, r), this._lastScaleX = 1, this._lastScaleY = 1;
								return b.filterBackend || (b.filterBackend = b.initFilterBackend()), b.filterBackend.applyFilters(t, this._originalElement, n, r, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this
							},
							_render: function(t) {
								b.util.setImageSmoothing(t, this.imageSmoothing), !0 !== this.isMoving && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t)
							},
							drawCacheOnCanvas: function(t) {
								b.util.setImageSmoothing(t, this.imageSmoothing), b.Object.prototype.drawCacheOnCanvas.call(this, t)
							},
							shouldCache: function() {
								return this.needsItsOwnCache()
							},
							_renderFill: function(t) {
								var e = this._element;
								if (e) {
									var n = this._filterScalingX,
										r = this._filterScalingY,
										i = this.width,
										o = this.height,
										a = Math.min,
										s = Math.max,
										l = s(this.cropX, 0),
										c = s(this.cropY, 0),
										u = e.naturalWidth || e.width,
										h = e.naturalHeight || e.height,
										f = l * n,
										d = c * r,
										p = a(i * n, u - f),
										g = a(o * r, h - d),
										v = -i / 2,
										m = -o / 2,
										y = a(i, u / n - l),
										b = a(o, h / r - c);
									e && t.drawImage(e, f, d, p, g, v, m, y, b)
								}
							},
							_needsResize: function() {
								var t = this.getTotalObjectScaling();
								return t.scaleX !== this._lastScaleX || t.scaleY !== this._lastScaleY
							},
							_resetWidthHeight: function() {
								this.set(this.getOriginalSize())
							},
							_initElement: function(t, e) {
								this.setElement(b.util.getById(t), e), b.util.addClass(this.getElement(), b.Image.CSS_CANVAS)
							},
							_initConfig: function(t) {
								t || (t = {}), this.setOptions(t), this._setWidthHeight(t)
							},
							_initFilters: function(t, e) {
								t && t.length ? b.util.enlivenObjects(t, (function(t) {
									e && e(t)
								}), "fabric.Image.filters") : e && e()
							},
							_setWidthHeight: function(t) {
								t || (t = {});
								var e = this.getElement();
								this.width = t.width || e.naturalWidth || e.width || 0, this.height = t.height || e.naturalHeight || e.height || 0
							},
							parsePreserveAspectRatioAttribute: function() {
								var t, e = b.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""),
									n = this._element.width,
									r = this._element.height,
									i = 1,
									o = 1,
									a = 0,
									s = 0,
									l = 0,
									c = 0,
									u = this.width,
									h = this.height,
									f = {
										width: u,
										height: h
									};
								return !e || "none" === e.alignX && "none" === e.alignY ? (i = u / n, o = h / r) : ("meet" === e.meetOrSlice && (t = (u - n * (i = o = b.util.findScaleToFit(this._element, f))) / 2, "Min" === e.alignX && (a = -t), "Max" === e.alignX && (a = t), t = (h - r * o) / 2, "Min" === e.alignY && (s = -t), "Max" === e.alignY && (s = t)), "slice" === e.meetOrSlice && (t = n - u / (i = o = b.util.findScaleToCover(this._element, f)), "Mid" === e.alignX && (l = t / 2), "Max" === e.alignX && (l = t), t = r - h / o, "Mid" === e.alignY && (c = t / 2), "Max" === e.alignY && (c = t), n = u / i, r = h / o)), {
									width: n,
									height: r,
									scaleX: i,
									scaleY: o,
									offsetLeft: a,
									offsetTop: s,
									cropX: l,
									cropY: c
								}
							}
						}), b.Image.CSS_CANVAS = "canvas-img", b.Image.prototype.getSvgSrc = b.Image.prototype.getSrc, b.Image.fromObject = function(t, e) {
							var n = b.util.object.clone(t);
							b.util.loadImage(n.src, (function(t, r) {
								r ? e && e(null, !0) : b.Image.prototype._initFilters.call(n, n.filters, (function(r) {
									n.filters = r || [], b.Image.prototype._initFilters.call(n, [n.resizeFilter], (function(r) {
										n.resizeFilter = r[0], b.util.enlivenObjectEnlivables(n, n, (function() {
											var r = new b.Image(t, n);
											e(r, !1)
										}))
									}))
								}))
							}), null, n.crossOrigin)
						}, b.Image.fromURL = function(t, e, n) {
							b.util.loadImage(t, (function(t, r) {
								e && e(new b.Image(t, n), r)
							}), null, n && n.crossOrigin)
						}, b.Image.ATTRIBUTE_NAMES = b.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), b.Image.fromElement = function(t, n, r) {
							var i = b.parseAttributes(t, b.Image.ATTRIBUTE_NAMES);
							b.Image.fromURL(i["xlink:href"], n, e(r ? b.util.object.clone(r) : {}, i))
						})
					}(e), b.util.object.extend(b.Object.prototype, {
						_getAngleValueForStraighten: function() {
							var t = this.angle % 360;
							return t > 0 ? 90 * Math.round((t - 1) / 90) : 90 * Math.round(t / 90)
						},
						straighten: function() {
							return this.rotate(this._getAngleValueForStraighten())
						},
						fxStraighten: function(t) {
							var e = function() {},
								n = (t = t || {}).onComplete || e,
								r = t.onChange || e,
								i = this;
							return b.util.animate({
								target: this,
								startValue: this.get("angle"),
								endValue: this._getAngleValueForStraighten(),
								duration: this.FX_DURATION,
								onChange: function(t) {
									i.rotate(t), r()
								},
								onComplete: function() {
									i.setCoords(), n()
								}
							})
						}
					}), b.util.object.extend(b.StaticCanvas.prototype, {
						straightenObject: function(t) {
							return t.straighten(), this.requestRenderAll(), this
						},
						fxStraightenObject: function(t) {
							return t.fxStraighten({
								onChange: this.requestRenderAllBound
							})
						}
					}),
					function() {
						"use strict";

						function t(t, e) {
							var n = "precision " + e + " float;\nvoid main(){}",
								r = t.createShader(t.FRAGMENT_SHADER);
							return t.shaderSource(r, n), t.compileShader(r), !!t.getShaderParameter(r, t.COMPILE_STATUS)
						}

						function e(t) {
							t && t.tileSize && (this.tileSize = t.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo()
						}
						b.isWebglSupported = function(e) {
							if (b.isLikelyNode) return !1;
							e = e || b.WebglFilterBackend.prototype.tileSize;
							var n = document.createElement("canvas"),
								r = n.getContext("webgl") || n.getContext("experimental-webgl"),
								i = !1;
							if (r) {
								b.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), i = b.maxTextureSize >= e;
								for (var o = ["highp", "mediump", "lowp"], a = 0; a < 3; a++)
									if (t(r, o[a])) {
										b.webGlPrecision = o[a];
										break
									}
							}
							return this.isSupported = i, i
						}, b.WebglFilterBackend = e, e.prototype = {
							tileSize: 2048,
							resources: {},
							setupGLContext: function(t, e) {
								this.dispose(), this.createWebGLCanvas(t, e), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(t, e)
							},
							chooseFastestCopyGLTo2DMethod: function(t, e) {
								var n, r = void 0 !== window.performance;
								try {
									new ImageData(1, 1), n = !0
								} catch (t) {
									n = !1
								}
								var i = "undefined" != typeof ArrayBuffer,
									o = "undefined" != typeof Uint8ClampedArray;
								if (r && n && i && o) {
									var a = b.util.createCanvasElement(),
										s = new ArrayBuffer(t * e * 4);
									if (b.forceGLPutImageData) return this.imageBuffer = s, void(this.copyGLTo2D = C);
									var l, c, u = {
										imageBuffer: s,
										destinationWidth: t,
										destinationHeight: e,
										targetCanvas: a
									};
									a.width = t, a.height = e, l = window.performance.now(), w.call(u, this.gl, u), c = window.performance.now() - l, l = window.performance.now(), C.call(u, this.gl, u), c > window.performance.now() - l ? (this.imageBuffer = s, this.copyGLTo2D = C) : this.copyGLTo2D = w
								}
							},
							createWebGLCanvas: function(t, e) {
								var n = b.util.createCanvasElement();
								n.width = t, n.height = e;
								var r = {
										alpha: !0,
										premultipliedAlpha: !1,
										depth: !1,
										stencil: !1,
										antialias: !1
									},
									i = n.getContext("webgl", r);
								i || (i = n.getContext("experimental-webgl", r)), i && (i.clearColor(0, 0, 0, 0), this.canvas = n, this.gl = i)
							},
							applyFilters: function(t, e, n, r, i, o) {
								var a, s = this.gl;
								o && (a = this.getCachedTexture(o, e));
								var l = {
										originalWidth: e.width || e.originalWidth,
										originalHeight: e.height || e.originalHeight,
										sourceWidth: n,
										sourceHeight: r,
										destinationWidth: n,
										destinationHeight: r,
										context: s,
										sourceTexture: this.createTexture(s, n, r, !a && e),
										targetTexture: this.createTexture(s, n, r),
										originalTexture: a || this.createTexture(s, n, r, !a && e),
										passes: t.length,
										webgl: !0,
										aPosition: this.aPosition,
										programCache: this.programCache,
										pass: 0,
										filterBackend: this,
										targetCanvas: i
									},
									c = s.createFramebuffer();
								return s.bindFramebuffer(s.FRAMEBUFFER, c), t.forEach((function(t) {
										t && t.applyTo(l)
									})),
									function(t) {
										var e = t.targetCanvas,
											n = e.width,
											r = e.height,
											i = t.destinationWidth,
											o = t.destinationHeight;
										n === i && r === o || (e.width = i, e.height = o)
									}(l), this.copyGLTo2D(s, l), s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(l.sourceTexture), s.deleteTexture(l.targetTexture), s.deleteFramebuffer(c), i.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), l
							},
							dispose: function() {
								this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches()
							},
							clearWebGLCaches: function() {
								this.programCache = {}, this.textureCache = {}
							},
							createTexture: function(t, e, n, r, i) {
								var o = t.createTexture();
								return t.bindTexture(t.TEXTURE_2D, o), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, i || t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i || t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), r ? t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, n, 0, t.RGBA, t.UNSIGNED_BYTE, null), o
							},
							getCachedTexture: function(t, e) {
								if (this.textureCache[t]) return this.textureCache[t];
								var n = this.createTexture(this.gl, e.width, e.height, e);
								return this.textureCache[t] = n, n
							},
							evictCachesForKey: function(t) {
								this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t])
							},
							copyGLTo2D: w,
							captureGPUInfo: function() {
								if (this.gpuInfo) return this.gpuInfo;
								var t = this.gl,
									e = {
										renderer: "",
										vendor: ""
									};
								if (!t) return e;
								var n = t.getExtension("WEBGL_debug_renderer_info");
								if (n) {
									var r = t.getParameter(n.UNMASKED_RENDERER_WEBGL),
										i = t.getParameter(n.UNMASKED_VENDOR_WEBGL);
									r && (e.renderer = r.toLowerCase()), i && (e.vendor = i.toLowerCase())
								}
								return this.gpuInfo = e, e
							}
						}
					}(),
					function() {
						"use strict";
						var t = function() {};

						function e() {}
						b.Canvas2dFilterBackend = e, e.prototype = {
							evictCachesForKey: t,
							dispose: t,
							clearWebGLCaches: t,
							resources: {},
							applyFilters: function(t, e, n, r, i) {
								var o = i.getContext("2d");
								o.drawImage(e, 0, 0, n, r);
								var a = {
									sourceWidth: n,
									sourceHeight: r,
									imageData: o.getImageData(0, 0, n, r),
									originalEl: e,
									originalImageData: o.getImageData(0, 0, n, r),
									canvasEl: i,
									ctx: o,
									filterBackend: this
								};
								return t.forEach((function(t) {
									t.applyTo(a)
								})), a.imageData.width === n && a.imageData.height === r || (i.width = a.imageData.width, i.height = a.imageData.height), o.putImageData(a.imageData, 0, 0), a
							}
						}
					}(), b.Image = b.Image || {}, b.Image.filters = b.Image.filters || {}, b.Image.filters.BaseFilter = b.util.createClass({
						type: "BaseFilter",
						vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
						fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}",
						initialize: function(t) {
							t && this.setOptions(t)
						},
						setOptions: function(t) {
							for (var e in t) this[e] = t[e]
						},
						createProgram: function(t, e, n) {
							e = e || this.fragmentSource, n = n || this.vertexSource, "highp" !== b.webGlPrecision && (e = e.replace(/precision highp float/g, "precision " + b.webGlPrecision + " float"));
							var r = t.createShader(t.VERTEX_SHADER);
							if (t.shaderSource(r, n), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + t.getShaderInfoLog(r));
							var i = t.createShader(t.FRAGMENT_SHADER);
							if (t.shaderSource(i, e), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + t.getShaderInfoLog(i));
							var o = t.createProgram();
							if (t.attachShader(o, r), t.attachShader(o, i), t.linkProgram(o), !t.getProgramParameter(o, t.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + t.getProgramInfoLog(o));
							var a = this.getAttributeLocations(t, o),
								s = this.getUniformLocations(t, o) || {};
							return s.uStepW = t.getUniformLocation(o, "uStepW"), s.uStepH = t.getUniformLocation(o, "uStepH"), {
								program: o,
								attributeLocations: a,
								uniformLocations: s
							}
						},
						getAttributeLocations: function(t, e) {
							return {
								aPosition: t.getAttribLocation(e, "aPosition")
							}
						},
						getUniformLocations: function() {
							return {}
						},
						sendAttributeData: function(t, e, n) {
							var r = e.aPosition,
								i = t.createBuffer();
							t.bindBuffer(t.ARRAY_BUFFER, i), t.enableVertexAttribArray(r), t.vertexAttribPointer(r, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW)
						},
						_setupFrameBuffer: function(t) {
							var e, n, r = t.context;
							t.passes > 1 ? (e = t.destinationWidth, n = t.destinationHeight, t.sourceWidth === e && t.sourceHeight === n || (r.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(r, e, n)), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t.targetTexture, 0)) : (r.bindFramebuffer(r.FRAMEBUFFER, null), r.finish())
						},
						_swapTextures: function(t) {
							t.passes--, t.pass++;
							var e = t.targetTexture;
							t.targetTexture = t.sourceTexture, t.sourceTexture = e
						},
						isNeutralState: function() {
							var t = this.mainParameter,
								e = b.Image.filters[this.type].prototype;
							if (t) {
								if (Array.isArray(e[t])) {
									for (var n = e[t].length; n--;)
										if (this[t][n] !== e[t][n]) return !1;
									return !0
								}
								return e[t] === this[t]
							}
							return !1
						},
						applyTo: function(t) {
							t.webgl ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t)
						},
						retrieveShader: function(t) {
							return t.programCache.hasOwnProperty(this.type) || (t.programCache[this.type] = this.createProgram(t.context)), t.programCache[this.type]
						},
						applyToWebGL: function(t) {
							var e = t.context,
								n = this.retrieveShader(t);
							0 === t.pass && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(n.program), this.sendAttributeData(e, n.attributeLocations, t.aPosition), e.uniform1f(n.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(n.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, n.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4)
						},
						bindAdditionalTexture: function(t, e, n) {
							t.activeTexture(n), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0)
						},
						unbindAdditionalTexture: function(t, e) {
							t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0)
						},
						getMainParameter: function() {
							return this[this.mainParameter]
						},
						setMainParameter: function(t) {
							this[this.mainParameter] = t
						},
						sendUniformData: function() {},
						createHelpLayer: function(t) {
							if (!t.helpLayer) {
								var e = document.createElement("canvas");
								e.width = t.sourceWidth, e.height = t.sourceHeight, t.helpLayer = e
							}
						},
						toObject: function() {
							var t = {
									type: this.type
								},
								e = this.mainParameter;
							return e && (t[e] = this[e]), t
						},
						toJSON: function() {
							return this.toObject()
						}
					}), b.Image.filters.BaseFilter.fromObject = function(t, e) {
						var n = new b.Image.filters[t.type](t);
						return e && e(n), n
					},
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.ColorMatrix = r(n.BaseFilter, {
							type: "ColorMatrix",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}",
							matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
							mainParameter: "matrix",
							colorsOnly: !0,
							initialize: function(t) {
								this.callSuper("initialize", t), this.matrix = this.matrix.slice(0)
							},
							applyTo2d: function(t) {
								var e, n, r, i, o, a = t.imageData.data,
									s = a.length,
									l = this.matrix,
									c = this.colorsOnly;
								for (o = 0; o < s; o += 4) e = a[o], n = a[o + 1], r = a[o + 2], c ? (a[o] = e * l[0] + n * l[1] + r * l[2] + 255 * l[4], a[o + 1] = e * l[5] + n * l[6] + r * l[7] + 255 * l[9], a[o + 2] = e * l[10] + n * l[11] + r * l[12] + 255 * l[14]) : (i = a[o + 3], a[o] = e * l[0] + n * l[1] + r * l[2] + i * l[3] + 255 * l[4], a[o + 1] = e * l[5] + n * l[6] + r * l[7] + i * l[8] + 255 * l[9], a[o + 2] = e * l[10] + n * l[11] + r * l[12] + i * l[13] + 255 * l[14], a[o + 3] = e * l[15] + n * l[16] + r * l[17] + i * l[18] + 255 * l[19])
							},
							getUniformLocations: function(t, e) {
								return {
									uColorMatrix: t.getUniformLocation(e, "uColorMatrix"),
									uConstants: t.getUniformLocation(e, "uConstants")
								}
							},
							sendUniformData: function(t, e) {
								var n = this.matrix,
									r = [n[0], n[1], n[2], n[3], n[5], n[6], n[7], n[8], n[10], n[11], n[12], n[13], n[15], n[16], n[17], n[18]],
									i = [n[4], n[9], n[14], n[19]];
								t.uniformMatrix4fv(e.uColorMatrix, !1, r), t.uniform4fv(e.uConstants, i)
							}
						}), e.Image.filters.ColorMatrix.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Brightness = r(n.BaseFilter, {
							type: "Brightness",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}",
							brightness: 0,
							mainParameter: "brightness",
							applyTo2d: function(t) {
								if (0 !== this.brightness) {
									var e, n = t.imageData.data,
										r = n.length,
										i = Math.round(255 * this.brightness);
									for (e = 0; e < r; e += 4) n[e] = n[e] + i, n[e + 1] = n[e + 1] + i, n[e + 2] = n[e + 2] + i
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uBrightness: t.getUniformLocation(e, "uBrightness")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uBrightness, this.brightness)
							}
						}), e.Image.filters.Brightness.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.Image.filters,
							i = e.util.createClass;
						r.Convolute = i(r.BaseFilter, {
							type: "Convolute",
							opaque: !1,
							matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],
							fragmentSource: {
								Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
								Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
								Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
								Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
								Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
								Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
								Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
								Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}"
							},
							retrieveShader: function(t) {
								var e = Math.sqrt(this.matrix.length),
									n = this.type + "_" + e + "_" + (this.opaque ? 1 : 0),
									r = this.fragmentSource[n];
								return t.programCache.hasOwnProperty(n) || (t.programCache[n] = this.createProgram(t.context, r)), t.programCache[n]
							},
							applyTo2d: function(t) {
								var e, n, r, i, o, a, s, l, c, u, h, f, d, p = t.imageData,
									g = p.data,
									v = this.matrix,
									m = Math.round(Math.sqrt(v.length)),
									y = Math.floor(m / 2),
									b = p.width,
									x = p.height,
									w = t.ctx.createImageData(b, x),
									C = w.data,
									S = this.opaque ? 1 : 0;
								for (h = 0; h < x; h++)
									for (u = 0; u < b; u++) {
										for (o = 4 * (h * b + u), e = 0, n = 0, r = 0, i = 0, d = 0; d < m; d++)
											for (f = 0; f < m; f++) a = u + f - y, (s = h + d - y) < 0 || s >= x || a < 0 || a >= b || (l = 4 * (s * b + a), c = v[d * m + f], e += g[l] * c, n += g[l + 1] * c, r += g[l + 2] * c, S || (i += g[l + 3] * c));
										C[o] = e, C[o + 1] = n, C[o + 2] = r, C[o + 3] = S ? g[o + 3] : i
									}
								t.imageData = w
							},
							getUniformLocations: function(t, e) {
								return {
									uMatrix: t.getUniformLocation(e, "uMatrix"),
									uOpaque: t.getUniformLocation(e, "uOpaque"),
									uHalfSize: t.getUniformLocation(e, "uHalfSize"),
									uSize: t.getUniformLocation(e, "uSize")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1fv(e.uMatrix, this.matrix)
							},
							toObject: function() {
								return n(this.callSuper("toObject"), {
									opaque: this.opaque,
									matrix: this.matrix
								})
							}
						}), e.Image.filters.Convolute.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Grayscale = r(n.BaseFilter, {
							type: "Grayscale",
							fragmentSource: {
								average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}",
								lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}",
								luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}"
							},
							mode: "average",
							mainParameter: "mode",
							applyTo2d: function(t) {
								var e, n, r = t.imageData.data,
									i = r.length,
									o = this.mode;
								for (e = 0; e < i; e += 4) "average" === o ? n = (r[e] + r[e + 1] + r[e + 2]) / 3 : "lightness" === o ? n = (Math.min(r[e], r[e + 1], r[e + 2]) + Math.max(r[e], r[e + 1], r[e + 2])) / 2 : "luminosity" === o && (n = .21 * r[e] + .72 * r[e + 1] + .07 * r[e + 2]), r[e] = n, r[e + 1] = n, r[e + 2] = n
							},
							retrieveShader: function(t) {
								var e = this.type + "_" + this.mode;
								if (!t.programCache.hasOwnProperty(e)) {
									var n = this.fragmentSource[this.mode];
									t.programCache[e] = this.createProgram(t.context, n)
								}
								return t.programCache[e]
							},
							getUniformLocations: function(t, e) {
								return {
									uMode: t.getUniformLocation(e, "uMode")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1i(e.uMode, 1)
							},
							isNeutralState: function() {
								return !1
							}
						}), e.Image.filters.Grayscale.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Invert = r(n.BaseFilter, {
							type: "Invert",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}",
							invert: !0,
							mainParameter: "invert",
							applyTo2d: function(t) {
								var e, n = t.imageData.data,
									r = n.length;
								for (e = 0; e < r; e += 4) n[e] = 255 - n[e], n[e + 1] = 255 - n[e + 1], n[e + 2] = 255 - n[e + 2]
							},
							isNeutralState: function() {
								return !this.invert
							},
							getUniformLocations: function(t, e) {
								return {
									uInvert: t.getUniformLocation(e, "uInvert")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1i(e.uInvert, this.invert)
							}
						}), e.Image.filters.Invert.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.Image.filters,
							i = e.util.createClass;
						r.Noise = i(r.BaseFilter, {
							type: "Noise",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}",
							mainParameter: "noise",
							noise: 0,
							applyTo2d: function(t) {
								if (0 !== this.noise) {
									var e, n, r = t.imageData.data,
										i = r.length,
										o = this.noise;
									for (e = 0, i = r.length; e < i; e += 4) n = (.5 - Math.random()) * o, r[e] += n, r[e + 1] += n, r[e + 2] += n
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uNoise: t.getUniformLocation(e, "uNoise"),
									uSeed: t.getUniformLocation(e, "uSeed")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random())
							},
							toObject: function() {
								return n(this.callSuper("toObject"), {
									noise: this.noise
								})
							}
						}), e.Image.filters.Noise.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Pixelate = r(n.BaseFilter, {
							type: "Pixelate",
							blocksize: 4,
							mainParameter: "blocksize",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}",
							applyTo2d: function(t) {
								var e, n, r, i, o, a, s, l, c, u, h, f = t.imageData,
									d = f.data,
									p = f.height,
									g = f.width;
								for (n = 0; n < p; n += this.blocksize)
									for (r = 0; r < g; r += this.blocksize)
										for (i = d[e = 4 * n * g + 4 * r], o = d[e + 1], a = d[e + 2], s = d[e + 3], u = Math.min(n + this.blocksize, p), h = Math.min(r + this.blocksize, g), l = n; l < u; l++)
											for (c = r; c < h; c++) d[e = 4 * l * g + 4 * c] = i, d[e + 1] = o, d[e + 2] = a, d[e + 3] = s
							},
							isNeutralState: function() {
								return 1 === this.blocksize
							},
							getUniformLocations: function(t, e) {
								return {
									uBlocksize: t.getUniformLocation(e, "uBlocksize"),
									uStepW: t.getUniformLocation(e, "uStepW"),
									uStepH: t.getUniformLocation(e, "uStepH")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uBlocksize, this.blocksize)
							}
						}), e.Image.filters.Pixelate.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.extend,
							r = e.Image.filters,
							i = e.util.createClass;
						r.RemoveColor = i(r.BaseFilter, {
							type: "RemoveColor",
							color: "#FFFFFF",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}",
							distance: .02,
							useAlpha: !1,
							applyTo2d: function(t) {
								var n, r, i, o, a = t.imageData.data,
									s = 255 * this.distance,
									l = new e.Color(this.color).getSource(),
									c = [l[0] - s, l[1] - s, l[2] - s],
									u = [l[0] + s, l[1] + s, l[2] + s];
								for (n = 0; n < a.length; n += 4) r = a[n], i = a[n + 1], o = a[n + 2], r > c[0] && i > c[1] && o > c[2] && r < u[0] && i < u[1] && o < u[2] && (a[n + 3] = 0)
							},
							getUniformLocations: function(t, e) {
								return {
									uLow: t.getUniformLocation(e, "uLow"),
									uHigh: t.getUniformLocation(e, "uHigh")
								}
							},
							sendUniformData: function(t, n) {
								var r = new e.Color(this.color).getSource(),
									i = parseFloat(this.distance),
									o = [0 + r[0] / 255 - i, 0 + r[1] / 255 - i, 0 + r[2] / 255 - i, 1],
									a = [r[0] / 255 + i, r[1] / 255 + i, r[2] / 255 + i, 1];
								t.uniform4fv(n.uLow, o), t.uniform4fv(n.uHigh, a)
							},
							toObject: function() {
								return n(this.callSuper("toObject"), {
									color: this.color,
									distance: this.distance
								})
							}
						}), e.Image.filters.RemoveColor.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass,
							i = {
								Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0],
								Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0],
								Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0],
								Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0],
								Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0],
								Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0],
								BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]
							};
						for (var o in i) n[o] = r(n.ColorMatrix, {
							type: o,
							matrix: i[o],
							mainParameter: !1,
							colorsOnly: !0
						}), e.Image.filters[o].fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric,
							n = e.Image.filters,
							r = e.util.createClass;
						n.BlendColor = r(n.BaseFilter, {
							type: "BlendColor",
							color: "#F95C63",
							mode: "multiply",
							alpha: 1,
							fragmentSource: {
								multiply: "gl_FragColor.rgb *= uColor.rgb;\n",
								screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",
								add: "gl_FragColor.rgb += uColor.rgb;\n",
								diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",
								subtract: "gl_FragColor.rgb -= uColor.rgb;\n",
								lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",
								darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",
								exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",
								overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n",
								tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n"
							},
							buildSource: function(t) {
								return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[t] + "}\n}"
							},
							retrieveShader: function(t) {
								var e, n = this.type + "_" + this.mode;
								return t.programCache.hasOwnProperty(n) || (e = this.buildSource(this.mode), t.programCache[n] = this.createProgram(t.context, e)), t.programCache[n]
							},
							applyTo2d: function(t) {
								var n, r, i, o, a, s, l, c = t.imageData.data,
									u = c.length,
									h = 1 - this.alpha;
								n = (l = new e.Color(this.color).getSource())[0] * this.alpha, r = l[1] * this.alpha, i = l[2] * this.alpha;
								for (var f = 0; f < u; f += 4) switch (o = c[f], a = c[f + 1], s = c[f + 2], this.mode) {
									case "multiply":
										c[f] = o * n / 255, c[f + 1] = a * r / 255, c[f + 2] = s * i / 255;
										break;
									case "screen":
										c[f] = 255 - (255 - o) * (255 - n) / 255, c[f + 1] = 255 - (255 - a) * (255 - r) / 255, c[f + 2] = 255 - (255 - s) * (255 - i) / 255;
										break;
									case "add":
										c[f] = o + n, c[f + 1] = a + r, c[f + 2] = s + i;
										break;
									case "diff":
									case "difference":
										c[f] = Math.abs(o - n), c[f + 1] = Math.abs(a - r), c[f + 2] = Math.abs(s - i);
										break;
									case "subtract":
										c[f] = o - n, c[f + 1] = a - r, c[f + 2] = s - i;
										break;
									case "darken":
										c[f] = Math.min(o, n), c[f + 1] = Math.min(a, r), c[f + 2] = Math.min(s, i);
										break;
									case "lighten":
										c[f] = Math.max(o, n), c[f + 1] = Math.max(a, r), c[f + 2] = Math.max(s, i);
										break;
									case "overlay":
										c[f] = n < 128 ? 2 * o * n / 255 : 255 - 2 * (255 - o) * (255 - n) / 255, c[f + 1] = r < 128 ? 2 * a * r / 255 : 255 - 2 * (255 - a) * (255 - r) / 255, c[f + 2] = i < 128 ? 2 * s * i / 255 : 255 - 2 * (255 - s) * (255 - i) / 255;
										break;
									case "exclusion":
										c[f] = n + o - 2 * n * o / 255, c[f + 1] = r + a - 2 * r * a / 255, c[f + 2] = i + s - 2 * i * s / 255;
										break;
									case "tint":
										c[f] = n + o * h, c[f + 1] = r + a * h, c[f + 2] = i + s * h
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uColor: t.getUniformLocation(e, "uColor")
								}
							},
							sendUniformData: function(t, n) {
								var r = new e.Color(this.color).getSource();
								r[0] = this.alpha * r[0] / 255, r[1] = this.alpha * r[1] / 255, r[2] = this.alpha * r[2] / 255, r[3] = this.alpha, t.uniform4fv(n.uColor, r)
							},
							toObject: function() {
								return {
									type: this.type,
									color: this.color,
									mode: this.mode,
									alpha: this.alpha
								}
							}
						}), e.Image.filters.BlendColor.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric,
							n = e.Image.filters,
							r = e.util.createClass;
						n.BlendImage = r(n.BaseFilter, {
							type: "BlendImage",
							image: null,
							mode: "multiply",
							alpha: 1,
							vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
							fragmentSource: {
								multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}",
								mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}"
							},
							retrieveShader: function(t) {
								var e = this.type + "_" + this.mode,
									n = this.fragmentSource[this.mode];
								return t.programCache.hasOwnProperty(e) || (t.programCache[e] = this.createProgram(t.context, n)), t.programCache[e]
							},
							applyToWebGL: function(t) {
								var e = t.context,
									n = this.createTexture(t.filterBackend, this.image);
								this.bindAdditionalTexture(e, n, e.TEXTURE1), this.callSuper("applyToWebGL", t), this.unbindAdditionalTexture(e, e.TEXTURE1)
							},
							createTexture: function(t, e) {
								return t.getCachedTexture(e.cacheKey, e._element)
							},
							calculateMatrix: function() {
								var t = this.image,
									e = t._element.width,
									n = t._element.height;
								return [1 / t.scaleX, 0, 0, 0, 1 / t.scaleY, 0, -t.left / e, -t.top / n, 1]
							},
							applyTo2d: function(t) {
								var n, r, i, o, a, s, l, c, u, h, f, d = t.imageData,
									p = t.filterBackend.resources,
									g = d.data,
									v = g.length,
									m = d.width,
									y = d.height,
									b = this.image;
								p.blendImage || (p.blendImage = e.util.createCanvasElement()), h = (u = p.blendImage).getContext("2d"), u.width !== m || u.height !== y ? (u.width = m, u.height = y) : h.clearRect(0, 0, m, y), h.setTransform(b.scaleX, 0, 0, b.scaleY, b.left, b.top), h.drawImage(b._element, 0, 0, m, y), f = h.getImageData(0, 0, m, y).data;
								for (var x = 0; x < v; x += 4) switch (a = g[x], s = g[x + 1], l = g[x + 2], c = g[x + 3], n = f[x], r = f[x + 1], i = f[x + 2], o = f[x + 3], this.mode) {
									case "multiply":
										g[x] = a * n / 255, g[x + 1] = s * r / 255, g[x + 2] = l * i / 255, g[x + 3] = c * o / 255;
										break;
									case "mask":
										g[x + 3] = o
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uTransformMatrix: t.getUniformLocation(e, "uTransformMatrix"),
									uImage: t.getUniformLocation(e, "uImage")
								}
							},
							sendUniformData: function(t, e) {
								var n = this.calculateMatrix();
								t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, n)
							},
							toObject: function() {
								return {
									type: this.type,
									image: this.image && this.image.toObject(),
									mode: this.mode,
									alpha: this.alpha
								}
							}
						}), e.Image.filters.BlendImage.fromObject = function(t, n) {
							e.Image.fromObject(t.image, (function(r) {
								var i = e.util.object.clone(t);
								i.image = r, n(new e.Image.filters.BlendImage(i))
							}))
						}
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = Math.pow,
							r = Math.floor,
							i = Math.sqrt,
							o = Math.abs,
							a = Math.round,
							s = Math.sin,
							l = Math.ceil,
							c = e.Image.filters,
							u = e.util.createClass;
						c.Resize = u(c.BaseFilter, {
							type: "Resize",
							resizeType: "hermite",
							scaleX: 1,
							scaleY: 1,
							lanczosLobes: 3,
							getUniformLocations: function(t, e) {
								return {
									uDelta: t.getUniformLocation(e, "uDelta"),
									uTaps: t.getUniformLocation(e, "uTaps")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform2fv(e.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t.uniform1fv(e.uTaps, this.taps)
							},
							retrieveShader: function(t) {
								var e = this.getFilterWindow(),
									n = this.type + "_" + e;
								if (!t.programCache.hasOwnProperty(n)) {
									var r = this.generateShader(e);
									t.programCache[n] = this.createProgram(t.context, r)
								}
								return t.programCache[n]
							},
							getFilterWindow: function() {
								var t = this.tempScale;
								return Math.ceil(this.lanczosLobes / t)
							},
							getTaps: function() {
								for (var t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, n = this.getFilterWindow(), r = new Array(n), i = 1; i <= n; i++) r[i - 1] = t(i * e);
								return r
							},
							generateShader: function(t) {
								for (var e = new Array(t), n = this.fragmentSourceTOP, r = 1; r <= t; r++) e[r - 1] = r + ".0 * uDelta";
								return n += "uniform float uTaps[" + t + "];\n", n += "void main() {\n", n += "  vec4 color = texture2D(uTexture, vTexCoord);\n", n += "  float sum = 1.0;\n", e.forEach((function(t, e) {
									n += "  color += texture2D(uTexture, vTexCoord + " + t + ") * uTaps[" + e + "];\n", n += "  color += texture2D(uTexture, vTexCoord - " + t + ") * uTaps[" + e + "];\n", n += "  sum += 2.0 * uTaps[" + e + "];\n"
								})), n += "  gl_FragColor = color / sum;\n", n += "}"
							},
							fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n",
							applyTo: function(t) {
								t.webgl ? (t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceHeight = t.destinationHeight) : this.applyTo2d(t)
							},
							isNeutralState: function() {
								return 1 === this.scaleX && 1 === this.scaleY
							},
							lanczosCreate: function(t) {
								return function(e) {
									if (e >= t || e <= -t) return 0;
									if (e < 1.1920929e-7 && e > -1.1920929e-7) return 1;
									var n = (e *= Math.PI) / t;
									return s(e) / e * s(n) / n
								}
							},
							applyTo2d: function(t) {
								var e = t.imageData,
									n = this.scaleX,
									r = this.scaleY;
								this.rcpScaleX = 1 / n, this.rcpScaleY = 1 / r;
								var i, o = e.width,
									s = e.height,
									l = a(o * n),
									c = a(s * r);
								"sliceHack" === this.resizeType ? i = this.sliceByTwo(t, o, s, l, c) : "hermite" === this.resizeType ? i = this.hermiteFastResize(t, o, s, l, c) : "bilinear" === this.resizeType ? i = this.bilinearFiltering(t, o, s, l, c) : "lanczos" === this.resizeType && (i = this.lanczosResize(t, o, s, l, c)), t.imageData = i
							},
							sliceByTwo: function(t, n, i, o, a) {
								var s, l, c = t.imageData,
									u = .5,
									h = !1,
									f = !1,
									d = n * u,
									p = i * u,
									g = e.filterBackend.resources,
									v = 0,
									m = 0,
									y = n,
									b = 0;
								for (g.sliceByTwo || (g.sliceByTwo = document.createElement("canvas")), ((s = g.sliceByTwo).width < 1.5 * n || s.height < i) && (s.width = 1.5 * n, s.height = i), (l = s.getContext("2d")).clearRect(0, 0, 1.5 * n, i), l.putImageData(c, 0, 0), o = r(o), a = r(a); !h || !f;) n = d, i = p, o < r(d * u) ? d = r(d * u) : (d = o, h = !0), a < r(p * u) ? p = r(p * u) : (p = a, f = !0), l.drawImage(s, v, m, n, i, y, b, d, p), v = y, m = b, b += p;
								return l.getImageData(v, m, o, a)
							},
							lanczosResize: function(t, e, a, s, c) {
								var u = t.imageData.data,
									h = t.ctx.createImageData(s, c),
									f = h.data,
									d = this.lanczosCreate(this.lanczosLobes),
									p = this.rcpScaleX,
									g = this.rcpScaleY,
									v = 2 / this.rcpScaleX,
									m = 2 / this.rcpScaleY,
									y = l(p * this.lanczosLobes / 2),
									b = l(g * this.lanczosLobes / 2),
									x = {},
									w = {},
									C = {};
								return function t(l) {
									var S, O, T, k, F, P, j, A, _, E, D;
									for (w.x = (l + .5) * p, C.x = r(w.x), S = 0; S < c; S++) {
										for (w.y = (S + .5) * g, C.y = r(w.y), F = 0, P = 0, j = 0, A = 0, _ = 0, O = C.x - y; O <= C.x + y; O++)
											if (!(O < 0 || O >= e)) {
												E = r(1e3 * o(O - w.x)), x[E] || (x[E] = {});
												for (var M = C.y - b; M <= C.y + b; M++) M < 0 || M >= a || (D = r(1e3 * o(M - w.y)), x[E][D] || (x[E][D] = d(i(n(E * v, 2) + n(D * m, 2)) / 1e3)), (T = x[E][D]) > 0 && (F += T, P += T * u[k = 4 * (M * e + O)], j += T * u[k + 1], A += T * u[k + 2], _ += T * u[k + 3]))
											} f[k = 4 * (S * s + l)] = P / F, f[k + 1] = j / F, f[k + 2] = A / F, f[k + 3] = _ / F
									}
									return ++l < s ? t(l) : h
								}(0)
							},
							bilinearFiltering: function(t, e, n, i, o) {
								var a, s, l, c, u, h, f, d, p, g = 0,
									v = this.rcpScaleX,
									m = this.rcpScaleY,
									y = 4 * (e - 1),
									b = t.imageData.data,
									x = t.ctx.createImageData(i, o),
									w = x.data;
								for (l = 0; l < o; l++)
									for (c = 0; c < i; c++)
										for (u = v * c - (a = r(v * c)), h = m * l - (s = r(m * l)), p = 4 * (s * e + a), f = 0; f < 4; f++) d = b[p + f] * (1 - u) * (1 - h) + b[p + 4 + f] * u * (1 - h) + b[p + y + f] * h * (1 - u) + b[p + y + 4 + f] * u * h, w[g++] = d;
								return x
							},
							hermiteFastResize: function(t, e, n, a, s) {
								for (var c = this.rcpScaleX, u = this.rcpScaleY, h = l(c / 2), f = l(u / 2), d = t.imageData.data, p = t.ctx.createImageData(a, s), g = p.data, v = 0; v < s; v++)
									for (var m = 0; m < a; m++) {
										for (var y = 4 * (m + v * a), b = 0, x = 0, w = 0, C = 0, S = 0, O = 0, T = 0, k = (v + .5) * u, F = r(v * u); F < (v + 1) * u; F++)
											for (var P = o(k - (F + .5)) / f, j = (m + .5) * c, A = P * P, _ = r(m * c); _ < (m + 1) * c; _++) {
												var E = o(j - (_ + .5)) / h,
													D = i(A + E * E);
												D > 1 && D < -1 || (b = 2 * D * D * D - 3 * D * D + 1) > 0 && (T += b * d[3 + (E = 4 * (_ + F * e))], w += b, d[E + 3] < 255 && (b = b * d[E + 3] / 250), C += b * d[E], S += b * d[E + 1], O += b * d[E + 2], x += b)
											}
										g[y] = C / x, g[y + 1] = S / x, g[y + 2] = O / x, g[y + 3] = T / w
									}
								return p
							},
							toObject: function() {
								return {
									type: this.type,
									scaleX: this.scaleX,
									scaleY: this.scaleY,
									resizeType: this.resizeType,
									lanczosLobes: this.lanczosLobes
								}
							}
						}), e.Image.filters.Resize.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Contrast = r(n.BaseFilter, {
							type: "Contrast",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}",
							contrast: 0,
							mainParameter: "contrast",
							applyTo2d: function(t) {
								if (0 !== this.contrast) {
									var e, n = t.imageData.data,
										r = n.length,
										i = Math.floor(255 * this.contrast),
										o = 259 * (i + 255) / (255 * (259 - i));
									for (e = 0; e < r; e += 4) n[e] = o * (n[e] - 128) + 128, n[e + 1] = o * (n[e + 1] - 128) + 128, n[e + 2] = o * (n[e + 2] - 128) + 128
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uContrast: t.getUniformLocation(e, "uContrast")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uContrast, this.contrast)
							}
						}), e.Image.filters.Contrast.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Saturation = r(n.BaseFilter, {
							type: "Saturation",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}",
							saturation: 0,
							mainParameter: "saturation",
							applyTo2d: function(t) {
								if (0 !== this.saturation) {
									var e, n, r = t.imageData.data,
										i = r.length,
										o = -this.saturation;
									for (e = 0; e < i; e += 4) n = Math.max(r[e], r[e + 1], r[e + 2]), r[e] += n !== r[e] ? (n - r[e]) * o : 0, r[e + 1] += n !== r[e + 1] ? (n - r[e + 1]) * o : 0, r[e + 2] += n !== r[e + 2] ? (n - r[e + 2]) * o : 0
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uSaturation: t.getUniformLocation(e, "uSaturation")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uSaturation, -this.saturation)
							}
						}), e.Image.filters.Saturation.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Vibrance = r(n.BaseFilter, {
							type: "Vibrance",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uVibrance;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat max = max(color.r, max(color.g, color.b));\nfloat avg = (color.r + color.g + color.b) / 3.0;\nfloat amt = (abs(max - avg) * 2.0) * uVibrance;\ncolor.r += max != color.r ? (max - color.r) * amt : 0.00;\ncolor.g += max != color.g ? (max - color.g) * amt : 0.00;\ncolor.b += max != color.b ? (max - color.b) * amt : 0.00;\ngl_FragColor = color;\n}",
							vibrance: 0,
							mainParameter: "vibrance",
							applyTo2d: function(t) {
								if (0 !== this.vibrance) {
									var e, n, r, i, o = t.imageData.data,
										a = o.length,
										s = -this.vibrance;
									for (e = 0; e < a; e += 4) n = Math.max(o[e], o[e + 1], o[e + 2]), r = (o[e] + o[e + 1] + o[e + 2]) / 3, i = 2 * Math.abs(n - r) / 255 * s, o[e] += n !== o[e] ? (n - o[e]) * i : 0, o[e + 1] += n !== o[e + 1] ? (n - o[e + 1]) * i : 0, o[e + 2] += n !== o[e + 2] ? (n - o[e + 2]) * i : 0
								}
							},
							getUniformLocations: function(t, e) {
								return {
									uVibrance: t.getUniformLocation(e, "uVibrance")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform1f(e.uVibrance, -this.vibrance)
							}
						}), e.Image.filters.Vibrance.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Blur = r(n.BaseFilter, {
							type: "Blur",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}",
							blur: 0,
							mainParameter: "blur",
							applyTo: function(t) {
								t.webgl ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t)
							},
							applyTo2d: function(t) {
								t.imageData = this.simpleBlur(t)
							},
							simpleBlur: function(t) {
								var n, r, i = t.filterBackend.resources,
									o = t.imageData.width,
									a = t.imageData.height;
								i.blurLayer1 || (i.blurLayer1 = e.util.createCanvasElement(), i.blurLayer2 = e.util.createCanvasElement()), n = i.blurLayer1, r = i.blurLayer2, n.width === o && n.height === a || (r.width = n.width = o, r.height = n.height = a);
								var s, l, c, u, h = n.getContext("2d"),
									f = r.getContext("2d"),
									d = .06 * this.blur * .5;
								for (h.putImageData(t.imageData, 0, 0), f.clearRect(0, 0, o, a), u = -15; u <= 15; u++) c = d * (l = u / 15) * o + (s = (Math.random() - .5) / 4), f.globalAlpha = 1 - Math.abs(l), f.drawImage(n, c, s), h.drawImage(r, 0, 0), f.globalAlpha = 1, f.clearRect(0, 0, r.width, r.height);
								for (u = -15; u <= 15; u++) c = d * (l = u / 15) * a + (s = (Math.random() - .5) / 4), f.globalAlpha = 1 - Math.abs(l), f.drawImage(n, s, c), h.drawImage(r, 0, 0), f.globalAlpha = 1, f.clearRect(0, 0, r.width, r.height);
								t.ctx.drawImage(n, 0, 0);
								var p = t.ctx.getImageData(0, 0, n.width, n.height);
								return h.globalAlpha = 1, h.clearRect(0, 0, n.width, n.height), p
							},
							getUniformLocations: function(t, e) {
								return {
									delta: t.getUniformLocation(e, "uDelta")
								}
							},
							sendUniformData: function(t, e) {
								var n = this.chooseRightDelta();
								t.uniform2fv(e.delta, n)
							},
							chooseRightDelta: function() {
								var t, e = 1,
									n = [0, 0];
								return this.horizontal ? this.aspectRatio > 1 && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio), t = e * this.blur * .12, this.horizontal ? n[0] = t : n[1] = t, n
							}
						}), n.Blur.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Gamma = r(n.BaseFilter, {
							type: "Gamma",
							fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}",
							gamma: [1, 1, 1],
							mainParameter: "gamma",
							initialize: function(t) {
								this.gamma = [1, 1, 1], n.BaseFilter.prototype.initialize.call(this, t)
							},
							applyTo2d: function(t) {
								var e, n = t.imageData.data,
									r = this.gamma,
									i = n.length,
									o = 1 / r[0],
									a = 1 / r[1],
									s = 1 / r[2];
								for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), e = 0, i = 256; e < i; e++) this.rVals[e] = 255 * Math.pow(e / 255, o), this.gVals[e] = 255 * Math.pow(e / 255, a), this.bVals[e] = 255 * Math.pow(e / 255, s);
								for (e = 0, i = n.length; e < i; e += 4) n[e] = this.rVals[n[e]], n[e + 1] = this.gVals[n[e + 1]], n[e + 2] = this.bVals[n[e + 2]]
							},
							getUniformLocations: function(t, e) {
								return {
									uGamma: t.getUniformLocation(e, "uGamma")
								}
							},
							sendUniformData: function(t, e) {
								t.uniform3fv(e.uGamma, this.gamma)
							}
						}), e.Image.filters.Gamma.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.Composed = r(n.BaseFilter, {
							type: "Composed",
							subFilters: [],
							initialize: function(t) {
								this.callSuper("initialize", t), this.subFilters = this.subFilters.slice(0)
							},
							applyTo: function(t) {
								t.passes += this.subFilters.length - 1, this.subFilters.forEach((function(e) {
									e.applyTo(t)
								}))
							},
							toObject: function() {
								return e.util.object.extend(this.callSuper("toObject"), {
									subFilters: this.subFilters.map((function(t) {
										return t.toObject()
									}))
								})
							},
							isNeutralState: function() {
								return !this.subFilters.some((function(t) {
									return !t.isNeutralState()
								}))
							}
						}), e.Image.filters.Composed.fromObject = function(t, n) {
							var r = (t.subFilters || []).map((function(t) {
									return new e.Image.filters[t.type](t)
								})),
								i = new e.Image.filters.Composed({
									subFilters: r
								});
							return n && n(i), i
						}
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.Image.filters,
							r = e.util.createClass;
						n.HueRotation = r(n.ColorMatrix, {
							type: "HueRotation",
							rotation: 0,
							mainParameter: "rotation",
							calculateMatrix: function() {
								var t = this.rotation * Math.PI,
									n = e.util.cos(t),
									r = e.util.sin(t),
									i = 1 / 3,
									o = Math.sqrt(i) * r,
									a = 1 - n;
								this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = n + a / 3, this.matrix[1] = i * a - o, this.matrix[2] = i * a + o, this.matrix[5] = i * a + o, this.matrix[6] = n + i * a, this.matrix[7] = i * a - o, this.matrix[10] = i * a - o, this.matrix[11] = i * a + o, this.matrix[12] = n + i * a
							},
							isNeutralState: function(t) {
								return this.calculateMatrix(), n.BaseFilter.prototype.isNeutralState.call(this, t)
							},
							applyTo: function(t) {
								this.calculateMatrix(), n.BaseFilter.prototype.applyTo.call(this, t)
							}
						}), e.Image.filters.HueRotation.fromObject = e.Image.filters.BaseFilter.fromObject
					}(e),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {}),
							n = e.util.object.clone;
						if (e.Text) e.warn("fabric.Text is already defined");
						else {
							var r = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" ");
							e.Text = e.util.createClass(e.Object, {
								_dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"],
								_reNewline: /\r?\n/,
								_reSpacesAndTabs: /[ \t\r]/g,
								_reSpaceAndTab: /[ \t\r]/,
								_reWords: /\S+/g,
								type: "text",
								fontSize: 40,
								fontWeight: "normal",
								fontFamily: "Times New Roman",
								underline: !1,
								overline: !1,
								linethrough: !1,
								textAlign: "left",
								fontStyle: "normal",
								lineHeight: 1.16,
								superscript: {
									size: .6,
									baseline: -.35
								},
								subscript: {
									size: .6,
									baseline: .11
								},
								textBackgroundColor: "",
								stateProperties: e.Object.prototype.stateProperties.concat(r),
								cacheProperties: e.Object.prototype.cacheProperties.concat(r),
								stroke: null,
								shadow: null,
								path: null,
								pathStartOffset: 0,
								pathSide: "left",
								pathAlign: "baseline",
								_fontSizeFraction: .222,
								offsets: {
									underline: .1,
									linethrough: -.315,
									overline: -.88
								},
								_fontSizeMult: 1.13,
								charSpacing: 0,
								styles: null,
								_measuringContext: null,
								deltaY: 0,
								direction: "ltr",
								_styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"],
								__charBounds: [],
								CACHE_FONT_SIZE: 400,
								MIN_TEXT_WIDTH: 2,
								initialize: function(t, e) {
									this.styles = e && e.styles || {}, this.text = t, this.__skipDimension = !0, this.callSuper("initialize", e), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({
										propertySet: "_dimensionAffectingProps"
									})
								},
								setPathInfo: function() {
									var t = this.path;
									t && (t.segmentsInfo = e.util.getPathSegmentsInfo(t.path))
								},
								getMeasuringContext: function() {
									return e._measuringContext || (e._measuringContext = this.canvas && this.canvas.contextCache || e.util.createCanvasElement().getContext("2d")), e._measuringContext
								},
								_splitText: function() {
									var t = this._splitTextIntoLines(this.text);
									return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t
								},
								initDimensions: function() {
									this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.saveState({
										propertySet: "_dimensionAffectingProps"
									}))
								},
								enlargeSpaces: function() {
									for (var t, e, n, r, i, o, a, s = 0, l = this._textLines.length; s < l; s++)
										if (("justify" === this.textAlign || s !== l - 1 && !this.isEndOfWrapping(s)) && (r = 0, i = this._textLines[s], (e = this.getLineWidth(s)) < this.width && (a = this.textLines[s].match(this._reSpacesAndTabs)))) {
											n = a.length, t = (this.width - e) / n;
											for (var c = 0, u = i.length; c <= u; c++) o = this.__charBounds[s][c], this._reSpaceAndTab.test(i[c]) ? (o.width += t, o.kernedWidth += t, o.left += r, r += t) : o.left += r
										}
								},
								isEndOfWrapping: function(t) {
									return t === this._textLines.length - 1
								},
								missingNewlineOffset: function() {
									return 1
								},
								toString: function() {
									return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>'
								},
								_getCacheCanvasDimensions: function() {
									var t = this.callSuper("_getCacheCanvasDimensions"),
										e = this.fontSize;
									return t.width += e * t.zoomX, t.height += e * t.zoomY, t
								},
								_render: function(t) {
									var e = this.path;
									e && !e.isNotVisible() && e._render(t), this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, "underline"), this._renderText(t), this._renderTextDecoration(t, "overline"), this._renderTextDecoration(t, "linethrough")
								},
								_renderText: function(t) {
									"stroke" === this.paintFirst ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t))
								},
								_setTextStyles: function(t, e, n) {
									if (t.textBaseline = "alphabetical", this.path) switch (this.pathAlign) {
										case "center":
											t.textBaseline = "middle";
											break;
										case "ascender":
											t.textBaseline = "top";
											break;
										case "descender":
											t.textBaseline = "bottom"
									}
									t.font = this._getFontDeclaration(e, n)
								},
								calcTextWidth: function() {
									for (var t = this.getLineWidth(0), e = 1, n = this._textLines.length; e < n; e++) {
										var r = this.getLineWidth(e);
										r > t && (t = r)
									}
									return t
								},
								_renderTextLine: function(t, e, n, r, i, o) {
									this._renderChars(t, e, n, r, i, o)
								},
								_renderTextLinesBackground: function(t) {
									if (this.textBackgroundColor || this.styleHas("textBackgroundColor")) {
										for (var e, n, r, i, o, a, s, l = t.fillStyle, c = this._getLeftOffset(), u = this._getTopOffset(), h = 0, f = 0, d = this.path, p = 0, g = this._textLines.length; p < g; p++)
											if (e = this.getHeightOfLine(p), this.textBackgroundColor || this.styleHas("textBackgroundColor", p)) {
												r = this._textLines[p], n = this._getLineLeftOffset(p), f = 0, h = 0, i = this.getValueOfPropertyAt(p, 0, "textBackgroundColor");
												for (var v = 0, m = r.length; v < m; v++) o = this.__charBounds[p][v], a = this.getValueOfPropertyAt(p, v, "textBackgroundColor"), d ? (t.save(), t.translate(o.renderLeft, o.renderTop), t.rotate(o.angle), t.fillStyle = a, a && t.fillRect(-o.width / 2, -e / this.lineHeight * (1 - this._fontSizeFraction), o.width, e / this.lineHeight), t.restore()) : a !== i ? (s = c + n + h, "rtl" === this.direction && (s = this.width - s - f), t.fillStyle = i, i && t.fillRect(s, u, f, e / this.lineHeight), h = o.left, f = o.width, i = a) : f += o.kernedWidth;
												a && !d && (s = c + n + h, "rtl" === this.direction && (s = this.width - s - f), t.fillStyle = a, t.fillRect(s, u, f, e / this.lineHeight)), u += e
											} else u += e;
										t.fillStyle = l, this._removeShadow(t)
									}
								},
								getFontCache: function(t) {
									var n = t.fontFamily.toLowerCase();
									e.charWidthsCache[n] || (e.charWidthsCache[n] = {});
									var r = e.charWidthsCache[n],
										i = t.fontStyle.toLowerCase() + "_" + (t.fontWeight + "").toLowerCase();
									return r[i] || (r[i] = {}), r[i]
								},
								_measureChar: function(t, e, n, r) {
									var i, o, a, s, l = this.getFontCache(e),
										c = n + t,
										u = this._getFontDeclaration(e) === this._getFontDeclaration(r),
										h = e.fontSize / this.CACHE_FONT_SIZE;
									if (n && void 0 !== l[n] && (a = l[n]), void 0 !== l[t] && (s = i = l[t]), u && void 0 !== l[c] && (s = (o = l[c]) - a), void 0 === i || void 0 === a || void 0 === o) {
										var f = this.getMeasuringContext();
										this._setTextStyles(f, e, !0)
									}
									return void 0 === i && (s = i = f.measureText(t).width, l[t] = i), void 0 === a && u && n && (a = f.measureText(n).width, l[n] = a), u && void 0 === o && (o = f.measureText(c).width, l[c] = o, s = o - a), {
										width: i * h,
										kernedWidth: s * h
									}
								},
								getHeightOfChar: function(t, e) {
									return this.getValueOfPropertyAt(t, e, "fontSize")
								},
								measureLine: function(t) {
									var e = this._measureLine(t);
									return 0 !== this.charSpacing && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e
								},
								_measureLine: function(t) {
									var n, r, i, o, a, s, l = 0,
										c = this._textLines[t],
										u = new Array(c.length),
										h = 0,
										f = this.path,
										d = "right" === this.pathSide;
									for (this.__charBounds[t] = u, n = 0; n < c.length; n++) r = c[n], o = this._getGraphemeBox(r, t, n, i), u[n] = o, l += o.kernedWidth, i = r;
									if (u[n] = {
											left: o ? o.left + o.width : 0,
											width: 0,
											kernedWidth: 0,
											height: this.fontSize
										}, f) {
										switch (s = f.segmentsInfo[f.segmentsInfo.length - 1].length, (a = e.util.getPointOnPath(f.path, 0, f.segmentsInfo)).x += f.pathOffset.x, a.y += f.pathOffset.y, this.textAlign) {
											case "left":
												h = d ? s - l : 0;
												break;
											case "center":
												h = (s - l) / 2;
												break;
											case "right":
												h = d ? 0 : s - l
										}
										for (h += this.pathStartOffset * (d ? -1 : 1), n = d ? c.length - 1 : 0; d ? n >= 0 : n < c.length; d ? n-- : n++) o = u[n], h > s ? h %= s : h < 0 && (h += s), this._setGraphemeOnPath(h, o, a), h += o.kernedWidth
									}
									return {
										width: l,
										numOfSpaces: 0
									}
								},
								_setGraphemeOnPath: function(t, n, r) {
									var i = t + n.kernedWidth / 2,
										o = this.path,
										a = e.util.getPointOnPath(o.path, i, o.segmentsInfo);
									n.renderLeft = a.x - r.x, n.renderTop = a.y - r.y, n.angle = a.angle + ("right" === this.pathSide ? Math.PI : 0)
								},
								_getGraphemeBox: function(t, e, n, r, i) {
									var o, a = this.getCompleteStyleDeclaration(e, n),
										s = r ? this.getCompleteStyleDeclaration(e, n - 1) : {},
										l = this._measureChar(t, a, r, s),
										c = l.kernedWidth,
										u = l.width;
									0 !== this.charSpacing && (u += o = this._getWidthOfCharSpacing(), c += o);
									var h = {
										width: u,
										left: 0,
										height: a.fontSize,
										kernedWidth: c,
										deltaY: a.deltaY
									};
									if (n > 0 && !i) {
										var f = this.__charBounds[e][n - 1];
										h.left = f.left + f.width + l.kernedWidth - l.width
									}
									return h
								},
								getHeightOfLine: function(t) {
									if (this.__lineHeights[t]) return this.__lineHeights[t];
									for (var e = this._textLines[t], n = this.getHeightOfChar(t, 0), r = 1, i = e.length; r < i; r++) n = Math.max(this.getHeightOfChar(t, r), n);
									return this.__lineHeights[t] = n * this.lineHeight * this._fontSizeMult
								},
								calcTextHeight: function() {
									for (var t, e = 0, n = 0, r = this._textLines.length; n < r; n++) t = this.getHeightOfLine(n), e += n === r - 1 ? t / this.lineHeight : t;
									return e
								},
								_getLeftOffset: function() {
									return "ltr" === this.direction ? -this.width / 2 : this.width / 2
								},
								_getTopOffset: function() {
									return -this.height / 2
								},
								_renderTextCommon: function(t, e) {
									t.save();
									for (var n = 0, r = this._getLeftOffset(), i = this._getTopOffset(), o = 0, a = this._textLines.length; o < a; o++) {
										var s = this.getHeightOfLine(o),
											l = s / this.lineHeight,
											c = this._getLineLeftOffset(o);
										this._renderTextLine(e, t, this._textLines[o], r + c, i + n + l, o), n += s
									}
									t.restore()
								},
								_renderTextFill: function(t) {
									(this.fill || this.styleHas("fill")) && this._renderTextCommon(t, "fillText")
								},
								_renderTextStroke: function(t) {
									(this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, "strokeText"), t.closePath(), t.restore())
								},
								_renderChars: function(t, n, r, i, o, a) {
									var s, l, c, u, h, f = this.getHeightOfLine(a),
										d = -1 !== this.textAlign.indexOf("justify"),
										p = "",
										g = 0,
										v = this.path,
										m = !d && 0 === this.charSpacing && this.isEmptyStyles(a) && !v,
										y = "ltr" === this.direction,
										b = "ltr" === this.direction ? 1 : -1,
										x = n.canvas.getAttribute("dir");
									if (n.save(), x !== this.direction && (n.canvas.setAttribute("dir", y ? "ltr" : "rtl"), n.direction = y ? "ltr" : "rtl", n.textAlign = y ? "left" : "right"), o -= f * this._fontSizeFraction / this.lineHeight, m) return this._renderChar(t, n, a, 0, r.join(""), i, o, f), void n.restore();
									for (var w = 0, C = r.length - 1; w <= C; w++) u = w === C || this.charSpacing || v, p += r[w], c = this.__charBounds[a][w], 0 === g ? (i += b * (c.kernedWidth - c.width), g += c.width) : g += c.kernedWidth, d && !u && this._reSpaceAndTab.test(r[w]) && (u = !0), u || (s = s || this.getCompleteStyleDeclaration(a, w), l = this.getCompleteStyleDeclaration(a, w + 1), u = e.util.hasStyleChanged(s, l, !1)), u && (v ? (n.save(), n.translate(c.renderLeft, c.renderTop), n.rotate(c.angle), this._renderChar(t, n, a, w, p, -g / 2, 0, f), n.restore()) : (h = i, this._renderChar(t, n, a, w, p, h, o, f)), p = "", s = l, i += b * g, g = 0);
									n.restore()
								},
								_applyPatternGradientTransformText: function(t) {
									var n, r = e.util.createCanvasElement(),
										i = this.width + this.strokeWidth,
										o = this.height + this.strokeWidth;
									return r.width = i, r.height = o, (n = r.getContext("2d")).beginPath(), n.moveTo(0, 0), n.lineTo(i, 0), n.lineTo(i, o), n.lineTo(0, o), n.closePath(), n.translate(i / 2, o / 2), n.fillStyle = t.toLive(n), this._applyPatternGradientTransform(n, t), n.fill(), n.createPattern(r, "no-repeat")
								},
								handleFiller: function(t, e, n) {
									var r, i;
									return n.toLive ? "percentage" === n.gradientUnits || n.gradientTransform || n.patternTransform ? (r = -this.width / 2, i = -this.height / 2, t.translate(r, i), t[e] = this._applyPatternGradientTransformText(n), {
										offsetX: r,
										offsetY: i
									}) : (t[e] = n.toLive(t, this), this._applyPatternGradientTransform(t, n)) : (t[e] = n, {
										offsetX: 0,
										offsetY: 0
									})
								},
								_setStrokeStyles: function(t, e) {
									return t.lineWidth = e.strokeWidth, t.lineCap = this.strokeLineCap, t.lineDashOffset = this.strokeDashOffset, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, this.handleFiller(t, "strokeStyle", e.stroke)
								},
								_setFillStyles: function(t, e) {
									return this.handleFiller(t, "fillStyle", e.fill)
								},
								_renderChar: function(t, e, n, r, i, o, a) {
									var s, l, c = this._getStyleDeclaration(n, r),
										u = this.getCompleteStyleDeclaration(n, r),
										h = "fillText" === t && u.fill,
										f = "strokeText" === t && u.stroke && u.strokeWidth;
									(f || h) && (e.save(), h && (s = this._setFillStyles(e, u)), f && (l = this._setStrokeStyles(e, u)), e.font = this._getFontDeclaration(u), c && c.textBackgroundColor && this._removeShadow(e), c && c.deltaY && (a += c.deltaY), h && e.fillText(i, o - s.offsetX, a - s.offsetY), f && e.strokeText(i, o - l.offsetX, a - l.offsetY), e.restore())
								},
								setSuperscript: function(t, e) {
									return this._setScript(t, e, this.superscript)
								},
								setSubscript: function(t, e) {
									return this._setScript(t, e, this.subscript)
								},
								_setScript: function(t, e, n) {
									var r = this.get2DCursorLocation(t, !0),
										i = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "fontSize"),
										o = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "deltaY"),
										a = {
											fontSize: i * n.size,
											deltaY: o + i * n.baseline
										};
									return this.setSelectionStyles(a, t, e), this
								},
								_getLineLeftOffset: function(t) {
									var e = this.getLineWidth(t),
										n = this.width - e,
										r = this.textAlign,
										i = this.direction,
										o = 0,
										a = this.isEndOfWrapping(t);
									return "justify" === r || "justify-center" === r && !a || "justify-right" === r && !a || "justify-left" === r && !a ? 0 : ("center" === r && (o = n / 2), "right" === r && (o = n), "justify-center" === r && (o = n / 2), "justify-right" === r && (o = n), "rtl" === i && (o -= n), o)
								},
								_clearCache: function() {
									this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = []
								},
								_shouldClearDimensionCache: function() {
									var t = this._forceClearCache;
									return t || (t = this.hasStateChanged("_dimensionAffectingProps")), t && (this.dirty = !0, this._forceClearCache = !1), t
								},
								getLineWidth: function(t) {
									if (void 0 !== this.__lineWidths[t]) return this.__lineWidths[t];
									var e = this.measureLine(t).width;
									return this.__lineWidths[t] = e, e
								},
								_getWidthOfCharSpacing: function() {
									return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0
								},
								getValueOfPropertyAt: function(t, e, n) {
									var r = this._getStyleDeclaration(t, e);
									return r && void 0 !== r[n] ? r[n] : this[n]
								},
								_renderTextDecoration: function(t, e) {
									if (this[e] || this.styleHas(e)) {
										for (var n, r, i, o, a, s, l, c, u, h, f, d, p, g, v, m, y = this._getLeftOffset(), b = this._getTopOffset(), x = this.path, w = this._getWidthOfCharSpacing(), C = this.offsets[e], S = 0, O = this._textLines.length; S < O; S++)
											if (n = this.getHeightOfLine(S), this[e] || this.styleHas(e, S)) {
												l = this._textLines[S], g = n / this.lineHeight, o = this._getLineLeftOffset(S), h = 0, f = 0, c = this.getValueOfPropertyAt(S, 0, e), m = this.getValueOfPropertyAt(S, 0, "fill"), u = b + g * (1 - this._fontSizeFraction), r = this.getHeightOfChar(S, 0), a = this.getValueOfPropertyAt(S, 0, "deltaY");
												for (var T = 0, k = l.length; T < k; T++)
													if (d = this.__charBounds[S][T], p = this.getValueOfPropertyAt(S, T, e), v = this.getValueOfPropertyAt(S, T, "fill"), i = this.getHeightOfChar(S, T), s = this.getValueOfPropertyAt(S, T, "deltaY"), x && p && v) t.save(), t.fillStyle = m, t.translate(d.renderLeft, d.renderTop), t.rotate(d.angle), t.fillRect(-d.kernedWidth / 2, C * i + s, d.kernedWidth, this.fontSize / 15), t.restore();
													else if ((p !== c || v !== m || i !== r || s !== a) && f > 0) {
													var F = y + o + h;
													"rtl" === this.direction && (F = this.width - F - f), c && m && (t.fillStyle = m, t.fillRect(F, u + C * r + a, f, this.fontSize / 15)), h = d.left, f = d.width, c = p, m = v, r = i, a = s
												} else f += d.kernedWidth;
												F = y + o + h, "rtl" === this.direction && (F = this.width - F - f), t.fillStyle = v, p && v && t.fillRect(F, u + C * r + a, f - w, this.fontSize / 15), b += n
											} else b += n;
										this._removeShadow(t)
									}
								},
								_getFontDeclaration: function(t, n) {
									var r = t || this,
										i = this.fontFamily,
										o = e.Text.genericFonts.indexOf(i.toLowerCase()) > -1,
										a = void 0 === i || i.indexOf("'") > -1 || i.indexOf(",") > -1 || i.indexOf('"') > -1 || o ? r.fontFamily : '"' + r.fontFamily + '"';
									return [e.isLikelyNode ? r.fontWeight : r.fontStyle, e.isLikelyNode ? r.fontStyle : r.fontWeight, n ? this.CACHE_FONT_SIZE + "px" : r.fontSize + "px", a].join(" ")
								},
								render: function(t) {
									this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", t)))
								},
								_splitTextIntoLines: function(t) {
									for (var n = t.split(this._reNewline), r = new Array(n.length), i = ["\n"], o = [], a = 0; a < n.length; a++) r[a] = e.util.string.graphemeSplit(n[a]), o = o.concat(r[a], i);
									return o.pop(), {
										_unwrappedLines: r,
										lines: n,
										graphemeText: o,
										graphemeLines: r
									}
								},
								toObject: function(t) {
									var n = r.concat(t),
										i = this.callSuper("toObject", n);
									return i.styles = e.util.stylesToArray(this.styles, this.text), i.path && (i.path = this.path.toObject()), i
								},
								set: function(t, e) {
									this.callSuper("set", t, e);
									var n = !1,
										r = !1;
									if ("object" == typeof t)
										for (var i in t) "path" === i && this.setPathInfo(), n = n || -1 !== this._dimensionAffectingProps.indexOf(i), r = r || "path" === i;
									else n = -1 !== this._dimensionAffectingProps.indexOf(t), r = "path" === t;
									return r && this.setPathInfo(), n && (this.initDimensions(), this.setCoords()), this
								},
								complexity: function() {
									return 1
								}
							}), e.Text.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), e.Text.DEFAULT_SVG_FONT_SIZE = 16, e.Text.fromElement = function(t, r, i) {
								if (!t) return r(null);
								var o = e.parseAttributes(t, e.Text.ATTRIBUTE_NAMES),
									a = o.textAnchor || "left";
								if ((i = e.util.object.extend(i ? n(i) : {}, o)).top = i.top || 0, i.left = i.left || 0, o.textDecoration) {
									var s = o.textDecoration; - 1 !== s.indexOf("underline") && (i.underline = !0), -1 !== s.indexOf("overline") && (i.overline = !0), -1 !== s.indexOf("line-through") && (i.linethrough = !0), delete i.textDecoration
								}
								"dx" in o && (i.left += o.dx), "dy" in o && (i.top += o.dy), "fontSize" in i || (i.fontSize = e.Text.DEFAULT_SVG_FONT_SIZE);
								var l = "";
								"textContent" in t ? l = t.textContent : "firstChild" in t && null !== t.firstChild && "data" in t.firstChild && null !== t.firstChild.data && (l = t.firstChild.data), l = l.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
								var c = i.strokeWidth;
								i.strokeWidth = 0;
								var u = new e.Text(l, i),
									h = u.getScaledHeight() / u.height,
									f = ((u.height + u.strokeWidth) * u.lineHeight - u.height) * h,
									d = u.getScaledHeight() + f,
									p = 0;
								"center" === a && (p = u.getScaledWidth() / 2), "right" === a && (p = u.getScaledWidth()), u.set({
									left: u.left - p,
									top: u.top - (d - u.fontSize * (.07 + u._fontSizeFraction)) / u.lineHeight,
									strokeWidth: void 0 !== c ? c : 1
								}), r(u)
							}, e.Text.fromObject = function(t, r) {
								var i = n(t),
									o = t.path;
								return delete i.path, e.Object._fromObject("Text", i, (function(n) {
									n.styles = e.util.stylesFromArray(t.styles, t.text), o ? e.Object._fromObject("Path", o, (function(t) {
										n.set("path", t), r(n)
									}), "path") : r(n)
								}), "text")
							}, e.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], e.util.createAccessors && e.util.createAccessors(e.Text)
						}
					}(e), b.util.object.extend(b.Text.prototype, {
						isEmptyStyles: function(t) {
							if (!this.styles) return !0;
							if (void 0 !== t && !this.styles[t]) return !0;
							var e = void 0 === t ? this.styles : {
								line: this.styles[t]
							};
							for (var n in e)
								for (var r in e[n])
									for (var i in e[n][r]) return !1;
							return !0
						},
						styleHas: function(t, e) {
							if (!this.styles || !t || "" === t) return !1;
							if (void 0 !== e && !this.styles[e]) return !1;
							var n = void 0 === e ? this.styles : {
								0: this.styles[e]
							};
							for (var r in n)
								for (var i in n[r])
									if (void 0 !== n[r][i][t]) return !0;
							return !1
						},
						cleanStyle: function(t) {
							if (!this.styles || !t || "" === t) return !1;
							var e, n, r = this.styles,
								i = 0,
								o = !0,
								a = 0;
							for (var s in r) {
								for (var l in e = 0, r[s]) {
									var c;
									i++, (c = r[s][l]).hasOwnProperty(t) ? (n ? c[t] !== n && (o = !1) : n = c[t], c[t] === this[t] && delete c[t]) : o = !1, 0 !== Object.keys(c).length ? e++ : delete r[s][l]
								}
								0 === e && delete r[s]
							}
							for (var u = 0; u < this._textLines.length; u++) a += this._textLines[u].length;
							o && i === a && (this[t] = n, this.removeStyle(t))
						},
						removeStyle: function(t) {
							if (this.styles && t && "" !== t) {
								var e, n, r, i = this.styles;
								for (n in i) {
									for (r in e = i[n]) delete e[r][t], 0 === Object.keys(e[r]).length && delete e[r];
									0 === Object.keys(e).length && delete i[n]
								}
							}
						},
						_extendStyles: function(t, e) {
							var n = this.get2DCursorLocation(t);
							this._getLineStyle(n.lineIndex) || this._setLineStyle(n.lineIndex), this._getStyleDeclaration(n.lineIndex, n.charIndex) || this._setStyleDeclaration(n.lineIndex, n.charIndex, {}), b.util.object.extend(this._getStyleDeclaration(n.lineIndex, n.charIndex), e)
						},
						get2DCursorLocation: function(t, e) {
							void 0 === t && (t = this.selectionStart);
							for (var n = e ? this._unwrappedTextLines : this._textLines, r = n.length, i = 0; i < r; i++) {
								if (t <= n[i].length) return {
									lineIndex: i,
									charIndex: t
								};
								t -= n[i].length + this.missingNewlineOffset(i)
							}
							return {
								lineIndex: i - 1,
								charIndex: n[i - 1].length < t ? n[i - 1].length : t
							}
						},
						getSelectionStyles: function(t, e, n) {
							void 0 === t && (t = this.selectionStart || 0), void 0 === e && (e = this.selectionEnd || t);
							for (var r = [], i = t; i < e; i++) r.push(this.getStyleAtPosition(i, n));
							return r
						},
						getStyleAtPosition: function(t, e) {
							var n = this.get2DCursorLocation(t);
							return (e ? this.getCompleteStyleDeclaration(n.lineIndex, n.charIndex) : this._getStyleDeclaration(n.lineIndex, n.charIndex)) || {}
						},
						setSelectionStyles: function(t, e, n) {
							void 0 === e && (e = this.selectionStart || 0), void 0 === n && (n = this.selectionEnd || e);
							for (var r = e; r < n; r++) this._extendStyles(r, t);
							return this._forceClearCache = !0, this
						},
						_getStyleDeclaration: function(t, e) {
							var n = this.styles && this.styles[t];
							return n ? n[e] : null
						},
						getCompleteStyleDeclaration: function(t, e) {
							for (var n, r = this._getStyleDeclaration(t, e) || {}, i = {}, o = 0; o < this._styleProperties.length; o++) i[n = this._styleProperties[o]] = void 0 === r[n] ? this[n] : r[n];
							return i
						},
						_setStyleDeclaration: function(t, e, n) {
							this.styles[t][e] = n
						},
						_deleteStyleDeclaration: function(t, e) {
							delete this.styles[t][e]
						},
						_getLineStyle: function(t) {
							return !!this.styles[t]
						},
						_setLineStyle: function(t) {
							this.styles[t] = {}
						},
						_deleteLineStyle: function(t) {
							delete this.styles[t]
						}
					}),
					function() {
						function t(t) {
							t.textDecoration && (t.textDecoration.indexOf("underline") > -1 && (t.underline = !0), t.textDecoration.indexOf("line-through") > -1 && (t.linethrough = !0), t.textDecoration.indexOf("overline") > -1 && (t.overline = !0), delete t.textDecoration)
						}
						b.IText = b.util.createClass(b.Text, b.Observable, {
							type: "i-text",
							selectionStart: 0,
							selectionEnd: 0,
							selectionColor: "rgba(17,119,255,0.3)",
							isEditing: !1,
							editable: !0,
							editingBorderColor: "rgba(102,153,255,0.25)",
							cursorWidth: 2,
							cursorColor: "",
							cursorDelay: 1e3,
							cursorDuration: 600,
							caching: !0,
							hiddenTextareaContainer: null,
							_reSpace: /\s|\n/,
							_currentCursorOpacity: 0,
							_selectionDirection: null,
							_abortCursorAnimation: !1,
							__widthOfSpace: [],
							inCompositionMode: !1,
							initialize: function(t, e) {
								this.callSuper("initialize", t, e), this.initBehavior()
							},
							setSelectionStart: function(t) {
								t = Math.max(t, 0), this._updateAndFire("selectionStart", t)
							},
							setSelectionEnd: function(t) {
								t = Math.min(t, this.text.length), this._updateAndFire("selectionEnd", t)
							},
							_updateAndFire: function(t, e) {
								this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea()
							},
							_fireSelectionChanged: function() {
								this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", {
									target: this
								})
							},
							initDimensions: function() {
								this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions")
							},
							render: function(t) {
								this.clearContextTop(), this.callSuper("render", t), this.cursorOffsetCache = {}, this.renderCursorOrSelection()
							},
							_render: function(t) {
								this.callSuper("_render", t)
							},
							clearContextTop: function(t) {
								if (this.isEditing && this.canvas && this.canvas.contextTop) {
									var e = this.canvas.contextTop,
										n = this.canvas.viewportTransform;
									e.save(), e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), this.transform(e), this._clearTextArea(e), t || e.restore()
								}
							},
							renderCursorOrSelection: function() {
								if (this.isEditing && this.canvas && this.canvas.contextTop) {
									var t = this._getCursorBoundaries(),
										e = this.canvas.contextTop;
									this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(t, e) : this.renderSelection(t, e), e.restore()
								}
							},
							_clearTextArea: function(t) {
								var e = this.width + 4,
									n = this.height + 4;
								t.clearRect(-e / 2, -n / 2, e, n)
							},
							_getCursorBoundaries: function(t) {
								void 0 === t && (t = this.selectionStart);
								var e = this._getLeftOffset(),
									n = this._getTopOffset(),
									r = this._getCursorBoundariesOffsets(t);
								return {
									left: e,
									top: n,
									leftOffset: r.left,
									topOffset: r.top
								}
							},
							_getCursorBoundariesOffsets: function(t) {
								if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache;
								var e, n, r, i, o = 0,
									a = 0,
									s = this.get2DCursorLocation(t);
								r = s.charIndex, n = s.lineIndex;
								for (var l = 0; l < n; l++) o += this.getHeightOfLine(l);
								e = this._getLineLeftOffset(n);
								var c = this.__charBounds[n][r];
								return c && (a = c.left), 0 !== this.charSpacing && r === this._textLines[n].length && (a -= this._getWidthOfCharSpacing()), i = {
									top: o,
									left: e + (a > 0 ? a : 0)
								}, "rtl" === this.direction && (i.left *= -1), this.cursorOffsetCache = i, this.cursorOffsetCache
							},
							renderCursor: function(t, e) {
								var n = this.get2DCursorLocation(),
									r = n.lineIndex,
									i = n.charIndex > 0 ? n.charIndex - 1 : 0,
									o = this.getValueOfPropertyAt(r, i, "fontSize"),
									a = this.scaleX * this.canvas.getZoom(),
									s = this.cursorWidth / a,
									l = t.topOffset,
									c = this.getValueOfPropertyAt(r, i, "deltaY");
								l += (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - o * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(t, e), e.fillStyle = this.cursorColor || this.getValueOfPropertyAt(r, i, "fill"), e.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, e.fillRect(t.left + t.leftOffset - s / 2, l + t.top + c, s, o)
							},
							renderSelection: function(t, e) {
								for (var n = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, r = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, i = -1 !== this.textAlign.indexOf("justify"), o = this.get2DCursorLocation(n), a = this.get2DCursorLocation(r), s = o.lineIndex, l = a.lineIndex, c = o.charIndex < 0 ? 0 : o.charIndex, u = a.charIndex < 0 ? 0 : a.charIndex, h = s; h <= l; h++) {
									var f, d = this._getLineLeftOffset(h) || 0,
										p = this.getHeightOfLine(h),
										g = 0,
										v = 0;
									if (h === s && (g = this.__charBounds[s][c].left), h >= s && h < l) v = i && !this.isEndOfWrapping(h) ? this.width : this.getLineWidth(h) || 5;
									else if (h === l)
										if (0 === u) v = this.__charBounds[l][u].left;
										else {
											var m = this._getWidthOfCharSpacing();
											v = this.__charBounds[l][u - 1].left + this.__charBounds[l][u - 1].width - m
										} f = p, (this.lineHeight < 1 || h === l && this.lineHeight > 1) && (p /= this.lineHeight);
									var y = t.left + d + g,
										b = v - g,
										x = p,
										w = 0;
									this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", x = 1, w = p) : e.fillStyle = this.selectionColor, "rtl" === this.direction && (y = this.width - y - b), e.fillRect(y, t.top + t.topOffset + w, b, x), t.topOffset += f
								}
							},
							getCurrentCharFontSize: function() {
								var t = this._getCurrentCharIndex();
								return this.getValueOfPropertyAt(t.l, t.c, "fontSize")
							},
							getCurrentCharColor: function() {
								var t = this._getCurrentCharIndex();
								return this.getValueOfPropertyAt(t.l, t.c, "fill")
							},
							_getCurrentCharIndex: function() {
								var t = this.get2DCursorLocation(this.selectionStart, !0),
									e = t.charIndex > 0 ? t.charIndex - 1 : 0;
								return {
									l: t.lineIndex,
									c: e
								}
							}
						}), b.IText.fromObject = function(e, n) {
							var r = b.util.stylesFromArray(e.styles, e.text),
								i = Object.assign({}, e, {
									styles: r
								});
							if (t(i), i.styles)
								for (var o in i.styles)
									for (var a in i.styles[o]) t(i.styles[o][a]);
							b.Object._fromObject("IText", i, n, "text")
						}
					}(), d = b.util.object.clone, b.util.object.extend(b.IText.prototype, {
						initBehavior: function() {
							this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this)
						},
						onDeselect: function() {
							this.isEditing && this.exitEditing(), this.selected = !1
						},
						initAddedHandler: function() {
							var t = this;
							this.on("added", (function() {
								var e = t.canvas;
								e && (e._hasITextHandlers || (e._hasITextHandlers = !0, t._initCanvasHandlers(e)), e._iTextInstances = e._iTextInstances || [], e._iTextInstances.push(t))
							}))
						},
						initRemovedHandler: function() {
							var t = this;
							this.on("removed", (function() {
								var e = t.canvas;
								e && (e._iTextInstances = e._iTextInstances || [], b.util.removeFromArray(e._iTextInstances, t), 0 === e._iTextInstances.length && (e._hasITextHandlers = !1, t._removeCanvasHandlers(e)))
							}))
						},
						_initCanvasHandlers: function(t) {
							t._mouseUpITextHandler = function() {
								t._iTextInstances && t._iTextInstances.forEach((function(t) {
									t.__isMousedown = !1
								}))
							}, t.on("mouse:up", t._mouseUpITextHandler)
						},
						_removeCanvasHandlers: function(t) {
							t.off("mouse:up", t._mouseUpITextHandler)
						},
						_tick: function() {
							this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete")
						},
						_animateCursor: function(t, e, n, r) {
							var i;
							return i = {
								isAborted: !1,
								abort: function() {
									this.isAborted = !0
								}
							}, t.animate("_currentCursorOpacity", e, {
								duration: n,
								onComplete: function() {
									i.isAborted || t[r]()
								},
								onChange: function() {
									t.canvas && t.selectionStart === t.selectionEnd && t.renderCursorOrSelection()
								},
								abort: function() {
									return i.isAborted
								}
							}), i
						},
						_onTickComplete: function() {
							var t = this;
							this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout((function() {
								t._currentTickCompleteState = t._animateCursor(t, 0, this.cursorDuration / 2, "_tick")
							}), 100)
						},
						initDelayedCursor: function(t) {
							var e = this,
								n = t ? 0 : this.cursorDelay;
							this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout((function() {
								e._tick()
							}), n)
						},
						abortCursorAnimation: function() {
							var t = this._currentTickState || this._currentTickCompleteState,
								e = this.canvas;
							this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, t && e && e.clearContext(e.contextTop || e.contextContainer)
						},
						selectAll: function() {
							return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this
						},
						getSelectedText: function() {
							return this._text.slice(this.selectionStart, this.selectionEnd).join("")
						},
						findWordBoundaryLeft: function(t) {
							var e = 0,
								n = t - 1;
							if (this._reSpace.test(this._text[n]))
								for (; this._reSpace.test(this._text[n]);) e++, n--;
							for (;
								/\S/.test(this._text[n]) && n > -1;) e++, n--;
							return t - e
						},
						findWordBoundaryRight: function(t) {
							var e = 0,
								n = t;
							if (this._reSpace.test(this._text[n]))
								for (; this._reSpace.test(this._text[n]);) e++, n++;
							for (;
								/\S/.test(this._text[n]) && n < this._text.length;) e++, n++;
							return t + e
						},
						findLineBoundaryLeft: function(t) {
							for (var e = 0, n = t - 1; !/\n/.test(this._text[n]) && n > -1;) e++, n--;
							return t - e
						},
						findLineBoundaryRight: function(t) {
							for (var e = 0, n = t; !/\n/.test(this._text[n]) && n < this._text.length;) e++, n++;
							return t + e
						},
						searchWordBoundary: function(t, e) {
							for (var n = this._text, r = this._reSpace.test(n[t]) ? t - 1 : t, i = n[r], o = b.reNonWord; !o.test(i) && r > 0 && r < n.length;) i = n[r += e];
							return o.test(i) && (r += 1 === e ? 0 : 1), r
						},
						selectWord: function(t) {
							t = t || this.selectionStart;
							var e = this.searchWordBoundary(t, -1),
								n = this.searchWordBoundary(t, 1);
							this.selectionStart = e, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()
						},
						selectLine: function(t) {
							t = t || this.selectionStart;
							var e = this.findLineBoundaryLeft(t),
								n = this.findLineBoundaryRight(t);
							return this.selectionStart = e, this.selectionEnd = n, this._fireSelectionChanged(), this._updateTextarea(), this
						},
						enterEditing: function(t) {
							if (!this.isEditing && this.editable) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(t), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", {
								target: this
							}), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this
						},
						exitEditingOnOthers: function(t) {
							t._iTextInstances && t._iTextInstances.forEach((function(t) {
								t.selected = !1, t.isEditing && t.exitEditing()
							}))
						},
						initMouseMoveHandler: function() {
							this.canvas.on("mouse:move", this.mouseMoveHandler)
						},
						mouseMoveHandler: function(t) {
							if (this.__isMousedown && this.isEditing) {
								document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();
								var e = this.getSelectionStartFromPointer(t.e),
									n = this.selectionStart,
									r = this.selectionEnd;
								(e === this.__selectionStartOnMouseDown && n !== r || n !== e && r !== e) && (e > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = e) : (this.selectionStart = e, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === n && this.selectionEnd === r || (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()))
							}
						},
						_setEditingProps: function() {
							this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0
						},
						fromStringToGraphemeSelection: function(t, e, n) {
							var r = n.slice(0, t),
								i = b.util.string.graphemeSplit(r).length;
							if (t === e) return {
								selectionStart: i,
								selectionEnd: i
							};
							var o = n.slice(t, e);
							return {
								selectionStart: i,
								selectionEnd: i + b.util.string.graphemeSplit(o).length
							}
						},
						fromGraphemeToStringSelection: function(t, e, n) {
							var r = n.slice(0, t).join("").length;
							return t === e ? {
								selectionStart: r,
								selectionEnd: r
							} : {
								selectionStart: r,
								selectionEnd: r + n.slice(t, e).join("").length
							}
						},
						_updateTextarea: function() {
							if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
								if (!this.inCompositionMode) {
									var t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
									this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd
								}
								this.updateTextareaPosition()
							}
						},
						updateFromTextArea: function() {
							if (this.hiddenTextarea) {
								this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords());
								var t = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
								this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition()
							}
						},
						updateTextareaPosition: function() {
							if (this.selectionStart === this.selectionEnd) {
								var t = this._calcTextareaPosition();
								this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top
							}
						},
						_calcTextareaPosition: function() {
							if (!this.canvas) return {
								x: 1,
								y: 1
							};
							var t = this.inCompositionMode ? this.compositionStart : this.selectionStart,
								e = this._getCursorBoundaries(t),
								n = this.get2DCursorLocation(t),
								r = n.lineIndex,
								i = n.charIndex,
								o = this.getValueOfPropertyAt(r, i, "fontSize") * this.lineHeight,
								a = e.leftOffset,
								s = this.calcTransformMatrix(),
								l = {
									x: e.left + a,
									y: e.top + e.topOffset + o
								},
								c = this.canvas.getRetinaScaling(),
								u = this.canvas.upperCanvasEl,
								h = u.width / c,
								f = u.height / c,
								d = h - o,
								p = f - o,
								g = u.clientWidth / h,
								v = u.clientHeight / f;
							return l = b.util.transformPoint(l, s), (l = b.util.transformPoint(l, this.canvas.viewportTransform)).x *= g, l.y *= v, l.x < 0 && (l.x = 0), l.x > d && (l.x = d), l.y < 0 && (l.y = 0), l.y > p && (l.y = p), l.x += this.canvas._offset.left, l.y += this.canvas._offset.top, {
								left: l.x + "px",
								top: l.y + "px",
								fontSize: o + "px",
								charHeight: o
							}
						},
						_saveEditingProps: function() {
							this._savedProps = {
								hasControls: this.hasControls,
								borderColor: this.borderColor,
								lockMovementX: this.lockMovementX,
								lockMovementY: this.lockMovementY,
								hoverCursor: this.hoverCursor,
								selectable: this.selectable,
								defaultCursor: this.canvas && this.canvas.defaultCursor,
								moveCursor: this.canvas && this.canvas.moveCursor
							}
						},
						_restoreEditingProps: function() {
							this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor))
						},
						exitEditing: function() {
							var t = this._textBeforeEdit !== this.text,
								e = this.hiddenTextarea;
							return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), t && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", {
								target: this
							}), t && this.canvas.fire("object:modified", {
								target: this
							})), this
						},
						_removeExtraneousStyles: function() {
							for (var t in this.styles) this._textLines[t] || delete this.styles[t]
						},
						removeStyleFromTo: function(t, e) {
							var n, r, i = this.get2DCursorLocation(t, !0),
								o = this.get2DCursorLocation(e, !0),
								a = i.lineIndex,
								s = i.charIndex,
								l = o.lineIndex,
								c = o.charIndex;
							if (a !== l) {
								if (this.styles[a])
									for (n = s; n < this._unwrappedTextLines[a].length; n++) delete this.styles[a][n];
								if (this.styles[l])
									for (n = c; n < this._unwrappedTextLines[l].length; n++)(r = this.styles[l][n]) && (this.styles[a] || (this.styles[a] = {}), this.styles[a][s + n - c] = r);
								for (n = a + 1; n <= l; n++) delete this.styles[n];
								this.shiftLineStyles(l, a - l)
							} else if (this.styles[a]) {
								r = this.styles[a];
								var u, h, f = c - s;
								for (n = s; n < c; n++) delete r[n];
								for (h in this.styles[a])(u = parseInt(h, 10)) >= c && (r[u - f] = r[h], delete r[h])
							}
						},
						shiftLineStyles: function(t, e) {
							var n = d(this.styles);
							for (var r in this.styles) {
								var i = parseInt(r, 10);
								i > t && (this.styles[i + e] = n[i], n[i - e] || delete this.styles[i])
							}
						},
						restartCursorIfNeeded: function() {
							this._currentTickState && !this._currentTickState.isAborted && this._currentTickCompleteState && !this._currentTickCompleteState.isAborted || this.initDelayedCursor()
						},
						insertNewlineStyleObject: function(t, e, n, r) {
							var i, o = {},
								a = !1,
								s = this._unwrappedTextLines[t].length === e;
							for (var l in n || (n = 1), this.shiftLineStyles(t, n), this.styles[t] && (i = this.styles[t][0 === e ? e : e - 1]), this.styles[t]) {
								var c = parseInt(l, 10);
								c >= e && (a = !0, o[c - e] = this.styles[t][l], s && 0 === e || delete this.styles[t][l])
							}
							var u = !1;
							for (a && !s && (this.styles[t + n] = o, u = !0), u && n--; n > 0;) r && r[n - 1] ? this.styles[t + n] = {
								0: d(r[n - 1])
							} : i ? this.styles[t + n] = {
								0: d(i)
							} : delete this.styles[t + n], n--;
							this._forceClearCache = !0
						},
						insertCharStyleObject: function(t, e, n, r) {
							this.styles || (this.styles = {});
							var i = this.styles[t],
								o = i ? d(i) : {};
							for (var a in n || (n = 1), o) {
								var s = parseInt(a, 10);
								s >= e && (i[s + n] = o[s], o[s - n] || delete i[s])
							}
							if (this._forceClearCache = !0, r)
								for (; n--;) Object.keys(r[n]).length && (this.styles[t] || (this.styles[t] = {}), this.styles[t][e + n] = d(r[n]));
							else if (i)
								for (var l = i[e ? e - 1 : 1]; l && n--;) this.styles[t][e + n] = d(l)
						},
						insertNewStyleBlock: function(t, e, n) {
							for (var r = this.get2DCursorLocation(e, !0), i = [0], o = 0, a = 0; a < t.length; a++) "\n" === t[a] ? i[++o] = 0 : i[o]++;
							for (i[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, i[0], n), n = n && n.slice(i[0] + 1)), o && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + i[0], o), a = 1; a < o; a++) i[a] > 0 ? this.insertCharStyleObject(r.lineIndex + a, 0, i[a], n) : n && this.styles[r.lineIndex + a] && n[0] && (this.styles[r.lineIndex + a][0] = n[0]), n = n && n.slice(i[a] + 1);
							i[a] > 0 && this.insertCharStyleObject(r.lineIndex + a, 0, i[a], n)
						},
						setSelectionStartEndWithShift: function(t, e, n) {
							n <= t ? (e === t ? this._selectionDirection = "left" : "right" === this._selectionDirection && (this._selectionDirection = "left", this.selectionEnd = t), this.selectionStart = n) : n > t && n < e ? "right" === this._selectionDirection ? this.selectionEnd = n : this.selectionStart = n : (e === t ? this._selectionDirection = "right" : "left" === this._selectionDirection && (this._selectionDirection = "right", this.selectionStart = e), this.selectionEnd = n)
						},
						setSelectionInBoundaries: function() {
							var t = this.text.length;
							this.selectionStart > t ? this.selectionStart = t : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > t ? this.selectionEnd = t : this.selectionEnd < 0 && (this.selectionEnd = 0)
						}
					}), b.util.object.extend(b.IText.prototype, {
						initDoubleClickSimulation: function() {
							this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown)
						},
						onMouseDown: function(t) {
							if (this.canvas) {
								this.__newClickTime = +new Date;
								var e = t.pointer;
								this.isTripleClick(e) && (this.fire("tripleclick", t), this._stopEvent(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected
							}
						},
						isTripleClick: function(t) {
							return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y
						},
						_stopEvent: function(t) {
							t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation()
						},
						initCursorSelectionHandlers: function() {
							this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks()
						},
						doubleClickHandler: function(t) {
							this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t.e))
						},
						tripleClickHandler: function(t) {
							this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t.e))
						},
						initClicks: function() {
							this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler)
						},
						_mouseDownHandler: function(t) {
							!this.canvas || !this.editable || t.e.button && 1 !== t.e.button || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(t.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()))
						},
						_mouseDownHandlerBefore: function(t) {
							!this.canvas || !this.editable || t.e.button && 1 !== t.e.button || (this.selected = this === this.canvas._activeObject)
						},
						initMousedownHandler: function() {
							this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore)
						},
						initMouseupHandler: function() {
							this.on("mouseup", this.mouseUpHandler)
						},
						mouseUpHandler: function(t) {
							if (this.__isMousedown = !1, !(!this.editable || this.group || t.transform && t.transform.actionPerformed || t.e.button && 1 !== t.e.button)) {
								if (this.canvas) {
									var e = this.canvas._activeObject;
									if (e && e !== this) return
								}
								this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0
							}
						},
						setCursorByClick: function(t) {
							var e = this.getSelectionStartFromPointer(t),
								n = this.selectionStart,
								r = this.selectionEnd;
							t.shiftKey ? this.setSelectionStartEndWithShift(n, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea())
						},
						getSelectionStartFromPointer: function(t) {
							for (var e, n = this.getLocalPointer(t), r = 0, i = 0, o = 0, a = 0, s = 0, l = 0, c = this._textLines.length; l < c && o <= n.y; l++) o += this.getHeightOfLine(l) * this.scaleY, s = l, l > 0 && (a += this._textLines[l - 1].length + this.missingNewlineOffset(l - 1));
							i = this._getLineLeftOffset(s) * this.scaleX, e = this._textLines[s], "rtl" === this.direction && (n.x = this.width * this.scaleX - n.x + i);
							for (var u = 0, h = e.length; u < h && (r = i, (i += this.__charBounds[s][u].kernedWidth * this.scaleX) <= n.x); u++) a++;
							return this._getNewSelectionStartFromOffset(n, r, i, a, h)
						},
						_getNewSelectionStartFromOffset: function(t, e, n, r, i) {
							var o = t.x - e,
								a = n - t.x,
								s = r + (a > o || a < 0 ? 0 : 1);
							return this.flipX && (s = i - s), s > this._text.length && (s = this._text.length), s
						}
					}), b.util.object.extend(b.IText.prototype, {
						initHiddenTextarea: function() {
							this.hiddenTextarea = b.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off");
							var t = this._calcTextareaPosition();
							this.hiddenTextarea.style.cssText = "position: absolute; top: " + t.top + "; left: " + t.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + t.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : b.document.body.appendChild(this.hiddenTextarea), b.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), b.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), b.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), b.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), b.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), b.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), b.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), b.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), b.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (b.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0)
						},
						keysMap: {
							9: "exitEditing",
							27: "exitEditing",
							33: "moveCursorUp",
							34: "moveCursorDown",
							35: "moveCursorRight",
							36: "moveCursorLeft",
							37: "moveCursorLeft",
							38: "moveCursorUp",
							39: "moveCursorRight",
							40: "moveCursorDown"
						},
						keysMapRtl: {
							9: "exitEditing",
							27: "exitEditing",
							33: "moveCursorUp",
							34: "moveCursorDown",
							35: "moveCursorLeft",
							36: "moveCursorRight",
							37: "moveCursorRight",
							38: "moveCursorUp",
							39: "moveCursorLeft",
							40: "moveCursorDown"
						},
						ctrlKeysMapUp: {
							67: "copy",
							88: "cut"
						},
						ctrlKeysMapDown: {
							65: "selectAll"
						},
						onClick: function() {
							this.hiddenTextarea && this.hiddenTextarea.focus()
						},
						onKeyDown: function(t) {
							if (this.isEditing) {
								var e = "rtl" === this.direction ? this.keysMapRtl : this.keysMap;
								if (t.keyCode in e) this[e[t.keyCode]](t);
								else {
									if (!(t.keyCode in this.ctrlKeysMapDown) || !t.ctrlKey && !t.metaKey) return;
									this[this.ctrlKeysMapDown[t.keyCode]](t)
								}
								t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll()
							}
						},
						onKeyUp: function(t) {
							!this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll())
						},
						onInput: function(t) {
							var e = this.fromPaste;
							if (this.fromPaste = !1, t && t.stopPropagation(), this.isEditing) {
								var n, r, i, o, a, s = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
									l = this._text.length,
									c = s.length,
									u = c - l,
									h = this.selectionStart,
									f = this.selectionEnd,
									d = h !== f;
								if ("" === this.hiddenTextarea.value) return this.styles = {}, this.updateFromTextArea(), this.fire("changed"), void(this.canvas && (this.canvas.fire("text:changed", {
									target: this
								}), this.canvas.requestRenderAll()));
								var p = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value),
									g = h > p.selectionStart;
								d ? (n = this._text.slice(h, f), u += f - h) : c < l && (n = g ? this._text.slice(f + u, f) : this._text.slice(h, h - u)), r = s.slice(p.selectionEnd - u, p.selectionEnd), n && n.length && (r.length && (i = this.getSelectionStyles(h, h + 1, !1), i = r.map((function() {
									return i[0]
								}))), d ? (o = h, a = f) : g ? (o = f - n.length, a = f) : (o = f, a = f + n.length), this.removeStyleFromTo(o, a)), r.length && (e && r.join("") === b.copiedText && !b.disableStyleCopyPaste && (i = b.copiedTextStyle), this.insertNewStyleBlock(r, h, i)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", {
									target: this
								}), this.canvas.requestRenderAll())
							}
						},
						onCompositionStart: function() {
							this.inCompositionMode = !0
						},
						onCompositionEnd: function() {
							this.inCompositionMode = !1
						},
						onCompositionUpdate: function(t) {
							this.compositionStart = t.target.selectionStart, this.compositionEnd = t.target.selectionEnd, this.updateTextareaPosition()
						},
						copy: function() {
							this.selectionStart !== this.selectionEnd && (b.copiedText = this.getSelectedText(), b.disableStyleCopyPaste ? b.copiedTextStyle = null : b.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0)
						},
						paste: function() {
							this.fromPaste = !0
						},
						_getClipboardData: function(t) {
							return t && t.clipboardData || b.window.clipboardData
						},
						_getWidthBeforeCursor: function(t, e) {
							var n, r = this._getLineLeftOffset(t);
							return e > 0 && (r += (n = this.__charBounds[t][e - 1]).left + n.width), r
						},
						getDownCursorOffset: function(t, e) {
							var n = this._getSelectionForOffset(t, e),
								r = this.get2DCursorLocation(n),
								i = r.lineIndex;
							if (i === this._textLines.length - 1 || t.metaKey || 34 === t.keyCode) return this._text.length - n;
							var o = r.charIndex,
								a = this._getWidthBeforeCursor(i, o),
								s = this._getIndexOnLine(i + 1, a);
							return this._textLines[i].slice(o).length + s + 1 + this.missingNewlineOffset(i)
						},
						_getSelectionForOffset: function(t, e) {
							return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart
						},
						getUpCursorOffset: function(t, e) {
							var n = this._getSelectionForOffset(t, e),
								r = this.get2DCursorLocation(n),
								i = r.lineIndex;
							if (0 === i || t.metaKey || 33 === t.keyCode) return -n;
							var o = r.charIndex,
								a = this._getWidthBeforeCursor(i, o),
								s = this._getIndexOnLine(i - 1, a),
								l = this._textLines[i].slice(0, o),
								c = this.missingNewlineOffset(i - 1);
							return -this._textLines[i - 1].length + s - l.length + (1 - c)
						},
						_getIndexOnLine: function(t, e) {
							for (var n, r, i = this._textLines[t], o = this._getLineLeftOffset(t), a = 0, s = 0, l = i.length; s < l; s++)
								if ((o += n = this.__charBounds[t][s].width) > e) {
									r = !0;
									var c = o - n,
										u = o,
										h = Math.abs(c - e);
									a = Math.abs(u - e) < h ? s : s - 1;
									break
								} return r || (a = i.length - 1), a
						},
						moveCursorDown: function(t) {
							this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t)
						},
						moveCursorUp: function(t) {
							0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown("Up", t)
						},
						_moveCursorUpOrDown: function(t, e) {
							var n = this["get" + t + "CursorOffset"](e, "right" === this._selectionDirection);
							e.shiftKey ? this.moveCursorWithShift(n) : this.moveCursorWithoutShift(n), 0 !== n && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea())
						},
						moveCursorWithShift: function(t) {
							var e = "left" === this._selectionDirection ? this.selectionStart + t : this.selectionEnd + t;
							return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), 0 !== t
						},
						moveCursorWithoutShift: function(t) {
							return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), 0 !== t
						},
						moveCursorLeft: function(t) {
							0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight("Left", t)
						},
						_move: function(t, e, n) {
							var r;
							if (t.altKey) r = this["findWordBoundary" + n](this[e]);
							else {
								if (!t.metaKey && 35 !== t.keyCode && 36 !== t.keyCode) return this[e] += "Left" === n ? -1 : 1, !0;
								r = this["findLineBoundary" + n](this[e])
							}
							if (void 0 !== r && this[e] !== r) return this[e] = r, !0
						},
						_moveLeft: function(t, e) {
							return this._move(t, e, "Left")
						},
						_moveRight: function(t, e) {
							return this._move(t, e, "Right")
						},
						moveCursorLeftWithoutShift: function(t) {
							var e = !0;
							return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e = this._moveLeft(t, "selectionStart")), this.selectionEnd = this.selectionStart, e
						},
						moveCursorLeftWithShift: function(t) {
							return "right" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = "left", this._moveLeft(t, "selectionStart")) : void 0
						},
						moveCursorRight: function(t) {
							this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t)
						},
						_moveCursorLeftOrRight: function(t, e) {
							var n = "moveCursor" + t + "With";
							this._currentCursorOpacity = 1, e.shiftKey ? n += "Shift" : n += "outShift", this[n](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea())
						},
						moveCursorRightWithShift: function(t) {
							return "left" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveRight(t, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = "right", this._moveRight(t, "selectionEnd")) : void 0
						},
						moveCursorRightWithoutShift: function(t) {
							var e = !0;
							return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e
						},
						removeChars: function(t, e) {
							void 0 === e && (e = t + 1), this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles()
						},
						insertChars: function(t, e, n, r) {
							void 0 === r && (r = n), r > n && this.removeStyleFromTo(n, r);
							var i = b.util.string.graphemeSplit(t);
							this.insertNewStyleBlock(i, n, e), this._text = [].concat(this._text.slice(0, n), i, this._text.slice(r)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles()
						}
					}), p = b.util.toFixed, g = /  +/g, b.util.object.extend(b.Text.prototype, {
						_toSVG: function() {
							var t = this._getSVGLeftTopOffsets(),
								e = this._getSVGTextAndBg(t.textTop, t.textLeft);
							return this._wrapSVGTextAndBg(e)
						},
						toSVG: function(t) {
							return this._createBaseSVGMarkup(this._toSVG(), {
								reviver: t,
								noStyle: !0,
								withShadow: !0
							})
						},
						_getSVGLeftTopOffsets: function() {
							return {
								textLeft: -this.width / 2,
								textTop: -this.height / 2,
								lineTop: this.getHeightOfLine(0)
							}
						},
						_wrapSVGTextAndBg: function(t) {
							var e = this.getSvgTextDecoration(this);
							return [t.textBgRects.join(""), '\t\t<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", e ? 'text-decoration="' + e + '" ' : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", t.textSpans.join(""), "</text>\n"]
						},
						_getSVGTextAndBg: function(t, e) {
							var n, r = [],
								i = [],
								o = t;
							this._setSVGBg(i);
							for (var a = 0, s = this._textLines.length; a < s; a++) n = this._getLineLeftOffset(a), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(i, a, e + n, o), this._setSVGTextLineText(r, a, e + n, o), o += this.getHeightOfLine(a);
							return {
								textSpans: r,
								textBgRects: i
							}
						},
						_createTextCharSpan: function(t, e, n, r) {
							var i = t !== t.trim() || t.match(g),
								o = this.getSvgSpanStyles(e, i),
								a = o ? 'style="' + o + '"' : "",
								s = e.deltaY,
								l = "",
								c = b.Object.NUM_FRACTION_DIGITS;
							return s && (l = ' dy="' + p(s, c) + '" '), ['<tspan x="', p(n, c), '" y="', p(r, c), '" ', l, a, ">", b.util.string.escapeXml(t), "</tspan>"].join("")
						},
						_setSVGTextLineText: function(t, e, n, r) {
							var i, o, a, s, l, c = this.getHeightOfLine(e),
								u = -1 !== this.textAlign.indexOf("justify"),
								h = "",
								f = 0,
								d = this._textLines[e];
							r += c * (1 - this._fontSizeFraction) / this.lineHeight;
							for (var p = 0, g = d.length - 1; p <= g; p++) l = p === g || this.charSpacing, h += d[p], a = this.__charBounds[e][p], 0 === f ? (n += a.kernedWidth - a.width, f += a.width) : f += a.kernedWidth, u && !l && this._reSpaceAndTab.test(d[p]) && (l = !0), l || (i = i || this.getCompleteStyleDeclaration(e, p), o = this.getCompleteStyleDeclaration(e, p + 1), l = b.util.hasStyleChanged(i, o, !0)), l && (s = this._getStyleDeclaration(e, p) || {}, t.push(this._createTextCharSpan(h, s, n, r)), h = "", i = o, n += f, f = 0)
						},
						_pushTextBgRect: function(t, e, n, r, i, o) {
							var a = b.Object.NUM_FRACTION_DIGITS;
							t.push("\t\t<rect ", this._getFillAttributes(e), ' x="', p(n, a), '" y="', p(r, a), '" width="', p(i, a), '" height="', p(o, a), '"></rect>\n')
						},
						_setSVGTextLineBg: function(t, e, n, r) {
							for (var i, o, a = this._textLines[e], s = this.getHeightOfLine(e) / this.lineHeight, l = 0, c = 0, u = this.getValueOfPropertyAt(e, 0, "textBackgroundColor"), h = 0, f = a.length; h < f; h++) i = this.__charBounds[e][h], (o = this.getValueOfPropertyAt(e, h, "textBackgroundColor")) !== u ? (u && this._pushTextBgRect(t, u, n + c, r, l, s), c = i.left, l = i.width, u = o) : l += i.kernedWidth;
							o && this._pushTextBgRect(t, o, n + c, r, l, s)
						},
						_getFillAttributes: function(t) {
							var e = t && "string" == typeof t ? new b.Color(t) : "";
							return e && e.getSource() && 1 !== e.getAlpha() ? 'opacity="' + e.getAlpha() + '" fill="' + e.setAlpha(1).toRgb() + '"' : 'fill="' + t + '"'
						},
						_getSVGLineTopOffset: function(t) {
							for (var e, n = 0, r = 0; r < t; r++) n += this.getHeightOfLine(r);
							return e = this.getHeightOfLine(r), {
								lineTop: n,
								offset: (this._fontSizeMult - this._fontSizeFraction) * e / (this.lineHeight * this._fontSizeMult)
							}
						},
						getSvgStyles: function(t) {
							return b.Object.prototype.getSvgStyles.call(this, t) + " white-space: pre;"
						}
					}),
					function(t) {
						"use strict";
						var e = t.fabric || (t.fabric = {});
						e.Textbox = e.util.createClass(e.IText, e.Observable, {
							type: "textbox",
							minWidth: 20,
							dynamicMinWidth: 2,
							__cachedLines: null,
							lockScalingFlip: !0,
							noScaleCache: !1,
							_dimensionAffectingProps: e.Text.prototype._dimensionAffectingProps.concat("width"),
							_wordJoiners: /[ \t\r]/,
							splitByGrapheme: !1,
							initDimensions: function() {
								this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({
									propertySet: "_dimensionAffectingProps"
								}))
							},
							_generateStyleMap: function(t) {
								for (var e = 0, n = 0, r = 0, i = {}, o = 0; o < t.graphemeLines.length; o++) "\n" === t.graphemeText[r] && o > 0 ? (n = 0, r++, e++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t.graphemeText[r]) && o > 0 && (n++, r++), i[o] = {
									line: e,
									offset: n
								}, r += t.graphemeLines[o].length, n += t.graphemeLines[o].length;
								return i
							},
							styleHas: function(t, n) {
								if (this._styleMap && !this.isWrapping) {
									var r = this._styleMap[n];
									r && (n = r.line)
								}
								return e.Text.prototype.styleHas.call(this, t, n)
							},
							isEmptyStyles: function(t) {
								if (!this.styles) return !0;
								var e, n, r = 0,
									i = !1,
									o = this._styleMap[t],
									a = this._styleMap[t + 1];
								for (var s in o && (t = o.line, r = o.offset), a && (i = a.line === t, e = a.offset), n = void 0 === t ? this.styles : {
										line: this.styles[t]
									})
									for (var l in n[s])
										if (l >= r && (!i || l < e))
											for (var c in n[s][l]) return !1;
								return !0
							},
							_getStyleDeclaration: function(t, e) {
								if (this._styleMap && !this.isWrapping) {
									var n = this._styleMap[t];
									if (!n) return null;
									t = n.line, e = n.offset + e
								}
								return this.callSuper("_getStyleDeclaration", t, e)
							},
							_setStyleDeclaration: function(t, e, n) {
								var r = this._styleMap[t];
								t = r.line, e = r.offset + e, this.styles[t][e] = n
							},
							_deleteStyleDeclaration: function(t, e) {
								var n = this._styleMap[t];
								t = n.line, e = n.offset + e, delete this.styles[t][e]
							},
							_getLineStyle: function(t) {
								var e = this._styleMap[t];
								return !!this.styles[e.line]
							},
							_setLineStyle: function(t) {
								var e = this._styleMap[t];
								this.styles[e.line] = {}
							},
							_wrapText: function(t, e) {
								var n, r = [];
								for (this.isWrapping = !0, n = 0; n < t.length; n++) r = r.concat(this._wrapLine(t[n], n, e));
								return this.isWrapping = !1, r
							},
							_measureWord: function(t, e, n) {
								var r, i = 0;
								n = n || 0;
								for (var o = 0, a = t.length; o < a; o++) i += this._getGraphemeBox(t[o], e, o + n, r, !0).kernedWidth, r = t[o];
								return i
							},
							_wrapLine: function(t, n, r, i) {
								var o = 0,
									a = this.splitByGrapheme,
									s = [],
									l = [],
									c = a ? e.util.string.graphemeSplit(t) : t.split(this._wordJoiners),
									u = "",
									h = 0,
									f = a ? "" : " ",
									d = 0,
									p = 0,
									g = 0,
									v = !0,
									m = this._getWidthOfCharSpacing();
								i = i || 0, 0 === c.length && c.push([]), r -= i;
								for (var y = 0; y < c.length; y++) u = a ? c[y] : e.util.string.graphemeSplit(c[y]), d = this._measureWord(u, n, h), h += u.length, (o += p + d - m) > r && !v ? (s.push(l), l = [], o = d, v = !0) : o += m, v || a || l.push(f), l = l.concat(u), p = a ? 0 : this._measureWord([f], n, h), h++, v = !1, d > g && (g = d);
								return y && s.push(l), g + i > this.dynamicMinWidth && (this.dynamicMinWidth = g - m + i), s
							},
							isEndOfWrapping: function(t) {
								return !this._styleMap[t + 1] || this._styleMap[t + 1].line !== this._styleMap[t].line
							},
							missingNewlineOffset: function(t) {
								return this.splitByGrapheme ? this.isEndOfWrapping(t) ? 1 : 0 : 1
							},
							_splitTextIntoLines: function(t) {
								for (var n = e.Text.prototype._splitTextIntoLines.call(this, t), r = this._wrapText(n.lines, this.width), i = new Array(r.length), o = 0; o < r.length; o++) i[o] = r[o].join("");
								return n.lines = i, n.graphemeLines = r, n
							},
							getMinWidth: function() {
								return Math.max(this.minWidth, this.dynamicMinWidth)
							},
							_removeExtraneousStyles: function() {
								var t = {};
								for (var e in this._styleMap) this._textLines[e] && (t[this._styleMap[e].line] = 1);
								for (var e in this.styles) t[e] || delete this.styles[e]
							},
							toObject: function(t) {
								return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(t))
							}
						}), e.Textbox.fromObject = function(t, n) {
							var r = e.util.stylesFromArray(t.styles, t.text),
								i = Object.assign({}, t, {
									styles: r
								});
							return e.Object._fromObject("Textbox", i, n, "text")
						}
					}(e),
					function() {
						var t = b.controlsUtils,
							e = t.scaleSkewCursorStyleHandler,
							n = t.scaleCursorStyleHandler,
							r = t.scalingEqually,
							i = t.scalingYOrSkewingX,
							o = t.scalingXOrSkewingY,
							a = t.scaleOrSkewActionName,
							s = b.Object.prototype.controls;
						if (s.ml = new b.Control({
								x: -.5,
								y: 0,
								cursorStyleHandler: e,
								actionHandler: o,
								getActionName: a
							}), s.mr = new b.Control({
								x: .5,
								y: 0,
								cursorStyleHandler: e,
								actionHandler: o,
								getActionName: a
							}), s.mb = new b.Control({
								x: 0,
								y: .5,
								cursorStyleHandler: e,
								actionHandler: i,
								getActionName: a
							}), s.mt = new b.Control({
								x: 0,
								y: -.5,
								cursorStyleHandler: e,
								actionHandler: i,
								getActionName: a
							}), s.tl = new b.Control({
								x: -.5,
								y: -.5,
								cursorStyleHandler: n,
								actionHandler: r
							}), s.tr = new b.Control({
								x: .5,
								y: -.5,
								cursorStyleHandler: n,
								actionHandler: r
							}), s.bl = new b.Control({
								x: -.5,
								y: .5,
								cursorStyleHandler: n,
								actionHandler: r
							}), s.br = new b.Control({
								x: .5,
								y: .5,
								cursorStyleHandler: n,
								actionHandler: r
							}), s.mtr = new b.Control({
								x: 0,
								y: -.5,
								actionHandler: t.rotationWithSnapping,
								cursorStyleHandler: t.rotationStyleHandler,
								offsetY: -40,
								withConnection: !0,
								actionName: "rotate"
							}), b.Textbox) {
							var l = b.Textbox.prototype.controls = {};
							l.mtr = s.mtr, l.tr = s.tr, l.br = s.br, l.tl = s.tl, l.bl = s.bl, l.mt = s.mt, l.mb = s.mb, l.mr = new b.Control({
								x: .5,
								y: 0,
								actionHandler: t.changeWidth,
								cursorStyleHandler: e,
								actionName: "resizing"
							}), l.ml = new b.Control({
								x: -.5,
								y: 0,
								actionHandler: t.changeWidth,
								cursorStyleHandler: e,
								actionName: "resizing"
							})
						}
					}()
			},
			563: function(t, e) {
				var n;
				! function(e, n) {
					"use strict";
					"object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function(t) {
						if (!t.document) throw new Error("jQuery requires a window with a document");
						return n(t)
					} : n(e)
				}("undefined" != typeof window ? window : this, (function(r, i) {
					"use strict";
					var o = [],
						a = Object.getPrototypeOf,
						s = o.slice,
						l = o.flat ? function(t) {
							return o.flat.call(t)
						} : function(t) {
							return o.concat.apply([], t)
						},
						c = o.push,
						u = o.indexOf,
						h = {},
						f = h.toString,
						d = h.hasOwnProperty,
						p = d.toString,
						g = p.call(Object),
						v = {},
						m = function(t) {
							return "function" == typeof t && "number" != typeof t.nodeType && "function" != typeof t.item
						},
						y = function(t) {
							return null != t && t === t.window
						},
						b = r.document,
						x = {
							type: !0,
							src: !0,
							nonce: !0,
							noModule: !0
						};

					function w(t, e, n) {
						var r, i, o = (n = n || b).createElement("script");
						if (o.text = t, e)
							for (r in x)(i = e[r] || e.getAttribute && e.getAttribute(r)) && o.setAttribute(r, i);
						n.head.appendChild(o).parentNode.removeChild(o)
					}

					function C(t) {
						return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? h[f.call(t)] || "object" : typeof t
					}
					var S = "3.7.1",
						O = /HTML$/i,
						T = function(t, e) {
							return new T.fn.init(t, e)
						};

					function k(t) {
						var e = !!t && "length" in t && t.length,
							n = C(t);
						return !m(t) && !y(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
					}

					function F(t, e) {
						return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
					}
					T.fn = T.prototype = {
						jquery: S,
						constructor: T,
						length: 0,
						toArray: function() {
							return s.call(this)
						},
						get: function(t) {
							return null == t ? s.call(this) : t < 0 ? this[t + this.length] : this[t]
						},
						pushStack: function(t) {
							var e = T.merge(this.constructor(), t);
							return e.prevObject = this, e
						},
						each: function(t) {
							return T.each(this, t)
						},
						map: function(t) {
							return this.pushStack(T.map(this, (function(e, n) {
								return t.call(e, n, e)
							})))
						},
						slice: function() {
							return this.pushStack(s.apply(this, arguments))
						},
						first: function() {
							return this.eq(0)
						},
						last: function() {
							return this.eq(-1)
						},
						even: function() {
							return this.pushStack(T.grep(this, (function(t, e) {
								return (e + 1) % 2
							})))
						},
						odd: function() {
							return this.pushStack(T.grep(this, (function(t, e) {
								return e % 2
							})))
						},
						eq: function(t) {
							var e = this.length,
								n = +t + (t < 0 ? e : 0);
							return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
						},
						end: function() {
							return this.prevObject || this.constructor()
						},
						push: c,
						sort: o.sort,
						splice: o.splice
					}, T.extend = T.fn.extend = function() {
						var t, e, n, r, i, o, a = arguments[0] || {},
							s = 1,
							l = arguments.length,
							c = !1;
						for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === l && (a = this, s--); s < l; s++)
							if (null != (t = arguments[s]))
								for (e in t) r = t[e], "__proto__" !== e && a !== r && (c && r && (T.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[e], o = i && !Array.isArray(n) ? [] : i || T.isPlainObject(n) ? n : {}, i = !1, a[e] = T.extend(c, o, r)) : void 0 !== r && (a[e] = r));
						return a
					}, T.extend({
						expando: "jQuery" + (S + Math.random()).replace(/\D/g, ""),
						isReady: !0,
						error: function(t) {
							throw new Error(t)
						},
						noop: function() {},
						isPlainObject: function(t) {
							var e, n;
							return !(!t || "[object Object]" !== f.call(t) || (e = a(t)) && ("function" != typeof(n = d.call(e, "constructor") && e.constructor) || p.call(n) !== g))
						},
						isEmptyObject: function(t) {
							var e;
							for (e in t) return !1;
							return !0
						},
						globalEval: function(t, e, n) {
							w(t, {
								nonce: e && e.nonce
							}, n)
						},
						each: function(t, e) {
							var n, r = 0;
							if (k(t))
								for (n = t.length; r < n && !1 !== e.call(t[r], r, t[r]); r++);
							else
								for (r in t)
									if (!1 === e.call(t[r], r, t[r])) break;
							return t
						},
						text: function(t) {
							var e, n = "",
								r = 0,
								i = t.nodeType;
							if (!i)
								for (; e = t[r++];) n += T.text(e);
							return 1 === i || 11 === i ? t.textContent : 9 === i ? t.documentElement.textContent : 3 === i || 4 === i ? t.nodeValue : n
						},
						makeArray: function(t, e) {
							var n = e || [];
							return null != t && (k(Object(t)) ? T.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)), n
						},
						inArray: function(t, e, n) {
							return null == e ? -1 : u.call(e, t, n)
						},
						isXMLDoc: function(t) {
							var e = t && t.namespaceURI,
								n = t && (t.ownerDocument || t).documentElement;
							return !O.test(e || n && n.nodeName || "HTML")
						},
						merge: function(t, e) {
							for (var n = +e.length, r = 0, i = t.length; r < n; r++) t[i++] = e[r];
							return t.length = i, t
						},
						grep: function(t, e, n) {
							for (var r = [], i = 0, o = t.length, a = !n; i < o; i++) !e(t[i], i) !== a && r.push(t[i]);
							return r
						},
						map: function(t, e, n) {
							var r, i, o = 0,
								a = [];
							if (k(t))
								for (r = t.length; o < r; o++) null != (i = e(t[o], o, n)) && a.push(i);
							else
								for (o in t) null != (i = e(t[o], o, n)) && a.push(i);
							return l(a)
						},
						guid: 1,
						support: v
					}), "function" == typeof Symbol && (T.fn[Symbol.iterator] = o[Symbol.iterator]), T.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(t, e) {
						h["[object " + e + "]"] = e.toLowerCase()
					}));
					var P = o.pop,
						j = o.sort,
						A = o.splice,
						_ = "[\\x20\\t\\r\\n\\f]",
						E = new RegExp("^" + _ + "+|((?:^|[^\\\\])(?:\\\\.)*)" + _ + "+$", "g");
					T.contains = function(t, e) {
						var n = e && e.parentNode;
						return t === n || !(!n || 1 !== n.nodeType || !(t.contains ? t.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
					};
					var D = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

					function M(t, e) {
						return e ? "\0" === t ? "" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
					}
					T.escapeSelector = function(t) {
						return (t + "").replace(D, M)
					};
					var I = b,
						R = c;
					! function() {
						var t, e, n, i, a, l, c, h, f, p, g = R,
							m = T.expando,
							y = 0,
							b = 0,
							x = tt(),
							w = tt(),
							C = tt(),
							S = tt(),
							O = function(t, e) {
								return t === e && (a = !0), 0
							},
							k = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
							D = "(?:\\\\[\\da-fA-F]{1,6}" + _ + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
							M = "\\[" + _ + "*(" + D + ")(?:" + _ + "*([*^$|!~]?=)" + _ + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + D + "))|)" + _ + "*\\]",
							B = ":(" + D + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + M + ")*)|.*)\\)|)",
							N = new RegExp(_ + "+", "g"),
							L = new RegExp("^" + _ + "*," + _ + "*"),
							z = new RegExp("^" + _ + "*([>+~]|" + _ + ")" + _ + "*"),
							W = new RegExp(_ + "|>"),
							V = new RegExp(B),
							U = new RegExp("^" + D + "$"),
							H = {
								ID: new RegExp("^#(" + D + ")"),
								CLASS: new RegExp("^\\.(" + D + ")"),
								TAG: new RegExp("^(" + D + "|[*])"),
								ATTR: new RegExp("^" + M),
								PSEUDO: new RegExp("^" + B),
								CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + _ + "*(even|odd|(([+-]|)(\\d*)n|)" + _ + "*(?:([+-]|)" + _ + "*(\\d+)|))" + _ + "*\\)|)", "i"),
								bool: new RegExp("^(?:" + k + ")$", "i"),
								needsContext: new RegExp("^" + _ + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + _ + "*((?:-\\d)?\\d*)" + _ + "*\\)|)(?=[^-]|$)", "i")
							},
							q = /^(?:input|select|textarea|button)$/i,
							X = /^h\d$/i,
							G = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
							K = /[+~]/,
							Y = new RegExp("\\\\[\\da-fA-F]{1,6}" + _ + "?|\\\\([^\\r\\n\\f])", "g"),
							Z = function(t, e) {
								var n = "0x" + t.slice(1) - 65536;
								return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
							},
							J = function() {
								lt()
							},
							Q = ft((function(t) {
								return !0 === t.disabled && F(t, "fieldset")
							}), {
								dir: "parentNode",
								next: "legend"
							});
						try {
							g.apply(o = s.call(I.childNodes), I.childNodes), o[I.childNodes.length].nodeType
						} catch (t) {
							g = {
								apply: function(t, e) {
									R.apply(t, s.call(e))
								},
								call: function(t) {
									R.apply(t, s.call(arguments, 1))
								}
							}
						}

						function $(t, e, n, r) {
							var i, o, a, s, c, u, d, p = e && e.ownerDocument,
								y = e ? e.nodeType : 9;
							if (n = n || [], "string" != typeof t || !t || 1 !== y && 9 !== y && 11 !== y) return n;
							if (!r && (lt(e), e = e || l, h)) {
								if (11 !== y && (c = G.exec(t)))
									if (i = c[1]) {
										if (9 === y) {
											if (!(a = e.getElementById(i))) return n;
											if (a.id === i) return g.call(n, a), n
										} else if (p && (a = p.getElementById(i)) && $.contains(e, a) && a.id === i) return g.call(n, a), n
									} else {
										if (c[2]) return g.apply(n, e.getElementsByTagName(t)), n;
										if ((i = c[3]) && e.getElementsByClassName) return g.apply(n, e.getElementsByClassName(i)), n
									} if (!(S[t + " "] || f && f.test(t))) {
									if (d = t, p = e, 1 === y && (W.test(t) || z.test(t))) {
										for ((p = K.test(t) && st(e.parentNode) || e) == e && v.scope || ((s = e.getAttribute("id")) ? s = T.escapeSelector(s) : e.setAttribute("id", s = m)), o = (u = ut(t)).length; o--;) u[o] = (s ? "#" + s : ":scope") + " " + ht(u[o]);
										d = u.join(",")
									}
									try {
										return g.apply(n, p.querySelectorAll(d)), n
									} catch (e) {
										S(t, !0)
									} finally {
										s === m && e.removeAttribute("id")
									}
								}
							}
							return yt(t.replace(E, "$1"), e, n, r)
						}

						function tt() {
							var t = [];
							return function n(r, i) {
								return t.push(r + " ") > e.cacheLength && delete n[t.shift()], n[r + " "] = i
							}
						}

						function et(t) {
							return t[m] = !0, t
						}

						function nt(t) {
							var e = l.createElement("fieldset");
							try {
								return !!t(e)
							} catch (t) {
								return !1
							} finally {
								e.parentNode && e.parentNode.removeChild(e), e = null
							}
						}

						function rt(t) {
							return function(e) {
								return F(e, "input") && e.type === t
							}
						}

						function it(t) {
							return function(e) {
								return (F(e, "input") || F(e, "button")) && e.type === t
							}
						}

						function ot(t) {
							return function(e) {
								return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && Q(e) === t : e.disabled === t : "label" in e && e.disabled === t
							}
						}

						function at(t) {
							return et((function(e) {
								return e = +e, et((function(n, r) {
									for (var i, o = t([], n.length, e), a = o.length; a--;) n[i = o[a]] && (n[i] = !(r[i] = n[i]))
								}))
							}))
						}

						function st(t) {
							return t && void 0 !== t.getElementsByTagName && t
						}

						function lt(t) {
							var n, r = t ? t.ownerDocument || t : I;
							return r != l && 9 === r.nodeType && r.documentElement ? (c = (l = r).documentElement, h = !T.isXMLDoc(l), p = c.matches || c.webkitMatchesSelector || c.msMatchesSelector, c.msMatchesSelector && I != l && (n = l.defaultView) && n.top !== n && n.addEventListener("unload", J), v.getById = nt((function(t) {
								return c.appendChild(t).id = T.expando, !l.getElementsByName || !l.getElementsByName(T.expando).length
							})), v.disconnectedMatch = nt((function(t) {
								return p.call(t, "*")
							})), v.scope = nt((function() {
								return l.querySelectorAll(":scope")
							})), v.cssHas = nt((function() {
								try {
									return l.querySelector(":has(*,:jqfake)"), !1
								} catch (t) {
									return !0
								}
							})), v.getById ? (e.filter.ID = function(t) {
								var e = t.replace(Y, Z);
								return function(t) {
									return t.getAttribute("id") === e
								}
							}, e.find.ID = function(t, e) {
								if (void 0 !== e.getElementById && h) {
									var n = e.getElementById(t);
									return n ? [n] : []
								}
							}) : (e.filter.ID = function(t) {
								var e = t.replace(Y, Z);
								return function(t) {
									var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
									return n && n.value === e
								}
							}, e.find.ID = function(t, e) {
								if (void 0 !== e.getElementById && h) {
									var n, r, i, o = e.getElementById(t);
									if (o) {
										if ((n = o.getAttributeNode("id")) && n.value === t) return [o];
										for (i = e.getElementsByName(t), r = 0; o = i[r++];)
											if ((n = o.getAttributeNode("id")) && n.value === t) return [o]
									}
									return []
								}
							}), e.find.TAG = function(t, e) {
								return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : e.querySelectorAll(t)
							}, e.find.CLASS = function(t, e) {
								if (void 0 !== e.getElementsByClassName && h) return e.getElementsByClassName(t)
							}, f = [], nt((function(t) {
								var e;
								c.appendChild(t).innerHTML = "<a id='" + m + "' href='' disabled='disabled'></a><select id='" + m + "-\r\\' disabled='disabled'><option selected=''></option></select>", t.querySelectorAll("[selected]").length || f.push("\\[" + _ + "*(?:value|" + k + ")"), t.querySelectorAll("[id~=" + m + "-]").length || f.push("~="), t.querySelectorAll("a#" + m + "+*").length || f.push(".#.+[+~]"), t.querySelectorAll(":checked").length || f.push(":checked"), (e = l.createElement("input")).setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), c.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && f.push(":enabled", ":disabled"), (e = l.createElement("input")).setAttribute("name", ""), t.appendChild(e), t.querySelectorAll("[name='']").length || f.push("\\[" + _ + "*name" + _ + "*=" + _ + "*(?:''|\"\")")
							})), v.cssHas || f.push(":has"), f = f.length && new RegExp(f.join("|")), O = function(t, e) {
								if (t === e) return a = !0, 0;
								var n = !t.compareDocumentPosition - !e.compareDocumentPosition;
								return n || (1 & (n = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !v.sortDetached && e.compareDocumentPosition(t) === n ? t === l || t.ownerDocument == I && $.contains(I, t) ? -1 : e === l || e.ownerDocument == I && $.contains(I, e) ? 1 : i ? u.call(i, t) - u.call(i, e) : 0 : 4 & n ? -1 : 1)
							}, l) : l
						}
						for (t in $.matches = function(t, e) {
								return $(t, null, null, e)
							}, $.matchesSelector = function(t, e) {
								if (lt(t), h && !S[e + " "] && (!f || !f.test(e))) try {
									var n = p.call(t, e);
									if (n || v.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n
								} catch (t) {
									S(e, !0)
								}
								return $(e, l, null, [t]).length > 0
							}, $.contains = function(t, e) {
								return (t.ownerDocument || t) != l && lt(t), T.contains(t, e)
							}, $.attr = function(t, n) {
								(t.ownerDocument || t) != l && lt(t);
								var r = e.attrHandle[n.toLowerCase()],
									i = r && d.call(e.attrHandle, n.toLowerCase()) ? r(t, n, !h) : void 0;
								return void 0 !== i ? i : t.getAttribute(n)
							}, $.error = function(t) {
								throw new Error("Syntax error, unrecognized expression: " + t)
							}, T.uniqueSort = function(t) {
								var e, n = [],
									r = 0,
									o = 0;
								if (a = !v.sortStable, i = !v.sortStable && s.call(t, 0), j.call(t, O), a) {
									for (; e = t[o++];) e === t[o] && (r = n.push(o));
									for (; r--;) A.call(t, n[r], 1)
								}
								return i = null, t
							}, T.fn.uniqueSort = function() {
								return this.pushStack(T.uniqueSort(s.apply(this)))
							}, e = T.expr = {
								cacheLength: 50,
								createPseudo: et,
								match: H,
								attrHandle: {},
								find: {},
								relative: {
									">": {
										dir: "parentNode",
										first: !0
									},
									" ": {
										dir: "parentNode"
									},
									"+": {
										dir: "previousSibling",
										first: !0
									},
									"~": {
										dir: "previousSibling"
									}
								},
								preFilter: {
									ATTR: function(t) {
										return t[1] = t[1].replace(Y, Z), t[3] = (t[3] || t[4] || t[5] || "").replace(Y, Z), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
									},
									CHILD: function(t) {
										return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || $.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && $.error(t[0]), t
									},
									PSEUDO: function(t) {
										var e, n = !t[6] && t[2];
										return H.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && V.test(n) && (e = ut(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
									}
								},
								filter: {
									TAG: function(t) {
										var e = t.replace(Y, Z).toLowerCase();
										return "*" === t ? function() {
											return !0
										} : function(t) {
											return F(t, e)
										}
									},
									CLASS: function(t) {
										var e = x[t + " "];
										return e || (e = new RegExp("(^|" + _ + ")" + t + "(" + _ + "|$)")) && x(t, (function(t) {
											return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
										}))
									},
									ATTR: function(t, e, n) {
										return function(r) {
											var i = $.attr(r, t);
											return null == i ? "!=" === e : !e || (i += "", "=" === e ? i === n : "!=" === e ? i !== n : "^=" === e ? n && 0 === i.indexOf(n) : "*=" === e ? n && i.indexOf(n) > -1 : "$=" === e ? n && i.slice(-n.length) === n : "~=" === e ? (" " + i.replace(N, " ") + " ").indexOf(n) > -1 : "|=" === e && (i === n || i.slice(0, n.length + 1) === n + "-"))
										}
									},
									CHILD: function(t, e, n, r, i) {
										var o = "nth" !== t.slice(0, 3),
											a = "last" !== t.slice(-4),
											s = "of-type" === e;
										return 1 === r && 0 === i ? function(t) {
											return !!t.parentNode
										} : function(e, n, l) {
											var c, u, h, f, d, p = o !== a ? "nextSibling" : "previousSibling",
												g = e.parentNode,
												v = s && e.nodeName.toLowerCase(),
												b = !l && !s,
												x = !1;
											if (g) {
												if (o) {
													for (; p;) {
														for (h = e; h = h[p];)
															if (s ? F(h, v) : 1 === h.nodeType) return !1;
														d = p = "only" === t && !d && "nextSibling"
													}
													return !0
												}
												if (d = [a ? g.firstChild : g.lastChild], a && b) {
													for (x = (f = (c = (u = g[m] || (g[m] = {}))[t] || [])[0] === y && c[1]) && c[2], h = f && g.childNodes[f]; h = ++f && h && h[p] || (x = f = 0) || d.pop();)
														if (1 === h.nodeType && ++x && h === e) {
															u[t] = [y, f, x];
															break
														}
												} else if (b && (x = f = (c = (u = e[m] || (e[m] = {}))[t] || [])[0] === y && c[1]), !1 === x)
													for (;
														(h = ++f && h && h[p] || (x = f = 0) || d.pop()) && (!(s ? F(h, v) : 1 === h.nodeType) || !++x || (b && ((u = h[m] || (h[m] = {}))[t] = [y, x]), h !== e)););
												return (x -= i) === r || x % r == 0 && x / r >= 0
											}
										}
									},
									PSEUDO: function(t, n) {
										var r, i = e.pseudos[t] || e.setFilters[t.toLowerCase()] || $.error("unsupported pseudo: " + t);
										return i[m] ? i(n) : i.length > 1 ? (r = [t, t, "", n], e.setFilters.hasOwnProperty(t.toLowerCase()) ? et((function(t, e) {
											for (var r, o = i(t, n), a = o.length; a--;) t[r = u.call(t, o[a])] = !(e[r] = o[a])
										})) : function(t) {
											return i(t, 0, r)
										}) : i
									}
								},
								pseudos: {
									not: et((function(t) {
										var e = [],
											n = [],
											r = mt(t.replace(E, "$1"));
										return r[m] ? et((function(t, e, n, i) {
											for (var o, a = r(t, null, i, []), s = t.length; s--;)(o = a[s]) && (t[s] = !(e[s] = o))
										})) : function(t, i, o) {
											return e[0] = t, r(e, null, o, n), e[0] = null, !n.pop()
										}
									})),
									has: et((function(t) {
										return function(e) {
											return $(t, e).length > 0
										}
									})),
									contains: et((function(t) {
										return t = t.replace(Y, Z),
											function(e) {
												return (e.textContent || T.text(e)).indexOf(t) > -1
											}
									})),
									lang: et((function(t) {
										return U.test(t || "") || $.error("unsupported lang: " + t), t = t.replace(Y, Z).toLowerCase(),
											function(e) {
												var n;
												do {
													if (n = h ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
												} while ((e = e.parentNode) && 1 === e.nodeType);
												return !1
											}
									})),
									target: function(t) {
										var e = r.location && r.location.hash;
										return e && e.slice(1) === t.id
									},
									root: function(t) {
										return t === c
									},
									focus: function(t) {
										return t === function() {
											try {
												return l.activeElement
											} catch (t) {}
										}() && l.hasFocus() && !!(t.type || t.href || ~t.tabIndex)
									},
									enabled: ot(!1),
									disabled: ot(!0),
									checked: function(t) {
										return F(t, "input") && !!t.checked || F(t, "option") && !!t.selected
									},
									selected: function(t) {
										return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
									},
									empty: function(t) {
										for (t = t.firstChild; t; t = t.nextSibling)
											if (t.nodeType < 6) return !1;
										return !0
									},
									parent: function(t) {
										return !e.pseudos.empty(t)
									},
									header: function(t) {
										return X.test(t.nodeName)
									},
									input: function(t) {
										return q.test(t.nodeName)
									},
									button: function(t) {
										return F(t, "input") && "button" === t.type || F(t, "button")
									},
									text: function(t) {
										var e;
										return F(t, "input") && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
									},
									first: at((function() {
										return [0]
									})),
									last: at((function(t, e) {
										return [e - 1]
									})),
									eq: at((function(t, e, n) {
										return [n < 0 ? n + e : n]
									})),
									even: at((function(t, e) {
										for (var n = 0; n < e; n += 2) t.push(n);
										return t
									})),
									odd: at((function(t, e) {
										for (var n = 1; n < e; n += 2) t.push(n);
										return t
									})),
									lt: at((function(t, e, n) {
										var r;
										for (r = n < 0 ? n + e : n > e ? e : n; --r >= 0;) t.push(r);
										return t
									})),
									gt: at((function(t, e, n) {
										for (var r = n < 0 ? n + e : n; ++r < e;) t.push(r);
										return t
									}))
								}
							}, e.pseudos.nth = e.pseudos.eq, {
								radio: !0,
								checkbox: !0,
								file: !0,
								password: !0,
								image: !0
							}) e.pseudos[t] = rt(t);
						for (t in {
								submit: !0,
								reset: !0
							}) e.pseudos[t] = it(t);

						function ct() {}

						function ut(t, n) {
							var r, i, o, a, s, l, c, u = w[t + " "];
							if (u) return n ? 0 : u.slice(0);
							for (s = t, l = [], c = e.preFilter; s;) {
								for (a in r && !(i = L.exec(s)) || (i && (s = s.slice(i[0].length) || s), l.push(o = [])), r = !1, (i = z.exec(s)) && (r = i.shift(), o.push({
										value: r,
										type: i[0].replace(E, " ")
									}), s = s.slice(r.length)), e.filter) !(i = H[a].exec(s)) || c[a] && !(i = c[a](i)) || (r = i.shift(), o.push({
									value: r,
									type: a,
									matches: i
								}), s = s.slice(r.length));
								if (!r) break
							}
							return n ? s.length : s ? $.error(t) : w(t, l).slice(0)
						}

						function ht(t) {
							for (var e = 0, n = t.length, r = ""; e < n; e++) r += t[e].value;
							return r
						}

						function ft(t, e, n) {
							var r = e.dir,
								i = e.next,
								o = i || r,
								a = n && "parentNode" === o,
								s = b++;
							return e.first ? function(e, n, i) {
								for (; e = e[r];)
									if (1 === e.nodeType || a) return t(e, n, i);
								return !1
							} : function(e, n, l) {
								var c, u, h = [y, s];
								if (l) {
									for (; e = e[r];)
										if ((1 === e.nodeType || a) && t(e, n, l)) return !0
								} else
									for (; e = e[r];)
										if (1 === e.nodeType || a)
											if (u = e[m] || (e[m] = {}), i && F(e, i)) e = e[r] || e;
											else {
												if ((c = u[o]) && c[0] === y && c[1] === s) return h[2] = c[2];
												if (u[o] = h, h[2] = t(e, n, l)) return !0
											} return !1
							}
						}

						function dt(t) {
							return t.length > 1 ? function(e, n, r) {
								for (var i = t.length; i--;)
									if (!t[i](e, n, r)) return !1;
								return !0
							} : t[0]
						}

						function pt(t, e, n, r, i) {
							for (var o, a = [], s = 0, l = t.length, c = null != e; s < l; s++)(o = t[s]) && (n && !n(o, r, i) || (a.push(o), c && e.push(s)));
							return a
						}

						function gt(t, e, n, r, i, o) {
							return r && !r[m] && (r = gt(r)), i && !i[m] && (i = gt(i, o)), et((function(o, a, s, l) {
								var c, h, f, d, p = [],
									v = [],
									m = a.length,
									y = o || function(t, e, n) {
										for (var r = 0, i = e.length; r < i; r++) $(t, e[r], n);
										return n
									}(e || "*", s.nodeType ? [s] : s, []),
									b = !t || !o && e ? y : pt(y, p, t, s, l);
								if (n ? n(b, d = i || (o ? t : m || r) ? [] : a, s, l) : d = b, r)
									for (c = pt(d, v), r(c, [], s, l), h = c.length; h--;)(f = c[h]) && (d[v[h]] = !(b[v[h]] = f));
								if (o) {
									if (i || t) {
										if (i) {
											for (c = [], h = d.length; h--;)(f = d[h]) && c.push(b[h] = f);
											i(null, d = [], c, l)
										}
										for (h = d.length; h--;)(f = d[h]) && (c = i ? u.call(o, f) : p[h]) > -1 && (o[c] = !(a[c] = f))
									}
								} else d = pt(d === a ? d.splice(m, d.length) : d), i ? i(null, a, d, l) : g.apply(a, d)
							}))
						}

						function vt(t) {
							for (var r, i, o, a = t.length, s = e.relative[t[0].type], l = s || e.relative[" "], c = s ? 1 : 0, h = ft((function(t) {
									return t === r
								}), l, !0), f = ft((function(t) {
									return u.call(r, t) > -1
								}), l, !0), d = [function(t, e, i) {
									var o = !s && (i || e != n) || ((r = e).nodeType ? h(t, e, i) : f(t, e, i));
									return r = null, o
								}]; c < a; c++)
								if (i = e.relative[t[c].type]) d = [ft(dt(d), i)];
								else {
									if ((i = e.filter[t[c].type].apply(null, t[c].matches))[m]) {
										for (o = ++c; o < a && !e.relative[t[o].type]; o++);
										return gt(c > 1 && dt(d), c > 1 && ht(t.slice(0, c - 1).concat({
											value: " " === t[c - 2].type ? "*" : ""
										})).replace(E, "$1"), i, c < o && vt(t.slice(c, o)), o < a && vt(t = t.slice(o)), o < a && ht(t))
									}
									d.push(i)
								} return dt(d)
						}

						function mt(t, r) {
							var i, o = [],
								a = [],
								s = C[t + " "];
							if (!s) {
								for (r || (r = ut(t)), i = r.length; i--;)(s = vt(r[i]))[m] ? o.push(s) : a.push(s);
								s = C(t, function(t, r) {
									var i = r.length > 0,
										o = t.length > 0,
										a = function(a, s, c, u, f) {
											var d, p, v, m = 0,
												b = "0",
												x = a && [],
												w = [],
												C = n,
												S = a || o && e.find.TAG("*", f),
												O = y += null == C ? 1 : Math.random() || .1,
												k = S.length;
											for (f && (n = s == l || s || f); b !== k && null != (d = S[b]); b++) {
												if (o && d) {
													for (p = 0, s || d.ownerDocument == l || (lt(d), c = !h); v = t[p++];)
														if (v(d, s || l, c)) {
															g.call(u, d);
															break
														} f && (y = O)
												}
												i && ((d = !v && d) && m--, a && x.push(d))
											}
											if (m += b, i && b !== m) {
												for (p = 0; v = r[p++];) v(x, w, s, c);
												if (a) {
													if (m > 0)
														for (; b--;) x[b] || w[b] || (w[b] = P.call(u));
													w = pt(w)
												}
												g.apply(u, w), f && !a && w.length > 0 && m + r.length > 1 && T.uniqueSort(u)
											}
											return f && (y = O, n = C), x
										};
									return i ? et(a) : a
								}(a, o)), s.selector = t
							}
							return s
						}

						function yt(t, n, r, i) {
							var o, a, s, l, c, u = "function" == typeof t && t,
								f = !i && ut(t = u.selector || t);
							if (r = r || [], 1 === f.length) {
								if ((a = f[0] = f[0].slice(0)).length > 2 && "ID" === (s = a[0]).type && 9 === n.nodeType && h && e.relative[a[1].type]) {
									if (!(n = (e.find.ID(s.matches[0].replace(Y, Z), n) || [])[0])) return r;
									u && (n = n.parentNode), t = t.slice(a.shift().value.length)
								}
								for (o = H.needsContext.test(t) ? 0 : a.length; o-- && (s = a[o], !e.relative[l = s.type]);)
									if ((c = e.find[l]) && (i = c(s.matches[0].replace(Y, Z), K.test(a[0].type) && st(n.parentNode) || n))) {
										if (a.splice(o, 1), !(t = i.length && ht(a))) return g.apply(r, i), r;
										break
									}
							}
							return (u || mt(t, f))(i, n, !h, r, !n || K.test(t) && st(n.parentNode) || n), r
						}
						ct.prototype = e.filters = e.pseudos, e.setFilters = new ct, v.sortStable = m.split("").sort(O).join("") === m, lt(), v.sortDetached = nt((function(t) {
							return 1 & t.compareDocumentPosition(l.createElement("fieldset"))
						})), T.find = $, T.expr[":"] = T.expr.pseudos, T.unique = T.uniqueSort, $.compile = mt, $.select = yt, $.setDocument = lt, $.tokenize = ut, $.escape = T.escapeSelector, $.getText = T.text, $.isXML = T.isXMLDoc, $.selectors = T.expr, $.support = T.support, $.uniqueSort = T.uniqueSort
					}();
					var B = function(t, e, n) {
							for (var r = [], i = void 0 !== n;
								(t = t[e]) && 9 !== t.nodeType;)
								if (1 === t.nodeType) {
									if (i && T(t).is(n)) break;
									r.push(t)
								} return r
						},
						N = function(t, e) {
							for (var n = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && n.push(t);
							return n
						},
						L = T.expr.match.needsContext,
						z = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

					function W(t, e, n) {
						return m(e) ? T.grep(t, (function(t, r) {
							return !!e.call(t, r, t) !== n
						})) : e.nodeType ? T.grep(t, (function(t) {
							return t === e !== n
						})) : "string" != typeof e ? T.grep(t, (function(t) {
							return u.call(e, t) > -1 !== n
						})) : T.filter(e, t, n)
					}
					T.filter = function(t, e, n) {
						var r = e[0];
						return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === r.nodeType ? T.find.matchesSelector(r, t) ? [r] : [] : T.find.matches(t, T.grep(e, (function(t) {
							return 1 === t.nodeType
						})))
					}, T.fn.extend({
						find: function(t) {
							var e, n, r = this.length,
								i = this;
							if ("string" != typeof t) return this.pushStack(T(t).filter((function() {
								for (e = 0; e < r; e++)
									if (T.contains(i[e], this)) return !0
							})));
							for (n = this.pushStack([]), e = 0; e < r; e++) T.find(t, i[e], n);
							return r > 1 ? T.uniqueSort(n) : n
						},
						filter: function(t) {
							return this.pushStack(W(this, t || [], !1))
						},
						not: function(t) {
							return this.pushStack(W(this, t || [], !0))
						},
						is: function(t) {
							return !!W(this, "string" == typeof t && L.test(t) ? T(t) : t || [], !1).length
						}
					});
					var V, U = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
					(T.fn.init = function(t, e, n) {
						var r, i;
						if (!t) return this;
						if (n = n || V, "string" == typeof t) {
							if (!(r = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : U.exec(t)) || !r[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
							if (r[1]) {
								if (e = e instanceof T ? e[0] : e, T.merge(this, T.parseHTML(r[1], e && e.nodeType ? e.ownerDocument || e : b, !0)), z.test(r[1]) && T.isPlainObject(e))
									for (r in e) m(this[r]) ? this[r](e[r]) : this.attr(r, e[r]);
								return this
							}
							return (i = b.getElementById(r[2])) && (this[0] = i, this.length = 1), this
						}
						return t.nodeType ? (this[0] = t, this.length = 1, this) : m(t) ? void 0 !== n.ready ? n.ready(t) : t(T) : T.makeArray(t, this)
					}).prototype = T.fn, V = T(b);
					var H = /^(?:parents|prev(?:Until|All))/,
						q = {
							children: !0,
							contents: !0,
							next: !0,
							prev: !0
						};

					function X(t, e) {
						for (;
							(t = t[e]) && 1 !== t.nodeType;);
						return t
					}
					T.fn.extend({
						has: function(t) {
							var e = T(t, this),
								n = e.length;
							return this.filter((function() {
								for (var t = 0; t < n; t++)
									if (T.contains(this, e[t])) return !0
							}))
						},
						closest: function(t, e) {
							var n, r = 0,
								i = this.length,
								o = [],
								a = "string" != typeof t && T(t);
							if (!L.test(t))
								for (; r < i; r++)
									for (n = this[r]; n && n !== e; n = n.parentNode)
										if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && T.find.matchesSelector(n, t))) {
											o.push(n);
											break
										} return this.pushStack(o.length > 1 ? T.uniqueSort(o) : o)
						},
						index: function(t) {
							return t ? "string" == typeof t ? u.call(T(t), this[0]) : u.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
						},
						add: function(t, e) {
							return this.pushStack(T.uniqueSort(T.merge(this.get(), T(t, e))))
						},
						addBack: function(t) {
							return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
						}
					}), T.each({
						parent: function(t) {
							var e = t.parentNode;
							return e && 11 !== e.nodeType ? e : null
						},
						parents: function(t) {
							return B(t, "parentNode")
						},
						parentsUntil: function(t, e, n) {
							return B(t, "parentNode", n)
						},
						next: function(t) {
							return X(t, "nextSibling")
						},
						prev: function(t) {
							return X(t, "previousSibling")
						},
						nextAll: function(t) {
							return B(t, "nextSibling")
						},
						prevAll: function(t) {
							return B(t, "previousSibling")
						},
						nextUntil: function(t, e, n) {
							return B(t, "nextSibling", n)
						},
						prevUntil: function(t, e, n) {
							return B(t, "previousSibling", n)
						},
						siblings: function(t) {
							return N((t.parentNode || {}).firstChild, t)
						},
						children: function(t) {
							return N(t.firstChild)
						},
						contents: function(t) {
							return null != t.contentDocument && a(t.contentDocument) ? t.contentDocument : (F(t, "template") && (t = t.content || t), T.merge([], t.childNodes))
						}
					}, (function(t, e) {
						T.fn[t] = function(n, r) {
							var i = T.map(this, e, n);
							return "Until" !== t.slice(-5) && (r = n), r && "string" == typeof r && (i = T.filter(r, i)), this.length > 1 && (q[t] || T.uniqueSort(i), H.test(t) && i.reverse()), this.pushStack(i)
						}
					}));
					var G = /[^\x20\t\r\n\f]+/g;

					function K(t) {
						return t
					}

					function Y(t) {
						throw t
					}

					function Z(t, e, n, r) {
						var i;
						try {
							t && m(i = t.promise) ? i.call(t).done(e).fail(n) : t && m(i = t.then) ? i.call(t, e, n) : e.apply(void 0, [t].slice(r))
						} catch (t) {
							n.apply(void 0, [t])
						}
					}
					T.Callbacks = function(t) {
						t = "string" == typeof t ? function(t) {
							var e = {};
							return T.each(t.match(G) || [], (function(t, n) {
								e[n] = !0
							})), e
						}(t) : T.extend({}, t);
						var e, n, r, i, o = [],
							a = [],
							s = -1,
							l = function() {
								for (i = i || t.once, r = e = !0; a.length; s = -1)
									for (n = a.shift(); ++s < o.length;) !1 === o[s].apply(n[0], n[1]) && t.stopOnFalse && (s = o.length, n = !1);
								t.memory || (n = !1), e = !1, i && (o = n ? [] : "")
							},
							c = {
								add: function() {
									return o && (n && !e && (s = o.length - 1, a.push(n)), function e(n) {
										T.each(n, (function(n, r) {
											m(r) ? t.unique && c.has(r) || o.push(r) : r && r.length && "string" !== C(r) && e(r)
										}))
									}(arguments), n && !e && l()), this
								},
								remove: function() {
									return T.each(arguments, (function(t, e) {
										for (var n;
											(n = T.inArray(e, o, n)) > -1;) o.splice(n, 1), n <= s && s--
									})), this
								},
								has: function(t) {
									return t ? T.inArray(t, o) > -1 : o.length > 0
								},
								empty: function() {
									return o && (o = []), this
								},
								disable: function() {
									return i = a = [], o = n = "", this
								},
								disabled: function() {
									return !o
								},
								lock: function() {
									return i = a = [], n || e || (o = n = ""), this
								},
								locked: function() {
									return !!i
								},
								fireWith: function(t, n) {
									return i || (n = [t, (n = n || []).slice ? n.slice() : n], a.push(n), e || l()), this
								},
								fire: function() {
									return c.fireWith(this, arguments), this
								},
								fired: function() {
									return !!r
								}
							};
						return c
					}, T.extend({
						Deferred: function(t) {
							var e = [
									["notify", "progress", T.Callbacks("memory"), T.Callbacks("memory"), 2],
									["resolve", "done", T.Callbacks("once memory"), T.Callbacks("once memory"), 0, "resolved"],
									["reject", "fail", T.Callbacks("once memory"), T.Callbacks("once memory"), 1, "rejected"]
								],
								n = "pending",
								i = {
									state: function() {
										return n
									},
									always: function() {
										return o.done(arguments).fail(arguments), this
									},
									catch: function(t) {
										return i.then(null, t)
									},
									pipe: function() {
										var t = arguments;
										return T.Deferred((function(n) {
											T.each(e, (function(e, r) {
												var i = m(t[r[4]]) && t[r[4]];
												o[r[1]]((function() {
													var t = i && i.apply(this, arguments);
													t && m(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[r[0] + "With"](this, i ? [t] : arguments)
												}))
											})), t = null
										})).promise()
									},
									then: function(t, n, i) {
										var o = 0;

										function a(t, e, n, i) {
											return function() {
												var s = this,
													l = arguments,
													c = function() {
														var r, c;
														if (!(t < o)) {
															if ((r = n.apply(s, l)) === e.promise()) throw new TypeError("Thenable self-resolution");
															c = r && ("object" == typeof r || "function" == typeof r) && r.then, m(c) ? i ? c.call(r, a(o, e, K, i), a(o, e, Y, i)) : (o++, c.call(r, a(o, e, K, i), a(o, e, Y, i), a(o, e, K, e.notifyWith))) : (n !== K && (s = void 0, l = [r]), (i || e.resolveWith)(s, l))
														}
													},
													u = i ? c : function() {
														try {
															c()
														} catch (r) {
															T.Deferred.exceptionHook && T.Deferred.exceptionHook(r, u.error), t + 1 >= o && (n !== Y && (s = void 0, l = [r]), e.rejectWith(s, l))
														}
													};
												t ? u() : (T.Deferred.getErrorHook ? u.error = T.Deferred.getErrorHook() : T.Deferred.getStackHook && (u.error = T.Deferred.getStackHook()), r.setTimeout(u))
											}
										}
										return T.Deferred((function(r) {
											e[0][3].add(a(0, r, m(i) ? i : K, r.notifyWith)), e[1][3].add(a(0, r, m(t) ? t : K)), e[2][3].add(a(0, r, m(n) ? n : Y))
										})).promise()
									},
									promise: function(t) {
										return null != t ? T.extend(t, i) : i
									}
								},
								o = {};
							return T.each(e, (function(t, r) {
								var a = r[2],
									s = r[5];
								i[r[1]] = a.add, s && a.add((function() {
									n = s
								}), e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock), a.add(r[3].fire), o[r[0]] = function() {
									return o[r[0] + "With"](this === o ? void 0 : this, arguments), this
								}, o[r[0] + "With"] = a.fireWith
							})), i.promise(o), t && t.call(o, o), o
						},
						when: function(t) {
							var e = arguments.length,
								n = e,
								r = Array(n),
								i = s.call(arguments),
								o = T.Deferred(),
								a = function(t) {
									return function(n) {
										r[t] = this, i[t] = arguments.length > 1 ? s.call(arguments) : n, --e || o.resolveWith(r, i)
									}
								};
							if (e <= 1 && (Z(t, o.done(a(n)).resolve, o.reject, !e), "pending" === o.state() || m(i[n] && i[n].then))) return o.then();
							for (; n--;) Z(i[n], a(n), o.reject);
							return o.promise()
						}
					});
					var J = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
					T.Deferred.exceptionHook = function(t, e) {
						r.console && r.console.warn && t && J.test(t.name) && r.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
					}, T.readyException = function(t) {
						r.setTimeout((function() {
							throw t
						}))
					};
					var Q = T.Deferred();

					function $() {
						b.removeEventListener("DOMContentLoaded", $), r.removeEventListener("load", $), T.ready()
					}
					T.fn.ready = function(t) {
						return Q.then(t).catch((function(t) {
							T.readyException(t)
						})), this
					}, T.extend({
						isReady: !1,
						readyWait: 1,
						ready: function(t) {
							(!0 === t ? --T.readyWait : T.isReady) || (T.isReady = !0, !0 !== t && --T.readyWait > 0 || Q.resolveWith(b, [T]))
						}
					}), T.ready.then = Q.then, "complete" === b.readyState || "loading" !== b.readyState && !b.documentElement.doScroll ? r.setTimeout(T.ready) : (b.addEventListener("DOMContentLoaded", $), r.addEventListener("load", $));
					var tt = function(t, e, n, r, i, o, a) {
							var s = 0,
								l = t.length,
								c = null == n;
							if ("object" === C(n))
								for (s in i = !0, n) tt(t, e, s, n[s], !0, o, a);
							else if (void 0 !== r && (i = !0, m(r) || (a = !0), c && (a ? (e.call(t, r), e = null) : (c = e, e = function(t, e, n) {
									return c.call(T(t), n)
								})), e))
								for (; s < l; s++) e(t[s], n, a ? r : r.call(t[s], s, e(t[s], n)));
							return i ? t : c ? e.call(t) : l ? e(t[0], n) : o
						},
						et = /^-ms-/,
						nt = /-([a-z])/g;

					function rt(t, e) {
						return e.toUpperCase()
					}

					function it(t) {
						return t.replace(et, "ms-").replace(nt, rt)
					}
					var ot = function(t) {
						return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
					};

					function at() {
						this.expando = T.expando + at.uid++
					}
					at.uid = 1, at.prototype = {
						cache: function(t) {
							var e = t[this.expando];
							return e || (e = {}, ot(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
								value: e,
								configurable: !0
							}))), e
						},
						set: function(t, e, n) {
							var r, i = this.cache(t);
							if ("string" == typeof e) i[it(e)] = n;
							else
								for (r in e) i[it(r)] = e[r];
							return i
						},
						get: function(t, e) {
							return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][it(e)]
						},
						access: function(t, e, n) {
							return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e)
						},
						remove: function(t, e) {
							var n, r = t[this.expando];
							if (void 0 !== r) {
								if (void 0 !== e) {
									n = (e = Array.isArray(e) ? e.map(it) : (e = it(e)) in r ? [e] : e.match(G) || []).length;
									for (; n--;) delete r[e[n]]
								}(void 0 === e || T.isEmptyObject(r)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
							}
						},
						hasData: function(t) {
							var e = t[this.expando];
							return void 0 !== e && !T.isEmptyObject(e)
						}
					};
					var st = new at,
						lt = new at,
						ct = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
						ut = /[A-Z]/g;

					function ht(t, e, n) {
						var r;
						if (void 0 === n && 1 === t.nodeType)
							if (r = "data-" + e.replace(ut, "-$&").toLowerCase(), "string" == typeof(n = t.getAttribute(r))) {
								try {
									n = function(t) {
										return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : ct.test(t) ? JSON.parse(t) : t)
									}(n)
								} catch (t) {}
								lt.set(t, e, n)
							} else n = void 0;
						return n
					}
					T.extend({
						hasData: function(t) {
							return lt.hasData(t) || st.hasData(t)
						},
						data: function(t, e, n) {
							return lt.access(t, e, n)
						},
						removeData: function(t, e) {
							lt.remove(t, e)
						},
						_data: function(t, e, n) {
							return st.access(t, e, n)
						},
						_removeData: function(t, e) {
							st.remove(t, e)
						}
					}), T.fn.extend({
						data: function(t, e) {
							var n, r, i, o = this[0],
								a = o && o.attributes;
							if (void 0 === t) {
								if (this.length && (i = lt.get(o), 1 === o.nodeType && !st.get(o, "hasDataAttrs"))) {
									for (n = a.length; n--;) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = it(r.slice(5)), ht(o, r, i[r]));
									st.set(o, "hasDataAttrs", !0)
								}
								return i
							}
							return "object" == typeof t ? this.each((function() {
								lt.set(this, t)
							})) : tt(this, (function(e) {
								var n;
								if (o && void 0 === e) return void 0 !== (n = lt.get(o, t)) || void 0 !== (n = ht(o, t)) ? n : void 0;
								this.each((function() {
									lt.set(this, t, e)
								}))
							}), null, e, arguments.length > 1, null, !0)
						},
						removeData: function(t) {
							return this.each((function() {
								lt.remove(this, t)
							}))
						}
					}), T.extend({
						queue: function(t, e, n) {
							var r;
							if (t) return e = (e || "fx") + "queue", r = st.get(t, e), n && (!r || Array.isArray(n) ? r = st.access(t, e, T.makeArray(n)) : r.push(n)), r || []
						},
						dequeue: function(t, e) {
							e = e || "fx";
							var n = T.queue(t, e),
								r = n.length,
								i = n.shift(),
								o = T._queueHooks(t, e);
							"inprogress" === i && (i = n.shift(), r--), i && ("fx" === e && n.unshift("inprogress"), delete o.stop, i.call(t, (function() {
								T.dequeue(t, e)
							}), o)), !r && o && o.empty.fire()
						},
						_queueHooks: function(t, e) {
							var n = e + "queueHooks";
							return st.get(t, n) || st.access(t, n, {
								empty: T.Callbacks("once memory").add((function() {
									st.remove(t, [e + "queue", n])
								}))
							})
						}
					}), T.fn.extend({
						queue: function(t, e) {
							var n = 2;
							return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? T.queue(this[0], t) : void 0 === e ? this : this.each((function() {
								var n = T.queue(this, t, e);
								T._queueHooks(this, t), "fx" === t && "inprogress" !== n[0] && T.dequeue(this, t)
							}))
						},
						dequeue: function(t) {
							return this.each((function() {
								T.dequeue(this, t)
							}))
						},
						clearQueue: function(t) {
							return this.queue(t || "fx", [])
						},
						promise: function(t, e) {
							var n, r = 1,
								i = T.Deferred(),
								o = this,
								a = this.length,
								s = function() {
									--r || i.resolveWith(o, [o])
								};
							for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; a--;)(n = st.get(o[a], t + "queueHooks")) && n.empty && (r++, n.empty.add(s));
							return s(), i.promise(e)
						}
					});
					var ft = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
						dt = new RegExp("^(?:([+-])=|)(" + ft + ")([a-z%]*)$", "i"),
						pt = ["Top", "Right", "Bottom", "Left"],
						gt = b.documentElement,
						vt = function(t) {
							return T.contains(t.ownerDocument, t)
						},
						mt = {
							composed: !0
						};
					gt.getRootNode && (vt = function(t) {
						return T.contains(t.ownerDocument, t) || t.getRootNode(mt) === t.ownerDocument
					});
					var yt = function(t, e) {
						return "none" === (t = e || t).style.display || "" === t.style.display && vt(t) && "none" === T.css(t, "display")
					};

					function bt(t, e, n, r) {
						var i, o, a = 20,
							s = r ? function() {
								return r.cur()
							} : function() {
								return T.css(t, e, "")
							},
							l = s(),
							c = n && n[3] || (T.cssNumber[e] ? "" : "px"),
							u = t.nodeType && (T.cssNumber[e] || "px" !== c && +l) && dt.exec(T.css(t, e));
						if (u && u[3] !== c) {
							for (l /= 2, c = c || u[3], u = +l || 1; a--;) T.style(t, e, u + c), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), u /= o;
							u *= 2, T.style(t, e, u + c), n = n || []
						}
						return n && (u = +u || +l || 0, i = n[1] ? u + (n[1] + 1) * n[2] : +n[2], r && (r.unit = c, r.start = u, r.end = i)), i
					}
					var xt = {};

					function wt(t) {
						var e, n = t.ownerDocument,
							r = t.nodeName,
							i = xt[r];
						return i || (e = n.body.appendChild(n.createElement(r)), i = T.css(e, "display"), e.parentNode.removeChild(e), "none" === i && (i = "block"), xt[r] = i, i)
					}

					function Ct(t, e) {
						for (var n, r, i = [], o = 0, a = t.length; o < a; o++)(r = t[o]).style && (n = r.style.display, e ? ("none" === n && (i[o] = st.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && yt(r) && (i[o] = wt(r))) : "none" !== n && (i[o] = "none", st.set(r, "display", n)));
						for (o = 0; o < a; o++) null != i[o] && (t[o].style.display = i[o]);
						return t
					}
					T.fn.extend({
						show: function() {
							return Ct(this, !0)
						},
						hide: function() {
							return Ct(this)
						},
						toggle: function(t) {
							return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function() {
								yt(this) ? T(this).show() : T(this).hide()
							}))
						}
					});
					var St, Ot, Tt = /^(?:checkbox|radio)$/i,
						kt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
						Ft = /^$|^module$|\/(?:java|ecma)script/i;
					St = b.createDocumentFragment().appendChild(b.createElement("div")), (Ot = b.createElement("input")).setAttribute("type", "radio"), Ot.setAttribute("checked", "checked"), Ot.setAttribute("name", "t"), St.appendChild(Ot), v.checkClone = St.cloneNode(!0).cloneNode(!0).lastChild.checked, St.innerHTML = "<textarea>x</textarea>", v.noCloneChecked = !!St.cloneNode(!0).lastChild.defaultValue, St.innerHTML = "<option></option>", v.option = !!St.lastChild;
					var Pt = {
						thead: [1, "<table>", "</table>"],
						col: [2, "<table><colgroup>", "</colgroup></table>"],
						tr: [2, "<table><tbody>", "</tbody></table>"],
						td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
						_default: [0, "", ""]
					};

					function jt(t, e) {
						var n;
						return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && F(t, e) ? T.merge([t], n) : n
					}

					function At(t, e) {
						for (var n = 0, r = t.length; n < r; n++) st.set(t[n], "globalEval", !e || st.get(e[n], "globalEval"))
					}
					Pt.tbody = Pt.tfoot = Pt.colgroup = Pt.caption = Pt.thead, Pt.th = Pt.td, v.option || (Pt.optgroup = Pt.option = [1, "<select multiple='multiple'>", "</select>"]);
					var _t = /<|&#?\w+;/;

					function Et(t, e, n, r, i) {
						for (var o, a, s, l, c, u, h = e.createDocumentFragment(), f = [], d = 0, p = t.length; d < p; d++)
							if ((o = t[d]) || 0 === o)
								if ("object" === C(o)) T.merge(f, o.nodeType ? [o] : o);
								else if (_t.test(o)) {
							for (a = a || h.appendChild(e.createElement("div")), s = (kt.exec(o) || ["", ""])[1].toLowerCase(), l = Pt[s] || Pt._default, a.innerHTML = l[1] + T.htmlPrefilter(o) + l[2], u = l[0]; u--;) a = a.lastChild;
							T.merge(f, a.childNodes), (a = h.firstChild).textContent = ""
						} else f.push(e.createTextNode(o));
						for (h.textContent = "", d = 0; o = f[d++];)
							if (r && T.inArray(o, r) > -1) i && i.push(o);
							else if (c = vt(o), a = jt(h.appendChild(o), "script"), c && At(a), n)
							for (u = 0; o = a[u++];) Ft.test(o.type || "") && n.push(o);
						return h
					}
					var Dt = /^([^.]*)(?:\.(.+)|)/;

					function Mt() {
						return !0
					}

					function It() {
						return !1
					}

					function Rt(t, e, n, r, i, o) {
						var a, s;
						if ("object" == typeof e) {
							for (s in "string" != typeof n && (r = r || n, n = void 0), e) Rt(t, s, n, r, e[s], o);
							return t
						}
						if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = It;
						else if (!i) return t;
						return 1 === o && (a = i, i = function(t) {
							return T().off(t), a.apply(this, arguments)
						}, i.guid = a.guid || (a.guid = T.guid++)), t.each((function() {
							T.event.add(this, e, i, r, n)
						}))
					}

					function Bt(t, e, n) {
						n ? (st.set(t, e, !1), T.event.add(t, e, {
							namespace: !1,
							handler: function(t) {
								var n, r = st.get(this, e);
								if (1 & t.isTrigger && this[e]) {
									if (r)(T.event.special[e] || {}).delegateType && t.stopPropagation();
									else if (r = s.call(arguments), st.set(this, e, r), this[e](), n = st.get(this, e), st.set(this, e, !1), r !== n) return t.stopImmediatePropagation(), t.preventDefault(), n
								} else r && (st.set(this, e, T.event.trigger(r[0], r.slice(1), this)), t.stopPropagation(), t.isImmediatePropagationStopped = Mt)
							}
						})) : void 0 === st.get(t, e) && T.event.add(t, e, Mt)
					}
					T.event = {
						global: {},
						add: function(t, e, n, r, i) {
							var o, a, s, l, c, u, h, f, d, p, g, v = st.get(t);
							if (ot(t))
								for (n.handler && (n = (o = n).handler, i = o.selector), i && T.find.matchesSelector(gt, i), n.guid || (n.guid = T.guid++), (l = v.events) || (l = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function(e) {
										return void 0 !== T && T.event.triggered !== e.type ? T.event.dispatch.apply(t, arguments) : void 0
									}), c = (e = (e || "").match(G) || [""]).length; c--;) d = g = (s = Dt.exec(e[c]) || [])[1], p = (s[2] || "").split(".").sort(), d && (h = T.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, h = T.event.special[d] || {}, u = T.extend({
									type: d,
									origType: g,
									data: r,
									handler: n,
									guid: n.guid,
									selector: i,
									needsContext: i && T.expr.match.needsContext.test(i),
									namespace: p.join(".")
								}, o), (f = l[d]) || ((f = l[d] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(t, r, p, a) || t.addEventListener && t.addEventListener(d, a)), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = n.guid)), i ? f.splice(f.delegateCount++, 0, u) : f.push(u), T.event.global[d] = !0)
						},
						remove: function(t, e, n, r, i) {
							var o, a, s, l, c, u, h, f, d, p, g, v = st.hasData(t) && st.get(t);
							if (v && (l = v.events)) {
								for (c = (e = (e || "").match(G) || [""]).length; c--;)
									if (d = g = (s = Dt.exec(e[c]) || [])[1], p = (s[2] || "").split(".").sort(), d) {
										for (h = T.event.special[d] || {}, f = l[d = (r ? h.delegateType : h.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = f.length; o--;) u = f[o], !i && g !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || r && r !== u.selector && ("**" !== r || !u.selector) || (f.splice(o, 1), u.selector && f.delegateCount--, h.remove && h.remove.call(t, u));
										a && !f.length && (h.teardown && !1 !== h.teardown.call(t, p, v.handle) || T.removeEvent(t, d, v.handle), delete l[d])
									} else
										for (d in l) T.event.remove(t, d + e[c], n, r, !0);
								T.isEmptyObject(l) && st.remove(t, "handle events")
							}
						},
						dispatch: function(t) {
							var e, n, r, i, o, a, s = new Array(arguments.length),
								l = T.event.fix(t),
								c = (st.get(this, "events") || Object.create(null))[l.type] || [],
								u = T.event.special[l.type] || {};
							for (s[0] = l, e = 1; e < arguments.length; e++) s[e] = arguments[e];
							if (l.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, l)) {
								for (a = T.event.handlers.call(this, l, c), e = 0;
									(i = a[e++]) && !l.isPropagationStopped();)
									for (l.currentTarget = i.elem, n = 0;
										(o = i.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== o.namespace && !l.rnamespace.test(o.namespace) || (l.handleObj = o, l.data = o.data, void 0 !== (r = ((T.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (l.result = r) && (l.preventDefault(), l.stopPropagation()));
								return u.postDispatch && u.postDispatch.call(this, l), l.result
							}
						},
						handlers: function(t, e) {
							var n, r, i, o, a, s = [],
								l = e.delegateCount,
								c = t.target;
							if (l && c.nodeType && !("click" === t.type && t.button >= 1))
								for (; c !== this; c = c.parentNode || this)
									if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
										for (o = [], a = {}, n = 0; n < l; n++) void 0 === a[i = (r = e[n]).selector + " "] && (a[i] = r.needsContext ? T(i, this).index(c) > -1 : T.find(i, this, null, [c]).length), a[i] && o.push(r);
										o.length && s.push({
											elem: c,
											handlers: o
										})
									} return c = this, l < e.length && s.push({
								elem: c,
								handlers: e.slice(l)
							}), s
						},
						addProp: function(t, e) {
							Object.defineProperty(T.Event.prototype, t, {
								enumerable: !0,
								configurable: !0,
								get: m(e) ? function() {
									if (this.originalEvent) return e(this.originalEvent)
								} : function() {
									if (this.originalEvent) return this.originalEvent[t]
								},
								set: function(e) {
									Object.defineProperty(this, t, {
										enumerable: !0,
										configurable: !0,
										writable: !0,
										value: e
									})
								}
							})
						},
						fix: function(t) {
							return t[T.expando] ? t : new T.Event(t)
						},
						special: {
							load: {
								noBubble: !0
							},
							click: {
								setup: function(t) {
									var e = this || t;
									return Tt.test(e.type) && e.click && F(e, "input") && Bt(e, "click", !0), !1
								},
								trigger: function(t) {
									var e = this || t;
									return Tt.test(e.type) && e.click && F(e, "input") && Bt(e, "click"), !0
								},
								_default: function(t) {
									var e = t.target;
									return Tt.test(e.type) && e.click && F(e, "input") && st.get(e, "click") || F(e, "a")
								}
							},
							beforeunload: {
								postDispatch: function(t) {
									void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
								}
							}
						}
					}, T.removeEvent = function(t, e, n) {
						t.removeEventListener && t.removeEventListener(e, n)
					}, T.Event = function(t, e) {
						if (!(this instanceof T.Event)) return new T.Event(t, e);
						t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Mt : It, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && T.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[T.expando] = !0
					}, T.Event.prototype = {
						constructor: T.Event,
						isDefaultPrevented: It,
						isPropagationStopped: It,
						isImmediatePropagationStopped: It,
						isSimulated: !1,
						preventDefault: function() {
							var t = this.originalEvent;
							this.isDefaultPrevented = Mt, t && !this.isSimulated && t.preventDefault()
						},
						stopPropagation: function() {
							var t = this.originalEvent;
							this.isPropagationStopped = Mt, t && !this.isSimulated && t.stopPropagation()
						},
						stopImmediatePropagation: function() {
							var t = this.originalEvent;
							this.isImmediatePropagationStopped = Mt, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
						}
					}, T.each({
						altKey: !0,
						bubbles: !0,
						cancelable: !0,
						changedTouches: !0,
						ctrlKey: !0,
						detail: !0,
						eventPhase: !0,
						metaKey: !0,
						pageX: !0,
						pageY: !0,
						shiftKey: !0,
						view: !0,
						char: !0,
						code: !0,
						charCode: !0,
						key: !0,
						keyCode: !0,
						button: !0,
						buttons: !0,
						clientX: !0,
						clientY: !0,
						offsetX: !0,
						offsetY: !0,
						pointerId: !0,
						pointerType: !0,
						screenX: !0,
						screenY: !0,
						targetTouches: !0,
						toElement: !0,
						touches: !0,
						which: !0
					}, T.event.addProp), T.each({
						focus: "focusin",
						blur: "focusout"
					}, (function(t, e) {
						function n(t) {
							if (b.documentMode) {
								var n = st.get(this, "handle"),
									r = T.event.fix(t);
								r.type = "focusin" === t.type ? "focus" : "blur", r.isSimulated = !0, n(t), r.target === r.currentTarget && n(r)
							} else T.event.simulate(e, t.target, T.event.fix(t))
						}
						T.event.special[t] = {
							setup: function() {
								var r;
								if (Bt(this, t, !0), !b.documentMode) return !1;
								(r = st.get(this, e)) || this.addEventListener(e, n), st.set(this, e, (r || 0) + 1)
							},
							trigger: function() {
								return Bt(this, t), !0
							},
							teardown: function() {
								var t;
								if (!b.documentMode) return !1;
								(t = st.get(this, e) - 1) ? st.set(this, e, t): (this.removeEventListener(e, n), st.remove(this, e))
							},
							_default: function(e) {
								return st.get(e.target, t)
							},
							delegateType: e
						}, T.event.special[e] = {
							setup: function() {
								var r = this.ownerDocument || this.document || this,
									i = b.documentMode ? this : r,
									o = st.get(i, e);
								o || (b.documentMode ? this.addEventListener(e, n) : r.addEventListener(t, n, !0)), st.set(i, e, (o || 0) + 1)
							},
							teardown: function() {
								var r = this.ownerDocument || this.document || this,
									i = b.documentMode ? this : r,
									o = st.get(i, e) - 1;
								o ? st.set(i, e, o) : (b.documentMode ? this.removeEventListener(e, n) : r.removeEventListener(t, n, !0), st.remove(i, e))
							}
						}
					})), T.each({
						mouseenter: "mouseover",
						mouseleave: "mouseout",
						pointerenter: "pointerover",
						pointerleave: "pointerout"
					}, (function(t, e) {
						T.event.special[t] = {
							delegateType: e,
							bindType: e,
							handle: function(t) {
								var n, r = t.relatedTarget,
									i = t.handleObj;
								return r && (r === this || T.contains(this, r)) || (t.type = i.origType, n = i.handler.apply(this, arguments), t.type = e), n
							}
						}
					})), T.fn.extend({
						on: function(t, e, n, r) {
							return Rt(this, t, e, n, r)
						},
						one: function(t, e, n, r) {
							return Rt(this, t, e, n, r, 1)
						},
						off: function(t, e, n) {
							var r, i;
							if (t && t.preventDefault && t.handleObj) return r = t.handleObj, T(t.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
							if ("object" == typeof t) {
								for (i in t) this.off(i, e, t[i]);
								return this
							}
							return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = It), this.each((function() {
								T.event.remove(this, t, n, e)
							}))
						}
					});
					var Nt = /<script|<style|<link/i,
						Lt = /checked\s*(?:[^=]|=\s*.checked.)/i,
						zt = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

					function Wt(t, e) {
						return F(t, "table") && F(11 !== e.nodeType ? e : e.firstChild, "tr") && T(t).children("tbody")[0] || t
					}

					function Vt(t) {
						return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
					}

					function Ut(t) {
						return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
					}

					function Ht(t, e) {
						var n, r, i, o, a, s;
						if (1 === e.nodeType) {
							if (st.hasData(t) && (s = st.get(t).events))
								for (i in st.remove(e, "handle events"), s)
									for (n = 0, r = s[i].length; n < r; n++) T.event.add(e, i, s[i][n]);
							lt.hasData(t) && (o = lt.access(t), a = T.extend({}, o), lt.set(e, a))
						}
					}

					function qt(t, e) {
						var n = e.nodeName.toLowerCase();
						"input" === n && Tt.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
					}

					function Xt(t, e, n, r) {
						e = l(e);
						var i, o, a, s, c, u, h = 0,
							f = t.length,
							d = f - 1,
							p = e[0],
							g = m(p);
						if (g || f > 1 && "string" == typeof p && !v.checkClone && Lt.test(p)) return t.each((function(i) {
							var o = t.eq(i);
							g && (e[0] = p.call(this, i, o.html())), Xt(o, e, n, r)
						}));
						if (f && (o = (i = Et(e, t[0].ownerDocument, !1, t, r)).firstChild, 1 === i.childNodes.length && (i = o), o || r)) {
							for (s = (a = T.map(jt(i, "script"), Vt)).length; h < f; h++) c = i, h !== d && (c = T.clone(c, !0, !0), s && T.merge(a, jt(c, "script"))), n.call(t[h], c, h);
							if (s)
								for (u = a[a.length - 1].ownerDocument, T.map(a, Ut), h = 0; h < s; h++) c = a[h], Ft.test(c.type || "") && !st.access(c, "globalEval") && T.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? T._evalUrl && !c.noModule && T._evalUrl(c.src, {
									nonce: c.nonce || c.getAttribute("nonce")
								}, u) : w(c.textContent.replace(zt, ""), c, u))
						}
						return t
					}

					function Gt(t, e, n) {
						for (var r, i = e ? T.filter(e, t) : t, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || T.cleanData(jt(r)), r.parentNode && (n && vt(r) && At(jt(r, "script")), r.parentNode.removeChild(r));
						return t
					}
					T.extend({
						htmlPrefilter: function(t) {
							return t
						},
						clone: function(t, e, n) {
							var r, i, o, a, s = t.cloneNode(!0),
								l = vt(t);
							if (!(v.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || T.isXMLDoc(t)))
								for (a = jt(s), r = 0, i = (o = jt(t)).length; r < i; r++) qt(o[r], a[r]);
							if (e)
								if (n)
									for (o = o || jt(t), a = a || jt(s), r = 0, i = o.length; r < i; r++) Ht(o[r], a[r]);
								else Ht(t, s);
							return (a = jt(s, "script")).length > 0 && At(a, !l && jt(t, "script")), s
						},
						cleanData: function(t) {
							for (var e, n, r, i = T.event.special, o = 0; void 0 !== (n = t[o]); o++)
								if (ot(n)) {
									if (e = n[st.expando]) {
										if (e.events)
											for (r in e.events) i[r] ? T.event.remove(n, r) : T.removeEvent(n, r, e.handle);
										n[st.expando] = void 0
									}
									n[lt.expando] && (n[lt.expando] = void 0)
								}
						}
					}), T.fn.extend({
						detach: function(t) {
							return Gt(this, t, !0)
						},
						remove: function(t) {
							return Gt(this, t)
						},
						text: function(t) {
							return tt(this, (function(t) {
								return void 0 === t ? T.text(this) : this.empty().each((function() {
									1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
								}))
							}), null, t, arguments.length)
						},
						append: function() {
							return Xt(this, arguments, (function(t) {
								1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Wt(this, t).appendChild(t)
							}))
						},
						prepend: function() {
							return Xt(this, arguments, (function(t) {
								if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
									var e = Wt(this, t);
									e.insertBefore(t, e.firstChild)
								}
							}))
						},
						before: function() {
							return Xt(this, arguments, (function(t) {
								this.parentNode && this.parentNode.insertBefore(t, this)
							}))
						},
						after: function() {
							return Xt(this, arguments, (function(t) {
								this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
							}))
						},
						empty: function() {
							for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (T.cleanData(jt(t, !1)), t.textContent = "");
							return this
						},
						clone: function(t, e) {
							return t = null != t && t, e = null == e ? t : e, this.map((function() {
								return T.clone(this, t, e)
							}))
						},
						html: function(t) {
							return tt(this, (function(t) {
								var e = this[0] || {},
									n = 0,
									r = this.length;
								if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
								if ("string" == typeof t && !Nt.test(t) && !Pt[(kt.exec(t) || ["", ""])[1].toLowerCase()]) {
									t = T.htmlPrefilter(t);
									try {
										for (; n < r; n++) 1 === (e = this[n] || {}).nodeType && (T.cleanData(jt(e, !1)), e.innerHTML = t);
										e = 0
									} catch (t) {}
								}
								e && this.empty().append(t)
							}), null, t, arguments.length)
						},
						replaceWith: function() {
							var t = [];
							return Xt(this, arguments, (function(e) {
								var n = this.parentNode;
								T.inArray(this, t) < 0 && (T.cleanData(jt(this)), n && n.replaceChild(e, this))
							}), t)
						}
					}), T.each({
						appendTo: "append",
						prependTo: "prepend",
						insertBefore: "before",
						insertAfter: "after",
						replaceAll: "replaceWith"
					}, (function(t, e) {
						T.fn[t] = function(t) {
							for (var n, r = [], i = T(t), o = i.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), T(i[a])[e](n), c.apply(r, n.get());
							return this.pushStack(r)
						}
					}));
					var Kt = new RegExp("^(" + ft + ")(?!px)[a-z%]+$", "i"),
						Yt = /^--/,
						Zt = function(t) {
							var e = t.ownerDocument.defaultView;
							return e && e.opener || (e = r), e.getComputedStyle(t)
						},
						Jt = function(t, e, n) {
							var r, i, o = {};
							for (i in e) o[i] = t.style[i], t.style[i] = e[i];
							for (i in r = n.call(t), e) t.style[i] = o[i];
							return r
						},
						Qt = new RegExp(pt.join("|"), "i");

					function $t(t, e, n) {
						var r, i, o, a, s = Yt.test(e),
							l = t.style;
						return (n = n || Zt(t)) && (a = n.getPropertyValue(e) || n[e], s && a && (a = a.replace(E, "$1") || void 0), "" !== a || vt(t) || (a = T.style(t, e)), !v.pixelBoxStyles() && Kt.test(a) && Qt.test(e) && (r = l.width, i = l.minWidth, o = l.maxWidth, l.minWidth = l.maxWidth = l.width = a, a = n.width, l.width = r, l.minWidth = i, l.maxWidth = o)), void 0 !== a ? a + "" : a
					}

					function te(t, e) {
						return {
							get: function() {
								if (!t()) return (this.get = e).apply(this, arguments);
								delete this.get
							}
						}
					}! function() {
						function t() {
							if (u) {
								c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", gt.appendChild(c).appendChild(u);
								var t = r.getComputedStyle(u);
								n = "1%" !== t.top, l = 12 === e(t.marginLeft), u.style.right = "60%", a = 36 === e(t.right), i = 36 === e(t.width), u.style.position = "absolute", o = 12 === e(u.offsetWidth / 3), gt.removeChild(c), u = null
							}
						}

						function e(t) {
							return Math.round(parseFloat(t))
						}
						var n, i, o, a, s, l, c = b.createElement("div"),
							u = b.createElement("div");
						u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", v.clearCloneStyle = "content-box" === u.style.backgroundClip, T.extend(v, {
							boxSizingReliable: function() {
								return t(), i
							},
							pixelBoxStyles: function() {
								return t(), a
							},
							pixelPosition: function() {
								return t(), n
							},
							reliableMarginLeft: function() {
								return t(), l
							},
							scrollboxSize: function() {
								return t(), o
							},
							reliableTrDimensions: function() {
								var t, e, n, i;
								return null == s && (t = b.createElement("table"), e = b.createElement("tr"), n = b.createElement("div"), t.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", e.style.cssText = "box-sizing:content-box;border:1px solid", e.style.height = "1px", n.style.height = "9px", n.style.display = "block", gt.appendChild(t).appendChild(e).appendChild(n), i = r.getComputedStyle(e), s = parseInt(i.height, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10) === e.offsetHeight, gt.removeChild(t)), s
							}
						}))
					}();
					var ee = ["Webkit", "Moz", "ms"],
						ne = b.createElement("div").style,
						re = {};

					function ie(t) {
						return T.cssProps[t] || re[t] || (t in ne ? t : re[t] = function(t) {
							for (var e = t[0].toUpperCase() + t.slice(1), n = ee.length; n--;)
								if ((t = ee[n] + e) in ne) return t
						}(t) || t)
					}
					var oe = /^(none|table(?!-c[ea]).+)/,
						ae = {
							position: "absolute",
							visibility: "hidden",
							display: "block"
						},
						se = {
							letterSpacing: "0",
							fontWeight: "400"
						};

					function le(t, e, n) {
						var r = dt.exec(e);
						return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : e
					}

					function ce(t, e, n, r, i, o) {
						var a = "width" === e ? 1 : 0,
							s = 0,
							l = 0,
							c = 0;
						if (n === (r ? "border" : "content")) return 0;
						for (; a < 4; a += 2) "margin" === n && (c += T.css(t, n + pt[a], !0, i)), r ? ("content" === n && (l -= T.css(t, "padding" + pt[a], !0, i)), "margin" !== n && (l -= T.css(t, "border" + pt[a] + "Width", !0, i))) : (l += T.css(t, "padding" + pt[a], !0, i), "padding" !== n ? l += T.css(t, "border" + pt[a] + "Width", !0, i) : s += T.css(t, "border" + pt[a] + "Width", !0, i));
						return !r && o >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o - l - s - .5)) || 0), l + c
					}

					function ue(t, e, n) {
						var r = Zt(t),
							i = (!v.boxSizingReliable() || n) && "border-box" === T.css(t, "boxSizing", !1, r),
							o = i,
							a = $t(t, e, r),
							s = "offset" + e[0].toUpperCase() + e.slice(1);
						if (Kt.test(a)) {
							if (!n) return a;
							a = "auto"
						}
						return (!v.boxSizingReliable() && i || !v.reliableTrDimensions() && F(t, "tr") || "auto" === a || !parseFloat(a) && "inline" === T.css(t, "display", !1, r)) && t.getClientRects().length && (i = "border-box" === T.css(t, "boxSizing", !1, r), (o = s in t) && (a = t[s])), (a = parseFloat(a) || 0) + ce(t, e, n || (i ? "border" : "content"), o, r, a) + "px"
					}

					function he(t, e, n, r, i) {
						return new he.prototype.init(t, e, n, r, i)
					}
					T.extend({
						cssHooks: {
							opacity: {
								get: function(t, e) {
									if (e) {
										var n = $t(t, "opacity");
										return "" === n ? "1" : n
									}
								}
							}
						},
						cssNumber: {
							animationIterationCount: !0,
							aspectRatio: !0,
							borderImageSlice: !0,
							columnCount: !0,
							flexGrow: !0,
							flexShrink: !0,
							fontWeight: !0,
							gridArea: !0,
							gridColumn: !0,
							gridColumnEnd: !0,
							gridColumnStart: !0,
							gridRow: !0,
							gridRowEnd: !0,
							gridRowStart: !0,
							lineHeight: !0,
							opacity: !0,
							order: !0,
							orphans: !0,
							scale: !0,
							widows: !0,
							zIndex: !0,
							zoom: !0,
							fillOpacity: !0,
							floodOpacity: !0,
							stopOpacity: !0,
							strokeMiterlimit: !0,
							strokeOpacity: !0
						},
						cssProps: {},
						style: function(t, e, n, r) {
							if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
								var i, o, a, s = it(e),
									l = Yt.test(e),
									c = t.style;
								if (l || (e = ie(s)), a = T.cssHooks[e] || T.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(t, !1, r)) ? i : c[e];
								"string" == (o = typeof n) && (i = dt.exec(n)) && i[1] && (n = bt(t, e, i), o = "number"), null != n && n == n && ("number" !== o || l || (n += i && i[3] || (T.cssNumber[s] ? "" : "px")), v.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] = "inherit"), a && "set" in a && void 0 === (n = a.set(t, n, r)) || (l ? c.setProperty(e, n) : c[e] = n))
							}
						},
						css: function(t, e, n, r) {
							var i, o, a, s = it(e);
							return Yt.test(e) || (e = ie(s)), (a = T.cssHooks[e] || T.cssHooks[s]) && "get" in a && (i = a.get(t, !0, n)), void 0 === i && (i = $t(t, e, r)), "normal" === i && e in se && (i = se[e]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
						}
					}), T.each(["height", "width"], (function(t, e) {
						T.cssHooks[e] = {
							get: function(t, n, r) {
								if (n) return !oe.test(T.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ue(t, e, r) : Jt(t, ae, (function() {
									return ue(t, e, r)
								}))
							},
							set: function(t, n, r) {
								var i, o = Zt(t),
									a = !v.scrollboxSize() && "absolute" === o.position,
									s = (a || r) && "border-box" === T.css(t, "boxSizing", !1, o),
									l = r ? ce(t, e, r, s, o) : 0;
								return s && a && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(o[e]) - ce(t, e, "border", !1, o) - .5)), l && (i = dt.exec(n)) && "px" !== (i[3] || "px") && (t.style[e] = n, n = T.css(t, e)), le(0, n, l)
							}
						}
					})), T.cssHooks.marginLeft = te(v.reliableMarginLeft, (function(t, e) {
						if (e) return (parseFloat($t(t, "marginLeft")) || t.getBoundingClientRect().left - Jt(t, {
							marginLeft: 0
						}, (function() {
							return t.getBoundingClientRect().left
						}))) + "px"
					})), T.each({
						margin: "",
						padding: "",
						border: "Width"
					}, (function(t, e) {
						T.cssHooks[t + e] = {
							expand: function(n) {
								for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++) i[t + pt[r] + e] = o[r] || o[r - 2] || o[0];
								return i
							}
						}, "margin" !== t && (T.cssHooks[t + e].set = le)
					})), T.fn.extend({
						css: function(t, e) {
							return tt(this, (function(t, e, n) {
								var r, i, o = {},
									a = 0;
								if (Array.isArray(e)) {
									for (r = Zt(t), i = e.length; a < i; a++) o[e[a]] = T.css(t, e[a], !1, r);
									return o
								}
								return void 0 !== n ? T.style(t, e, n) : T.css(t, e)
							}), t, e, arguments.length > 1)
						}
					}), T.Tween = he, he.prototype = {
						constructor: he,
						init: function(t, e, n, r, i, o) {
							this.elem = t, this.prop = n, this.easing = i || T.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = r, this.unit = o || (T.cssNumber[n] ? "" : "px")
						},
						cur: function() {
							var t = he.propHooks[this.prop];
							return t && t.get ? t.get(this) : he.propHooks._default.get(this)
						},
						run: function(t) {
							var e, n = he.propHooks[this.prop];
							return this.options.duration ? this.pos = e = T.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : he.propHooks._default.set(this), this
						}
					}, he.prototype.init.prototype = he.prototype, he.propHooks = {
						_default: {
							get: function(t) {
								var e;
								return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = T.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
							},
							set: function(t) {
								T.fx.step[t.prop] ? T.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !T.cssHooks[t.prop] && null == t.elem.style[ie(t.prop)] ? t.elem[t.prop] = t.now : T.style(t.elem, t.prop, t.now + t.unit)
							}
						}
					}, he.propHooks.scrollTop = he.propHooks.scrollLeft = {
						set: function(t) {
							t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
						}
					}, T.easing = {
						linear: function(t) {
							return t
						},
						swing: function(t) {
							return .5 - Math.cos(t * Math.PI) / 2
						},
						_default: "swing"
					}, T.fx = he.prototype.init, T.fx.step = {};
					var fe, de, pe = /^(?:toggle|show|hide)$/,
						ge = /queueHooks$/;

					function ve() {
						de && (!1 === b.hidden && r.requestAnimationFrame ? r.requestAnimationFrame(ve) : r.setTimeout(ve, T.fx.interval), T.fx.tick())
					}

					function me() {
						return r.setTimeout((function() {
							fe = void 0
						})), fe = Date.now()
					}

					function ye(t, e) {
						var n, r = 0,
							i = {
								height: t
							};
						for (e = e ? 1 : 0; r < 4; r += 2 - e) i["margin" + (n = pt[r])] = i["padding" + n] = t;
						return e && (i.opacity = i.width = t), i
					}

					function be(t, e, n) {
						for (var r, i = (xe.tweeners[e] || []).concat(xe.tweeners["*"]), o = 0, a = i.length; o < a; o++)
							if (r = i[o].call(n, e, t)) return r
					}

					function xe(t, e, n) {
						var r, i, o = 0,
							a = xe.prefilters.length,
							s = T.Deferred().always((function() {
								delete l.elem
							})),
							l = function() {
								if (i) return !1;
								for (var e = fe || me(), n = Math.max(0, c.startTime + c.duration - e), r = 1 - (n / c.duration || 0), o = 0, a = c.tweens.length; o < a; o++) c.tweens[o].run(r);
								return s.notifyWith(t, [c, r, n]), r < 1 && a ? n : (a || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1)
							},
							c = s.promise({
								elem: t,
								props: T.extend({}, e),
								opts: T.extend(!0, {
									specialEasing: {},
									easing: T.easing._default
								}, n),
								originalProperties: e,
								originalOptions: n,
								startTime: fe || me(),
								duration: n.duration,
								tweens: [],
								createTween: function(e, n) {
									var r = T.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
									return c.tweens.push(r), r
								},
								stop: function(e) {
									var n = 0,
										r = e ? c.tweens.length : 0;
									if (i) return this;
									for (i = !0; n < r; n++) c.tweens[n].run(1);
									return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this
								}
							}),
							u = c.props;
						for (function(t, e) {
								var n, r, i, o, a;
								for (n in t)
									if (i = e[r = it(n)], o = t[n], Array.isArray(o) && (i = o[1], o = t[n] = o[0]), n !== r && (t[r] = o, delete t[n]), (a = T.cssHooks[r]) && "expand" in a)
										for (n in o = a.expand(o), delete t[r], o) n in t || (t[n] = o[n], e[n] = i);
									else e[r] = i
							}(u, c.opts.specialEasing); o < a; o++)
							if (r = xe.prefilters[o].call(c, t, u, c.opts)) return m(r.stop) && (T._queueHooks(c.elem, c.opts.queue).stop = r.stop.bind(r)), r;
						return T.map(u, be, c), m(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), T.fx.timer(T.extend(l, {
							elem: t,
							anim: c,
							queue: c.opts.queue
						})), c
					}
					T.Animation = T.extend(xe, {
							tweeners: {
								"*": [function(t, e) {
									var n = this.createTween(t, e);
									return bt(n.elem, t, dt.exec(e), n), n
								}]
							},
							tweener: function(t, e) {
								m(t) ? (e = t, t = ["*"]) : t = t.match(G);
								for (var n, r = 0, i = t.length; r < i; r++) n = t[r], xe.tweeners[n] = xe.tweeners[n] || [], xe.tweeners[n].unshift(e)
							},
							prefilters: [function(t, e, n) {
								var r, i, o, a, s, l, c, u, h = "width" in e || "height" in e,
									f = this,
									d = {},
									p = t.style,
									g = t.nodeType && yt(t),
									v = st.get(t, "fxshow");
								for (r in n.queue || (null == (a = T._queueHooks(t, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
										a.unqueued || s()
									}), a.unqueued++, f.always((function() {
										f.always((function() {
											a.unqueued--, T.queue(t, "fx").length || a.empty.fire()
										}))
									}))), e)
									if (i = e[r], pe.test(i)) {
										if (delete e[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
											if ("show" !== i || !v || void 0 === v[r]) continue;
											g = !0
										}
										d[r] = v && v[r] || T.style(t, r)
									} if ((l = !T.isEmptyObject(e)) || !T.isEmptyObject(d))
									for (r in h && 1 === t.nodeType && (n.overflow = [p.overflow, p.overflowX, p.overflowY], null == (c = v && v.display) && (c = st.get(t, "display")), "none" === (u = T.css(t, "display")) && (c ? u = c : (Ct([t], !0), c = t.style.display || c, u = T.css(t, "display"), Ct([t]))), ("inline" === u || "inline-block" === u && null != c) && "none" === T.css(t, "float") && (l || (f.done((function() {
											p.display = c
										})), null == c && (u = p.display, c = "none" === u ? "" : u)), p.display = "inline-block")), n.overflow && (p.overflow = "hidden", f.always((function() {
											p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]
										}))), l = !1, d) l || (v ? "hidden" in v && (g = v.hidden) : v = st.access(t, "fxshow", {
										display: c
									}), o && (v.hidden = !g), g && Ct([t], !0), f.done((function() {
										for (r in g || Ct([t]), st.remove(t, "fxshow"), d) T.style(t, r, d[r])
									}))), l = be(g ? v[r] : 0, r, f), r in v || (v[r] = l.start, g && (l.end = l.start, l.start = 0))
							}],
							prefilter: function(t, e) {
								e ? xe.prefilters.unshift(t) : xe.prefilters.push(t)
							}
						}), T.speed = function(t, e, n) {
							var r = t && "object" == typeof t ? T.extend({}, t) : {
								complete: n || !n && e || m(t) && t,
								duration: t,
								easing: n && e || e && !m(e) && e
							};
							return T.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in T.fx.speeds ? r.duration = T.fx.speeds[r.duration] : r.duration = T.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
								m(r.old) && r.old.call(this), r.queue && T.dequeue(this, r.queue)
							}, r
						}, T.fn.extend({
							fadeTo: function(t, e, n, r) {
								return this.filter(yt).css("opacity", 0).show().end().animate({
									opacity: e
								}, t, n, r)
							},
							animate: function(t, e, n, r) {
								var i = T.isEmptyObject(t),
									o = T.speed(e, n, r),
									a = function() {
										var e = xe(this, T.extend({}, t), o);
										(i || st.get(this, "finish")) && e.stop(!0)
									};
								return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
							},
							stop: function(t, e, n) {
								var r = function(t) {
									var e = t.stop;
									delete t.stop, e(n)
								};
								return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each((function() {
									var e = !0,
										i = null != t && t + "queueHooks",
										o = T.timers,
										a = st.get(this);
									if (i) a[i] && a[i].stop && r(a[i]);
									else
										for (i in a) a[i] && a[i].stop && ge.test(i) && r(a[i]);
									for (i = o.length; i--;) o[i].elem !== this || null != t && o[i].queue !== t || (o[i].anim.stop(n), e = !1, o.splice(i, 1));
									!e && n || T.dequeue(this, t)
								}))
							},
							finish: function(t) {
								return !1 !== t && (t = t || "fx"), this.each((function() {
									var e, n = st.get(this),
										r = n[t + "queue"],
										i = n[t + "queueHooks"],
										o = T.timers,
										a = r ? r.length : 0;
									for (n.finish = !0, T.queue(this, t, []), i && i.stop && i.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
									for (e = 0; e < a; e++) r[e] && r[e].finish && r[e].finish.call(this);
									delete n.finish
								}))
							}
						}), T.each(["toggle", "show", "hide"], (function(t, e) {
							var n = T.fn[e];
							T.fn[e] = function(t, r, i) {
								return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(ye(e, !0), t, r, i)
							}
						})), T.each({
							slideDown: ye("show"),
							slideUp: ye("hide"),
							slideToggle: ye("toggle"),
							fadeIn: {
								opacity: "show"
							},
							fadeOut: {
								opacity: "hide"
							},
							fadeToggle: {
								opacity: "toggle"
							}
						}, (function(t, e) {
							T.fn[t] = function(t, n, r) {
								return this.animate(e, t, n, r)
							}
						})), T.timers = [], T.fx.tick = function() {
							var t, e = 0,
								n = T.timers;
							for (fe = Date.now(); e < n.length; e++)(t = n[e])() || n[e] !== t || n.splice(e--, 1);
							n.length || T.fx.stop(), fe = void 0
						}, T.fx.timer = function(t) {
							T.timers.push(t), T.fx.start()
						}, T.fx.interval = 13, T.fx.start = function() {
							de || (de = !0, ve())
						}, T.fx.stop = function() {
							de = null
						}, T.fx.speeds = {
							slow: 600,
							fast: 200,
							_default: 400
						}, T.fn.delay = function(t, e) {
							return t = T.fx && T.fx.speeds[t] || t, e = e || "fx", this.queue(e, (function(e, n) {
								var i = r.setTimeout(e, t);
								n.stop = function() {
									r.clearTimeout(i)
								}
							}))
						},
						function() {
							var t = b.createElement("input"),
								e = b.createElement("select").appendChild(b.createElement("option"));
							t.type = "checkbox", v.checkOn = "" !== t.value, v.optSelected = e.selected, (t = b.createElement("input")).value = "t", t.type = "radio", v.radioValue = "t" === t.value
						}();
					var we, Ce = T.expr.attrHandle;
					T.fn.extend({
						attr: function(t, e) {
							return tt(this, T.attr, t, e, arguments.length > 1)
						},
						removeAttr: function(t) {
							return this.each((function() {
								T.removeAttr(this, t)
							}))
						}
					}), T.extend({
						attr: function(t, e, n) {
							var r, i, o = t.nodeType;
							if (3 !== o && 8 !== o && 2 !== o) return void 0 === t.getAttribute ? T.prop(t, e, n) : (1 === o && T.isXMLDoc(t) || (i = T.attrHooks[e.toLowerCase()] || (T.expr.match.bool.test(e) ? we : void 0)), void 0 !== n ? null === n ? void T.removeAttr(t, e) : i && "set" in i && void 0 !== (r = i.set(t, n, e)) ? r : (t.setAttribute(e, n + ""), n) : i && "get" in i && null !== (r = i.get(t, e)) ? r : null == (r = T.find.attr(t, e)) ? void 0 : r)
						},
						attrHooks: {
							type: {
								set: function(t, e) {
									if (!v.radioValue && "radio" === e && F(t, "input")) {
										var n = t.value;
										return t.setAttribute("type", e), n && (t.value = n), e
									}
								}
							}
						},
						removeAttr: function(t, e) {
							var n, r = 0,
								i = e && e.match(G);
							if (i && 1 === t.nodeType)
								for (; n = i[r++];) t.removeAttribute(n)
						}
					}), we = {
						set: function(t, e, n) {
							return !1 === e ? T.removeAttr(t, n) : t.setAttribute(n, n), n
						}
					}, T.each(T.expr.match.bool.source.match(/\w+/g), (function(t, e) {
						var n = Ce[e] || T.find.attr;
						Ce[e] = function(t, e, r) {
							var i, o, a = e.toLowerCase();
							return r || (o = Ce[a], Ce[a] = i, i = null != n(t, e, r) ? a : null, Ce[a] = o), i
						}
					}));
					var Se = /^(?:input|select|textarea|button)$/i,
						Oe = /^(?:a|area)$/i;

					function Te(t) {
						return (t.match(G) || []).join(" ")
					}

					function ke(t) {
						return t.getAttribute && t.getAttribute("class") || ""
					}

					function Fe(t) {
						return Array.isArray(t) ? t : "string" == typeof t && t.match(G) || []
					}
					T.fn.extend({
						prop: function(t, e) {
							return tt(this, T.prop, t, e, arguments.length > 1)
						},
						removeProp: function(t) {
							return this.each((function() {
								delete this[T.propFix[t] || t]
							}))
						}
					}), T.extend({
						prop: function(t, e, n) {
							var r, i, o = t.nodeType;
							if (3 !== o && 8 !== o && 2 !== o) return 1 === o && T.isXMLDoc(t) || (e = T.propFix[e] || e, i = T.propHooks[e]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(t, n, e)) ? r : t[e] = n : i && "get" in i && null !== (r = i.get(t, e)) ? r : t[e]
						},
						propHooks: {
							tabIndex: {
								get: function(t) {
									var e = T.find.attr(t, "tabindex");
									return e ? parseInt(e, 10) : Se.test(t.nodeName) || Oe.test(t.nodeName) && t.href ? 0 : -1
								}
							}
						},
						propFix: {
							for: "htmlFor",
							class: "className"
						}
					}), v.optSelected || (T.propHooks.selected = {
						get: function(t) {
							var e = t.parentNode;
							return e && e.parentNode && e.parentNode.selectedIndex, null
						},
						set: function(t) {
							var e = t.parentNode;
							e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
						}
					}), T.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
						T.propFix[this.toLowerCase()] = this
					})), T.fn.extend({
						addClass: function(t) {
							var e, n, r, i, o, a;
							return m(t) ? this.each((function(e) {
								T(this).addClass(t.call(this, e, ke(this)))
							})) : (e = Fe(t)).length ? this.each((function() {
								if (r = ke(this), n = 1 === this.nodeType && " " + Te(r) + " ") {
									for (o = 0; o < e.length; o++) i = e[o], n.indexOf(" " + i + " ") < 0 && (n += i + " ");
									a = Te(n), r !== a && this.setAttribute("class", a)
								}
							})) : this
						},
						removeClass: function(t) {
							var e, n, r, i, o, a;
							return m(t) ? this.each((function(e) {
								T(this).removeClass(t.call(this, e, ke(this)))
							})) : arguments.length ? (e = Fe(t)).length ? this.each((function() {
								if (r = ke(this), n = 1 === this.nodeType && " " + Te(r) + " ") {
									for (o = 0; o < e.length; o++)
										for (i = e[o]; n.indexOf(" " + i + " ") > -1;) n = n.replace(" " + i + " ", " ");
									a = Te(n), r !== a && this.setAttribute("class", a)
								}
							})) : this : this.attr("class", "")
						},
						toggleClass: function(t, e) {
							var n, r, i, o, a = typeof t,
								s = "string" === a || Array.isArray(t);
							return m(t) ? this.each((function(n) {
								T(this).toggleClass(t.call(this, n, ke(this), e), e)
							})) : "boolean" == typeof e && s ? e ? this.addClass(t) : this.removeClass(t) : (n = Fe(t), this.each((function() {
								if (s)
									for (o = T(this), i = 0; i < n.length; i++) r = n[i], o.hasClass(r) ? o.removeClass(r) : o.addClass(r);
								else void 0 !== t && "boolean" !== a || ((r = ke(this)) && st.set(this, "__className__", r), this.setAttribute && this.setAttribute("class", r || !1 === t ? "" : st.get(this, "__className__") || ""))
							})))
						},
						hasClass: function(t) {
							var e, n, r = 0;
							for (e = " " + t + " "; n = this[r++];)
								if (1 === n.nodeType && (" " + Te(ke(n)) + " ").indexOf(e) > -1) return !0;
							return !1
						}
					});
					var Pe = /\r/g;
					T.fn.extend({
						val: function(t) {
							var e, n, r, i = this[0];
							return arguments.length ? (r = m(t), this.each((function(n) {
								var i;
								1 === this.nodeType && (null == (i = r ? t.call(this, n, T(this).val()) : t) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = T.map(i, (function(t) {
									return null == t ? "" : t + ""
								}))), (e = T.valHooks[this.type] || T.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, i, "value") || (this.value = i))
							}))) : i ? (e = T.valHooks[i.type] || T.valHooks[i.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(i, "value")) ? n : "string" == typeof(n = i.value) ? n.replace(Pe, "") : null == n ? "" : n : void 0
						}
					}), T.extend({
						valHooks: {
							option: {
								get: function(t) {
									var e = T.find.attr(t, "value");
									return null != e ? e : Te(T.text(t))
								}
							},
							select: {
								get: function(t) {
									var e, n, r, i = t.options,
										o = t.selectedIndex,
										a = "select-one" === t.type,
										s = a ? null : [],
										l = a ? o + 1 : i.length;
									for (r = o < 0 ? l : a ? o : 0; r < l; r++)
										if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !F(n.parentNode, "optgroup"))) {
											if (e = T(n).val(), a) return e;
											s.push(e)
										} return s
								},
								set: function(t, e) {
									for (var n, r, i = t.options, o = T.makeArray(e), a = i.length; a--;)((r = i[a]).selected = T.inArray(T.valHooks.option.get(r), o) > -1) && (n = !0);
									return n || (t.selectedIndex = -1), o
								}
							}
						}
					}), T.each(["radio", "checkbox"], (function() {
						T.valHooks[this] = {
							set: function(t, e) {
								if (Array.isArray(e)) return t.checked = T.inArray(T(t).val(), e) > -1
							}
						}, v.checkOn || (T.valHooks[this].get = function(t) {
							return null === t.getAttribute("value") ? "on" : t.value
						})
					}));
					var je = r.location,
						Ae = {
							guid: Date.now()
						},
						_e = /\?/;
					T.parseXML = function(t) {
						var e, n;
						if (!t || "string" != typeof t) return null;
						try {
							e = (new r.DOMParser).parseFromString(t, "text/xml")
						} catch (t) {}
						return n = e && e.getElementsByTagName("parsererror")[0], e && !n || T.error("Invalid XML: " + (n ? T.map(n.childNodes, (function(t) {
							return t.textContent
						})).join("\n") : t)), e
					};
					var Ee = /^(?:focusinfocus|focusoutblur)$/,
						De = function(t) {
							t.stopPropagation()
						};
					T.extend(T.event, {
						trigger: function(t, e, n, i) {
							var o, a, s, l, c, u, h, f, p = [n || b],
								g = d.call(t, "type") ? t.type : t,
								v = d.call(t, "namespace") ? t.namespace.split(".") : [];
							if (a = f = s = n = n || b, 3 !== n.nodeType && 8 !== n.nodeType && !Ee.test(g + T.event.triggered) && (g.indexOf(".") > -1 && (v = g.split("."), g = v.shift(), v.sort()), c = g.indexOf(":") < 0 && "on" + g, (t = t[T.expando] ? t : new T.Event(g, "object" == typeof t && t)).isTrigger = i ? 2 : 3, t.namespace = v.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = n), e = null == e ? [t] : T.makeArray(e, [t]), h = T.event.special[g] || {}, i || !h.trigger || !1 !== h.trigger.apply(n, e))) {
								if (!i && !h.noBubble && !y(n)) {
									for (l = h.delegateType || g, Ee.test(l + g) || (a = a.parentNode); a; a = a.parentNode) p.push(a), s = a;
									s === (n.ownerDocument || b) && p.push(s.defaultView || s.parentWindow || r)
								}
								for (o = 0;
									(a = p[o++]) && !t.isPropagationStopped();) f = a, t.type = o > 1 ? l : h.bindType || g, (u = (st.get(a, "events") || Object.create(null))[t.type] && st.get(a, "handle")) && u.apply(a, e), (u = c && a[c]) && u.apply && ot(a) && (t.result = u.apply(a, e), !1 === t.result && t.preventDefault());
								return t.type = g, i || t.isDefaultPrevented() || h._default && !1 !== h._default.apply(p.pop(), e) || !ot(n) || c && m(n[g]) && !y(n) && ((s = n[c]) && (n[c] = null), T.event.triggered = g, t.isPropagationStopped() && f.addEventListener(g, De), n[g](), t.isPropagationStopped() && f.removeEventListener(g, De), T.event.triggered = void 0, s && (n[c] = s)), t.result
							}
						},
						simulate: function(t, e, n) {
							var r = T.extend(new T.Event, n, {
								type: t,
								isSimulated: !0
							});
							T.event.trigger(r, null, e)
						}
					}), T.fn.extend({
						trigger: function(t, e) {
							return this.each((function() {
								T.event.trigger(t, e, this)
							}))
						},
						triggerHandler: function(t, e) {
							var n = this[0];
							if (n) return T.event.trigger(t, e, n, !0)
						}
					});
					var Me = /\[\]$/,
						Ie = /\r?\n/g,
						Re = /^(?:submit|button|image|reset|file)$/i,
						Be = /^(?:input|select|textarea|keygen)/i;

					function Ne(t, e, n, r) {
						var i;
						if (Array.isArray(e)) T.each(e, (function(e, i) {
							n || Me.test(t) ? r(t, i) : Ne(t + "[" + ("object" == typeof i && null != i ? e : "") + "]", i, n, r)
						}));
						else if (n || "object" !== C(e)) r(t, e);
						else
							for (i in e) Ne(t + "[" + i + "]", e[i], n, r)
					}
					T.param = function(t, e) {
						var n, r = [],
							i = function(t, e) {
								var n = m(e) ? e() : e;
								r[r.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
							};
						if (null == t) return "";
						if (Array.isArray(t) || t.jquery && !T.isPlainObject(t)) T.each(t, (function() {
							i(this.name, this.value)
						}));
						else
							for (n in t) Ne(n, t[n], e, i);
						return r.join("&")
					}, T.fn.extend({
						serialize: function() {
							return T.param(this.serializeArray())
						},
						serializeArray: function() {
							return this.map((function() {
								var t = T.prop(this, "elements");
								return t ? T.makeArray(t) : this
							})).filter((function() {
								var t = this.type;
								return this.name && !T(this).is(":disabled") && Be.test(this.nodeName) && !Re.test(t) && (this.checked || !Tt.test(t))
							})).map((function(t, e) {
								var n = T(this).val();
								return null == n ? null : Array.isArray(n) ? T.map(n, (function(t) {
									return {
										name: e.name,
										value: t.replace(Ie, "\r\n")
									}
								})) : {
									name: e.name,
									value: n.replace(Ie, "\r\n")
								}
							})).get()
						}
					});
					var Le = /%20/g,
						ze = /#.*$/,
						We = /([?&])_=[^&]*/,
						Ve = /^(.*?):[ \t]*([^\r\n]*)$/gm,
						Ue = /^(?:GET|HEAD)$/,
						He = /^\/\//,
						qe = {},
						Xe = {},
						Ge = "*/".concat("*"),
						Ke = b.createElement("a");

					function Ye(t) {
						return function(e, n) {
							"string" != typeof e && (n = e, e = "*");
							var r, i = 0,
								o = e.toLowerCase().match(G) || [];
							if (m(n))
								for (; r = o[i++];) "+" === r[0] ? (r = r.slice(1) || "*", (t[r] = t[r] || []).unshift(n)) : (t[r] = t[r] || []).push(n)
						}
					}

					function Ze(t, e, n, r) {
						var i = {},
							o = t === Xe;

						function a(s) {
							var l;
							return i[s] = !0, T.each(t[s] || [], (function(t, s) {
								var c = s(e, n, r);
								return "string" != typeof c || o || i[c] ? o ? !(l = c) : void 0 : (e.dataTypes.unshift(c), a(c), !1)
							})), l
						}
						return a(e.dataTypes[0]) || !i["*"] && a("*")
					}

					function Je(t, e) {
						var n, r, i = T.ajaxSettings.flatOptions || {};
						for (n in e) void 0 !== e[n] && ((i[n] ? t : r || (r = {}))[n] = e[n]);
						return r && T.extend(!0, t, r), t
					}
					Ke.href = je.href, T.extend({
						active: 0,
						lastModified: {},
						etag: {},
						ajaxSettings: {
							url: je.href,
							type: "GET",
							isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(je.protocol),
							global: !0,
							processData: !0,
							async: !0,
							contentType: "application/x-www-form-urlencoded; charset=UTF-8",
							accepts: {
								"*": Ge,
								text: "text/plain",
								html: "text/html",
								xml: "application/xml, text/xml",
								json: "application/json, text/javascript"
							},
							contents: {
								xml: /\bxml\b/,
								html: /\bhtml/,
								json: /\bjson\b/
							},
							responseFields: {
								xml: "responseXML",
								text: "responseText",
								json: "responseJSON"
							},
							converters: {
								"* text": String,
								"text html": !0,
								"text json": JSON.parse,
								"text xml": T.parseXML
							},
							flatOptions: {
								url: !0,
								context: !0
							}
						},
						ajaxSetup: function(t, e) {
							return e ? Je(Je(t, T.ajaxSettings), e) : Je(T.ajaxSettings, t)
						},
						ajaxPrefilter: Ye(qe),
						ajaxTransport: Ye(Xe),
						ajax: function(t, e) {
							"object" == typeof t && (e = t, t = void 0), e = e || {};
							var n, i, o, a, s, l, c, u, h, f, d = T.ajaxSetup({}, e),
								p = d.context || d,
								g = d.context && (p.nodeType || p.jquery) ? T(p) : T.event,
								v = T.Deferred(),
								m = T.Callbacks("once memory"),
								y = d.statusCode || {},
								x = {},
								w = {},
								C = "canceled",
								S = {
									readyState: 0,
									getResponseHeader: function(t) {
										var e;
										if (c) {
											if (!a)
												for (a = {}; e = Ve.exec(o);) a[e[1].toLowerCase() + " "] = (a[e[1].toLowerCase() + " "] || []).concat(e[2]);
											e = a[t.toLowerCase() + " "]
										}
										return null == e ? null : e.join(", ")
									},
									getAllResponseHeaders: function() {
										return c ? o : null
									},
									setRequestHeader: function(t, e) {
										return null == c && (t = w[t.toLowerCase()] = w[t.toLowerCase()] || t, x[t] = e), this
									},
									overrideMimeType: function(t) {
										return null == c && (d.mimeType = t), this
									},
									statusCode: function(t) {
										var e;
										if (t)
											if (c) S.always(t[S.status]);
											else
												for (e in t) y[e] = [y[e], t[e]];
										return this
									},
									abort: function(t) {
										var e = t || C;
										return n && n.abort(e), O(0, e), this
									}
								};
							if (v.promise(S), d.url = ((t || d.url || je.href) + "").replace(He, je.protocol + "//"), d.type = e.method || e.type || d.method || d.type, d.dataTypes = (d.dataType || "*").toLowerCase().match(G) || [""], null == d.crossDomain) {
								l = b.createElement("a");
								try {
									l.href = d.url, l.href = l.href, d.crossDomain = Ke.protocol + "//" + Ke.host != l.protocol + "//" + l.host
								} catch (t) {
									d.crossDomain = !0
								}
							}
							if (d.data && d.processData && "string" != typeof d.data && (d.data = T.param(d.data, d.traditional)), Ze(qe, d, e, S), c) return S;
							for (h in (u = T.event && d.global) && 0 == T.active++ && T.event.trigger("ajaxStart"), d.type = d.type.toUpperCase(), d.hasContent = !Ue.test(d.type), i = d.url.replace(ze, ""), d.hasContent ? d.data && d.processData && 0 === (d.contentType || "").indexOf("application/x-www-form-urlencoded") && (d.data = d.data.replace(Le, "+")) : (f = d.url.slice(i.length), d.data && (d.processData || "string" == typeof d.data) && (i += (_e.test(i) ? "&" : "?") + d.data, delete d.data), !1 === d.cache && (i = i.replace(We, "$1"), f = (_e.test(i) ? "&" : "?") + "_=" + Ae.guid++ + f), d.url = i + f), d.ifModified && (T.lastModified[i] && S.setRequestHeader("If-Modified-Since", T.lastModified[i]), T.etag[i] && S.setRequestHeader("If-None-Match", T.etag[i])), (d.data && d.hasContent && !1 !== d.contentType || e.contentType) && S.setRequestHeader("Content-Type", d.contentType), S.setRequestHeader("Accept", d.dataTypes[0] && d.accepts[d.dataTypes[0]] ? d.accepts[d.dataTypes[0]] + ("*" !== d.dataTypes[0] ? ", " + Ge + "; q=0.01" : "") : d.accepts["*"]), d.headers) S.setRequestHeader(h, d.headers[h]);
							if (d.beforeSend && (!1 === d.beforeSend.call(p, S, d) || c)) return S.abort();
							if (C = "abort", m.add(d.complete), S.done(d.success), S.fail(d.error), n = Ze(Xe, d, e, S)) {
								if (S.readyState = 1, u && g.trigger("ajaxSend", [S, d]), c) return S;
								d.async && d.timeout > 0 && (s = r.setTimeout((function() {
									S.abort("timeout")
								}), d.timeout));
								try {
									c = !1, n.send(x, O)
								} catch (t) {
									if (c) throw t;
									O(-1, t)
								}
							} else O(-1, "No Transport");

							function O(t, e, a, l) {
								var h, f, b, x, w, C = e;
								c || (c = !0, s && r.clearTimeout(s), n = void 0, o = l || "", S.readyState = t > 0 ? 4 : 0, h = t >= 200 && t < 300 || 304 === t, a && (x = function(t, e, n) {
									for (var r, i, o, a, s = t.contents, l = t.dataTypes;
										"*" === l[0];) l.shift(), void 0 === r && (r = t.mimeType || e.getResponseHeader("Content-Type"));
									if (r)
										for (i in s)
											if (s[i] && s[i].test(r)) {
												l.unshift(i);
												break
											} if (l[0] in n) o = l[0];
									else {
										for (i in n) {
											if (!l[0] || t.converters[i + " " + l[0]]) {
												o = i;
												break
											}
											a || (a = i)
										}
										o = o || a
									}
									if (o) return o !== l[0] && l.unshift(o), n[o]
								}(d, S, a)), !h && T.inArray("script", d.dataTypes) > -1 && T.inArray("json", d.dataTypes) < 0 && (d.converters["text script"] = function() {}), x = function(t, e, n, r) {
									var i, o, a, s, l, c = {},
										u = t.dataTypes.slice();
									if (u[1])
										for (a in t.converters) c[a.toLowerCase()] = t.converters[a];
									for (o = u.shift(); o;)
										if (t.responseFields[o] && (n[t.responseFields[o]] = e), !l && r && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = o, o = u.shift())
											if ("*" === o) o = l;
											else if ("*" !== l && l !== o) {
										if (!(a = c[l + " " + o] || c["* " + o]))
											for (i in c)
												if ((s = i.split(" "))[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
													!0 === a ? a = c[i] : !0 !== c[i] && (o = s[0], u.unshift(s[1]));
													break
												} if (!0 !== a)
											if (a && t.throws) e = a(e);
											else try {
												e = a(e)
											} catch (t) {
												return {
													state: "parsererror",
													error: a ? t : "No conversion from " + l + " to " + o
												}
											}
									}
									return {
										state: "success",
										data: e
									}
								}(d, x, S, h), h ? (d.ifModified && ((w = S.getResponseHeader("Last-Modified")) && (T.lastModified[i] = w), (w = S.getResponseHeader("etag")) && (T.etag[i] = w)), 204 === t || "HEAD" === d.type ? C = "nocontent" : 304 === t ? C = "notmodified" : (C = x.state, f = x.data, h = !(b = x.error))) : (b = C, !t && C || (C = "error", t < 0 && (t = 0))), S.status = t, S.statusText = (e || C) + "", h ? v.resolveWith(p, [f, C, S]) : v.rejectWith(p, [S, C, b]), S.statusCode(y), y = void 0, u && g.trigger(h ? "ajaxSuccess" : "ajaxError", [S, d, h ? f : b]), m.fireWith(p, [S, C]), u && (g.trigger("ajaxComplete", [S, d]), --T.active || T.event.trigger("ajaxStop")))
							}
							return S
						},
						getJSON: function(t, e, n) {
							return T.get(t, e, n, "json")
						},
						getScript: function(t, e) {
							return T.get(t, void 0, e, "script")
						}
					}), T.each(["get", "post"], (function(t, e) {
						T[e] = function(t, n, r, i) {
							return m(n) && (i = i || r, r = n, n = void 0), T.ajax(T.extend({
								url: t,
								type: e,
								dataType: i,
								data: n,
								success: r
							}, T.isPlainObject(t) && t))
						}
					})), T.ajaxPrefilter((function(t) {
						var e;
						for (e in t.headers) "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
					})), T._evalUrl = function(t, e, n) {
						return T.ajax({
							url: t,
							type: "GET",
							dataType: "script",
							cache: !0,
							async: !1,
							global: !1,
							converters: {
								"text script": function() {}
							},
							dataFilter: function(t) {
								T.globalEval(t, e, n)
							}
						})
					}, T.fn.extend({
						wrapAll: function(t) {
							var e;
							return this[0] && (m(t) && (t = t.call(this[0])), e = T(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map((function() {
								for (var t = this; t.firstElementChild;) t = t.firstElementChild;
								return t
							})).append(this)), this
						},
						wrapInner: function(t) {
							return m(t) ? this.each((function(e) {
								T(this).wrapInner(t.call(this, e))
							})) : this.each((function() {
								var e = T(this),
									n = e.contents();
								n.length ? n.wrapAll(t) : e.append(t)
							}))
						},
						wrap: function(t) {
							var e = m(t);
							return this.each((function(n) {
								T(this).wrapAll(e ? t.call(this, n) : t)
							}))
						},
						unwrap: function(t) {
							return this.parent(t).not("body").each((function() {
								T(this).replaceWith(this.childNodes)
							})), this
						}
					}), T.expr.pseudos.hidden = function(t) {
						return !T.expr.pseudos.visible(t)
					}, T.expr.pseudos.visible = function(t) {
						return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
					}, T.ajaxSettings.xhr = function() {
						try {
							return new r.XMLHttpRequest
						} catch (t) {}
					};
					var Qe = {
							0: 200,
							1223: 204
						},
						$e = T.ajaxSettings.xhr();
					v.cors = !!$e && "withCredentials" in $e, v.ajax = $e = !!$e, T.ajaxTransport((function(t) {
						var e, n;
						if (v.cors || $e && !t.crossDomain) return {
							send: function(i, o) {
								var a, s = t.xhr();
								if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
									for (a in t.xhrFields) s[a] = t.xhrFields[a];
								for (a in t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"), i) s.setRequestHeader(a, i[a]);
								e = function(t) {
									return function() {
										e && (e = n = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(Qe[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
											binary: s.response
										} : {
											text: s.responseText
										}, s.getAllResponseHeaders()))
									}
								}, s.onload = e(), n = s.onerror = s.ontimeout = e("error"), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function() {
									4 === s.readyState && r.setTimeout((function() {
										e && n()
									}))
								}, e = e("abort");
								try {
									s.send(t.hasContent && t.data || null)
								} catch (t) {
									if (e) throw t
								}
							},
							abort: function() {
								e && e()
							}
						}
					})), T.ajaxPrefilter((function(t) {
						t.crossDomain && (t.contents.script = !1)
					})), T.ajaxSetup({
						accepts: {
							script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
						},
						contents: {
							script: /\b(?:java|ecma)script\b/
						},
						converters: {
							"text script": function(t) {
								return T.globalEval(t), t
							}
						}
					}), T.ajaxPrefilter("script", (function(t) {
						void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
					})), T.ajaxTransport("script", (function(t) {
						var e, n;
						if (t.crossDomain || t.scriptAttrs) return {
							send: function(r, i) {
								e = T("<script>").attr(t.scriptAttrs || {}).prop({
									charset: t.scriptCharset,
									src: t.url
								}).on("load error", n = function(t) {
									e.remove(), n = null, t && i("error" === t.type ? 404 : 200, t.type)
								}), b.head.appendChild(e[0])
							},
							abort: function() {
								n && n()
							}
						}
					}));
					var tn, en = [],
						nn = /(=)\?(?=&|$)|\?\?/;
					T.ajaxSetup({
						jsonp: "callback",
						jsonpCallback: function() {
							var t = en.pop() || T.expando + "_" + Ae.guid++;
							return this[t] = !0, t
						}
					}), T.ajaxPrefilter("json jsonp", (function(t, e, n) {
						var i, o, a, s = !1 !== t.jsonp && (nn.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && nn.test(t.data) && "data");
						if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = m(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(nn, "$1" + i) : !1 !== t.jsonp && (t.url += (_e.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function() {
							return a || T.error(i + " was not called"), a[0]
						}, t.dataTypes[0] = "json", o = r[i], r[i] = function() {
							a = arguments
						}, n.always((function() {
							void 0 === o ? T(r).removeProp(i) : r[i] = o, t[i] && (t.jsonpCallback = e.jsonpCallback, en.push(i)), a && m(o) && o(a[0]), a = o = void 0
						})), "script"
					})), v.createHTMLDocument = ((tn = b.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === tn.childNodes.length), T.parseHTML = function(t, e, n) {
						return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (v.createHTMLDocument ? ((r = (e = b.implementation.createHTMLDocument("")).createElement("base")).href = b.location.href, e.head.appendChild(r)) : e = b), o = !n && [], (i = z.exec(t)) ? [e.createElement(i[1])] : (i = Et([t], e, o), o && o.length && T(o).remove(), T.merge([], i.childNodes)));
						var r, i, o
					}, T.fn.load = function(t, e, n) {
						var r, i, o, a = this,
							s = t.indexOf(" ");
						return s > -1 && (r = Te(t.slice(s)), t = t.slice(0, s)), m(e) ? (n = e, e = void 0) : e && "object" == typeof e && (i = "POST"), a.length > 0 && T.ajax({
							url: t,
							type: i || "GET",
							dataType: "html",
							data: e
						}).done((function(t) {
							o = arguments, a.html(r ? T("<div>").append(T.parseHTML(t)).find(r) : t)
						})).always(n && function(t, e) {
							a.each((function() {
								n.apply(this, o || [t.responseText, e, t])
							}))
						}), this
					}, T.expr.pseudos.animated = function(t) {
						return T.grep(T.timers, (function(e) {
							return t === e.elem
						})).length
					}, T.offset = {
						setOffset: function(t, e, n) {
							var r, i, o, a, s, l, c = T.css(t, "position"),
								u = T(t),
								h = {};
							"static" === c && (t.style.position = "relative"), s = u.offset(), o = T.css(t, "top"), l = T.css(t, "left"), ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1 ? (a = (r = u.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(l) || 0), m(e) && (e = e.call(t, n, T.extend({}, s))), null != e.top && (h.top = e.top - s.top + a), null != e.left && (h.left = e.left - s.left + i), "using" in e ? e.using.call(t, h) : u.css(h)
						}
					}, T.fn.extend({
						offset: function(t) {
							if (arguments.length) return void 0 === t ? this : this.each((function(e) {
								T.offset.setOffset(this, t, e)
							}));
							var e, n, r = this[0];
							return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
								top: e.top + n.pageYOffset,
								left: e.left + n.pageXOffset
							}) : {
								top: 0,
								left: 0
							} : void 0
						},
						position: function() {
							if (this[0]) {
								var t, e, n, r = this[0],
									i = {
										top: 0,
										left: 0
									};
								if ("fixed" === T.css(r, "position")) e = r.getBoundingClientRect();
								else {
									for (e = this.offset(), n = r.ownerDocument, t = r.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === T.css(t, "position");) t = t.parentNode;
									t && t !== r && 1 === t.nodeType && ((i = T(t).offset()).top += T.css(t, "borderTopWidth", !0), i.left += T.css(t, "borderLeftWidth", !0))
								}
								return {
									top: e.top - i.top - T.css(r, "marginTop", !0),
									left: e.left - i.left - T.css(r, "marginLeft", !0)
								}
							}
						},
						offsetParent: function() {
							return this.map((function() {
								for (var t = this.offsetParent; t && "static" === T.css(t, "position");) t = t.offsetParent;
								return t || gt
							}))
						}
					}), T.each({
						scrollLeft: "pageXOffset",
						scrollTop: "pageYOffset"
					}, (function(t, e) {
						var n = "pageYOffset" === e;
						T.fn[t] = function(r) {
							return tt(this, (function(t, r, i) {
								var o;
								if (y(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === i) return o ? o[e] : t[r];
								o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : t[r] = i
							}), t, r, arguments.length)
						}
					})), T.each(["top", "left"], (function(t, e) {
						T.cssHooks[e] = te(v.pixelPosition, (function(t, n) {
							if (n) return n = $t(t, e), Kt.test(n) ? T(t).position()[e] + "px" : n
						}))
					})), T.each({
						Height: "height",
						Width: "width"
					}, (function(t, e) {
						T.each({
							padding: "inner" + t,
							content: e,
							"": "outer" + t
						}, (function(n, r) {
							T.fn[r] = function(i, o) {
								var a = arguments.length && (n || "boolean" != typeof i),
									s = n || (!0 === i || !0 === o ? "margin" : "border");
								return tt(this, (function(e, n, i) {
									var o;
									return y(e) ? 0 === r.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === i ? T.css(e, n, s) : T.style(e, n, i, s)
								}), e, a ? i : void 0, a)
							}
						}))
					})), T.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function(t, e) {
						T.fn[e] = function(t) {
							return this.on(e, t)
						}
					})), T.fn.extend({
						bind: function(t, e, n) {
							return this.on(t, null, e, n)
						},
						unbind: function(t, e) {
							return this.off(t, null, e)
						},
						delegate: function(t, e, n, r) {
							return this.on(e, t, n, r)
						},
						undelegate: function(t, e, n) {
							return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
						},
						hover: function(t, e) {
							return this.on("mouseenter", t).on("mouseleave", e || t)
						}
					}), T.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(t, e) {
						T.fn[e] = function(t, n) {
							return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
						}
					}));
					var rn = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
					T.proxy = function(t, e) {
						var n, r, i;
						if ("string" == typeof e && (n = t[e], e = t, t = n), m(t)) return r = s.call(arguments, 2), i = function() {
							return t.apply(e || this, r.concat(s.call(arguments)))
						}, i.guid = t.guid = t.guid || T.guid++, i
					}, T.holdReady = function(t) {
						t ? T.readyWait++ : T.ready(!0)
					}, T.isArray = Array.isArray, T.parseJSON = JSON.parse, T.nodeName = F, T.isFunction = m, T.isWindow = y, T.camelCase = it, T.type = C, T.now = Date.now, T.isNumeric = function(t) {
						var e = T.type(t);
						return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
					}, T.trim = function(t) {
						return null == t ? "" : (t + "").replace(rn, "$1")
					}, void 0 === (n = function() {
						return T
					}.apply(e, [])) || (t.exports = n);
					var on = r.jQuery,
						an = r.$;
					return T.noConflict = function(t) {
						return r.$ === T && (r.$ = an), t && r.jQuery === T && (r.jQuery = on), T
					}, void 0 === i && (r.jQuery = r.$ = T), T
				}))
			},
			513: (t, e, n) => {
				t.exports = function t(e, n, r) {
					function i(a, s) {
						if (!n[a]) {
							if (!e[a]) {
								if (o) return o(a, !0);
								var l = new Error("Cannot find module '" + a + "'");
								throw l.code = "MODULE_NOT_FOUND", l
							}
							var c = n[a] = {
								exports: {}
							};
							e[a][0].call(c.exports, (function(t) {
								return i(e[a][1][t] || t)
							}), c, c.exports, t, e, n, r)
						}
						return n[a].exports
					}
					for (var o = void 0, a = 0; a < r.length; a++) i(r[a]);
					return i
				}({
					1: [function(t, e, r) {
						(function(t) {
							"use strict";
							var n, r, i = t.MutationObserver || t.WebKitMutationObserver;
							if (i) {
								var o = 0,
									a = new i(u),
									s = t.document.createTextNode("");
								a.observe(s, {
									characterData: !0
								}), n = function() {
									s.data = o = ++o % 2
								}
							} else if (t.setImmediate || void 0 === t.MessageChannel) n = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function() {
								var e = t.document.createElement("script");
								e.onreadystatechange = function() {
									u(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null
								}, t.document.documentElement.appendChild(e)
							} : function() {
								setTimeout(u, 0)
							};
							else {
								var l = new t.MessageChannel;
								l.port1.onmessage = u, n = function() {
									l.port2.postMessage(0)
								}
							}
							var c = [];

							function u() {
								var t, e;
								r = !0;
								for (var n = c.length; n;) {
									for (e = c, c = [], t = -1; ++t < n;) e[t]();
									n = c.length
								}
								r = !1
							}
							e.exports = function(t) {
								1 !== c.push(t) || r || n()
							}
						}).call(this, void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
					}, {}],
					2: [function(t, e, n) {
						"use strict";
						var r = t(1);

						function i() {}
						var o = {},
							a = ["REJECTED"],
							s = ["FULFILLED"],
							l = ["PENDING"];

						function c(t) {
							if ("function" != typeof t) throw new TypeError("resolver must be a function");
							this.state = l, this.queue = [], this.outcome = void 0, t !== i && d(this, t)
						}

						function u(t, e, n) {
							this.promise = t, "function" == typeof e && (this.onFulfilled = e, this.callFulfilled = this.otherCallFulfilled), "function" == typeof n && (this.onRejected = n, this.callRejected = this.otherCallRejected)
						}

						function h(t, e, n) {
							r((function() {
								var r;
								try {
									r = e(n)
								} catch (e) {
									return o.reject(t, e)
								}
								r === t ? o.reject(t, new TypeError("Cannot resolve promise with itself")) : o.resolve(t, r)
							}))
						}

						function f(t) {
							var e = t && t.then;
							if (t && ("object" == typeof t || "function" == typeof t) && "function" == typeof e) return function() {
								e.apply(t, arguments)
							}
						}

						function d(t, e) {
							var n = !1;

							function r(e) {
								n || (n = !0, o.reject(t, e))
							}

							function i(e) {
								n || (n = !0, o.resolve(t, e))
							}
							var a = p((function() {
								e(i, r)
							}));
							"error" === a.status && r(a.value)
						}

						function p(t, e) {
							var n = {};
							try {
								n.value = t(e), n.status = "success"
							} catch (t) {
								n.status = "error", n.value = t
							}
							return n
						}
						e.exports = c, c.prototype.catch = function(t) {
							return this.then(null, t)
						}, c.prototype.then = function(t, e) {
							if ("function" != typeof t && this.state === s || "function" != typeof e && this.state === a) return this;
							var n = new this.constructor(i);
							return this.state !== l ? h(n, this.state === s ? t : e, this.outcome) : this.queue.push(new u(n, t, e)), n
						}, u.prototype.callFulfilled = function(t) {
							o.resolve(this.promise, t)
						}, u.prototype.otherCallFulfilled = function(t) {
							h(this.promise, this.onFulfilled, t)
						}, u.prototype.callRejected = function(t) {
							o.reject(this.promise, t)
						}, u.prototype.otherCallRejected = function(t) {
							h(this.promise, this.onRejected, t)
						}, o.resolve = function(t, e) {
							var n = p(f, e);
							if ("error" === n.status) return o.reject(t, n.value);
							var r = n.value;
							if (r) d(t, r);
							else {
								t.state = s, t.outcome = e;
								for (var i = -1, a = t.queue.length; ++i < a;) t.queue[i].callFulfilled(e)
							}
							return t
						}, o.reject = function(t, e) {
							t.state = a, t.outcome = e;
							for (var n = -1, r = t.queue.length; ++n < r;) t.queue[n].callRejected(e);
							return t
						}, c.resolve = function(t) {
							return t instanceof this ? t : o.resolve(new this(i), t)
						}, c.reject = function(t) {
							var e = new this(i);
							return o.reject(e, t)
						}, c.all = function(t) {
							var e = this;
							if ("[object Array]" !== Object.prototype.toString.call(t)) return this.reject(new TypeError("must be an array"));
							var n = t.length,
								r = !1;
							if (!n) return this.resolve([]);
							for (var a = new Array(n), s = 0, l = -1, c = new this(i); ++l < n;) u(t[l], l);
							return c;

							function u(t, i) {
								e.resolve(t).then((function(t) {
									a[i] = t, ++s !== n || r || (r = !0, o.resolve(c, a))
								}), (function(t) {
									r || (r = !0, o.reject(c, t))
								}))
							}
						}, c.race = function(t) {
							var e = this;
							if ("[object Array]" !== Object.prototype.toString.call(t)) return this.reject(new TypeError("must be an array"));
							var n, r = t.length,
								a = !1;
							if (!r) return this.resolve([]);
							for (var s = -1, l = new this(i); ++s < r;) n = t[s], e.resolve(n).then((function(t) {
								a || (a = !0, o.resolve(l, t))
							}), (function(t) {
								a || (a = !0, o.reject(l, t))
							}));
							return l
						}
					}, {
						1: 1
					}],
					3: [function(t, e, r) {
						(function(e) {
							"use strict";
							"function" != typeof e.Promise && (e.Promise = t(2))
						}).call(this, void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
					}, {
						2: 2
					}],
					4: [function(t, e, n) {
						"use strict";
						var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
							return typeof t
						} : function(t) {
							return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
						};
						var i = function() {
							try {
								if ("undefined" != typeof indexedDB) return indexedDB;
								if ("undefined" != typeof webkitIndexedDB) return webkitIndexedDB;
								if ("undefined" != typeof mozIndexedDB) return mozIndexedDB;
								if ("undefined" != typeof OIndexedDB) return OIndexedDB;
								if ("undefined" != typeof msIndexedDB) return msIndexedDB
							} catch (t) {
								return
							}
						}();

						function o(t, e) {
							t = t || [], e = e || {};
							try {
								return new Blob(t, e)
							} catch (i) {
								if ("TypeError" !== i.name) throw i;
								for (var n = new("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder), r = 0; r < t.length; r += 1) n.append(t[r]);
								return n.getBlob(e.type)
							}
						}
						"undefined" == typeof Promise && t(3);
						var a = Promise;

						function s(t, e) {
							e && t.then((function(t) {
								e(null, t)
							}), (function(t) {
								e(t)
							}))
						}

						function l(t, e, n) {
							"function" == typeof e && t.then(e), "function" == typeof n && t.catch(n)
						}

						function c(t) {
							return "string" != typeof t && (console.warn(t + " used as a key, but it is not a string."), t = String(t)), t
						}

						function u() {
							if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1]
						}
						var h = "local-forage-detect-blob-support",
							f = void 0,
							d = {},
							p = Object.prototype.toString,
							g = "readonly",
							v = "readwrite";

						function m(t) {
							for (var e = t.length, n = new ArrayBuffer(e), r = new Uint8Array(n), i = 0; i < e; i++) r[i] = t.charCodeAt(i);
							return n
						}

						function y(t) {
							return "boolean" == typeof f ? a.resolve(f) : function(t) {
								return new a((function(e) {
									var n = t.transaction(h, v),
										r = o([""]);
									n.objectStore(h).put(r, "key"), n.onabort = function(t) {
										t.preventDefault(), t.stopPropagation(), e(!1)
									}, n.oncomplete = function() {
										var t = navigator.userAgent.match(/Chrome\/(\d+)/),
											n = navigator.userAgent.match(/Edge\//);
										e(n || !t || parseInt(t[1], 10) >= 43)
									}
								})).catch((function() {
									return !1
								}))
							}(t).then((function(t) {
								return f = t
							}))
						}

						function b(t) {
							var e = d[t.name],
								n = {};
							n.promise = new a((function(t, e) {
								n.resolve = t, n.reject = e
							})), e.deferredOperations.push(n), e.dbReady ? e.dbReady = e.dbReady.then((function() {
								return n.promise
							})) : e.dbReady = n.promise
						}

						function x(t) {
							var e = d[t.name].deferredOperations.pop();
							if (e) return e.resolve(), e.promise
						}

						function w(t, e) {
							var n = d[t.name].deferredOperations.pop();
							if (n) return n.reject(e), n.promise
						}

						function C(t, e) {
							return new a((function(n, r) {
								if (d[t.name] = d[t.name] || {
										forages: [],
										db: null,
										dbReady: null,
										deferredOperations: []
									}, t.db) {
									if (!e) return n(t.db);
									b(t), t.db.close()
								}
								var o = [t.name];
								e && o.push(t.version);
								var a = i.open.apply(i, o);
								e && (a.onupgradeneeded = function(e) {
									var n = a.result;
									try {
										n.createObjectStore(t.storeName), e.oldVersion <= 1 && n.createObjectStore(h)
									} catch (n) {
										if ("ConstraintError" !== n.name) throw n;
										console.warn('The database "' + t.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + t.storeName + '" already exists.')
									}
								}), a.onerror = function(t) {
									t.preventDefault(), r(a.error)
								}, a.onsuccess = function() {
									var e = a.result;
									e.onversionchange = function(t) {
										t.target.close()
									}, n(e), x(t)
								}
							}))
						}

						function S(t) {
							return C(t, !1)
						}

						function O(t) {
							return C(t, !0)
						}

						function T(t, e) {
							if (!t.db) return !0;
							var n = !t.db.objectStoreNames.contains(t.storeName),
								r = t.version < t.db.version,
								i = t.version > t.db.version;
							if (r && (t.version !== e && console.warn('The database "' + t.name + "\" can't be downgraded from version " + t.db.version + " to version " + t.version + "."), t.version = t.db.version), i || n) {
								if (n) {
									var o = t.db.version + 1;
									o > t.version && (t.version = o)
								}
								return !0
							}
							return !1
						}

						function k(t) {
							return o([m(atob(t.data))], {
								type: t.type
							})
						}

						function F(t) {
							return t && t.__local_forage_encoded_blob
						}

						function P(t) {
							var e = this,
								n = e._initReady().then((function() {
									var t = d[e._dbInfo.name];
									if (t && t.dbReady) return t.dbReady
								}));
							return l(n, t, t), n
						}

						function j(t, e, n, r) {
							void 0 === r && (r = 1);
							try {
								var i = t.db.transaction(t.storeName, e);
								n(null, i)
							} catch (i) {
								if (r > 0 && (!t.db || "InvalidStateError" === i.name || "NotFoundError" === i.name)) return a.resolve().then((function() {
									if (!t.db || "NotFoundError" === i.name && !t.db.objectStoreNames.contains(t.storeName) && t.version <= t.db.version) return t.db && (t.version = t.db.version + 1), O(t)
								})).then((function() {
									return function(t) {
										b(t);
										for (var e = d[t.name], n = e.forages, r = 0; r < n.length; r++) {
											var i = n[r];
											i._dbInfo.db && (i._dbInfo.db.close(), i._dbInfo.db = null)
										}
										return t.db = null, S(t).then((function(e) {
											return t.db = e, T(t) ? O(t) : e
										})).then((function(r) {
											t.db = e.db = r;
											for (var i = 0; i < n.length; i++) n[i]._dbInfo.db = r
										})).catch((function(e) {
											throw w(t, e), e
										}))
									}(t).then((function() {
										j(t, e, n, r - 1)
									}))
								})).catch(n);
								n(i)
							}
						}
						var A = {
							_driver: "asyncStorage",
							_initStorage: function(t) {
								var e = this,
									n = {
										db: null
									};
								if (t)
									for (var r in t) n[r] = t[r];
								var i = d[n.name];
								i || (i = {
									forages: [],
									db: null,
									dbReady: null,
									deferredOperations: []
								}, d[n.name] = i), i.forages.push(e), e._initReady || (e._initReady = e.ready, e.ready = P);
								var o = [];

								function s() {
									return a.resolve()
								}
								for (var l = 0; l < i.forages.length; l++) {
									var c = i.forages[l];
									c !== e && o.push(c._initReady().catch(s))
								}
								var u = i.forages.slice(0);
								return a.all(o).then((function() {
									return n.db = i.db, S(n)
								})).then((function(t) {
									return n.db = t, T(n, e._defaultConfig.version) ? O(n) : t
								})).then((function(t) {
									n.db = i.db = t, e._dbInfo = n;
									for (var r = 0; r < u.length; r++) {
										var o = u[r];
										o !== e && (o._dbInfo.db = n.db, o._dbInfo.version = n.version)
									}
								}))
							},
							_support: function() {
								try {
									if (!i || !i.open) return !1;
									var t = "undefined" != typeof openDatabase && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform),
										e = "function" == typeof fetch && -1 !== fetch.toString().indexOf("[native code");
									return (!t || e) && "undefined" != typeof indexedDB && "undefined" != typeof IDBKeyRange
								} catch (t) {
									return !1
								}
							}(),
							iterate: function(t, e) {
								var n = this,
									r = new a((function(e, r) {
										n.ready().then((function() {
											j(n._dbInfo, g, (function(i, o) {
												if (i) return r(i);
												try {
													var a = o.objectStore(n._dbInfo.storeName).openCursor(),
														s = 1;
													a.onsuccess = function() {
														var n = a.result;
														if (n) {
															var r = n.value;
															F(r) && (r = k(r));
															var i = t(r, n.key, s++);
															void 0 !== i ? e(i) : n.continue()
														} else e()
													}, a.onerror = function() {
														r(a.error)
													}
												} catch (t) {
													r(t)
												}
											}))
										})).catch(r)
									}));
								return s(r, e), r
							},
							getItem: function(t, e) {
								var n = this;
								t = c(t);
								var r = new a((function(e, r) {
									n.ready().then((function() {
										j(n._dbInfo, g, (function(i, o) {
											if (i) return r(i);
											try {
												var a = o.objectStore(n._dbInfo.storeName).get(t);
												a.onsuccess = function() {
													var t = a.result;
													void 0 === t && (t = null), F(t) && (t = k(t)), e(t)
												}, a.onerror = function() {
													r(a.error)
												}
											} catch (t) {
												r(t)
											}
										}))
									})).catch(r)
								}));
								return s(r, e), r
							},
							setItem: function(t, e, n) {
								var r = this;
								t = c(t);
								var i = new a((function(n, i) {
									var o;
									r.ready().then((function() {
										return o = r._dbInfo, "[object Blob]" === p.call(e) ? y(o.db).then((function(t) {
											return t ? e : (n = e, new a((function(t, e) {
												var r = new FileReader;
												r.onerror = e, r.onloadend = function(e) {
													var r = btoa(e.target.result || "");
													t({
														__local_forage_encoded_blob: !0,
														data: r,
														type: n.type
													})
												}, r.readAsBinaryString(n)
											})));
											var n
										})) : e
									})).then((function(e) {
										j(r._dbInfo, v, (function(o, a) {
											if (o) return i(o);
											try {
												var s = a.objectStore(r._dbInfo.storeName);
												null === e && (e = void 0);
												var l = s.put(e, t);
												a.oncomplete = function() {
													void 0 === e && (e = null), n(e)
												}, a.onabort = a.onerror = function() {
													var t = l.error ? l.error : l.transaction.error;
													i(t)
												}
											} catch (t) {
												i(t)
											}
										}))
									})).catch(i)
								}));
								return s(i, n), i
							},
							removeItem: function(t, e) {
								var n = this;
								t = c(t);
								var r = new a((function(e, r) {
									n.ready().then((function() {
										j(n._dbInfo, v, (function(i, o) {
											if (i) return r(i);
											try {
												var a = o.objectStore(n._dbInfo.storeName).delete(t);
												o.oncomplete = function() {
													e()
												}, o.onerror = function() {
													r(a.error)
												}, o.onabort = function() {
													var t = a.error ? a.error : a.transaction.error;
													r(t)
												}
											} catch (t) {
												r(t)
											}
										}))
									})).catch(r)
								}));
								return s(r, e), r
							},
							clear: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											j(e._dbInfo, v, (function(r, i) {
												if (r) return n(r);
												try {
													var o = i.objectStore(e._dbInfo.storeName).clear();
													i.oncomplete = function() {
														t()
													}, i.onabort = i.onerror = function() {
														var t = o.error ? o.error : o.transaction.error;
														n(t)
													}
												} catch (t) {
													n(t)
												}
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							length: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											j(e._dbInfo, g, (function(r, i) {
												if (r) return n(r);
												try {
													var o = i.objectStore(e._dbInfo.storeName).count();
													o.onsuccess = function() {
														t(o.result)
													}, o.onerror = function() {
														n(o.error)
													}
												} catch (t) {
													n(t)
												}
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							key: function(t, e) {
								var n = this,
									r = new a((function(e, r) {
										t < 0 ? e(null) : n.ready().then((function() {
											j(n._dbInfo, g, (function(i, o) {
												if (i) return r(i);
												try {
													var a = o.objectStore(n._dbInfo.storeName),
														s = !1,
														l = a.openKeyCursor();
													l.onsuccess = function() {
														var n = l.result;
														n ? 0 === t || s ? e(n.key) : (s = !0, n.advance(t)) : e(null)
													}, l.onerror = function() {
														r(l.error)
													}
												} catch (t) {
													r(t)
												}
											}))
										})).catch(r)
									}));
								return s(r, e), r
							},
							keys: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											j(e._dbInfo, g, (function(r, i) {
												if (r) return n(r);
												try {
													var o = i.objectStore(e._dbInfo.storeName).openKeyCursor(),
														a = [];
													o.onsuccess = function() {
														var e = o.result;
														e ? (a.push(e.key), e.continue()) : t(a)
													}, o.onerror = function() {
														n(o.error)
													}
												} catch (t) {
													n(t)
												}
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							dropInstance: function(t, e) {
								e = u.apply(this, arguments);
								var n, r = this.config();
								if ((t = "function" != typeof t && t || {}).name || (t.name = t.name || r.name, t.storeName = t.storeName || r.storeName), t.name) {
									var o = t.name === r.name && this._dbInfo.db ? a.resolve(this._dbInfo.db) : S(t).then((function(e) {
										var n = d[t.name],
											r = n.forages;
										n.db = e;
										for (var i = 0; i < r.length; i++) r[i]._dbInfo.db = e;
										return e
									}));
									n = t.storeName ? o.then((function(e) {
										if (e.objectStoreNames.contains(t.storeName)) {
											var n = e.version + 1;
											b(t);
											var r = d[t.name],
												o = r.forages;
											e.close();
											for (var s = 0; s < o.length; s++) {
												var l = o[s];
												l._dbInfo.db = null, l._dbInfo.version = n
											}
											var c = new a((function(e, r) {
												var o = i.open(t.name, n);
												o.onerror = function(t) {
													o.result.close(), r(t)
												}, o.onupgradeneeded = function() {
													o.result.deleteObjectStore(t.storeName)
												}, o.onsuccess = function() {
													var t = o.result;
													t.close(), e(t)
												}
											}));
											return c.then((function(t) {
												r.db = t;
												for (var e = 0; e < o.length; e++) {
													var n = o[e];
													n._dbInfo.db = t, x(n._dbInfo)
												}
											})).catch((function(e) {
												throw (w(t, e) || a.resolve()).catch((function() {})), e
											}))
										}
									})) : o.then((function(e) {
										b(t);
										var n = d[t.name],
											r = n.forages;
										e.close();
										for (var o = 0; o < r.length; o++) r[o]._dbInfo.db = null;
										var s = new a((function(e, n) {
											var r = i.deleteDatabase(t.name);
											r.onerror = function() {
												var t = r.result;
												t && t.close(), n(r.error)
											}, r.onblocked = function() {
												console.warn('dropInstance blocked for database "' + t.name + '" until all open connections are closed')
											}, r.onsuccess = function() {
												var t = r.result;
												t && t.close(), e(t)
											}
										}));
										return s.then((function(t) {
											n.db = t;
											for (var e = 0; e < r.length; e++) x(r[e]._dbInfo)
										})).catch((function(e) {
											throw (w(t, e) || a.resolve()).catch((function() {})), e
										}))
									}))
								} else n = a.reject("Invalid arguments");
								return s(n, e), n
							}
						};
						var _ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
							E = /^~~local_forage_type~([^~]+)~/,
							D = "__lfsc__:",
							M = "arbf",
							I = "blob",
							R = "si08",
							B = "ui08",
							N = "uic8",
							L = "si16",
							z = "si32",
							W = "ur16",
							V = "ui32",
							U = "fl32",
							H = "fl64",
							q = Object.prototype.toString;

						function X(t) {
							var e, n, r, i, o, a = .75 * t.length,
								s = t.length,
								l = 0;
							"=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
							var c = new ArrayBuffer(a),
								u = new Uint8Array(c);
							for (e = 0; e < s; e += 4) n = _.indexOf(t[e]), r = _.indexOf(t[e + 1]), i = _.indexOf(t[e + 2]), o = _.indexOf(t[e + 3]), u[l++] = n << 2 | r >> 4, u[l++] = (15 & r) << 4 | i >> 2, u[l++] = (3 & i) << 6 | 63 & o;
							return c
						}

						function G(t) {
							var e, n = new Uint8Array(t),
								r = "";
							for (e = 0; e < n.length; e += 3) r += _[n[e] >> 2], r += _[(3 & n[e]) << 4 | n[e + 1] >> 4], r += _[(15 & n[e + 1]) << 2 | n[e + 2] >> 6], r += _[63 & n[e + 2]];
							return n.length % 3 == 2 ? r = r.substring(0, r.length - 1) + "=" : n.length % 3 == 1 && (r = r.substring(0, r.length - 2) + "=="), r
						}
						var K = {
							serialize: function(t, e) {
								var n = "";
								if (t && (n = q.call(t)), t && ("[object ArrayBuffer]" === n || t.buffer && "[object ArrayBuffer]" === q.call(t.buffer))) {
									var r, i = D;
									t instanceof ArrayBuffer ? (r = t, i += M) : (r = t.buffer, "[object Int8Array]" === n ? i += R : "[object Uint8Array]" === n ? i += B : "[object Uint8ClampedArray]" === n ? i += N : "[object Int16Array]" === n ? i += L : "[object Uint16Array]" === n ? i += W : "[object Int32Array]" === n ? i += z : "[object Uint32Array]" === n ? i += V : "[object Float32Array]" === n ? i += U : "[object Float64Array]" === n ? i += H : e(new Error("Failed to get type for BinaryArray"))), e(i + G(r))
								} else if ("[object Blob]" === n) {
									var o = new FileReader;
									o.onload = function() {
										var n = "~~local_forage_type~" + t.type + "~" + G(this.result);
										e(D + I + n)
									}, o.readAsArrayBuffer(t)
								} else try {
									e(JSON.stringify(t))
								} catch (n) {
									console.error("Couldn't convert value into a JSON string: ", t), e(null, n)
								}
							},
							deserialize: function(t) {
								if (t.substring(0, 9) !== D) return JSON.parse(t);
								var e, n = t.substring(13),
									r = t.substring(9, 13);
								if (r === I && E.test(n)) {
									var i = n.match(E);
									e = i[1], n = n.substring(i[0].length)
								}
								var a = X(n);
								switch (r) {
									case M:
										return a;
									case I:
										return o([a], {
											type: e
										});
									case R:
										return new Int8Array(a);
									case B:
										return new Uint8Array(a);
									case N:
										return new Uint8ClampedArray(a);
									case L:
										return new Int16Array(a);
									case W:
										return new Uint16Array(a);
									case z:
										return new Int32Array(a);
									case V:
										return new Uint32Array(a);
									case U:
										return new Float32Array(a);
									case H:
										return new Float64Array(a);
									default:
										throw new Error("Unkown type: " + r)
								}
							},
							stringToBuffer: X,
							bufferToString: G
						};

						function Y(t, e, n, r) {
							t.executeSql("CREATE TABLE IF NOT EXISTS " + e.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], n, r)
						}

						function Z(t, e, n, r, i, o) {
							t.executeSql(n, r, i, (function(t, a) {
								a.code === a.SYNTAX_ERR ? t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [e.storeName], (function(t, s) {
									s.rows.length ? o(t, a) : Y(t, e, (function() {
										t.executeSql(n, r, i, o)
									}), o)
								}), o) : o(t, a)
							}), o)
						}

						function J(t, e, n, r) {
							var i = this;
							t = c(t);
							var o = new a((function(o, a) {
								i.ready().then((function() {
									void 0 === e && (e = null);
									var s = e,
										l = i._dbInfo;
									l.serializer.serialize(e, (function(e, c) {
										c ? a(c) : l.db.transaction((function(n) {
											Z(n, l, "INSERT OR REPLACE INTO " + l.storeName + " (key, value) VALUES (?, ?)", [t, e], (function() {
												o(s)
											}), (function(t, e) {
												a(e)
											}))
										}), (function(e) {
											if (e.code === e.QUOTA_ERR) {
												if (r > 0) return void o(J.apply(i, [t, s, n, r - 1]));
												a(e)
											}
										}))
									}))
								})).catch(a)
							}));
							return s(o, n), o
						}
						var Q = {
							_driver: "webSQLStorage",
							_initStorage: function(t) {
								var e = this,
									n = {
										db: null
									};
								if (t)
									for (var r in t) n[r] = "string" != typeof t[r] ? t[r].toString() : t[r];
								var i = new a((function(t, r) {
									try {
										n.db = openDatabase(n.name, String(n.version), n.description, n.size)
									} catch (t) {
										return r(t)
									}
									n.db.transaction((function(i) {
										Y(i, n, (function() {
											e._dbInfo = n, t()
										}), (function(t, e) {
											r(e)
										}))
									}), r)
								}));
								return n.serializer = K, i
							},
							_support: "function" == typeof openDatabase,
							iterate: function(t, e) {
								var n = this,
									r = new a((function(e, r) {
										n.ready().then((function() {
											var i = n._dbInfo;
											i.db.transaction((function(n) {
												Z(n, i, "SELECT * FROM " + i.storeName, [], (function(n, r) {
													for (var o = r.rows, a = o.length, s = 0; s < a; s++) {
														var l = o.item(s),
															c = l.value;
														if (c && (c = i.serializer.deserialize(c)), void 0 !== (c = t(c, l.key, s + 1))) return void e(c)
													}
													e()
												}), (function(t, e) {
													r(e)
												}))
											}))
										})).catch(r)
									}));
								return s(r, e), r
							},
							getItem: function(t, e) {
								var n = this;
								t = c(t);
								var r = new a((function(e, r) {
									n.ready().then((function() {
										var i = n._dbInfo;
										i.db.transaction((function(n) {
											Z(n, i, "SELECT * FROM " + i.storeName + " WHERE key = ? LIMIT 1", [t], (function(t, n) {
												var r = n.rows.length ? n.rows.item(0).value : null;
												r && (r = i.serializer.deserialize(r)), e(r)
											}), (function(t, e) {
												r(e)
											}))
										}))
									})).catch(r)
								}));
								return s(r, e), r
							},
							setItem: function(t, e, n) {
								return J.apply(this, [t, e, n, 1])
							},
							removeItem: function(t, e) {
								var n = this;
								t = c(t);
								var r = new a((function(e, r) {
									n.ready().then((function() {
										var i = n._dbInfo;
										i.db.transaction((function(n) {
											Z(n, i, "DELETE FROM " + i.storeName + " WHERE key = ?", [t], (function() {
												e()
											}), (function(t, e) {
												r(e)
											}))
										}))
									})).catch(r)
								}));
								return s(r, e), r
							},
							clear: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											var r = e._dbInfo;
											r.db.transaction((function(e) {
												Z(e, r, "DELETE FROM " + r.storeName, [], (function() {
													t()
												}), (function(t, e) {
													n(e)
												}))
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							length: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											var r = e._dbInfo;
											r.db.transaction((function(e) {
												Z(e, r, "SELECT COUNT(key) as c FROM " + r.storeName, [], (function(e, n) {
													var r = n.rows.item(0).c;
													t(r)
												}), (function(t, e) {
													n(e)
												}))
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							key: function(t, e) {
								var n = this,
									r = new a((function(e, r) {
										n.ready().then((function() {
											var i = n._dbInfo;
											i.db.transaction((function(n) {
												Z(n, i, "SELECT key FROM " + i.storeName + " WHERE id = ? LIMIT 1", [t + 1], (function(t, n) {
													var r = n.rows.length ? n.rows.item(0).key : null;
													e(r)
												}), (function(t, e) {
													r(e)
												}))
											}))
										})).catch(r)
									}));
								return s(r, e), r
							},
							keys: function(t) {
								var e = this,
									n = new a((function(t, n) {
										e.ready().then((function() {
											var r = e._dbInfo;
											r.db.transaction((function(e) {
												Z(e, r, "SELECT key FROM " + r.storeName, [], (function(e, n) {
													for (var r = [], i = 0; i < n.rows.length; i++) r.push(n.rows.item(i).key);
													t(r)
												}), (function(t, e) {
													n(e)
												}))
											}))
										})).catch(n)
									}));
								return s(n, t), n
							},
							dropInstance: function(t, e) {
								e = u.apply(this, arguments);
								var n = this.config();
								(t = "function" != typeof t && t || {}).name || (t.name = t.name || n.name, t.storeName = t.storeName || n.storeName);
								var r, i = this;
								return s(r = t.name ? new a((function(e) {
									var r;
									r = t.name === n.name ? i._dbInfo.db : openDatabase(t.name, "", "", 0), t.storeName ? e({
										db: r,
										storeNames: [t.storeName]
									}) : e(function(t) {
										return new a((function(e, n) {
											t.transaction((function(r) {
												r.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], (function(n, r) {
													for (var i = [], o = 0; o < r.rows.length; o++) i.push(r.rows.item(o).name);
													e({
														db: t,
														storeNames: i
													})
												}), (function(t, e) {
													n(e)
												}))
											}), (function(t) {
												n(t)
											}))
										}))
									}(r))
								})).then((function(t) {
									return new a((function(e, n) {
										t.db.transaction((function(r) {
											function i(t) {
												return new a((function(e, n) {
													r.executeSql("DROP TABLE IF EXISTS " + t, [], (function() {
														e()
													}), (function(t, e) {
														n(e)
													}))
												}))
											}
											for (var o = [], s = 0, l = t.storeNames.length; s < l; s++) o.push(i(t.storeNames[s]));
											a.all(o).then((function() {
												e()
											})).catch((function(t) {
												n(t)
											}))
										}), (function(t) {
											n(t)
										}))
									}))
								})) : a.reject("Invalid arguments"), e), r
							}
						};

						function $(t, e) {
							var n = t.name + "/";
							return t.storeName !== e.storeName && (n += t.storeName + "/"), n
						}

						function tt() {
							return ! function() {
								var t = "_localforage_support_test";
								try {
									return localStorage.setItem(t, !0), localStorage.removeItem(t), !1
								} catch (t) {
									return !0
								}
							}() || localStorage.length > 0
						}
						var et = {
								_driver: "localStorageWrapper",
								_initStorage: function(t) {
									var e = {};
									if (t)
										for (var n in t) e[n] = t[n];
									return e.keyPrefix = $(t, this._defaultConfig), tt() ? (this._dbInfo = e, e.serializer = K, a.resolve()) : a.reject()
								},
								_support: function() {
									try {
										return "undefined" != typeof localStorage && "setItem" in localStorage && !!localStorage.setItem
									} catch (t) {
										return !1
									}
								}(),
								iterate: function(t, e) {
									var n = this,
										r = n.ready().then((function() {
											for (var e = n._dbInfo, r = e.keyPrefix, i = r.length, o = localStorage.length, a = 1, s = 0; s < o; s++) {
												var l = localStorage.key(s);
												if (0 === l.indexOf(r)) {
													var c = localStorage.getItem(l);
													if (c && (c = e.serializer.deserialize(c)), void 0 !== (c = t(c, l.substring(i), a++))) return c
												}
											}
										}));
									return s(r, e), r
								},
								getItem: function(t, e) {
									var n = this;
									t = c(t);
									var r = n.ready().then((function() {
										var e = n._dbInfo,
											r = localStorage.getItem(e.keyPrefix + t);
										return r && (r = e.serializer.deserialize(r)), r
									}));
									return s(r, e), r
								},
								setItem: function(t, e, n) {
									var r = this;
									t = c(t);
									var i = r.ready().then((function() {
										void 0 === e && (e = null);
										var n = e;
										return new a((function(i, o) {
											var a = r._dbInfo;
											a.serializer.serialize(e, (function(e, r) {
												if (r) o(r);
												else try {
													localStorage.setItem(a.keyPrefix + t, e), i(n)
												} catch (t) {
													"QuotaExceededError" !== t.name && "NS_ERROR_DOM_QUOTA_REACHED" !== t.name || o(t), o(t)
												}
											}))
										}))
									}));
									return s(i, n), i
								},
								removeItem: function(t, e) {
									var n = this;
									t = c(t);
									var r = n.ready().then((function() {
										var e = n._dbInfo;
										localStorage.removeItem(e.keyPrefix + t)
									}));
									return s(r, e), r
								},
								clear: function(t) {
									var e = this,
										n = e.ready().then((function() {
											for (var t = e._dbInfo.keyPrefix, n = localStorage.length - 1; n >= 0; n--) {
												var r = localStorage.key(n);
												0 === r.indexOf(t) && localStorage.removeItem(r)
											}
										}));
									return s(n, t), n
								},
								length: function(t) {
									var e = this.keys().then((function(t) {
										return t.length
									}));
									return s(e, t), e
								},
								key: function(t, e) {
									var n = this,
										r = n.ready().then((function() {
											var e, r = n._dbInfo;
											try {
												e = localStorage.key(t)
											} catch (t) {
												e = null
											}
											return e && (e = e.substring(r.keyPrefix.length)), e
										}));
									return s(r, e), r
								},
								keys: function(t) {
									var e = this,
										n = e.ready().then((function() {
											for (var t = e._dbInfo, n = localStorage.length, r = [], i = 0; i < n; i++) {
												var o = localStorage.key(i);
												0 === o.indexOf(t.keyPrefix) && r.push(o.substring(t.keyPrefix.length))
											}
											return r
										}));
									return s(n, t), n
								},
								dropInstance: function(t, e) {
									if (e = u.apply(this, arguments), !(t = "function" != typeof t && t || {}).name) {
										var n = this.config();
										t.name = t.name || n.name, t.storeName = t.storeName || n.storeName
									}
									var r, i = this;
									return r = t.name ? new a((function(e) {
										t.storeName ? e($(t, i._defaultConfig)) : e(t.name + "/")
									})).then((function(t) {
										for (var e = localStorage.length - 1; e >= 0; e--) {
											var n = localStorage.key(e);
											0 === n.indexOf(t) && localStorage.removeItem(n)
										}
									})) : a.reject("Invalid arguments"), s(r, e), r
								}
							},
							nt = function(t, e) {
								for (var n = t.length, r = 0; r < n;) {
									if ((i = t[r]) === (o = e) || "number" == typeof i && "number" == typeof o && isNaN(i) && isNaN(o)) return !0;
									r++
								}
								var i, o;
								return !1
							},
							rt = Array.isArray || function(t) {
								return "[object Array]" === Object.prototype.toString.call(t)
							},
							it = {},
							ot = {},
							at = {
								INDEXEDDB: A,
								WEBSQL: Q,
								LOCALSTORAGE: et
							},
							st = [at.INDEXEDDB._driver, at.WEBSQL._driver, at.LOCALSTORAGE._driver],
							lt = ["dropInstance"],
							ct = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(lt),
							ut = {
								description: "",
								driver: st.slice(),
								name: "localforage",
								size: 4980736,
								storeName: "keyvaluepairs",
								version: 1
							};

						function ht(t, e) {
							t[e] = function() {
								var n = arguments;
								return t.ready().then((function() {
									return t[e].apply(t, n)
								}))
							}
						}

						function ft() {
							for (var t = 1; t < arguments.length; t++) {
								var e = arguments[t];
								if (e)
									for (var n in e) e.hasOwnProperty(n) && (rt(e[n]) ? arguments[0][n] = e[n].slice() : arguments[0][n] = e[n])
							}
							return arguments[0]
						}
						var dt = function() {
								function t(e) {
									for (var n in function(t, e) {
											if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
										}(this, t), at)
										if (at.hasOwnProperty(n)) {
											var r = at[n],
												i = r._driver;
											this[n] = i, it[i] || this.defineDriver(r)
										} this._defaultConfig = ft({}, ut), this._config = ft({}, this._defaultConfig, e), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch((function() {}))
								}
								return t.prototype.config = function(t) {
									if ("object" === (void 0 === t ? "undefined" : r(t))) {
										if (this._ready) return new Error("Can't call config() after localforage has been used.");
										for (var e in t) {
											if ("storeName" === e && (t[e] = t[e].replace(/\W/g, "_")), "version" === e && "number" != typeof t[e]) return new Error("Database version must be a number.");
											this._config[e] = t[e]
										}
										return !("driver" in t) || !t.driver || this.setDriver(this._config.driver)
									}
									return "string" == typeof t ? this._config[t] : this._config
								}, t.prototype.defineDriver = function(t, e, n) {
									var r = new a((function(e, n) {
										try {
											var r = t._driver,
												i = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
											if (!t._driver) return void n(i);
											for (var o = ct.concat("_initStorage"), l = 0, c = o.length; l < c; l++) {
												var u = o[l];
												if ((!nt(lt, u) || t[u]) && "function" != typeof t[u]) return void n(i)
											}! function() {
												for (var e = function(t) {
														return function() {
															var e = new Error("Method " + t + " is not implemented by the current driver"),
																n = a.reject(e);
															return s(n, arguments[arguments.length - 1]), n
														}
													}, n = 0, r = lt.length; n < r; n++) {
													var i = lt[n];
													t[i] || (t[i] = e(i))
												}
											}();
											var h = function(n) {
												it[r] && console.info("Redefining LocalForage driver: " + r), it[r] = t, ot[r] = n, e()
											};
											"_support" in t ? t._support && "function" == typeof t._support ? t._support().then(h, n) : h(!!t._support) : h(!0)
										} catch (t) {
											n(t)
										}
									}));
									return l(r, e, n), r
								}, t.prototype.driver = function() {
									return this._driver || null
								}, t.prototype.getDriver = function(t, e, n) {
									var r = it[t] ? a.resolve(it[t]) : a.reject(new Error("Driver not found."));
									return l(r, e, n), r
								}, t.prototype.getSerializer = function(t) {
									var e = a.resolve(K);
									return l(e, t), e
								}, t.prototype.ready = function(t) {
									var e = this,
										n = e._driverSet.then((function() {
											return null === e._ready && (e._ready = e._initDriver()), e._ready
										}));
									return l(n, t, t), n
								}, t.prototype.setDriver = function(t, e, n) {
									var r = this;
									rt(t) || (t = [t]);
									var i = this._getSupportedDrivers(t);

									function o() {
										r._config.driver = r.driver()
									}

									function s(t) {
										return r._extend(t), o(), r._ready = r._initStorage(r._config), r._ready
									}
									var c = null !== this._driverSet ? this._driverSet.catch((function() {
										return a.resolve()
									})) : a.resolve();
									return this._driverSet = c.then((function() {
										var t = i[0];
										return r._dbInfo = null, r._ready = null, r.getDriver(t).then((function(t) {
											r._driver = t._driver, o(), r._wrapLibraryMethodsWithReady(), r._initDriver = function(t) {
												return function() {
													var e = 0;
													return function n() {
														for (; e < t.length;) {
															var i = t[e];
															return e++, r._dbInfo = null, r._ready = null, r.getDriver(i).then(s).catch(n)
														}
														o();
														var l = new Error("No available storage method found.");
														return r._driverSet = a.reject(l), r._driverSet
													}()
												}
											}(i)
										}))
									})).catch((function() {
										o();
										var t = new Error("No available storage method found.");
										return r._driverSet = a.reject(t), r._driverSet
									})), l(this._driverSet, e, n), this._driverSet
								}, t.prototype.supports = function(t) {
									return !!ot[t]
								}, t.prototype._extend = function(t) {
									ft(this, t)
								}, t.prototype._getSupportedDrivers = function(t) {
									for (var e = [], n = 0, r = t.length; n < r; n++) {
										var i = t[n];
										this.supports(i) && e.push(i)
									}
									return e
								}, t.prototype._wrapLibraryMethodsWithReady = function() {
									for (var t = 0, e = ct.length; t < e; t++) ht(this, ct[t])
								}, t.prototype.createInstance = function(e) {
									return new t(e)
								}, t
							}(),
							pt = new dt;
						e.exports = pt
					}, {
						3: 3
					}]
				}, {}, [4])(4)
			},
			442: (t, e, n) => {
				"use strict";
				var r = {};
				(0, n(251).assign)(r, n(64), n(986), n(681)), t.exports = r
			},
			64: (t, e, n) => {
				"use strict";
				var r = n(246),
					i = n(251),
					o = n(816),
					a = n(587),
					s = n(213),
					l = Object.prototype.toString,
					c = 0,
					u = -1,
					h = 0,
					f = 8;

				function d(t) {
					if (!(this instanceof d)) return new d(t);
					this.options = i.assign({
						level: u,
						method: f,
						chunkSize: 16384,
						windowBits: 15,
						memLevel: 8,
						strategy: h,
						to: ""
					}, t || {});
					var e = this.options;
					e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0;
					var n = r.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
					if (n !== c) throw new Error(a[n]);
					if (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary) {
						var p;
						if (p = "string" == typeof e.dictionary ? o.string2buf(e.dictionary) : "[object ArrayBuffer]" === l.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (n = r.deflateSetDictionary(this.strm, p)) !== c) throw new Error(a[n]);
						this._dict_set = !0
					}
				}

				function p(t, e) {
					var n = new d(e);
					if (n.push(t, !0), n.err) throw n.msg || a[n.err];
					return n.result
				}
				d.prototype.push = function(t, e) {
					var n, a, s = this.strm,
						u = this.options.chunkSize;
					if (this.ended) return !1;
					a = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? s.input = o.string2buf(t) : "[object ArrayBuffer]" === l.call(t) ? s.input = new Uint8Array(t) : s.input = t, s.next_in = 0, s.avail_in = s.input.length;
					do {
						if (0 === s.avail_out && (s.output = new i.Buf8(u), s.next_out = 0, s.avail_out = u), 1 !== (n = r.deflate(s, a)) && n !== c) return this.onEnd(n), this.ended = !0, !1;
						0 !== s.avail_out && (0 !== s.avail_in || 4 !== a && 2 !== a) || ("string" === this.options.to ? this.onData(o.buf2binstring(i.shrinkBuf(s.output, s.next_out))) : this.onData(i.shrinkBuf(s.output, s.next_out)))
					} while ((s.avail_in > 0 || 0 === s.avail_out) && 1 !== n);
					return 4 === a ? (n = r.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === c) : 2 !== a || (this.onEnd(c), s.avail_out = 0, !0)
				}, d.prototype.onData = function(t) {
					this.chunks.push(t)
				}, d.prototype.onEnd = function(t) {
					t === c && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
				}, e.Deflate = d, e.deflate = p, e.deflateRaw = function(t, e) {
					return (e = e || {}).raw = !0, p(t, e)
				}, e.gzip = function(t, e) {
					return (e = e || {}).gzip = !0, p(t, e)
				}
			},
			986: (t, e, n) => {
				"use strict";
				var r = n(387),
					i = n(251),
					o = n(816),
					a = n(681),
					s = n(587),
					l = n(213),
					c = n(974),
					u = Object.prototype.toString;

				function h(t) {
					if (!(this instanceof h)) return new h(t);
					this.options = i.assign({
						chunkSize: 16384,
						windowBits: 0,
						to: ""
					}, t || {});
					var e = this.options;
					e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l, this.strm.avail_out = 0;
					var n = r.inflateInit2(this.strm, e.windowBits);
					if (n !== a.Z_OK) throw new Error(s[n]);
					if (this.header = new c, r.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = o.string2buf(e.dictionary) : "[object ArrayBuffer]" === u.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = r.inflateSetDictionary(this.strm, e.dictionary)) !== a.Z_OK)) throw new Error(s[n])
				}

				function f(t, e) {
					var n = new h(e);
					if (n.push(t, !0), n.err) throw n.msg || s[n.err];
					return n.result
				}
				h.prototype.push = function(t, e) {
					var n, s, l, c, h, f = this.strm,
						d = this.options.chunkSize,
						p = this.options.dictionary,
						g = !1;
					if (this.ended) return !1;
					s = e === ~~e ? e : !0 === e ? a.Z_FINISH : a.Z_NO_FLUSH, "string" == typeof t ? f.input = o.binstring2buf(t) : "[object ArrayBuffer]" === u.call(t) ? f.input = new Uint8Array(t) : f.input = t, f.next_in = 0, f.avail_in = f.input.length;
					do {
						if (0 === f.avail_out && (f.output = new i.Buf8(d), f.next_out = 0, f.avail_out = d), (n = r.inflate(f, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && p && (n = r.inflateSetDictionary(this.strm, p)), n === a.Z_BUF_ERROR && !0 === g && (n = a.Z_OK, g = !1), n !== a.Z_STREAM_END && n !== a.Z_OK) return this.onEnd(n), this.ended = !0, !1;
						f.next_out && (0 !== f.avail_out && n !== a.Z_STREAM_END && (0 !== f.avail_in || s !== a.Z_FINISH && s !== a.Z_SYNC_FLUSH) || ("string" === this.options.to ? (l = o.utf8border(f.output, f.next_out), c = f.next_out - l, h = o.buf2string(f.output, l), f.next_out = c, f.avail_out = d - c, c && i.arraySet(f.output, f.output, l, c, 0), this.onData(h)) : this.onData(i.shrinkBuf(f.output, f.next_out)))), 0 === f.avail_in && 0 === f.avail_out && (g = !0)
					} while ((f.avail_in > 0 || 0 === f.avail_out) && n !== a.Z_STREAM_END);
					return n === a.Z_STREAM_END && (s = a.Z_FINISH), s === a.Z_FINISH ? (n = r.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === a.Z_OK) : s !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), f.avail_out = 0, !0)
				}, h.prototype.onData = function(t) {
					this.chunks.push(t)
				}, h.prototype.onEnd = function(t) {
					t === a.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
				}, e.Inflate = h, e.inflate = f, e.inflateRaw = function(t, e) {
					return (e = e || {}).raw = !0, f(t, e)
				}, e.ungzip = f
			},
			251: (t, e) => {
				"use strict";
				var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;

				function r(t, e) {
					return Object.prototype.hasOwnProperty.call(t, e)
				}
				e.assign = function(t) {
					for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
						var n = e.shift();
						if (n) {
							if ("object" != typeof n) throw new TypeError(n + "must be non-object");
							for (var i in n) r(n, i) && (t[i] = n[i])
						}
					}
					return t
				}, e.shrinkBuf = function(t, e) {
					return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t)
				};
				var i = {
						arraySet: function(t, e, n, r, i) {
							if (e.subarray && t.subarray) t.set(e.subarray(n, n + r), i);
							else
								for (var o = 0; o < r; o++) t[i + o] = e[n + o]
						},
						flattenChunks: function(t) {
							var e, n, r, i, o, a;
							for (r = 0, e = 0, n = t.length; e < n; e++) r += t[e].length;
							for (a = new Uint8Array(r), i = 0, e = 0, n = t.length; e < n; e++) o = t[e], a.set(o, i), i += o.length;
							return a
						}
					},
					o = {
						arraySet: function(t, e, n, r, i) {
							for (var o = 0; o < r; o++) t[i + o] = e[n + o]
						},
						flattenChunks: function(t) {
							return [].concat.apply([], t)
						}
					};
				e.setTyped = function(t) {
					t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o))
				}, e.setTyped(n)
			},
			816: (t, e, n) => {
				"use strict";
				var r = n(251),
					i = !0,
					o = !0;
				try {
					String.fromCharCode.apply(null, [0])
				} catch (t) {
					i = !1
				}
				try {
					String.fromCharCode.apply(null, new Uint8Array(1))
				} catch (t) {
					o = !1
				}
				for (var a = new r.Buf8(256), s = 0; s < 256; s++) a[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1;

				function l(t, e) {
					if (e < 65534 && (t.subarray && o || !t.subarray && i)) return String.fromCharCode.apply(null, r.shrinkBuf(t, e));
					for (var n = "", a = 0; a < e; a++) n += String.fromCharCode(t[a]);
					return n
				}
				a[254] = a[254] = 1, e.string2buf = function(t) {
					var e, n, i, o, a, s = t.length,
						l = 0;
					for (o = 0; o < s; o++) 55296 == (64512 & (n = t.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (i = t.charCodeAt(o + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), o++), l += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
					for (e = new r.Buf8(l), a = 0, o = 0; a < l; o++) 55296 == (64512 & (n = t.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (i = t.charCodeAt(o + 1))) && (n = 65536 + (n - 55296 << 10) + (i - 56320), o++), n < 128 ? e[a++] = n : n < 2048 ? (e[a++] = 192 | n >>> 6, e[a++] = 128 | 63 & n) : n < 65536 ? (e[a++] = 224 | n >>> 12, e[a++] = 128 | n >>> 6 & 63, e[a++] = 128 | 63 & n) : (e[a++] = 240 | n >>> 18, e[a++] = 128 | n >>> 12 & 63, e[a++] = 128 | n >>> 6 & 63, e[a++] = 128 | 63 & n);
					return e
				}, e.buf2binstring = function(t) {
					return l(t, t.length)
				}, e.binstring2buf = function(t) {
					for (var e = new r.Buf8(t.length), n = 0, i = e.length; n < i; n++) e[n] = t.charCodeAt(n);
					return e
				}, e.buf2string = function(t, e) {
					var n, r, i, o, s = e || t.length,
						c = new Array(2 * s);
					for (r = 0, n = 0; n < s;)
						if ((i = t[n++]) < 128) c[r++] = i;
						else if ((o = a[i]) > 4) c[r++] = 65533, n += o - 1;
					else {
						for (i &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && n < s;) i = i << 6 | 63 & t[n++], o--;
						o > 1 ? c[r++] = 65533 : i < 65536 ? c[r++] = i : (i -= 65536, c[r++] = 55296 | i >> 10 & 1023, c[r++] = 56320 | 1023 & i)
					}
					return l(c, r)
				}, e.utf8border = function(t, e) {
					var n;
					for ((e = e || t.length) > t.length && (e = t.length), n = e - 1; n >= 0 && 128 == (192 & t[n]);) n--;
					return n < 0 || 0 === n ? e : n + a[t[n]] > e ? n : e
				}
			},
			775: t => {
				"use strict";
				t.exports = function(t, e, n, r) {
					for (var i = 65535 & t | 0, o = t >>> 16 & 65535 | 0, a = 0; 0 !== n;) {
						n -= a = n > 2e3 ? 2e3 : n;
						do {
							o = o + (i = i + e[r++] | 0) | 0
						} while (--a);
						i %= 65521, o %= 65521
					}
					return i | o << 16 | 0
				}
			},
			681: t => {
				"use strict";
				t.exports = {
					Z_NO_FLUSH: 0,
					Z_PARTIAL_FLUSH: 1,
					Z_SYNC_FLUSH: 2,
					Z_FULL_FLUSH: 3,
					Z_FINISH: 4,
					Z_BLOCK: 5,
					Z_TREES: 6,
					Z_OK: 0,
					Z_STREAM_END: 1,
					Z_NEED_DICT: 2,
					Z_ERRNO: -1,
					Z_STREAM_ERROR: -2,
					Z_DATA_ERROR: -3,
					Z_BUF_ERROR: -5,
					Z_NO_COMPRESSION: 0,
					Z_BEST_SPEED: 1,
					Z_BEST_COMPRESSION: 9,
					Z_DEFAULT_COMPRESSION: -1,
					Z_FILTERED: 1,
					Z_HUFFMAN_ONLY: 2,
					Z_RLE: 3,
					Z_FIXED: 4,
					Z_DEFAULT_STRATEGY: 0,
					Z_BINARY: 0,
					Z_TEXT: 1,
					Z_UNKNOWN: 2,
					Z_DEFLATED: 8
				}
			},
			576: t => {
				"use strict";
				var e = function() {
					for (var t, e = [], n = 0; n < 256; n++) {
						t = n;
						for (var r = 0; r < 8; r++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
						e[n] = t
					}
					return e
				}();
				t.exports = function(t, n, r, i) {
					var o = e,
						a = i + r;
					t ^= -1;
					for (var s = i; s < a; s++) t = t >>> 8 ^ o[255 & (t ^ n[s])];
					return -1 ^ t
				}
			},
			246: (t, e, n) => {
				"use strict";
				var r, i = n(251),
					o = n(443),
					a = n(775),
					s = n(576),
					l = n(587),
					c = 0,
					u = 0,
					h = -2,
					f = 2,
					d = 8,
					p = 286,
					g = 30,
					v = 19,
					m = 2 * p + 1,
					y = 15,
					b = 3,
					x = 258,
					w = x + b + 1,
					C = 42,
					S = 103,
					O = 113,
					T = 666;

				function k(t, e) {
					return t.msg = l[e], e
				}

				function F(t) {
					return (t << 1) - (t > 4 ? 9 : 0)
				}

				function P(t) {
					for (var e = t.length; --e >= 0;) t[e] = 0
				}

				function j(t) {
					var e = t.state,
						n = e.pending;
					n > t.avail_out && (n = t.avail_out), 0 !== n && (i.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, 0 === e.pending && (e.pending_out = 0))
				}

				function A(t, e) {
					o._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, j(t.strm)
				}

				function _(t, e) {
					t.pending_buf[t.pending++] = e
				}

				function E(t, e) {
					t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
				}

				function D(t, e) {
					var n, r, i = t.max_chain_length,
						o = t.strstart,
						a = t.prev_length,
						s = t.nice_match,
						l = t.strstart > t.w_size - w ? t.strstart - (t.w_size - w) : 0,
						c = t.window,
						u = t.w_mask,
						h = t.prev,
						f = t.strstart + x,
						d = c[o + a - 1],
						p = c[o + a];
					t.prev_length >= t.good_match && (i >>= 2), s > t.lookahead && (s = t.lookahead);
					do {
						if (c[(n = e) + a] === p && c[n + a - 1] === d && c[n] === c[o] && c[++n] === c[o + 1]) {
							o += 2, n++;
							do {} while (c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && o < f);
							if (r = x - (f - o), o = f - x, r > a) {
								if (t.match_start = e, a = r, r >= s) break;
								d = c[o + a - 1], p = c[o + a]
							}
						}
					} while ((e = h[e & u]) > l && 0 != --i);
					return a <= t.lookahead ? a : t.lookahead
				}

				function M(t) {
					var e, n, r, o, l, c, u, h, f, d, p = t.w_size;
					do {
						if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= p + (p - w)) {
							i.arraySet(t.window, t.window, p, p, 0), t.match_start -= p, t.strstart -= p, t.block_start -= p, e = n = t.hash_size;
							do {
								r = t.head[--e], t.head[e] = r >= p ? r - p : 0
							} while (--n);
							e = n = p;
							do {
								r = t.prev[--e], t.prev[e] = r >= p ? r - p : 0
							} while (--n);
							o += p
						}
						if (0 === t.strm.avail_in) break;
						if (c = t.strm, u = t.window, h = t.strstart + t.lookahead, f = o, d = void 0, (d = c.avail_in) > f && (d = f), n = 0 === d ? 0 : (c.avail_in -= d, i.arraySet(u, c.input, c.next_in, d, h), 1 === c.state.wrap ? c.adler = a(c.adler, u, d, h) : 2 === c.state.wrap && (c.adler = s(c.adler, u, d, h)), c.next_in += d, c.total_in += d, d), t.lookahead += n, t.lookahead + t.insert >= b)
							for (l = t.strstart - t.insert, t.ins_h = t.window[l], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[l + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[l + b - 1]) & t.hash_mask, t.prev[l & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = l, l++, t.insert--, !(t.lookahead + t.insert < b)););
					} while (t.lookahead < w && 0 !== t.strm.avail_in)
				}

				function I(t, e) {
					for (var n, r;;) {
						if (t.lookahead < w) {
							if (M(t), t.lookahead < w && e === c) return 1;
							if (0 === t.lookahead) break
						}
						if (n = 0, t.lookahead >= b && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + b - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== n && t.strstart - n <= t.w_size - w && (t.match_length = D(t, n)), t.match_length >= b)
							if (r = o._tr_tally(t, t.strstart - t.match_start, t.match_length - b), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= b) {
								t.match_length--;
								do {
									t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + b - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
								} while (0 != --t.match_length);
								t.strstart++
							} else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
						else r = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
						if (r && (A(t, !1), 0 === t.strm.avail_out)) return 1
					}
					return t.insert = t.strstart < b - 1 ? t.strstart : b - 1, 4 === e ? (A(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (A(t, !1), 0 === t.strm.avail_out) ? 1 : 2
				}

				function R(t, e) {
					for (var n, r, i;;) {
						if (t.lookahead < w) {
							if (M(t), t.lookahead < w && e === c) return 1;
							if (0 === t.lookahead) break
						}
						if (n = 0, t.lookahead >= b && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + b - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = b - 1, 0 !== n && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - w && (t.match_length = D(t, n), t.match_length <= 5 && (1 === t.strategy || t.match_length === b && t.strstart - t.match_start > 4096) && (t.match_length = b - 1)), t.prev_length >= b && t.match_length <= t.prev_length) {
							i = t.strstart + t.lookahead - b, r = o._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - b), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
							do {
								++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + b - 1]) & t.hash_mask, n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
							} while (0 != --t.prev_length);
							if (t.match_available = 0, t.match_length = b - 1, t.strstart++, r && (A(t, !1), 0 === t.strm.avail_out)) return 1
						} else if (t.match_available) {
							if ((r = o._tr_tally(t, 0, t.window[t.strstart - 1])) && A(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1
						} else t.match_available = 1, t.strstart++, t.lookahead--
					}
					return t.match_available && (r = o._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < b - 1 ? t.strstart : b - 1, 4 === e ? (A(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (A(t, !1), 0 === t.strm.avail_out) ? 1 : 2
				}

				function B(t, e, n, r, i) {
					this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i
				}

				function N() {
					this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = d, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(2 * m), this.dyn_dtree = new i.Buf16(2 * (2 * g + 1)), this.bl_tree = new i.Buf16(2 * (2 * v + 1)), P(this.dyn_ltree), P(this.dyn_dtree), P(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(y + 1), this.heap = new i.Buf16(2 * p + 1), P(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * p + 1), P(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
				}

				function L(t) {
					var e;
					return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = f, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? C : O, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = c, o._tr_init(e), u) : k(t, h)
				}

				function z(t) {
					var e, n = L(t);
					return n === u && ((e = t.state).window_size = 2 * e.w_size, P(e.head), e.max_lazy_match = r[e.level].max_lazy, e.good_match = r[e.level].good_length, e.nice_match = r[e.level].nice_length, e.max_chain_length = r[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = b - 1, e.match_available = 0, e.ins_h = 0), n
				}

				function W(t, e, n, r, o, a) {
					if (!t) return h;
					var s = 1;
					if (-1 === e && (e = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), o < 1 || o > 9 || n !== d || r < 8 || r > 15 || e < 0 || e > 9 || a < 0 || a > 4) return k(t, h);
					8 === r && (r = 9);
					var l = new N;
					return t.state = l, l.strm = t, l.wrap = s, l.gzhead = null, l.w_bits = r, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = o + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + b - 1) / b), l.window = new i.Buf8(2 * l.w_size), l.head = new i.Buf16(l.hash_size), l.prev = new i.Buf16(l.w_size), l.lit_bufsize = 1 << o + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new i.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = a, l.method = n, z(t)
				}
				r = [new B(0, 0, 0, 0, (function(t, e) {
					var n = 65535;
					for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5);;) {
						if (t.lookahead <= 1) {
							if (M(t), 0 === t.lookahead && e === c) return 1;
							if (0 === t.lookahead) break
						}
						t.strstart += t.lookahead, t.lookahead = 0;
						var r = t.block_start + n;
						if ((0 === t.strstart || t.strstart >= r) && (t.lookahead = t.strstart - r, t.strstart = r, A(t, !1), 0 === t.strm.avail_out)) return 1;
						if (t.strstart - t.block_start >= t.w_size - w && (A(t, !1), 0 === t.strm.avail_out)) return 1
					}
					return t.insert = 0, 4 === e ? (A(t, !0), 0 === t.strm.avail_out ? 3 : 4) : (t.strstart > t.block_start && (A(t, !1), t.strm.avail_out), 1)
				})), new B(4, 4, 8, 4, I), new B(4, 5, 16, 8, I), new B(4, 6, 32, 32, I), new B(4, 4, 16, 16, R), new B(8, 16, 32, 32, R), new B(8, 16, 128, 128, R), new B(8, 32, 128, 256, R), new B(32, 128, 258, 1024, R), new B(32, 258, 258, 4096, R)], e.deflateInit = function(t, e) {
					return W(t, e, d, 15, 8, 0)
				}, e.deflateInit2 = W, e.deflateReset = z, e.deflateResetKeep = L, e.deflateSetHeader = function(t, e) {
					return t && t.state ? 2 !== t.state.wrap ? h : (t.state.gzhead = e, u) : h
				}, e.deflate = function(t, e) {
					var n, i, a, l;
					if (!t || !t.state || e > 5 || e < 0) return t ? k(t, h) : h;
					if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || i.status === T && 4 !== e) return k(t, 0 === t.avail_out ? -5 : h);
					if (i.strm = t, n = i.last_flush, i.last_flush = e, i.status === C)
						if (2 === i.wrap) t.adler = 0, _(i, 31), _(i, 139), _(i, 8), i.gzhead ? (_(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), _(i, 255 & i.gzhead.time), _(i, i.gzhead.time >> 8 & 255), _(i, i.gzhead.time >> 16 & 255), _(i, i.gzhead.time >> 24 & 255), _(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), _(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (_(i, 255 & i.gzhead.extra.length), _(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = s(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (_(i, 0), _(i, 0), _(i, 0), _(i, 0), _(i, 0), _(i, 9 === i.level ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), _(i, 3), i.status = O);
						else {
							var f = d + (i.w_bits - 8 << 4) << 8;
							f |= (i.strategy >= 2 || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (f |= 32), f += 31 - f % 31, i.status = O, E(i, f), 0 !== i.strstart && (E(i, t.adler >>> 16), E(i, 65535 & t.adler)), t.adler = 1
						} if (69 === i.status)
						if (i.gzhead.extra) {
							for (a = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), j(t), a = i.pending, i.pending !== i.pending_buf_size));) _(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
							i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73)
						} else i.status = 73;
					if (73 === i.status)
						if (i.gzhead.name) {
							a = i.pending;
							do {
								if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), j(t), a = i.pending, i.pending === i.pending_buf_size)) {
									l = 1;
									break
								}
								l = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, _(i, l)
							} while (0 !== l);
							i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), 0 === l && (i.gzindex = 0, i.status = 91)
						} else i.status = 91;
					if (91 === i.status)
						if (i.gzhead.comment) {
							a = i.pending;
							do {
								if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), j(t), a = i.pending, i.pending === i.pending_buf_size)) {
									l = 1;
									break
								}
								l = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, _(i, l)
							} while (0 !== l);
							i.gzhead.hcrc && i.pending > a && (t.adler = s(t.adler, i.pending_buf, i.pending - a, a)), 0 === l && (i.status = S)
						} else i.status = S;
					if (i.status === S && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && j(t), i.pending + 2 <= i.pending_buf_size && (_(i, 255 & t.adler), _(i, t.adler >> 8 & 255), t.adler = 0, i.status = O)) : i.status = O), 0 !== i.pending) {
						if (j(t), 0 === t.avail_out) return i.last_flush = -1, u
					} else if (0 === t.avail_in && F(e) <= F(n) && 4 !== e) return k(t, -5);
					if (i.status === T && 0 !== t.avail_in) return k(t, -5);
					if (0 !== t.avail_in || 0 !== i.lookahead || e !== c && i.status !== T) {
						var p = 2 === i.strategy ? function(t, e) {
							for (var n;;) {
								if (0 === t.lookahead && (M(t), 0 === t.lookahead)) {
									if (e === c) return 1;
									break
								}
								if (t.match_length = 0, n = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (A(t, !1), 0 === t.strm.avail_out)) return 1
							}
							return t.insert = 0, 4 === e ? (A(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (A(t, !1), 0 === t.strm.avail_out) ? 1 : 2
						}(i, e) : 3 === i.strategy ? function(t, e) {
							for (var n, r, i, a, s = t.window;;) {
								if (t.lookahead <= x) {
									if (M(t), t.lookahead <= x && e === c) return 1;
									if (0 === t.lookahead) break
								}
								if (t.match_length = 0, t.lookahead >= b && t.strstart > 0 && (r = s[i = t.strstart - 1]) === s[++i] && r === s[++i] && r === s[++i]) {
									a = t.strstart + x;
									do {} while (r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && i < a);
									t.match_length = x - (a - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
								}
								if (t.match_length >= b ? (n = o._tr_tally(t, 1, t.match_length - b), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (A(t, !1), 0 === t.strm.avail_out)) return 1
							}
							return t.insert = 0, 4 === e ? (A(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (A(t, !1), 0 === t.strm.avail_out) ? 1 : 2
						}(i, e) : r[i.level].func(i, e);
						if (3 !== p && 4 !== p || (i.status = T), 1 === p || 3 === p) return 0 === t.avail_out && (i.last_flush = -1), u;
						if (2 === p && (1 === e ? o._tr_align(i) : 5 !== e && (o._tr_stored_block(i, 0, 0, !1), 3 === e && (P(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), j(t), 0 === t.avail_out)) return i.last_flush = -1, u
					}
					return 4 !== e ? u : i.wrap <= 0 ? 1 : (2 === i.wrap ? (_(i, 255 & t.adler), _(i, t.adler >> 8 & 255), _(i, t.adler >> 16 & 255), _(i, t.adler >> 24 & 255), _(i, 255 & t.total_in), _(i, t.total_in >> 8 & 255), _(i, t.total_in >> 16 & 255), _(i, t.total_in >> 24 & 255)) : (E(i, t.adler >>> 16), E(i, 65535 & t.adler)), j(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? u : 1)
				}, e.deflateEnd = function(t) {
					var e;
					return t && t.state ? (e = t.state.status) !== C && 69 !== e && 73 !== e && 91 !== e && e !== S && e !== O && e !== T ? k(t, h) : (t.state = null, e === O ? k(t, -3) : u) : h
				}, e.deflateSetDictionary = function(t, e) {
					var n, r, o, s, l, c, f, d, p = e.length;
					if (!t || !t.state) return h;
					if (2 === (s = (n = t.state).wrap) || 1 === s && n.status !== C || n.lookahead) return h;
					for (1 === s && (t.adler = a(t.adler, e, p, 0)), n.wrap = 0, p >= n.w_size && (0 === s && (P(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), d = new i.Buf8(n.w_size), i.arraySet(d, e, p - n.w_size, n.w_size, 0), e = d, p = n.w_size), l = t.avail_in, c = t.next_in, f = t.input, t.avail_in = p, t.next_in = 0, t.input = e, M(n); n.lookahead >= b;) {
						r = n.strstart, o = n.lookahead - (b - 1);
						do {
							n.ins_h = (n.ins_h << n.hash_shift ^ n.window[r + b - 1]) & n.hash_mask, n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++
						} while (--o);
						n.strstart = r, n.lookahead = b - 1, M(n)
					}
					return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = b - 1, n.match_available = 0, t.next_in = c, t.input = f, t.avail_in = l, n.wrap = s, u
				}, e.deflateInfo = "pako deflate (from Nodeca project)"
			},
			974: t => {
				"use strict";
				t.exports = function() {
					this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
				}
			},
			400: t => {
				"use strict";
				t.exports = function(t, e) {
					var n, r, i, o, a, s, l, c, u, h, f, d, p, g, v, m, y, b, x, w, C, S, O, T, k;
					n = t.state, r = t.next_in, T = t.input, i = r + (t.avail_in - 5), o = t.next_out, k = t.output, a = o - (e - t.avail_out), s = o + (t.avail_out - 257), l = n.dmax, c = n.wsize, u = n.whave, h = n.wnext, f = n.window, d = n.hold, p = n.bits, g = n.lencode, v = n.distcode, m = (1 << n.lenbits) - 1, y = (1 << n.distbits) - 1;
					t: do {
						p < 15 && (d += T[r++] << p, p += 8, d += T[r++] << p, p += 8), b = g[d & m];
						e: for (;;) {
							if (d >>>= x = b >>> 24, p -= x, 0 == (x = b >>> 16 & 255)) k[o++] = 65535 & b;
							else {
								if (!(16 & x)) {
									if (0 == (64 & x)) {
										b = g[(65535 & b) + (d & (1 << x) - 1)];
										continue e
									}
									if (32 & x) {
										n.mode = 12;
										break t
									}
									t.msg = "invalid literal/length code", n.mode = 30;
									break t
								}
								w = 65535 & b, (x &= 15) && (p < x && (d += T[r++] << p, p += 8), w += d & (1 << x) - 1, d >>>= x, p -= x), p < 15 && (d += T[r++] << p, p += 8, d += T[r++] << p, p += 8), b = v[d & y];
								n: for (;;) {
									if (d >>>= x = b >>> 24, p -= x, !(16 & (x = b >>> 16 & 255))) {
										if (0 == (64 & x)) {
											b = v[(65535 & b) + (d & (1 << x) - 1)];
											continue n
										}
										t.msg = "invalid distance code", n.mode = 30;
										break t
									}
									if (C = 65535 & b, p < (x &= 15) && (d += T[r++] << p, (p += 8) < x && (d += T[r++] << p, p += 8)), (C += d & (1 << x) - 1) > l) {
										t.msg = "invalid distance too far back", n.mode = 30;
										break t
									}
									if (d >>>= x, p -= x, C > (x = o - a)) {
										if ((x = C - x) > u && n.sane) {
											t.msg = "invalid distance too far back", n.mode = 30;
											break t
										}
										if (S = 0, O = f, 0 === h) {
											if (S += c - x, x < w) {
												w -= x;
												do {
													k[o++] = f[S++]
												} while (--x);
												S = o - C, O = k
											}
										} else if (h < x) {
											if (S += c + h - x, (x -= h) < w) {
												w -= x;
												do {
													k[o++] = f[S++]
												} while (--x);
												if (S = 0, h < w) {
													w -= x = h;
													do {
														k[o++] = f[S++]
													} while (--x);
													S = o - C, O = k
												}
											}
										} else if (S += h - x, x < w) {
											w -= x;
											do {
												k[o++] = f[S++]
											} while (--x);
											S = o - C, O = k
										}
										for (; w > 2;) k[o++] = O[S++], k[o++] = O[S++], k[o++] = O[S++], w -= 3;
										w && (k[o++] = O[S++], w > 1 && (k[o++] = O[S++]))
									} else {
										S = o - C;
										do {
											k[o++] = k[S++], k[o++] = k[S++], k[o++] = k[S++], w -= 3
										} while (w > 2);
										w && (k[o++] = k[S++], w > 1 && (k[o++] = k[S++]))
									}
									break
								}
							}
							break
						}
					} while (r < i && o < s);
					r -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, t.next_in = r, t.next_out = o, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = o < s ? s - o + 257 : 257 - (o - s), n.hold = d, n.bits = p
				}
			},
			387: (t, e, n) => {
				"use strict";
				var r = n(251),
					i = n(775),
					o = n(576),
					a = n(400),
					s = n(17),
					l = 0,
					c = -2,
					u = 1,
					h = 12,
					f = 30,
					d = 852,
					p = 592;

				function g(t) {
					return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
				}

				function v() {
					this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
				}

				function m(t) {
					var e;
					return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = u, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new r.Buf32(d), e.distcode = e.distdyn = new r.Buf32(p), e.sane = 1, e.back = -1, l) : c
				}

				function y(t) {
					var e;
					return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, m(t)) : c
				}

				function b(t, e) {
					var n, r;
					return t && t.state ? (r = t.state, e < 0 ? (n = 0, e = -e) : (n = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? c : (null !== r.window && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, y(t))) : c
				}

				function x(t, e) {
					var n, r;
					return t ? (r = new v, t.state = r, r.window = null, (n = b(t, e)) !== l && (t.state = null), n) : c
				}
				var w, C, S = !0;

				function O(t) {
					if (S) {
						var e;
						for (w = new r.Buf32(512), C = new r.Buf32(32), e = 0; e < 144;) t.lens[e++] = 8;
						for (; e < 256;) t.lens[e++] = 9;
						for (; e < 280;) t.lens[e++] = 7;
						for (; e < 288;) t.lens[e++] = 8;
						for (s(1, t.lens, 0, 288, w, 0, t.work, {
								bits: 9
							}), e = 0; e < 32;) t.lens[e++] = 5;
						s(2, t.lens, 0, 32, C, 0, t.work, {
							bits: 5
						}), S = !1
					}
					t.lencode = w, t.lenbits = 9, t.distcode = C, t.distbits = 5
				}

				function T(t, e, n, i) {
					var o, a = t.state;
					return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new r.Buf8(a.wsize)), i >= a.wsize ? (r.arraySet(a.window, e, n - a.wsize, a.wsize, 0), a.wnext = 0, a.whave = a.wsize) : ((o = a.wsize - a.wnext) > i && (o = i), r.arraySet(a.window, e, n - i, o, a.wnext), (i -= o) ? (r.arraySet(a.window, e, n - i, i, 0), a.wnext = i, a.whave = a.wsize) : (a.wnext += o, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += o))), 0
				}
				e.inflateReset = y, e.inflateReset2 = b, e.inflateResetKeep = m, e.inflateInit = function(t) {
					return x(t, 15)
				}, e.inflateInit2 = x, e.inflate = function(t, e) {
					var n, d, p, v, m, y, b, x, w, C, S, k, F, P, j, A, _, E, D, M, I, R, B, N, L = 0,
						z = new r.Buf8(4),
						W = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
					if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return c;
					(n = t.state).mode === h && (n.mode = 13), m = t.next_out, p = t.output, b = t.avail_out, v = t.next_in, d = t.input, y = t.avail_in, x = n.hold, w = n.bits, C = y, S = b, R = l;
					t: for (;;) switch (n.mode) {
						case u:
							if (0 === n.wrap) {
								n.mode = 13;
								break
							}
							for (; w < 16;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if (2 & n.wrap && 35615 === x) {
								n.check = 0, z[0] = 255 & x, z[1] = x >>> 8 & 255, n.check = o(n.check, z, 2, 0), x = 0, w = 0, n.mode = 2;
								break
							}
							if (n.flags = 0, n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & x) << 8) + (x >> 8)) % 31) {
								t.msg = "incorrect header check", n.mode = f;
								break
							}
							if (8 != (15 & x)) {
								t.msg = "unknown compression method", n.mode = f;
								break
							}
							if (w -= 4, I = 8 + (15 & (x >>>= 4)), 0 === n.wbits) n.wbits = I;
							else if (I > n.wbits) {
								t.msg = "invalid window size", n.mode = f;
								break
							}
							n.dmax = 1 << I, t.adler = n.check = 1, n.mode = 512 & x ? 10 : h, x = 0, w = 0;
							break;
						case 2:
							for (; w < 16;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if (n.flags = x, 8 != (255 & n.flags)) {
								t.msg = "unknown compression method", n.mode = f;
								break
							}
							if (57344 & n.flags) {
								t.msg = "unknown header flags set", n.mode = f;
								break
							}
							n.head && (n.head.text = x >> 8 & 1), 512 & n.flags && (z[0] = 255 & x, z[1] = x >>> 8 & 255, n.check = o(n.check, z, 2, 0)), x = 0, w = 0, n.mode = 3;
						case 3:
							for (; w < 32;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							n.head && (n.head.time = x), 512 & n.flags && (z[0] = 255 & x, z[1] = x >>> 8 & 255, z[2] = x >>> 16 & 255, z[3] = x >>> 24 & 255, n.check = o(n.check, z, 4, 0)), x = 0, w = 0, n.mode = 4;
						case 4:
							for (; w < 16;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							n.head && (n.head.xflags = 255 & x, n.head.os = x >> 8), 512 & n.flags && (z[0] = 255 & x, z[1] = x >>> 8 & 255, n.check = o(n.check, z, 2, 0)), x = 0, w = 0, n.mode = 5;
						case 5:
							if (1024 & n.flags) {
								for (; w < 16;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								n.length = x, n.head && (n.head.extra_len = x), 512 & n.flags && (z[0] = 255 & x, z[1] = x >>> 8 & 255, n.check = o(n.check, z, 2, 0)), x = 0, w = 0
							} else n.head && (n.head.extra = null);
							n.mode = 6;
						case 6:
							if (1024 & n.flags && ((k = n.length) > y && (k = y), k && (n.head && (I = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Array(n.head.extra_len)), r.arraySet(n.head.extra, d, v, k, I)), 512 & n.flags && (n.check = o(n.check, d, k, v)), y -= k, v += k, n.length -= k), n.length)) break t;
							n.length = 0, n.mode = 7;
						case 7:
							if (2048 & n.flags) {
								if (0 === y) break t;
								k = 0;
								do {
									I = d[v + k++], n.head && I && n.length < 65536 && (n.head.name += String.fromCharCode(I))
								} while (I && k < y);
								if (512 & n.flags && (n.check = o(n.check, d, k, v)), y -= k, v += k, I) break t
							} else n.head && (n.head.name = null);
							n.length = 0, n.mode = 8;
						case 8:
							if (4096 & n.flags) {
								if (0 === y) break t;
								k = 0;
								do {
									I = d[v + k++], n.head && I && n.length < 65536 && (n.head.comment += String.fromCharCode(I))
								} while (I && k < y);
								if (512 & n.flags && (n.check = o(n.check, d, k, v)), y -= k, v += k, I) break t
							} else n.head && (n.head.comment = null);
							n.mode = 9;
						case 9:
							if (512 & n.flags) {
								for (; w < 16;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								if (x !== (65535 & n.check)) {
									t.msg = "header crc mismatch", n.mode = f;
									break
								}
								x = 0, w = 0
							}
							n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = h;
							break;
						case 10:
							for (; w < 32;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							t.adler = n.check = g(x), x = 0, w = 0, n.mode = 11;
						case 11:
							if (0 === n.havedict) return t.next_out = m, t.avail_out = b, t.next_in = v, t.avail_in = y, n.hold = x, n.bits = w, 2;
							t.adler = n.check = 1, n.mode = h;
						case h:
							if (5 === e || 6 === e) break t;
						case 13:
							if (n.last) {
								x >>>= 7 & w, w -= 7 & w, n.mode = 27;
								break
							}
							for (; w < 3;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							switch (n.last = 1 & x, w -= 1, 3 & (x >>>= 1)) {
								case 0:
									n.mode = 14;
									break;
								case 1:
									if (O(n), n.mode = 20, 6 === e) {
										x >>>= 2, w -= 2;
										break t
									}
									break;
								case 2:
									n.mode = 17;
									break;
								case 3:
									t.msg = "invalid block type", n.mode = f
							}
							x >>>= 2, w -= 2;
							break;
						case 14:
							for (x >>>= 7 & w, w -= 7 & w; w < 32;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if ((65535 & x) != (x >>> 16 ^ 65535)) {
								t.msg = "invalid stored block lengths", n.mode = f;
								break
							}
							if (n.length = 65535 & x, x = 0, w = 0, n.mode = 15, 6 === e) break t;
						case 15:
							n.mode = 16;
						case 16:
							if (k = n.length) {
								if (k > y && (k = y), k > b && (k = b), 0 === k) break t;
								r.arraySet(p, d, v, k, m), y -= k, v += k, b -= k, m += k, n.length -= k;
								break
							}
							n.mode = h;
							break;
						case 17:
							for (; w < 14;) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if (n.nlen = 257 + (31 & x), x >>>= 5, w -= 5, n.ndist = 1 + (31 & x), x >>>= 5, w -= 5, n.ncode = 4 + (15 & x), x >>>= 4, w -= 4, n.nlen > 286 || n.ndist > 30) {
								t.msg = "too many length or distance symbols", n.mode = f;
								break
							}
							n.have = 0, n.mode = 18;
						case 18:
							for (; n.have < n.ncode;) {
								for (; w < 3;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								n.lens[W[n.have++]] = 7 & x, x >>>= 3, w -= 3
							}
							for (; n.have < 19;) n.lens[W[n.have++]] = 0;
							if (n.lencode = n.lendyn, n.lenbits = 7, B = {
									bits: n.lenbits
								}, R = s(0, n.lens, 0, 19, n.lencode, 0, n.work, B), n.lenbits = B.bits, R) {
								t.msg = "invalid code lengths set", n.mode = f;
								break
							}
							n.have = 0, n.mode = 19;
						case 19:
							for (; n.have < n.nlen + n.ndist;) {
								for (; A = (L = n.lencode[x & (1 << n.lenbits) - 1]) >>> 16 & 255, _ = 65535 & L, !((j = L >>> 24) <= w);) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								if (_ < 16) x >>>= j, w -= j, n.lens[n.have++] = _;
								else {
									if (16 === _) {
										for (N = j + 2; w < N;) {
											if (0 === y) break t;
											y--, x += d[v++] << w, w += 8
										}
										if (x >>>= j, w -= j, 0 === n.have) {
											t.msg = "invalid bit length repeat", n.mode = f;
											break
										}
										I = n.lens[n.have - 1], k = 3 + (3 & x), x >>>= 2, w -= 2
									} else if (17 === _) {
										for (N = j + 3; w < N;) {
											if (0 === y) break t;
											y--, x += d[v++] << w, w += 8
										}
										w -= j, I = 0, k = 3 + (7 & (x >>>= j)), x >>>= 3, w -= 3
									} else {
										for (N = j + 7; w < N;) {
											if (0 === y) break t;
											y--, x += d[v++] << w, w += 8
										}
										w -= j, I = 0, k = 11 + (127 & (x >>>= j)), x >>>= 7, w -= 7
									}
									if (n.have + k > n.nlen + n.ndist) {
										t.msg = "invalid bit length repeat", n.mode = f;
										break
									}
									for (; k--;) n.lens[n.have++] = I
								}
							}
							if (n.mode === f) break;
							if (0 === n.lens[256]) {
								t.msg = "invalid code -- missing end-of-block", n.mode = f;
								break
							}
							if (n.lenbits = 9, B = {
									bits: n.lenbits
								}, R = s(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, B), n.lenbits = B.bits, R) {
								t.msg = "invalid literal/lengths set", n.mode = f;
								break
							}
							if (n.distbits = 6, n.distcode = n.distdyn, B = {
									bits: n.distbits
								}, R = s(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, B), n.distbits = B.bits, R) {
								t.msg = "invalid distances set", n.mode = f;
								break
							}
							if (n.mode = 20, 6 === e) break t;
						case 20:
							n.mode = 21;
						case 21:
							if (y >= 6 && b >= 258) {
								t.next_out = m, t.avail_out = b, t.next_in = v, t.avail_in = y, n.hold = x, n.bits = w, a(t, S), m = t.next_out, p = t.output, b = t.avail_out, v = t.next_in, d = t.input, y = t.avail_in, x = n.hold, w = n.bits, n.mode === h && (n.back = -1);
								break
							}
							for (n.back = 0; A = (L = n.lencode[x & (1 << n.lenbits) - 1]) >>> 16 & 255, _ = 65535 & L, !((j = L >>> 24) <= w);) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if (A && 0 == (240 & A)) {
								for (E = j, D = A, M = _; A = (L = n.lencode[M + ((x & (1 << E + D) - 1) >> E)]) >>> 16 & 255, _ = 65535 & L, !(E + (j = L >>> 24) <= w);) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								x >>>= E, w -= E, n.back += E
							}
							if (x >>>= j, w -= j, n.back += j, n.length = _, 0 === A) {
								n.mode = 26;
								break
							}
							if (32 & A) {
								n.back = -1, n.mode = h;
								break
							}
							if (64 & A) {
								t.msg = "invalid literal/length code", n.mode = f;
								break
							}
							n.extra = 15 & A, n.mode = 22;
						case 22:
							if (n.extra) {
								for (N = n.extra; w < N;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								n.length += x & (1 << n.extra) - 1, x >>>= n.extra, w -= n.extra, n.back += n.extra
							}
							n.was = n.length, n.mode = 23;
						case 23:
							for (; A = (L = n.distcode[x & (1 << n.distbits) - 1]) >>> 16 & 255, _ = 65535 & L, !((j = L >>> 24) <= w);) {
								if (0 === y) break t;
								y--, x += d[v++] << w, w += 8
							}
							if (0 == (240 & A)) {
								for (E = j, D = A, M = _; A = (L = n.distcode[M + ((x & (1 << E + D) - 1) >> E)]) >>> 16 & 255, _ = 65535 & L, !(E + (j = L >>> 24) <= w);) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								x >>>= E, w -= E, n.back += E
							}
							if (x >>>= j, w -= j, n.back += j, 64 & A) {
								t.msg = "invalid distance code", n.mode = f;
								break
							}
							n.offset = _, n.extra = 15 & A, n.mode = 24;
						case 24:
							if (n.extra) {
								for (N = n.extra; w < N;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								n.offset += x & (1 << n.extra) - 1, x >>>= n.extra, w -= n.extra, n.back += n.extra
							}
							if (n.offset > n.dmax) {
								t.msg = "invalid distance too far back", n.mode = f;
								break
							}
							n.mode = 25;
						case 25:
							if (0 === b) break t;
							if (k = S - b, n.offset > k) {
								if ((k = n.offset - k) > n.whave && n.sane) {
									t.msg = "invalid distance too far back", n.mode = f;
									break
								}
								k > n.wnext ? (k -= n.wnext, F = n.wsize - k) : F = n.wnext - k, k > n.length && (k = n.length), P = n.window
							} else P = p, F = m - n.offset, k = n.length;
							k > b && (k = b), b -= k, n.length -= k;
							do {
								p[m++] = P[F++]
							} while (--k);
							0 === n.length && (n.mode = 21);
							break;
						case 26:
							if (0 === b) break t;
							p[m++] = n.length, b--, n.mode = 21;
							break;
						case 27:
							if (n.wrap) {
								for (; w < 32;) {
									if (0 === y) break t;
									y--, x |= d[v++] << w, w += 8
								}
								if (S -= b, t.total_out += S, n.total += S, S && (t.adler = n.check = n.flags ? o(n.check, p, S, m - S) : i(n.check, p, S, m - S)), S = b, (n.flags ? x : g(x)) !== n.check) {
									t.msg = "incorrect data check", n.mode = f;
									break
								}
								x = 0, w = 0
							}
							n.mode = 28;
						case 28:
							if (n.wrap && n.flags) {
								for (; w < 32;) {
									if (0 === y) break t;
									y--, x += d[v++] << w, w += 8
								}
								if (x !== (4294967295 & n.total)) {
									t.msg = "incorrect length check", n.mode = f;
									break
								}
								x = 0, w = 0
							}
							n.mode = 29;
						case 29:
							R = 1;
							break t;
						case f:
							R = -3;
							break t;
						case 31:
							return -4;
						default:
							return c
					}
					return t.next_out = m, t.avail_out = b, t.next_in = v, t.avail_in = y, n.hold = x, n.bits = w, (n.wsize || S !== t.avail_out && n.mode < f && (n.mode < 27 || 4 !== e)) && T(t, t.output, t.next_out, S - t.avail_out) ? (n.mode = 31, -4) : (C -= t.avail_in, S -= t.avail_out, t.total_in += C, t.total_out += S, n.total += S, n.wrap && S && (t.adler = n.check = n.flags ? o(n.check, p, S, t.next_out - S) : i(n.check, p, S, t.next_out - S)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === h ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0), (0 === C && 0 === S || 4 === e) && R === l && (R = -5), R)
				}, e.inflateEnd = function(t) {
					if (!t || !t.state) return c;
					var e = t.state;
					return e.window && (e.window = null), t.state = null, l
				}, e.inflateGetHeader = function(t, e) {
					var n;
					return t && t.state ? 0 == (2 & (n = t.state).wrap) ? c : (n.head = e, e.done = !1, l) : c
				}, e.inflateSetDictionary = function(t, e) {
					var n, r = e.length;
					return t && t.state ? 0 !== (n = t.state).wrap && 11 !== n.mode ? c : 11 === n.mode && i(1, e, r, 0) !== n.check ? -3 : T(t, e, r, r) ? (n.mode = 31, -4) : (n.havedict = 1, l) : c
				}, e.inflateInfo = "pako inflate (from Nodeca project)"
			},
			17: (t, e, n) => {
				"use strict";
				var r = n(251),
					i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
					o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
					a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
					s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
				t.exports = function(t, e, n, l, c, u, h, f) {
					var d, p, g, v, m, y, b, x, w, C = f.bits,
						S = 0,
						O = 0,
						T = 0,
						k = 0,
						F = 0,
						P = 0,
						j = 0,
						A = 0,
						_ = 0,
						E = 0,
						D = null,
						M = 0,
						I = new r.Buf16(16),
						R = new r.Buf16(16),
						B = null,
						N = 0;
					for (S = 0; S <= 15; S++) I[S] = 0;
					for (O = 0; O < l; O++) I[e[n + O]]++;
					for (F = C, k = 15; k >= 1 && 0 === I[k]; k--);
					if (F > k && (F = k), 0 === k) return c[u++] = 20971520, c[u++] = 20971520, f.bits = 1, 0;
					for (T = 1; T < k && 0 === I[T]; T++);
					for (F < T && (F = T), A = 1, S = 1; S <= 15; S++)
						if (A <<= 1, (A -= I[S]) < 0) return -1;
					if (A > 0 && (0 === t || 1 !== k)) return -1;
					for (R[1] = 0, S = 1; S < 15; S++) R[S + 1] = R[S] + I[S];
					for (O = 0; O < l; O++) 0 !== e[n + O] && (h[R[e[n + O]]++] = O);
					if (0 === t ? (D = B = h, y = 19) : 1 === t ? (D = i, M -= 257, B = o, N -= 257, y = 256) : (D = a, B = s, y = -1), E = 0, O = 0, S = T, m = u, P = F, j = 0, g = -1, v = (_ = 1 << F) - 1, 1 === t && _ > 852 || 2 === t && _ > 592) return 1;
					for (;;) {
						b = S - j, h[O] < y ? (x = 0, w = h[O]) : h[O] > y ? (x = B[N + h[O]], w = D[M + h[O]]) : (x = 96, w = 0), d = 1 << S - j, T = p = 1 << P;
						do {
							c[m + (E >> j) + (p -= d)] = b << 24 | x << 16 | w | 0
						} while (0 !== p);
						for (d = 1 << S - 1; E & d;) d >>= 1;
						if (0 !== d ? (E &= d - 1, E += d) : E = 0, O++, 0 == --I[S]) {
							if (S === k) break;
							S = e[n + h[O]]
						}
						if (S > F && (E & v) !== g) {
							for (0 === j && (j = F), m += T, A = 1 << (P = S - j); P + j < k && !((A -= I[P + j]) <= 0);) P++, A <<= 1;
							if (_ += 1 << P, 1 === t && _ > 852 || 2 === t && _ > 592) return 1;
							c[g = E & v] = F << 24 | P << 16 | m - u | 0
						}
					}
					return 0 !== E && (c[m + E] = S - j << 24 | 64 << 16 | 0), f.bits = F, 0
				}
			},
			587: t => {
				"use strict";
				t.exports = {
					2: "need dictionary",
					1: "stream end",
					0: "",
					"-1": "file error",
					"-2": "stream error",
					"-3": "data error",
					"-4": "insufficient memory",
					"-5": "buffer error",
					"-6": "incompatible version"
				}
			},
			443: (t, e, n) => {
				"use strict";
				var r = n(251);

				function i(t) {
					for (var e = t.length; --e >= 0;) t[e] = 0
				}
				var o = 256,
					a = 286,
					s = 30,
					l = 15,
					c = 16,
					u = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
					h = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
					f = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
					d = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
					p = new Array(576);
				i(p);
				var g = new Array(60);
				i(g);
				var v = new Array(512);
				i(v);
				var m = new Array(256);
				i(m);
				var y = new Array(29);
				i(y);
				var b, x, w, C = new Array(s);

				function S(t, e, n, r, i) {
					this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length
				}

				function O(t, e) {
					this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
				}

				function T(t) {
					return t < 256 ? v[t] : v[256 + (t >>> 7)]
				}

				function k(t, e) {
					t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
				}

				function F(t, e, n) {
					t.bi_valid > c - n ? (t.bi_buf |= e << t.bi_valid & 65535, k(t, t.bi_buf), t.bi_buf = e >> c - t.bi_valid, t.bi_valid += n - c) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n)
				}

				function P(t, e, n) {
					F(t, n[2 * e], n[2 * e + 1])
				}

				function j(t, e) {
					var n = 0;
					do {
						n |= 1 & t, t >>>= 1, n <<= 1
					} while (--e > 0);
					return n >>> 1
				}

				function A(t, e, n) {
					var r, i, o = new Array(l + 1),
						a = 0;
					for (r = 1; r <= l; r++) o[r] = a = a + n[r - 1] << 1;
					for (i = 0; i <= e; i++) {
						var s = t[2 * i + 1];
						0 !== s && (t[2 * i] = j(o[s]++, s))
					}
				}

				function _(t) {
					var e;
					for (e = 0; e < a; e++) t.dyn_ltree[2 * e] = 0;
					for (e = 0; e < s; e++) t.dyn_dtree[2 * e] = 0;
					for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;
					t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
				}

				function E(t) {
					t.bi_valid > 8 ? k(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
				}

				function D(t, e, n, r) {
					var i = 2 * e,
						o = 2 * n;
					return t[i] < t[o] || t[i] === t[o] && r[e] <= r[n]
				}

				function M(t, e, n) {
					for (var r = t.heap[n], i = n << 1; i <= t.heap_len && (i < t.heap_len && D(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !D(e, r, t.heap[i], t.depth));) t.heap[n] = t.heap[i], n = i, i <<= 1;
					t.heap[n] = r
				}

				function I(t, e, n) {
					var r, i, a, s, l = 0;
					if (0 !== t.last_lit)
						do {
							r = t.pending_buf[t.d_buf + 2 * l] << 8 | t.pending_buf[t.d_buf + 2 * l + 1], i = t.pending_buf[t.l_buf + l], l++, 0 === r ? P(t, i, e) : (P(t, (a = m[i]) + o + 1, e), 0 !== (s = u[a]) && F(t, i -= y[a], s), P(t, a = T(--r), n), 0 !== (s = h[a]) && F(t, r -= C[a], s))
						} while (l < t.last_lit);
					P(t, 256, e)
				}

				function R(t, e) {
					var n, r, i, o = e.dyn_tree,
						a = e.stat_desc.static_tree,
						s = e.stat_desc.has_stree,
						c = e.stat_desc.elems,
						u = -1;
					for (t.heap_len = 0, t.heap_max = 573, n = 0; n < c; n++) 0 !== o[2 * n] ? (t.heap[++t.heap_len] = u = n, t.depth[n] = 0) : o[2 * n + 1] = 0;
					for (; t.heap_len < 2;) o[2 * (i = t.heap[++t.heap_len] = u < 2 ? ++u : 0)] = 1, t.depth[i] = 0, t.opt_len--, s && (t.static_len -= a[2 * i + 1]);
					for (e.max_code = u, n = t.heap_len >> 1; n >= 1; n--) M(t, o, n);
					i = c;
					do {
						n = t.heap[1], t.heap[1] = t.heap[t.heap_len--], M(t, o, 1), r = t.heap[1], t.heap[--t.heap_max] = n, t.heap[--t.heap_max] = r, o[2 * i] = o[2 * n] + o[2 * r], t.depth[i] = (t.depth[n] >= t.depth[r] ? t.depth[n] : t.depth[r]) + 1, o[2 * n + 1] = o[2 * r + 1] = i, t.heap[1] = i++, M(t, o, 1)
					} while (t.heap_len >= 2);
					t.heap[--t.heap_max] = t.heap[1],
						function(t, e) {
							var n, r, i, o, a, s, c = e.dyn_tree,
								u = e.max_code,
								h = e.stat_desc.static_tree,
								f = e.stat_desc.has_stree,
								d = e.stat_desc.extra_bits,
								p = e.stat_desc.extra_base,
								g = e.stat_desc.max_length,
								v = 0;
							for (o = 0; o <= l; o++) t.bl_count[o] = 0;
							for (c[2 * t.heap[t.heap_max] + 1] = 0, n = t.heap_max + 1; n < 573; n++)(o = c[2 * c[2 * (r = t.heap[n]) + 1] + 1] + 1) > g && (o = g, v++), c[2 * r + 1] = o, r > u || (t.bl_count[o]++, a = 0, r >= p && (a = d[r - p]), s = c[2 * r], t.opt_len += s * (o + a), f && (t.static_len += s * (h[2 * r + 1] + a)));
							if (0 !== v) {
								do {
									for (o = g - 1; 0 === t.bl_count[o];) o--;
									t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[g]--, v -= 2
								} while (v > 0);
								for (o = g; 0 !== o; o--)
									for (r = t.bl_count[o]; 0 !== r;)(i = t.heap[--n]) > u || (c[2 * i + 1] !== o && (t.opt_len += (o - c[2 * i + 1]) * c[2 * i], c[2 * i + 1] = o), r--)
							}
						}(t, e), A(o, u, t.bl_count)
				}

				function B(t, e, n) {
					var r, i, o = -1,
						a = e[1],
						s = 0,
						l = 7,
						c = 4;
					for (0 === a && (l = 138, c = 3), e[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++) i = a, a = e[2 * (r + 1) + 1], ++s < l && i === a || (s < c ? t.bl_tree[2 * i] += s : 0 !== i ? (i !== o && t.bl_tree[2 * i]++, t.bl_tree[32]++) : s <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, s = 0, o = i, 0 === a ? (l = 138, c = 3) : i === a ? (l = 6, c = 3) : (l = 7, c = 4))
				}

				function N(t, e, n) {
					var r, i, o = -1,
						a = e[1],
						s = 0,
						l = 7,
						c = 4;
					for (0 === a && (l = 138, c = 3), r = 0; r <= n; r++)
						if (i = a, a = e[2 * (r + 1) + 1], !(++s < l && i === a)) {
							if (s < c)
								do {
									P(t, i, t.bl_tree)
								} while (0 != --s);
							else 0 !== i ? (i !== o && (P(t, i, t.bl_tree), s--), P(t, 16, t.bl_tree), F(t, s - 3, 2)) : s <= 10 ? (P(t, 17, t.bl_tree), F(t, s - 3, 3)) : (P(t, 18, t.bl_tree), F(t, s - 11, 7));
							s = 0, o = i, 0 === a ? (l = 138, c = 3) : i === a ? (l = 6, c = 3) : (l = 7, c = 4)
						}
				}
				i(C);
				var L = !1;

				function z(t, e, n, i) {
					F(t, 0 + (i ? 1 : 0), 3),
						function(t, e, n, i) {
							E(t), k(t, n), k(t, ~n), r.arraySet(t.pending_buf, t.window, e, n, t.pending), t.pending += n
						}(t, e, n)
				}
				e._tr_init = function(t) {
					L || (function() {
						var t, e, n, r, i, o = new Array(l + 1);
						for (n = 0, r = 0; r < 28; r++)
							for (y[r] = n, t = 0; t < 1 << u[r]; t++) m[n++] = r;
						for (m[n - 1] = r, i = 0, r = 0; r < 16; r++)
							for (C[r] = i, t = 0; t < 1 << h[r]; t++) v[i++] = r;
						for (i >>= 7; r < s; r++)
							for (C[r] = i << 7, t = 0; t < 1 << h[r] - 7; t++) v[256 + i++] = r;
						for (e = 0; e <= l; e++) o[e] = 0;
						for (t = 0; t <= 143;) p[2 * t + 1] = 8, t++, o[8]++;
						for (; t <= 255;) p[2 * t + 1] = 9, t++, o[9]++;
						for (; t <= 279;) p[2 * t + 1] = 7, t++, o[7]++;
						for (; t <= 287;) p[2 * t + 1] = 8, t++, o[8]++;
						for (A(p, 287, o), t = 0; t < s; t++) g[2 * t + 1] = 5, g[2 * t] = j(t, 5);
						b = new S(p, u, 257, a, l), x = new S(g, h, 0, s, l), w = new S(new Array(0), f, 0, 19, 7)
					}(), L = !0), t.l_desc = new O(t.dyn_ltree, b), t.d_desc = new O(t.dyn_dtree, x), t.bl_desc = new O(t.bl_tree, w), t.bi_buf = 0, t.bi_valid = 0, _(t)
				}, e._tr_stored_block = z, e._tr_flush_block = function(t, e, n, r) {
					var i, a, s = 0;
					t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function(t) {
						var e, n = 4093624447;
						for (e = 0; e <= 31; e++, n >>>= 1)
							if (1 & n && 0 !== t.dyn_ltree[2 * e]) return 0;
						if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
						for (e = 32; e < o; e++)
							if (0 !== t.dyn_ltree[2 * e]) return 1;
						return 0
					}(t)), R(t, t.l_desc), R(t, t.d_desc), s = function(t) {
						var e;
						for (B(t, t.dyn_ltree, t.l_desc.max_code), B(t, t.dyn_dtree, t.d_desc.max_code), R(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * d[e] + 1]; e--);
						return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
					}(t), i = t.opt_len + 3 + 7 >>> 3, (a = t.static_len + 3 + 7 >>> 3) <= i && (i = a)) : i = a = n + 5, n + 4 <= i && -1 !== e ? z(t, e, n, r) : 4 === t.strategy || a === i ? (F(t, 2 + (r ? 1 : 0), 3), I(t, p, g)) : (F(t, 4 + (r ? 1 : 0), 3), function(t, e, n, r) {
						var i;
						for (F(t, e - 257, 5), F(t, n - 1, 5), F(t, r - 4, 4), i = 0; i < r; i++) F(t, t.bl_tree[2 * d[i] + 1], 3);
						N(t, t.dyn_ltree, e - 1), N(t, t.dyn_dtree, n - 1)
					}(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), I(t, t.dyn_ltree, t.dyn_dtree)), _(t), r && E(t)
				}, e._tr_tally = function(t, e, n) {
					return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & n, t.last_lit++, 0 === e ? t.dyn_ltree[2 * n]++ : (t.matches++, e--, t.dyn_ltree[2 * (m[n] + o + 1)]++, t.dyn_dtree[2 * T(e)]++), t.last_lit === t.lit_bufsize - 1
				}, e._tr_align = function(t) {
					F(t, 2, 3), P(t, 256, p),
						function(t) {
							16 === t.bi_valid ? (k(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
						}(t)
				}
			},
			213: t => {
				"use strict";
				t.exports = function() {
					this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
				}
			},
			96: function(t, e, n) {
				t = n.nmd(t),
					function(n, r) {
						"use strict";
						var i = {};
						n.PubSub ? (i = n.PubSub, console.warn("PubSub already loaded, using existing version")) : (n.PubSub = i, function(t) {
							var e = {},
								n = -1,
								r = "*";

							function i(t, e, n) {
								try {
									t(e, n)
								} catch (t) {
									setTimeout(function(t) {
										return function() {
											throw t
										}
									}(t), 0)
								}
							}

							function o(t, e, n) {
								t(e, n)
							}

							function a(t, n, r, a) {
								var s, l = e[n],
									c = a ? o : i;
								if (Object.prototype.hasOwnProperty.call(e, n))
									for (s in l) Object.prototype.hasOwnProperty.call(l, s) && c(l[s], t, r)
							}

							function s(t) {
								var n = String(t);
								return Boolean(Object.prototype.hasOwnProperty.call(e, n) && function(t) {
									var e;
									for (e in t)
										if (Object.prototype.hasOwnProperty.call(t, e)) return !0;
									return !1
								}(e[n]))
							}

							function l(t, e, n, i) {
								var o = function(t, e, n) {
									return function() {
										var i = String(t),
											o = i.lastIndexOf(".");
										for (a(t, t, e, n); - 1 !== o;) o = (i = i.substr(0, o)).lastIndexOf("."), a(t, i, e, n);
										a(t, r, e, n)
									}
								}(t = "symbol" == typeof t ? t.toString() : t, e, i);
								return !! function(t) {
									for (var e = String(t), n = s(e) || s(r), i = e.lastIndexOf("."); !n && -1 !== i;) i = (e = e.substr(0, i)).lastIndexOf("."), n = s(e);
									return n
								}(t) && (!0 === n ? o() : setTimeout(o, 0), !0)
							}
							t.publish = function(e, n) {
								return l(e, n, !1, t.immediateExceptions)
							}, t.publishSync = function(e, n) {
								return l(e, n, !0, t.immediateExceptions)
							}, t.subscribe = function(t, r) {
								if ("function" != typeof r) return !1;
								t = "symbol" == typeof t ? t.toString() : t, Object.prototype.hasOwnProperty.call(e, t) || (e[t] = {});
								var i = "uid_" + String(++n);
								return e[t][i] = r, i
							}, t.subscribeAll = function(e) {
								return t.subscribe(r, e)
							}, t.subscribeOnce = function(e, n) {
								var r = t.subscribe(e, (function() {
									t.unsubscribe(r), n.apply(this, arguments)
								}));
								return t
							}, t.clearAllSubscriptions = function() {
								e = {}
							}, t.clearSubscriptions = function(t) {
								var n;
								for (n in e) Object.prototype.hasOwnProperty.call(e, n) && 0 === n.indexOf(t) && delete e[n]
							}, t.countSubscriptions = function(t) {
								var n, r, i = 0;
								for (n in e)
									if (Object.prototype.hasOwnProperty.call(e, n) && 0 === n.indexOf(t)) {
										for (r in e[n]) i++;
										break
									} return i
							}, t.getSubscriptions = function(t) {
								var n, r = [];
								for (n in e) Object.prototype.hasOwnProperty.call(e, n) && 0 === n.indexOf(t) && r.push(n);
								return r
							}, t.unsubscribe = function(n) {
								var r, i, o, a = "string" == typeof n && (Object.prototype.hasOwnProperty.call(e, n) || function(t) {
										var n;
										for (n in e)
											if (Object.prototype.hasOwnProperty.call(e, n) && 0 === n.indexOf(t)) return !0;
										return !1
									}(n)),
									s = !a && "string" == typeof n,
									l = "function" == typeof n,
									c = !1;
								if (!a) {
									for (r in e)
										if (Object.prototype.hasOwnProperty.call(e, r)) {
											if (i = e[r], s && i[n]) {
												delete i[n], c = n;
												break
											}
											if (l)
												for (o in i) Object.prototype.hasOwnProperty.call(i, o) && i[o] === n && (delete i[o], c = !0)
										} return c
								}
								t.clearSubscriptions(n)
							}
						}(i)), void 0 !== t && t.exports && (e = t.exports = i), e.PubSub = i, t.exports = e = i
					}("object" == typeof window && window || this)
			},
			21: (t, e) => {
				"use strict";
				e.Z = (t, e) => {
					const n = t.__vccOpts || t;
					for (const [t, r] of e) n[t] = r;
					return n
				}
			},
			960: () => {},
			759: () => {},
			272: () => {},
			518: (t, e, n) => {
				var r = n(435).default;

				function i() {
					"use strict";
					t.exports = i = function() {
						return n
					}, t.exports.__esModule = !0, t.exports.default = t.exports;
					var e, n = {},
						o = Object.prototype,
						a = o.hasOwnProperty,
						s = Object.defineProperty || function(t, e, n) {
							t[e] = n.value
						},
						l = "function" == typeof Symbol ? Symbol : {},
						c = l.iterator || "@@iterator",
						u = l.asyncIterator || "@@asyncIterator",
						h = l.toStringTag || "@@toStringTag";

					function f(t, e, n) {
						return Object.defineProperty(t, e, {
							value: n,
							enumerable: !0,
							configurable: !0,
							writable: !0
						}), t[e]
					}
					try {
						f({}, "")
					} catch (e) {
						f = function(t, e, n) {
							return t[e] = n
						}
					}

					function d(t, e, n, r) {
						var i = e && e.prototype instanceof x ? e : x,
							o = Object.create(i.prototype),
							a = new D(r || []);
						return s(o, "_invoke", {
							value: j(t, n, a)
						}), o
					}

					function p(t, e, n) {
						try {
							return {
								type: "normal",
								arg: t.call(e, n)
							}
						} catch (t) {
							return {
								type: "throw",
								arg: t
							}
						}
					}
					n.wrap = d;
					var g = "suspendedStart",
						v = "suspendedYield",
						m = "executing",
						y = "completed",
						b = {};

					function x() {}

					function w() {}

					function C() {}
					var S = {};
					f(S, c, (function() {
						return this
					}));
					var O = Object.getPrototypeOf,
						T = O && O(O(M([])));
					T && T !== o && a.call(T, c) && (S = T);
					var k = C.prototype = x.prototype = Object.create(S);

					function F(t) {
						["next", "throw", "return"].forEach((function(e) {
							f(t, e, (function(t) {
								return this._invoke(e, t)
							}))
						}))
					}

					function P(t, e) {
						function n(i, o, s, l) {
							var c = p(t[i], t, o);
							if ("throw" !== c.type) {
								var u = c.arg,
									h = u.value;
								return h && "object" == r(h) && a.call(h, "__await") ? e.resolve(h.__await).then((function(t) {
									n("next", t, s, l)
								}), (function(t) {
									n("throw", t, s, l)
								})) : e.resolve(h).then((function(t) {
									u.value = t, s(u)
								}), (function(t) {
									return n("throw", t, s, l)
								}))
							}
							l(c.arg)
						}
						var i;
						s(this, "_invoke", {
							value: function(t, r) {
								function o() {
									return new e((function(e, i) {
										n(t, r, e, i)
									}))
								}
								return i = i ? i.then(o, o) : o()
							}
						})
					}

					function j(t, n, r) {
						var i = g;
						return function(o, a) {
							if (i === m) throw new Error("Generator is already running");
							if (i === y) {
								if ("throw" === o) throw a;
								return {
									value: e,
									done: !0
								}
							}
							for (r.method = o, r.arg = a;;) {
								var s = r.delegate;
								if (s) {
									var l = A(s, r);
									if (l) {
										if (l === b) continue;
										return l
									}
								}
								if ("next" === r.method) r.sent = r._sent = r.arg;
								else if ("throw" === r.method) {
									if (i === g) throw i = y, r.arg;
									r.dispatchException(r.arg)
								} else "return" === r.method && r.abrupt("return", r.arg);
								i = m;
								var c = p(t, n, r);
								if ("normal" === c.type) {
									if (i = r.done ? y : v, c.arg === b) continue;
									return {
										value: c.arg,
										done: r.done
									}
								}
								"throw" === c.type && (i = y, r.method = "throw", r.arg = c.arg)
							}
						}
					}

					function A(t, n) {
						var r = n.method,
							i = t.iterator[r];
						if (i === e) return n.delegate = null, "throw" === r && t.iterator.return && (n.method = "return", n.arg = e, A(t, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), b;
						var o = p(i, t.iterator, n.arg);
						if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, b;
						var a = o.arg;
						return a ? a.done ? (n[t.resultName] = a.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, b) : a : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, b)
					}

					function _(t) {
						var e = {
							tryLoc: t[0]
						};
						1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
					}

					function E(t) {
						var e = t.completion || {};
						e.type = "normal", delete e.arg, t.completion = e
					}

					function D(t) {
						this.tryEntries = [{
							tryLoc: "root"
						}], t.forEach(_, this), this.reset(!0)
					}

					function M(t) {
						if (t || "" === t) {
							var n = t[c];
							if (n) return n.call(t);
							if ("function" == typeof t.next) return t;
							if (!isNaN(t.length)) {
								var i = -1,
									o = function n() {
										for (; ++i < t.length;)
											if (a.call(t, i)) return n.value = t[i], n.done = !1, n;
										return n.value = e, n.done = !0, n
									};
								return o.next = o
							}
						}
						throw new TypeError(r(t) + " is not iterable")
					}
					return w.prototype = C, s(k, "constructor", {
						value: C,
						configurable: !0
					}), s(C, "constructor", {
						value: w,
						configurable: !0
					}), w.displayName = f(C, h, "GeneratorFunction"), n.isGeneratorFunction = function(t) {
						var e = "function" == typeof t && t.constructor;
						return !!e && (e === w || "GeneratorFunction" === (e.displayName || e.name))
					}, n.mark = function(t) {
						return Object.setPrototypeOf ? Object.setPrototypeOf(t, C) : (t.__proto__ = C, f(t, h, "GeneratorFunction")), t.prototype = Object.create(k), t
					}, n.awrap = function(t) {
						return {
							__await: t
						}
					}, F(P.prototype), f(P.prototype, u, (function() {
						return this
					})), n.AsyncIterator = P, n.async = function(t, e, r, i, o) {
						void 0 === o && (o = Promise);
						var a = new P(d(t, e, r, i), o);
						return n.isGeneratorFunction(e) ? a : a.next().then((function(t) {
							return t.done ? t.value : a.next()
						}))
					}, F(k), f(k, h, "Generator"), f(k, c, (function() {
						return this
					})), f(k, "toString", (function() {
						return "[object Generator]"
					})), n.keys = function(t) {
						var e = Object(t),
							n = [];
						for (var r in e) n.push(r);
						return n.reverse(),
							function t() {
								for (; n.length;) {
									var r = n.pop();
									if (r in e) return t.value = r, t.done = !1, t
								}
								return t.done = !0, t
							}
					}, n.values = M, D.prototype = {
						constructor: D,
						reset: function(t) {
							if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(E), !t)
								for (var n in this) "t" === n.charAt(0) && a.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
						},
						stop: function() {
							this.done = !0;
							var t = this.tryEntries[0].completion;
							if ("throw" === t.type) throw t.arg;
							return this.rval
						},
						dispatchException: function(t) {
							if (this.done) throw t;
							var n = this;

							function r(r, i) {
								return s.type = "throw", s.arg = t, n.next = r, i && (n.method = "next", n.arg = e), !!i
							}
							for (var i = this.tryEntries.length - 1; i >= 0; --i) {
								var o = this.tryEntries[i],
									s = o.completion;
								if ("root" === o.tryLoc) return r("end");
								if (o.tryLoc <= this.prev) {
									var l = a.call(o, "catchLoc"),
										c = a.call(o, "finallyLoc");
									if (l && c) {
										if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
										if (this.prev < o.finallyLoc) return r(o.finallyLoc)
									} else if (l) {
										if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
									} else {
										if (!c) throw new Error("try statement without catch or finally");
										if (this.prev < o.finallyLoc) return r(o.finallyLoc)
									}
								}
							}
						},
						abrupt: function(t, e) {
							for (var n = this.tryEntries.length - 1; n >= 0; --n) {
								var r = this.tryEntries[n];
								if (r.tryLoc <= this.prev && a.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
									var i = r;
									break
								}
							}
							i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
							var o = i ? i.completion : {};
							return o.type = t, o.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, b) : this.complete(o)
						},
						complete: function(t, e) {
							if ("throw" === t.type) throw t.arg;
							return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), b
						},
						finish: function(t) {
							for (var e = this.tryEntries.length - 1; e >= 0; --e) {
								var n = this.tryEntries[e];
								if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), E(n), b
							}
						},
						catch: function(t) {
							for (var e = this.tryEntries.length - 1; e >= 0; --e) {
								var n = this.tryEntries[e];
								if (n.tryLoc === t) {
									var r = n.completion;
									if ("throw" === r.type) {
										var i = r.arg;
										E(n)
									}
									return i
								}
							}
							throw new Error("illegal catch attempt")
						},
						delegateYield: function(t, n, r) {
							return this.delegate = {
								iterator: M(t),
								resultName: n,
								nextLoc: r
							}, "next" === this.method && (this.arg = e), b
						}
					}, n
				}
				t.exports = i, t.exports.__esModule = !0, t.exports.default = t.exports
			},
			435: t => {
				function e(n) {
					return t.exports = e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
						return typeof t
					} : function(t) {
						return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
					}, t.exports.__esModule = !0, t.exports.default = t.exports, e(n)
				}
				t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
			},
			117: (t, e, n) => {
				var r = n(518)();
				t.exports = r;
				try {
					regeneratorRuntime = r
				} catch (t) {
					"object" == typeof globalThis ? globalThis.regeneratorRuntime = r : Function("r", "regeneratorRuntime = r")(r)
				}
			}
		},
		e = {};

	function n(r) {
		var i = e[r];
		if (void 0 !== i) return i.exports;
		var o = e[r] = {
			id: r,
			loaded: !1,
			exports: {}
		};
		return t[r].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports
	}
	n.n = t => {
		var e = t && t.__esModule ? () => t.default : () => t;
		return n.d(e, {
			a: e
		}), e
	}, n.d = (t, e) => {
		for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
			enumerable: !0,
			get: e[r]
		})
	}, n.g = function() {
		if ("object" == typeof globalThis) return globalThis;
		try {
			return this || new Function("return this")()
		} catch (t) {
			if ("object" == typeof window) return window
		}
	}(), n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nmd = t => (t.paths = [], t.children || (t.children = []), t), (() => {
		"use strict";

		function t(t, e) {
			const n = Object.create(null),
				r = t.split(",");
			for (let t = 0; t < r.length; t++) n[r[t]] = !0;
			return e ? t => !!n[t.toLowerCase()] : t => !!n[t]
		}
		const e = t("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");

		function r(t) {
			return !!t || "" === t
		}

		function i(t) {
			if (C(t)) {
				const e = {};
				for (let n = 0; n < t.length; n++) {
					const r = t[n],
						o = k(r) ? s(r) : i(r);
					if (o)
						for (const t in o) e[t] = o[t]
				}
				return e
			}
			return k(t) || P(t) ? t : void 0
		}
		const o = /;(?![^(]*\))/g,
			a = /:(.+)/;

		function s(t) {
			const e = {};
			return t.split(o).forEach((t => {
				if (t) {
					const n = t.split(a);
					n.length > 1 && (e[n[0].trim()] = n[1].trim())
				}
			})), e
		}

		function l(t) {
			let e = "";
			if (k(t)) e = t;
			else if (C(t))
				for (let n = 0; n < t.length; n++) {
					const r = l(t[n]);
					r && (e += r + " ")
				} else if (P(t))
					for (const n in t) t[n] && (e += n + " ");
			return e.trim()
		}
		const c = t => null == t ? "" : C(t) || P(t) && (t.toString === A || !T(t.toString)) ? JSON.stringify(t, u, 2) : String(t),
			u = (t, e) => e && e.__v_isRef ? u(t, e.value) : S(e) ? {
				[`Map(${e.size})`]: [...e.entries()].reduce(((t, [e, n]) => (t[`${e} =>`] = n, t)), {})
			} : O(e) ? {
				[`Set(${e.size})`]: [...e.values()]
			} : !P(e) || C(e) || D(e) ? e : String(e),
			h = {},
			f = [],
			d = () => {},
			p = () => !1,
			g = /^on[^a-z]/,
			v = t => g.test(t),
			m = t => t.startsWith("onUpdate:"),
			y = Object.assign,
			b = (t, e) => {
				const n = t.indexOf(e);
				n > -1 && t.splice(n, 1)
			},
			x = Object.prototype.hasOwnProperty,
			w = (t, e) => x.call(t, e),
			C = Array.isArray,
			S = t => "[object Map]" === _(t),
			O = t => "[object Set]" === _(t),
			T = t => "function" == typeof t,
			k = t => "string" == typeof t,
			F = t => "symbol" == typeof t,
			P = t => null !== t && "object" == typeof t,
			j = t => P(t) && T(t.then) && T(t.catch),
			A = Object.prototype.toString,
			_ = t => A.call(t),
			E = t => _(t).slice(8, -1),
			D = t => "[object Object]" === _(t),
			M = t => k(t) && "NaN" !== t && "-" !== t[0] && "" + parseInt(t, 10) === t,
			I = t(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
			R = t => {
				const e = Object.create(null);
				return n => e[n] || (e[n] = t(n))
			},
			B = /-(\w)/g,
			N = R((t => t.replace(B, ((t, e) => e ? e.toUpperCase() : "")))),
			L = /\B([A-Z])/g,
			z = R((t => t.replace(L, "-$1").toLowerCase())),
			W = R((t => t.charAt(0).toUpperCase() + t.slice(1))),
			V = R((t => t ? `on${W(t)}` : "")),
			U = (t, e) => !Object.is(t, e),
			H = (t, e) => {
				for (let n = 0; n < t.length; n++) t[n](e)
			},
			q = (t, e, n) => {
				Object.defineProperty(t, e, {
					configurable: !0,
					enumerable: !1,
					value: n
				})
			},
			X = t => {
				const e = parseFloat(t);
				return isNaN(e) ? t : e
			};
		let G;
		const K = [];
		class Y {
			constructor(t = !1) {
				this.active = !0, this.effects = [], this.cleanups = [], !t && G && (this.parent = G, this.index = (G.scopes || (G.scopes = [])).push(this) - 1)
			}
			run(t) {
				if (this.active) try {
					return this.on(), t()
				} finally {
					this.off()
				}
			}
			on() {
				this.active && (K.push(this), G = this)
			}
			off() {
				this.active && (K.pop(), G = K[K.length - 1])
			}
			stop(t) {
				if (this.active) {
					if (this.effects.forEach((t => t.stop())), this.cleanups.forEach((t => t())), this.scopes && this.scopes.forEach((t => t.stop(!0))), this.parent && !t) {
						const t = this.parent.scopes.pop();
						t && t !== this && (this.parent.scopes[this.index] = t, t.index = this.index)
					}
					this.active = !1
				}
			}
		}
		const Z = t => {
				const e = new Set(t);
				return e.w = 0, e.n = 0, e
			},
			J = t => (t.w & et) > 0,
			Q = t => (t.n & et) > 0,
			$ = new WeakMap;
		let tt = 0,
			et = 1;
		const nt = 30,
			rt = [];
		let it;
		const ot = Symbol(""),
			at = Symbol("");
		class st {
			constructor(t, e = null, n) {
				this.fn = t, this.scheduler = e, this.active = !0, this.deps = [],
					function(t, e) {
						(e = e || G) && e.active && e.effects.push(t)
					}(this, n)
			}
			run() {
				if (!this.active) return this.fn();
				if (!rt.includes(this)) try {
					return rt.push(it = this), ut.push(ct), ct = !0, et = 1 << ++tt, tt <= nt ? (({
						deps: t
					}) => {
						if (t.length)
							for (let e = 0; e < t.length; e++) t[e].w |= et
					})(this) : lt(this), this.fn()
				} finally {
					tt <= nt && (t => {
						const {
							deps: e
						} = t;
						if (e.length) {
							let n = 0;
							for (let r = 0; r < e.length; r++) {
								const i = e[r];
								J(i) && !Q(i) ? i.delete(t) : e[n++] = i, i.w &= ~et, i.n &= ~et
							}
							e.length = n
						}
					})(this), et = 1 << --tt, ft(), rt.pop();
					const t = rt.length;
					it = t > 0 ? rt[t - 1] : void 0
				}
			}
			stop() {
				this.active && (lt(this), this.onStop && this.onStop(), this.active = !1)
			}
		}

		function lt(t) {
			const {
				deps: e
			} = t;
			if (e.length) {
				for (let n = 0; n < e.length; n++) e[n].delete(t);
				e.length = 0
			}
		}
		let ct = !0;
		const ut = [];

		function ht() {
			ut.push(ct), ct = !1
		}

		function ft() {
			const t = ut.pop();
			ct = void 0 === t || t
		}

		function dt(t, e, n) {
			if (!pt()) return;
			let r = $.get(t);
			r || $.set(t, r = new Map);
			let i = r.get(n);
			i || r.set(n, i = Z()), gt(i)
		}

		function pt() {
			return ct && void 0 !== it
		}

		function gt(t, e) {
			let n = !1;
			tt <= nt ? Q(t) || (t.n |= et, n = !J(t)) : n = !t.has(it), n && (t.add(it), it.deps.push(t))
		}

		function vt(t, e, n, r, i, o) {
			const a = $.get(t);
			if (!a) return;
			let s = [];
			if ("clear" === e) s = [...a.values()];
			else if ("length" === n && C(t)) a.forEach(((t, e) => {
				("length" === e || e >= r) && s.push(t)
			}));
			else switch (void 0 !== n && s.push(a.get(n)), e) {
				case "add":
					C(t) ? M(n) && s.push(a.get("length")) : (s.push(a.get(ot)), S(t) && s.push(a.get(at)));
					break;
				case "delete":
					C(t) || (s.push(a.get(ot)), S(t) && s.push(a.get(at)));
					break;
				case "set":
					S(t) && s.push(a.get(ot))
			}
			if (1 === s.length) s[0] && mt(s[0]);
			else {
				const t = [];
				for (const e of s) e && t.push(...e);
				mt(Z(t))
			}
		}

		function mt(t, e) {
			for (const e of C(t) ? t : [...t])(e !== it || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
		}
		const yt = t("__proto__,__v_isRef,__isVue"),
			bt = new Set(Object.getOwnPropertyNames(Symbol).map((t => Symbol[t])).filter(F)),
			xt = Tt(),
			wt = Tt(!1, !0),
			Ct = Tt(!0),
			St = Ot();

		function Ot() {
			const t = {};
			return ["includes", "indexOf", "lastIndexOf"].forEach((e => {
				t[e] = function(...t) {
					const n = ue(this);
					for (let t = 0, e = this.length; t < e; t++) dt(n, 0, t + "");
					const r = n[e](...t);
					return -1 === r || !1 === r ? n[e](...t.map(ue)) : r
				}
			})), ["push", "pop", "shift", "unshift", "splice"].forEach((e => {
				t[e] = function(...t) {
					ht();
					const n = ue(this)[e].apply(this, t);
					return ft(), n
				}
			})), t
		}

		function Tt(t = !1, e = !1) {
			return function(n, r, i) {
				if ("__v_isReactive" === r) return !t;
				if ("__v_isReadonly" === r) return t;
				if ("__v_raw" === r && i === (t ? e ? ne : ee : e ? te : $t).get(n)) return n;
				const o = C(n);
				if (!t && o && w(St, r)) return Reflect.get(St, r, i);
				const a = Reflect.get(n, r, i);
				return (F(r) ? bt.has(r) : yt(r)) ? a : (t || dt(n, 0, r), e ? a : ge(a) ? o && M(r) ? a : a.value : P(a) ? t ? oe(a) : re(a) : a)
			}
		}

		function kt(t = !1) {
			return function(e, n, r, i) {
				let o = e[n];
				if (!t && (r = ue(r), o = ue(o), !C(e) && ge(o) && !ge(r))) return o.value = r, !0;
				const a = C(e) && M(n) ? Number(n) < e.length : w(e, n),
					s = Reflect.set(e, n, r, i);
				return e === ue(i) && (a ? U(r, o) && vt(e, "set", n, r) : vt(e, "add", n, r)), s
			}
		}
		const Ft = {
				get: xt,
				set: kt(),
				deleteProperty: function(t, e) {
					const n = w(t, e),
						r = (t[e], Reflect.deleteProperty(t, e));
					return r && n && vt(t, "delete", e, void 0), r
				},
				has: function(t, e) {
					const n = Reflect.has(t, e);
					return F(e) && bt.has(e) || dt(t, 0, e), n
				},
				ownKeys: function(t) {
					return dt(t, 0, C(t) ? "length" : ot), Reflect.ownKeys(t)
				}
			},
			Pt = {
				get: Ct,
				set: (t, e) => !0,
				deleteProperty: (t, e) => !0
			},
			jt = y({}, Ft, {
				get: wt,
				set: kt(!0)
			}),
			At = t => P(t) ? re(t) : t,
			_t = t => P(t) ? oe(t) : t,
			Et = t => t,
			Dt = t => Reflect.getPrototypeOf(t);

		function Mt(t, e, n = !1, r = !1) {
			const i = ue(t = t.__v_raw),
				o = ue(e);
			e !== o && !n && dt(i, 0, e), !n && dt(i, 0, o);
			const {
				has: a
			} = Dt(i), s = r ? Et : n ? _t : At;
			return a.call(i, e) ? s(t.get(e)) : a.call(i, o) ? s(t.get(o)) : void(t !== i && t.get(e))
		}

		function It(t, e = !1) {
			const n = this.__v_raw,
				r = ue(n),
				i = ue(t);
			return t !== i && !e && dt(r, 0, t), !e && dt(r, 0, i), t === i ? n.has(t) : n.has(t) || n.has(i)
		}

		function Rt(t, e = !1) {
			return t = t.__v_raw, !e && dt(ue(t), 0, ot), Reflect.get(t, "size", t)
		}

		function Bt(t) {
			t = ue(t);
			const e = ue(this);
			return Dt(e).has.call(e, t) || (e.add(t), vt(e, "add", t, t)), this
		}

		function Nt(t, e) {
			e = ue(e);
			const n = ue(this),
				{
					has: r,
					get: i
				} = Dt(n);
			let o = r.call(n, t);
			o || (t = ue(t), o = r.call(n, t));
			const a = i.call(n, t);
			return n.set(t, e), o ? U(e, a) && vt(n, "set", t, e) : vt(n, "add", t, e), this
		}

		function Lt(t) {
			const e = ue(this),
				{
					has: n,
					get: r
				} = Dt(e);
			let i = n.call(e, t);
			i || (t = ue(t), i = n.call(e, t)), r && r.call(e, t);
			const o = e.delete(t);
			return i && vt(e, "delete", t, void 0), o
		}

		function zt() {
			const t = ue(this),
				e = 0 !== t.size,
				n = t.clear();
			return e && vt(t, "clear", void 0, void 0), n
		}

		function Wt(t, e) {
			return function(n, r) {
				const i = this,
					o = i.__v_raw,
					a = ue(o),
					s = e ? Et : t ? _t : At;
				return !t && dt(a, 0, ot), o.forEach(((t, e) => n.call(r, s(t), s(e), i)))
			}
		}

		function Vt(t, e, n) {
			return function(...r) {
				const i = this.__v_raw,
					o = ue(i),
					a = S(o),
					s = "entries" === t || t === Symbol.iterator && a,
					l = "keys" === t && a,
					c = i[t](...r),
					u = n ? Et : e ? _t : At;
				return !e && dt(o, 0, l ? at : ot), {
					next() {
						const {
							value: t,
							done: e
						} = c.next();
						return e ? {
							value: t,
							done: e
						} : {
							value: s ? [u(t[0]), u(t[1])] : u(t),
							done: e
						}
					},
					[Symbol.iterator]() {
						return this
					}
				}
			}
		}

		function Ut(t) {
			return function(...e) {
				return "delete" !== t && this
			}
		}

		function Ht() {
			const t = {
					get(t) {
						return Mt(this, t)
					},
					get size() {
						return Rt(this)
					},
					has: It,
					add: Bt,
					set: Nt,
					delete: Lt,
					clear: zt,
					forEach: Wt(!1, !1)
				},
				e = {
					get(t) {
						return Mt(this, t, !1, !0)
					},
					get size() {
						return Rt(this)
					},
					has: It,
					add: Bt,
					set: Nt,
					delete: Lt,
					clear: zt,
					forEach: Wt(!1, !0)
				},
				n = {
					get(t) {
						return Mt(this, t, !0)
					},
					get size() {
						return Rt(this, !0)
					},
					has(t) {
						return It.call(this, t, !0)
					},
					add: Ut("add"),
					set: Ut("set"),
					delete: Ut("delete"),
					clear: Ut("clear"),
					forEach: Wt(!0, !1)
				},
				r = {
					get(t) {
						return Mt(this, t, !0, !0)
					},
					get size() {
						return Rt(this, !0)
					},
					has(t) {
						return It.call(this, t, !0)
					},
					add: Ut("add"),
					set: Ut("set"),
					delete: Ut("delete"),
					clear: Ut("clear"),
					forEach: Wt(!0, !0)
				};
			return ["keys", "values", "entries", Symbol.iterator].forEach((i => {
				t[i] = Vt(i, !1, !1), n[i] = Vt(i, !0, !1), e[i] = Vt(i, !1, !0), r[i] = Vt(i, !0, !0)
			})), [t, n, e, r]
		}
		const [qt, Xt, Gt, Kt] = Ht();

		function Yt(t, e) {
			const n = e ? t ? Kt : Gt : t ? Xt : qt;
			return (e, r, i) => "__v_isReactive" === r ? !t : "__v_isReadonly" === r ? t : "__v_raw" === r ? e : Reflect.get(w(n, r) && r in e ? n : e, r, i)
		}
		const Zt = {
				get: Yt(!1, !1)
			},
			Jt = {
				get: Yt(!1, !0)
			},
			Qt = {
				get: Yt(!0, !1)
			},
			$t = new WeakMap,
			te = new WeakMap,
			ee = new WeakMap,
			ne = new WeakMap;

		function re(t) {
			return t && t.__v_isReadonly ? t : ae(t, !1, Ft, Zt, $t)
		}

		function ie(t) {
			return ae(t, !1, jt, Jt, te)
		}

		function oe(t) {
			return ae(t, !0, Pt, Qt, ee)
		}

		function ae(t, e, n, r, i) {
			if (!P(t)) return t;
			if (t.__v_raw && (!e || !t.__v_isReactive)) return t;
			const o = i.get(t);
			if (o) return o;
			const a = (s = t).__v_skip || !Object.isExtensible(s) ? 0 : function(t) {
				switch (t) {
					case "Object":
					case "Array":
						return 1;
					case "Map":
					case "Set":
					case "WeakMap":
					case "WeakSet":
						return 2;
					default:
						return 0
				}
			}(E(s));
			var s;
			if (0 === a) return t;
			const l = new Proxy(t, 2 === a ? r : n);
			return i.set(t, l), l
		}

		function se(t) {
			return le(t) ? se(t.__v_raw) : !(!t || !t.__v_isReactive)
		}

		function le(t) {
			return !(!t || !t.__v_isReadonly)
		}

		function ce(t) {
			return se(t) || le(t)
		}

		function ue(t) {
			const e = t && t.__v_raw;
			return e ? ue(e) : t
		}

		function he(t) {
			return q(t, "__v_skip", !0), t
		}

		function fe(t) {
			pt() && ((t = ue(t)).dep || (t.dep = Z()), gt(t.dep))
		}

		function de(t, e) {
			(t = ue(t)).dep && mt(t.dep)
		}
		const pe = t => P(t) ? re(t) : t;

		function ge(t) {
			return Boolean(t && !0 === t.__v_isRef)
		}

		function ve(t) {
			return be(t)
		}

		function me(t) {
			return be(t, !0)
		}
		class ye {
			constructor(t, e = !1) {
				this._shallow = e, this.dep = void 0, this.__v_isRef = !0, this._rawValue = e ? t : ue(t), this._value = e ? t : pe(t)
			}
			get value() {
				return fe(this), this._value
			}
			set value(t) {
				t = this._shallow ? t : ue(t), U(t, this._rawValue) && (this._rawValue = t, this._value = this._shallow ? t : pe(t), de(this))
			}
		}

		function be(t, e = !1) {
			return ge(t) ? t : new ye(t, e)
		}

		function xe(t) {
			de(t)
		}

		function we(t) {
			return ge(t) ? t.value : t
		}
		const Ce = {
			get: (t, e, n) => we(Reflect.get(t, e, n)),
			set: (t, e, n, r) => {
				const i = t[e];
				return ge(i) && !ge(n) ? (i.value = n, !0) : Reflect.set(t, e, n, r)
			}
		};

		function Se(t) {
			return se(t) ? t : new Proxy(t, Ce)
		}

		function Oe(t) {
			const e = C(t) ? new Array(t.length) : {};
			for (const n in t) e[n] = ke(t, n);
			return e
		}
		class Te {
			constructor(t, e) {
				this._object = t, this._key = e, this.__v_isRef = !0
			}
			get value() {
				return this._object[this._key]
			}
			set value(t) {
				this._object[this._key] = t
			}
		}

		function ke(t, e) {
			const n = t[e];
			return ge(n) ? n : new Te(t, e)
		}
		class Fe {
			constructor(t, e, n) {
				this._setter = e, this.dep = void 0, this._dirty = !0, this.__v_isRef = !0, this.effect = new st(t, (() => {
					this._dirty || (this._dirty = !0, de(this))
				})), this.__v_isReadonly = n
			}
			get value() {
				const t = ue(this);
				return fe(t), t._dirty && (t._dirty = !1, t._value = t.effect.run()), t._value
			}
			set value(t) {
				this._setter(t)
			}
		}

		function Pe(t, e) {
			let n, r;
			return T(t) ? (n = t, r = d) : (n = t.get, r = t.set), new Fe(n, r, T(t) || !t.set)
		}

		function je(t, e, ...n) {
			const r = t.vnode.props || h;
			let i = n;
			const o = e.startsWith("update:"),
				a = o && e.slice(7);
			if (a && a in r) {
				const t = `${"modelValue"===a?"model":a}Modifiers`,
					{
						number: e,
						trim: o
					} = r[t] || h;
				o ? i = n.map((t => t.trim())) : e && (i = n.map(X))
			}
			let s, l = r[s = V(e)] || r[s = V(N(e))];
			!l && o && (l = r[s = V(z(e))]), l && Xr(l, t, 6, i);
			const c = r[s + "Once"];
			if (c) {
				if (t.emitted) {
					if (t.emitted[s]) return
				} else t.emitted = {};
				t.emitted[s] = !0, Xr(c, t, 6, i)
			}
		}

		function Ae(t, e, n = !1) {
			const r = e.emitsCache,
				i = r.get(t);
			if (void 0 !== i) return i;
			const o = t.emits;
			let a = {};
			return o ? (C(o) ? o.forEach((t => a[t] = null)) : y(a, o), r.set(t, a), a) : (r.set(t, null), null)
		}

		function _e(t, e) {
			return !(!t || !v(e)) && (e = e.slice(2).replace(/Once$/, ""), w(t, e[0].toLowerCase() + e.slice(1)) || w(t, z(e)) || w(t, e))
		}
		Promise.resolve(), new Set, new Map, Object.create(null), Object.create(null);
		let Ee = null,
			De = null;

		function Me(t) {
			const e = Ee;
			return Ee = t, De = t && t.type.__scopeId || null, e
		}

		function Ie(t, e = Ee, n) {
			if (!e) return t;
			if (t._n) return t;
			const r = (...n) => {
				r._d && $n(-1);
				const i = Me(e),
					o = t(...n);
				return Me(i), r._d && $n(1), o
			};
			return r._n = !0, r._c = !0, r._d = !0, r
		}

		function Re(t) {
			const {
				type: e,
				vnode: n,
				proxy: r,
				withProxy: i,
				props: o,
				propsOptions: [a],
				slots: s,
				attrs: l,
				emit: c,
				render: u,
				renderCache: h,
				data: f,
				setupState: d,
				ctx: p,
				inheritAttrs: g
			} = t;
			let v;
			const y = Me(t);
			try {
				let t;
				if (4 & n.shapeFlag) {
					const e = i || r;
					v = dr(u.call(e, e, h, o, d, f, p)), t = l
				} else {
					const n = e;
					v = dr(n.length > 1 ? n(o, {
						attrs: l,
						slots: s,
						emit: c
					}) : n(o, null)), t = e.props ? l : Be(l)
				}
				let y = v;
				if (t && !1 !== g) {
					const e = Object.keys(t),
						{
							shapeFlag: n
						} = y;
					e.length && 7 & n && (a && e.some(m) && (t = Ne(t, a)), y = ur(y, t))
				}
				n.dirs && (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs), n.transition && (y.transition = n.transition), v = y
			} catch (e) {
				Yn.length = 0, Gr(e, t, 1), v = cr(Gn)
			}
			return Me(y), v
		}
		const Be = t => {
				let e;
				for (const n in t)("class" === n || "style" === n || v(n)) && ((e || (e = {}))[n] = t[n]);
				return e
			},
			Ne = (t, e) => {
				const n = {};
				for (const r in t) m(r) && r.slice(9) in e || (n[r] = t[r]);
				return n
			};

		function Le(t, e, n) {
			const r = Object.keys(e);
			if (r.length !== Object.keys(t).length) return !0;
			for (let i = 0; i < r.length; i++) {
				const o = r[i];
				if (e[o] !== t[o] && !_e(n, o)) return !0
			}
			return !1
		}

		function ze(t, e) {
			if (kr) {
				let n = kr.provides;
				const r = kr.parent && kr.parent.provides;
				r === n && (n = kr.provides = Object.create(r)), n[t] = e
			}
		}

		function We(t, e, n = !1) {
			const r = kr || Ee;
			if (r) {
				const i = null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
				if (i && t in i) return i[t];
				if (arguments.length > 1) return n && T(e) ? e.call(r.proxy) : e
			}
		}
		const Ve = [Function, Array],
			Ue = {
				name: "BaseTransition",
				props: {
					mode: String,
					appear: Boolean,
					persisted: Boolean,
					onBeforeEnter: Ve,
					onEnter: Ve,
					onAfterEnter: Ve,
					onEnterCancelled: Ve,
					onBeforeLeave: Ve,
					onLeave: Ve,
					onAfterLeave: Ve,
					onLeaveCancelled: Ve,
					onBeforeAppear: Ve,
					onAppear: Ve,
					onAfterAppear: Ve,
					onAppearCancelled: Ve
				},
				setup(t, {
					slots: e
				}) {
					const n = Fr(),
						r = function() {
							const t = {
								isMounted: !1,
								isLeaving: !1,
								isUnmounting: !1,
								leavingVNodes: new Map
							};
							return on((() => {
								t.isMounted = !0
							})), sn((() => {
								t.isUnmounting = !0
							})), t
						}();
					let i;
					return () => {
						const o = e.default && Ye(e.default(), !0);
						if (!o || !o.length) return;
						const a = ue(t),
							{
								mode: s
							} = a,
							l = o[0];
						if (r.isLeaving) return Xe(l);
						const c = Ge(l);
						if (!c) return Xe(l);
						const u = qe(c, a, r, n);
						Ke(c, u);
						const h = n.subTree,
							f = h && Ge(h);
						let d = !1;
						const {
							getTransitionKey: p
						} = c.type;
						if (p) {
							const t = p();
							void 0 === i ? i = t : t !== i && (i = t, d = !0)
						}
						if (f && f.type !== Gn && (!ir(c, f) || d)) {
							const t = qe(f, a, r, n);
							if (Ke(f, t), "out-in" === s) return r.isLeaving = !0, t.afterLeave = () => {
								r.isLeaving = !1, n.update()
							}, Xe(l);
							"in-out" === s && c.type !== Gn && (t.delayLeave = (t, e, n) => {
								He(r, f)[String(f.key)] = f, t._leaveCb = () => {
									e(), t._leaveCb = void 0, delete u.delayedLeave
								}, u.delayedLeave = n
							})
						}
						return l
					}
				}
			};

		function He(t, e) {
			const {
				leavingVNodes: n
			} = t;
			let r = n.get(e.type);
			return r || (r = Object.create(null), n.set(e.type, r)), r
		}

		function qe(t, e, n, r) {
			const {
				appear: i,
				mode: o,
				persisted: a = !1,
				onBeforeEnter: s,
				onEnter: l,
				onAfterEnter: c,
				onEnterCancelled: u,
				onBeforeLeave: h,
				onLeave: f,
				onAfterLeave: d,
				onLeaveCancelled: p,
				onBeforeAppear: g,
				onAppear: v,
				onAfterAppear: m,
				onAppearCancelled: y
			} = e, b = String(t.key), x = He(n, t), w = (t, e) => {
				t && Xr(t, r, 9, e)
			}, C = {
				mode: o,
				persisted: a,
				beforeEnter(e) {
					let r = s;
					if (!n.isMounted) {
						if (!i) return;
						r = g || s
					}
					e._leaveCb && e._leaveCb(!0);
					const o = x[b];
					o && ir(t, o) && o.el._leaveCb && o.el._leaveCb(), w(r, [e])
				},
				enter(t) {
					let e = l,
						r = c,
						o = u;
					if (!n.isMounted) {
						if (!i) return;
						e = v || l, r = m || c, o = y || u
					}
					let a = !1;
					const s = t._enterCb = e => {
						a || (a = !0, w(e ? o : r, [t]), C.delayedLeave && C.delayedLeave(), t._enterCb = void 0)
					};
					e ? (e(t, s), e.length <= 1 && s()) : s()
				},
				leave(e, r) {
					const i = String(t.key);
					if (e._enterCb && e._enterCb(!0), n.isUnmounting) return r();
					w(h, [e]);
					let o = !1;
					const a = e._leaveCb = n => {
						o || (o = !0, r(), w(n ? p : d, [e]), e._leaveCb = void 0, x[i] === t && delete x[i])
					};
					x[i] = t, f ? (f(e, a), f.length <= 1 && a()) : a()
				},
				clone: t => qe(t, e, n, r)
			};
			return C
		}

		function Xe(t) {
			if (Qe(t)) return (t = ur(t)).children = null, t
		}

		function Ge(t) {
			return Qe(t) ? t.children ? t.children[0] : void 0 : t
		}

		function Ke(t, e) {
			6 & t.shapeFlag && t.component ? Ke(t.component.subTree, e) : 128 & t.shapeFlag ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
		}

		function Ye(t, e = !1) {
			let n = [],
				r = 0;
			for (let i = 0; i < t.length; i++) {
				const o = t[i];
				o.type === qn ? (128 & o.patchFlag && r++, n = n.concat(Ye(o.children, e))) : (e || o.type !== Gn) && n.push(o)
			}
			if (r > 1)
				for (let t = 0; t < n.length; t++) n[t].patchFlag = -2;
			return n
		}

		function Ze(t) {
			return T(t) ? {
				setup: t,
				name: t.name
			} : t
		}
		const Je = t => !!t.type.__asyncLoader,
			Qe = t => t.type.__isKeepAlive;

		function $e(t, e) {
			! function(t, e, n = kr) {
				const r = t.__wdc || (t.__wdc = () => {
					let e = n;
					for (; e;) {
						if (e.isDeactivated) return;
						e = e.parent
					}
					t()
				});
				if (en(e, r, n), n) {
					let t = n.parent;
					for (; t && t.parent;) Qe(t.parent.vnode) && tn(r, e, n, t), t = t.parent
				}
			}(t, "da", e)
		}

		function tn(t, e, n, r) {
			const i = en(e, t, r, !0);
			ln((() => {
				b(r[e], i)
			}), n)
		}

		function en(t, e, n = kr, r = !1) {
			if (n) {
				const i = n[t] || (n[t] = []),
					o = e.__weh || (e.__weh = (...r) => {
						if (n.isUnmounted) return;
						ht(), Pr(n);
						const i = Xr(e, n, t, r);
						return jr(), ft(), i
					});
				return r ? i.unshift(o) : i.push(o), o
			}
		}
		RegExp, RegExp;
		const nn = t => (e, n = kr) => (!Dr || "sp" === t) && en(t, e, n),
			rn = nn("bm"),
			on = nn("m"),
			an = (nn("bu"), nn("u")),
			sn = nn("bum"),
			ln = nn("um");

		function cn(t, e, n, r) {
			const [i, o] = t.propsOptions;
			let a, s = !1;
			if (e)
				for (let l in e) {
					if (I(l)) continue;
					const c = e[l];
					let u;
					i && w(i, u = N(l)) ? o && o.includes(u) ? (a || (a = {}))[u] = c : n[u] = c : _e(t.emitsOptions, l) || c !== r[l] && (r[l] = c, s = !0)
				}
			if (o) {
				const e = ue(n),
					r = a || h;
				for (let a = 0; a < o.length; a++) {
					const s = o[a];
					n[s] = un(i, e, s, r[s], t, !w(r, s))
				}
			}
			return s
		}

		function un(t, e, n, r, i, o) {
			const a = t[n];
			if (null != a) {
				const t = w(a, "default");
				if (t && void 0 === r) {
					const t = a.default;
					if (a.type !== Function && T(t)) {
						const {
							propsDefaults: o
						} = i;
						n in o ? r = o[n] : (Pr(i), r = o[n] = t.call(null, e), jr())
					} else r = t
				}
				a[0] && (o && !t ? r = !1 : !a[1] || "" !== r && r !== z(n) || (r = !0))
			}
			return r
		}

		function hn(t, e, n = !1) {
			const r = e.propsCache,
				i = r.get(t);
			if (i) return i;
			const o = t.props,
				a = {},
				s = [];
			if (!o) return r.set(t, f), f;
			if (C(o))
				for (let t = 0; t < o.length; t++) {
					const e = N(o[t]);
					fn(e) && (a[e] = h)
				} else if (o)
					for (const t in o) {
						const e = N(t);
						if (fn(e)) {
							const n = o[t],
								r = a[e] = C(n) || T(n) ? {
									type: n
								} : n;
							if (r) {
								const t = gn(Boolean, r.type),
									n = gn(String, r.type);
								r[0] = t > -1, r[1] = n < 0 || t < n, (t > -1 || w(r, "default")) && s.push(e)
							}
						}
					}
			const l = [a, s];
			return r.set(t, l), l
		}

		function fn(t) {
			return "$" !== t[0]
		}

		function dn(t) {
			const e = t && t.toString().match(/^\s*function (\w+)/);
			return e ? e[1] : null === t ? "null" : ""
		}

		function pn(t, e) {
			return dn(t) === dn(e)
		}

		function gn(t, e) {
			return C(e) ? e.findIndex((e => pn(e, t))) : T(e) && pn(e, t) ? 0 : -1
		}
		nn("sp"), nn("rtg"), nn("rtc");
		const vn = t => "_" === t[0] || "$stable" === t,
			mn = t => C(t) ? t.map(dr) : [dr(t)],
			yn = (t, e, n) => {
				const r = Ie(((...t) => mn(e(...t))), n);
				return r._c = !1, r
			},
			bn = (t, e, n) => {
				const r = t._ctx;
				for (const n in t) {
					if (vn(n)) continue;
					const i = t[n];
					if (T(i)) e[n] = yn(0, i, r);
					else if (null != i) {
						const t = mn(i);
						e[n] = () => t
					}
				}
			},
			xn = (t, e) => {
				const n = mn(e);
				t.slots.default = () => n
			},
			wn = (t, e) => {
				if (32 & t.vnode.shapeFlag) {
					const n = e._;
					n ? (t.slots = ue(e), q(e, "_", n)) : bn(e, t.slots = {})
				} else t.slots = {}, e && xn(t, e);
				q(t.slots, or, 1)
			},
			Cn = (t, e, n) => {
				const {
					vnode: r,
					slots: i
				} = t;
				let o = !0,
					a = h;
				if (32 & r.shapeFlag) {
					const t = e._;
					t ? n && 1 === t ? o = !1 : (y(i, e), n || 1 !== t || delete i._) : (o = !e.$stable, bn(e, i)), a = e
				} else e && (xn(t, e), a = {
					default: 1
				});
				if (o)
					for (const t in i) vn(t) || t in a || delete i[t]
			};

		function Sn(t, e) {
			if (null === Ee) return t;
			const n = Ee.proxy,
				r = t.dirs || (t.dirs = []);
			for (let t = 0; t < e.length; t++) {
				let [i, o, a, s = h] = e[t];
				T(i) && (i = {
					mounted: i,
					updated: i
				}), i.deep && yi(o), r.push({
					dir: i,
					instance: n,
					value: o,
					oldValue: void 0,
					arg: a,
					modifiers: s
				})
			}
			return t
		}

		function On(t, e, n, r) {
			const i = t.dirs,
				o = e && e.dirs;
			for (let a = 0; a < i.length; a++) {
				const s = i[a];
				o && (s.oldValue = o[a].value);
				let l = s.dir[r];
				l && (ht(), Xr(l, n, 8, [t.el, s, t, e]), ft())
			}
		}

		function Tn() {
			return {
				app: null,
				config: {
					isNativeTag: p,
					performance: !1,
					globalProperties: {},
					optionMergeStrategies: {},
					errorHandler: void 0,
					warnHandler: void 0,
					compilerOptions: {}
				},
				mixins: [],
				components: {},
				directives: {},
				provides: Object.create(null),
				optionsCache: new WeakMap,
				propsCache: new WeakMap,
				emitsCache: new WeakMap
			}
		}
		let kn = 0;

		function Fn(t, e) {
			return function(n, r = null) {
				null == r || P(r) || (r = null);
				const i = Tn(),
					o = new Set;
				let a = !1;
				const s = i.app = {
					_uid: kn++,
					_component: n,
					_props: r,
					_container: null,
					_context: i,
					_instance: null,
					version: wi,
					get config() {
						return i.config
					},
					set config(t) {},
					use: (t, ...e) => (o.has(t) || (t && T(t.install) ? (o.add(t), t.install(s, ...e)) : T(t) && (o.add(t), t(s, ...e))), s),
					mixin: t => s,
					component: (t, e) => e ? (i.components[t] = e, s) : i.components[t],
					directive: (t, e) => e ? (i.directives[t] = e, s) : i.directives[t],
					mount(o, l, c) {
						if (!a) {
							const u = cr(n, r);
							return u.appContext = i, l && e ? e(u, o) : t(u, o, c), a = !0, s._container = o, o.__vue_app__ = s, u.component.proxy
						}
					},
					unmount() {
						a && (t(null, s._container), delete s._container.__vue_app__)
					},
					provide: (t, e) => (i.provides[t] = e, s)
				};
				return s
			}
		}
		const Pn = function(t, e) {
			e && e.pendingBranch ? C(t) ? e.effects.push(...t) : e.effects.push(t) : ui(t, ni, ei, ri)
		};

		function jn(t, e) {
			const {
				insert: n,
				remove: r,
				patchProp: i,
				createElement: o,
				createText: a,
				createComment: s,
				setText: l,
				setElementText: c,
				parentNode: u,
				nextSibling: p,
				setScopeId: g = d,
				cloneNode: v,
				insertStaticContent: m
			} = t, y = (t, e, n, r = null, i = null, o = null, a = !1, s = null, l = !!e.dynamicChildren) => {
				if (t === e) return;
				t && !ir(t, e) && (r = Q(t), X(t, i, o, !0), t = null), -2 === e.patchFlag && (l = !1, e.dynamicChildren = null);
				const {
					type: c,
					ref: u,
					shapeFlag: h
				} = e;
				switch (c) {
					case Xn:
						b(t, e, n, r);
						break;
					case Gn:
						x(t, e, n, r);
						break;
					case Kn:
						null == t && C(e, n, r, a);
						break;
					case qn:
						_(t, e, n, r, i, o, a, s, l);
						break;
					default:
						1 & h ? S(t, e, n, r, i, o, a, s, l) : 6 & h ? E(t, e, n, r, i, o, a, s, l) : (64 & h || 128 & h) && c.process(t, e, n, r, i, o, a, s, l, tt)
				}
				null != u && i && An(u, t && t.ref, o, e || t, !e)
			}, b = (t, e, r, i) => {
				if (null == t) n(e.el = a(e.children), r, i);
				else {
					const n = e.el = t.el;
					e.children !== t.children && l(n, e.children)
				}
			}, x = (t, e, r, i) => {
				null == t ? n(e.el = s(e.children || ""), r, i) : e.el = t.el
			}, C = (t, e, n, r) => {
				[t.el, t.anchor] = m(t.children, e, n, r)
			}, S = (t, e, n, r, i, o, a, s, l) => {
				a = a || "svg" === e.type, null == t ? O(e, n, r, i, o, a, s, l) : F(t, e, i, o, a, s, l)
			}, O = (t, e, r, a, s, l, u, h) => {
				let f, d;
				const {
					type: p,
					props: g,
					shapeFlag: m,
					transition: y,
					patchFlag: b,
					dirs: x
				} = t;
				if (t.el && void 0 !== v && -1 === b) f = t.el = v(t.el);
				else {
					if (f = t.el = o(t.type, l, g && g.is, g), 8 & m ? c(f, t.children) : 16 & m && k(t.children, f, null, a, s, l && "foreignObject" !== p, u, h), x && On(t, null, a, "created"), g) {
						for (const e in g) "value" === e || I(e) || i(f, e, null, g[e], l, t.children, a, s, J);
						"value" in g && i(f, "value", null, g.value), (d = g.onVnodeBeforeMount) && _n(d, a, t)
					}
					T(f, t, t.scopeId, u, a)
				}
				x && On(t, null, a, "beforeMount");
				const w = (!s || s && !s.pendingBranch) && y && !y.persisted;
				w && y.beforeEnter(f), n(f, e, r), ((d = g && g.onVnodeMounted) || w || x) && Pn((() => {
					d && _n(d, a, t), w && y.enter(f), x && On(t, null, a, "mounted")
				}), s)
			}, T = (t, e, n, r, i) => {
				if (n && g(t, n), r)
					for (let e = 0; e < r.length; e++) g(t, r[e]);
				if (i && e === i.subTree) {
					const e = i.vnode;
					T(t, e, e.scopeId, e.slotScopeIds, i.parent)
				}
			}, k = (t, e, n, r, i, o, a, s, l = 0) => {
				for (let c = l; c < t.length; c++) {
					const l = t[c] = s ? pr(t[c]) : dr(t[c]);
					y(null, l, e, n, r, i, o, a, s)
				}
			}, F = (t, e, n, r, o, a, s) => {
				const l = e.el = t.el;
				let {
					patchFlag: u,
					dynamicChildren: f,
					dirs: d
				} = e;
				u |= 16 & t.patchFlag;
				const p = t.props || h,
					g = e.props || h;
				let v;
				(v = g.onVnodeBeforeUpdate) && _n(v, n, e, t), d && On(e, t, n, "beforeUpdate");
				const m = o && "foreignObject" !== e.type;
				if (f ? P(t.dynamicChildren, f, l, n, r, m, a) : s || L(t, e, l, null, n, r, m, a, !1), u > 0) {
					if (16 & u) A(l, e, p, g, n, r, o);
					else if (2 & u && p.class !== g.class && i(l, "class", null, g.class, o), 4 & u && i(l, "style", p.style, g.style, o), 8 & u) {
						const a = e.dynamicProps;
						for (let e = 0; e < a.length; e++) {
							const s = a[e],
								c = p[s],
								u = g[s];
							u === c && "value" !== s || i(l, s, c, u, o, t.children, n, r, J)
						}
					}
					1 & u && t.children !== e.children && c(l, e.children)
				} else s || null != f || A(l, e, p, g, n, r, o);
				((v = g.onVnodeUpdated) || d) && Pn((() => {
					v && _n(v, n, e, t), d && On(e, t, n, "updated")
				}), r)
			}, P = (t, e, n, r, i, o, a) => {
				for (let s = 0; s < e.length; s++) {
					const l = t[s],
						c = e[s],
						h = l.el && (l.type === qn || !ir(l, c) || 70 & l.shapeFlag) ? u(l.el) : n;
					y(l, c, h, null, r, i, o, a, !0)
				}
			}, A = (t, e, n, r, o, a, s) => {
				if (n !== r) {
					for (const l in r) {
						if (I(l)) continue;
						const c = r[l],
							u = n[l];
						c !== u && "value" !== l && i(t, l, u, c, s, e.children, o, a, J)
					}
					if (n !== h)
						for (const l in n) I(l) || l in r || i(t, l, n[l], null, s, e.children, o, a, J);
					"value" in r && i(t, "value", n.value, r.value)
				}
			}, _ = (t, e, r, i, o, s, l, c, u) => {
				const h = e.el = t ? t.el : a(""),
					f = e.anchor = t ? t.anchor : a("");
				let {
					patchFlag: d,
					dynamicChildren: p,
					slotScopeIds: g
				} = e;
				g && (c = c ? c.concat(g) : g), null == t ? (n(h, r, i), n(f, r, i), k(e.children, r, f, o, s, l, c, u)) : d > 0 && 64 & d && p && t.dynamicChildren ? (P(t.dynamicChildren, p, r, o, s, l, c), (null != e.key || o && e === o.subTree) && En(t, e, !0)) : L(t, e, r, f, o, s, l, c, u)
			}, E = (t, e, n, r, i, o, a, s, l) => {
				e.slotScopeIds = s, null == t ? 512 & e.shapeFlag ? i.ctx.activate(e, n, r, a, l) : D(e, n, r, i, o, a, l) : M(t, e, l)
			}, D = (t, e, n, r, i, o, a) => {
				const s = t.component = function(t, e, n) {
					const r = t.type,
						i = (e ? e.appContext : t.appContext) || Or,
						o = {
							uid: Tr++,
							vnode: t,
							type: r,
							parent: e,
							appContext: i,
							root: null,
							next: null,
							subTree: null,
							update: null,
							scope: new Y(!0),
							render: null,
							proxy: null,
							exposed: null,
							exposeProxy: null,
							withProxy: null,
							provides: e ? e.provides : Object.create(i.provides),
							accessCache: null,
							renderCache: [],
							components: null,
							directives: null,
							propsOptions: hn(r, i),
							emitsOptions: Ae(r, i),
							emit: null,
							emitted: null,
							propsDefaults: h,
							inheritAttrs: r.inheritAttrs,
							ctx: h,
							data: h,
							props: h,
							attrs: h,
							slots: h,
							refs: h,
							setupState: h,
							setupContext: null,
							suspense: n,
							suspenseId: n ? n.pendingId : 0,
							asyncDep: null,
							asyncResolved: !1,
							isMounted: !1,
							isUnmounted: !1,
							isDeactivated: !1,
							bc: null,
							c: null,
							bm: null,
							m: null,
							bu: null,
							u: null,
							um: null,
							bum: null,
							da: null,
							a: null,
							rtg: null,
							rtc: null,
							ec: null,
							sp: null
						};
					return o.ctx = {
						_: o
					}, o.root = e ? e.root : o, o.emit = je.bind(null, o), t.ce && t.ce(o), o
				}(t, r, i);
				if (Qe(t) && (s.ctx.renderer = tt), function(t, e = !1) {
						Dr = e;
						const {
							props: n,
							children: r
						} = t.vnode, i = Ar(t);
						! function(t, e, n, r = !1) {
							const i = {},
								o = {};
							q(o, or, 1), t.propsDefaults = Object.create(null), cn(t, e, i, o);
							for (const e in t.propsOptions[0]) e in i || (i[e] = void 0);
							n ? t.props = r ? i : ie(i) : t.type.props ? t.props = i : t.props = o, t.attrs = o
						}(t, n, i, e), wn(t, r);
						const o = i ? function(t, e) {
							const n = t.type;
							t.accessCache = Object.create(null), t.proxy = he(new Proxy(t.ctx, Sr));
							const {
								setup: r
							} = n;
							if (r) {
								const n = t.setupContext = r.length > 1 ? Rr(t) : null;
								Pr(t), ht();
								const i = qr(r, t, 0, [t.props, n]);
								if (ft(), jr(), j(i)) {
									if (i.then(jr, jr), e) return i.then((n => {
										Mr(t, n, e)
									})).catch((e => {
										Gr(e, t, 0)
									}));
									t.asyncDep = i
								} else Mr(t, i, e)
							} else Ir(t)
						}(t, e) : void 0;
						Dr = !1
					}(s), s.asyncDep) {
					if (i && i.registerDep(s, R), !t.el) {
						const t = s.subTree = cr(Gn);
						x(null, t, e, n)
					}
				} else R(s, t, e, n, i, o, a)
			}, M = (t, e, n) => {
				const r = e.component = t.component;
				if (function(t, e, n) {
						const {
							props: r,
							children: i,
							component: o
						} = t, {
							props: a,
							children: s,
							patchFlag: l
						} = e, c = o.emitsOptions;
						if (e.dirs || e.transition) return !0;
						if (!(n && l >= 0)) return !(!i && !s || s && s.$stable) || r !== a && (r ? !a || Le(r, a, c) : !!a);
						if (1024 & l) return !0;
						if (16 & l) return r ? Le(r, a, c) : !!a;
						if (8 & l) {
							const t = e.dynamicProps;
							for (let e = 0; e < t.length; e++) {
								const n = t[e];
								if (a[n] !== r[n] && !_e(c, n)) return !0
							}
						}
						return !1
					}(t, e, n)) {
					if (r.asyncDep && !r.asyncResolved) return void B(r, e, n);
					r.next = e,
						function(t) {
							const e = Zr.indexOf(t);
							e > Jr && Zr.splice(e, 1)
						}(r.update), r.update()
				} else e.component = t.component, e.el = t.el, r.vnode = e
			}, R = (t, e, n, r, i, o, a) => {
				const s = new st((() => {
						if (t.isMounted) {
							let e, {
									next: n,
									bu: r,
									u: l,
									parent: c,
									vnode: h
								} = t,
								f = n;
							s.allowRecurse = !1, n ? (n.el = h.el, B(t, n, a)) : n = h, r && H(r), (e = n.props && n.props.onVnodeBeforeUpdate) && _n(e, c, n, h), s.allowRecurse = !0;
							const d = Re(t),
								p = t.subTree;
							t.subTree = d, y(p, d, u(p.el), Q(p), t, i, o), n.el = d.el, null === f && function({
								vnode: t,
								parent: e
							}, n) {
								for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
							}(t, d.el), l && Pn(l, i), (e = n.props && n.props.onVnodeUpdated) && Pn((() => _n(e, c, n, h)), i)
						} else {
							let a;
							const {
								el: l,
								props: c
							} = e, {
								bm: u,
								m: h,
								parent: f
							} = t, d = Je(e);
							if (s.allowRecurse = !1, u && H(u), !d && (a = c && c.onVnodeBeforeMount) && _n(a, f, e), s.allowRecurse = !0, l && nt) {
								const n = () => {
									t.subTree = Re(t), nt(l, t.subTree, t, i, null)
								};
								d ? e.type.__asyncLoader().then((() => !t.isUnmounted && n())) : n()
							} else {
								const a = t.subTree = Re(t);
								y(null, a, n, r, t, i, o), e.el = a.el
							}
							if (h && Pn(h, i), !d && (a = c && c.onVnodeMounted)) {
								const t = e;
								Pn((() => _n(a, f, t)), i)
							}
							256 & e.shapeFlag && t.a && Pn(t.a, i), t.isMounted = !0, e = n = r = null
						}
					}), (() => li(t.update)), t.scope),
					l = t.update = s.run.bind(s);
				l.id = t.uid, s.allowRecurse = l.allowRecurse = !0, l()
			}, B = (t, e, n) => {
				e.component = t;
				const r = t.vnode.props;
				t.vnode = e, t.next = null,
					function(t, e, n, r) {
						const {
							props: i,
							attrs: o,
							vnode: {
								patchFlag: a
							}
						} = t, s = ue(i), [l] = t.propsOptions;
						let c = !1;
						if (!(r || a > 0) || 16 & a) {
							let r;
							cn(t, e, i, o) && (c = !0);
							for (const o in s) e && (w(e, o) || (r = z(o)) !== o && w(e, r)) || (l ? !n || void 0 === n[o] && void 0 === n[r] || (i[o] = un(l, s, o, void 0, t, !0)) : delete i[o]);
							if (o !== s)
								for (const t in o) e && w(e, t) || (delete o[t], c = !0)
						} else if (8 & a) {
							const n = t.vnode.dynamicProps;
							for (let r = 0; r < n.length; r++) {
								let a = n[r];
								const u = e[a];
								if (l)
									if (w(o, a)) u !== o[a] && (o[a] = u, c = !0);
									else {
										const e = N(a);
										i[e] = un(l, s, e, u, t, !1)
									}
								else u !== o[a] && (o[a] = u, c = !0)
							}
						}
						c && vt(t, "set", "$attrs")
					}(t, e.props, r, n), Cn(t, e.children, n), ht(), hi(void 0, t.update), ft()
			}, L = (t, e, n, r, i, o, a, s, l = !1) => {
				const u = t && t.children,
					h = t ? t.shapeFlag : 0,
					f = e.children,
					{
						patchFlag: d,
						shapeFlag: p
					} = e;
				if (d > 0) {
					if (128 & d) return void V(u, f, n, r, i, o, a, s, l);
					if (256 & d) return void W(u, f, n, r, i, o, a, s, l)
				}
				8 & p ? (16 & h && J(u, i, o), f !== u && c(n, f)) : 16 & h ? 16 & p ? V(u, f, n, r, i, o, a, s, l) : J(u, i, o, !0) : (8 & h && c(n, ""), 16 & p && k(f, n, r, i, o, a, s, l))
			}, W = (t, e, n, r, i, o, a, s, l) => {
				e = e || f;
				const c = (t = t || f).length,
					u = e.length,
					h = Math.min(c, u);
				let d;
				for (d = 0; d < h; d++) {
					const r = e[d] = l ? pr(e[d]) : dr(e[d]);
					y(t[d], r, n, null, i, o, a, s, l)
				}
				c > u ? J(t, i, o, !0, !1, h) : k(e, n, r, i, o, a, s, l, h)
			}, V = (t, e, n, r, i, o, a, s, l) => {
				let c = 0;
				const u = e.length;
				let h = t.length - 1,
					d = u - 1;
				for (; c <= h && c <= d;) {
					const r = t[c],
						u = e[c] = l ? pr(e[c]) : dr(e[c]);
					if (!ir(r, u)) break;
					y(r, u, n, null, i, o, a, s, l), c++
				}
				for (; c <= h && c <= d;) {
					const r = t[h],
						c = e[d] = l ? pr(e[d]) : dr(e[d]);
					if (!ir(r, c)) break;
					y(r, c, n, null, i, o, a, s, l), h--, d--
				}
				if (c > h) {
					if (c <= d) {
						const t = d + 1,
							h = t < u ? e[t].el : r;
						for (; c <= d;) y(null, e[c] = l ? pr(e[c]) : dr(e[c]), n, h, i, o, a, s, l), c++
					}
				} else if (c > d)
					for (; c <= h;) X(t[c], i, o, !0), c++;
				else {
					const p = c,
						g = c,
						v = new Map;
					for (c = g; c <= d; c++) {
						const t = e[c] = l ? pr(e[c]) : dr(e[c]);
						null != t.key && v.set(t.key, c)
					}
					let m, b = 0;
					const x = d - g + 1;
					let w = !1,
						C = 0;
					const S = new Array(x);
					for (c = 0; c < x; c++) S[c] = 0;
					for (c = p; c <= h; c++) {
						const r = t[c];
						if (b >= x) {
							X(r, i, o, !0);
							continue
						}
						let u;
						if (null != r.key) u = v.get(r.key);
						else
							for (m = g; m <= d; m++)
								if (0 === S[m - g] && ir(r, e[m])) {
									u = m;
									break
								} void 0 === u ? X(r, i, o, !0) : (S[u - g] = c + 1, u >= C ? C = u : w = !0, y(r, e[u], n, null, i, o, a, s, l), b++)
					}
					const O = w ? function(t) {
						const e = t.slice(),
							n = [0];
						let r, i, o, a, s;
						const l = t.length;
						for (r = 0; r < l; r++) {
							const l = t[r];
							if (0 !== l) {
								if (i = n[n.length - 1], t[i] < l) {
									e[r] = i, n.push(r);
									continue
								}
								for (o = 0, a = n.length - 1; o < a;) s = o + a >> 1, t[n[s]] < l ? o = s + 1 : a = s;
								l < t[n[o]] && (o > 0 && (e[r] = n[o - 1]), n[o] = r)
							}
						}
						for (o = n.length, a = n[o - 1]; o-- > 0;) n[o] = a, a = e[a];
						return n
					}(S) : f;
					for (m = O.length - 1, c = x - 1; c >= 0; c--) {
						const t = g + c,
							h = e[t],
							f = t + 1 < u ? e[t + 1].el : r;
						0 === S[c] ? y(null, h, n, f, i, o, a, s, l) : w && (m < 0 || c !== O[m] ? U(h, n, f, 2) : m--)
					}
				}
			}, U = (t, e, r, i, o = null) => {
				const {
					el: a,
					type: s,
					transition: l,
					children: c,
					shapeFlag: u
				} = t;
				if (6 & u) U(t.component.subTree, e, r, i);
				else if (128 & u) t.suspense.move(e, r, i);
				else if (64 & u) s.move(t, e, r, tt);
				else if (s !== qn)
					if (s !== Kn)
						if (2 !== i && 1 & u && l)
							if (0 === i) l.beforeEnter(a), n(a, e, r), Pn((() => l.enter(a)), o);
							else {
								const {
									leave: t,
									delayLeave: i,
									afterLeave: o
								} = l, s = () => n(a, e, r), c = () => {
									t(a, (() => {
										s(), o && o()
									}))
								};
								i ? i(a, s, c) : c()
							}
				else n(a, e, r);
				else(({
					el: t,
					anchor: e
				}, r, i) => {
					let o;
					for (; t && t !== e;) o = p(t), n(t, r, i), t = o;
					n(e, r, i)
				})(t, e, r);
				else {
					n(a, e, r);
					for (let t = 0; t < c.length; t++) U(c[t], e, r, i);
					n(t.anchor, e, r)
				}
			}, X = (t, e, n, r = !1, i = !1) => {
				const {
					type: o,
					props: a,
					ref: s,
					children: l,
					dynamicChildren: c,
					shapeFlag: u,
					patchFlag: h,
					dirs: f
				} = t;
				if (null != s && An(s, null, n, t, !0), 256 & u) return void e.ctx.deactivate(t);
				const d = 1 & u && f,
					p = !Je(t);
				let g;
				if (p && (g = a && a.onVnodeBeforeUnmount) && _n(g, e, t), 6 & u) Z(t.component, n, r);
				else {
					if (128 & u) return void t.suspense.unmount(n, r);
					d && On(t, null, e, "beforeUnmount"), 64 & u ? t.type.remove(t, e, n, i, tt, r) : c && (o !== qn || h > 0 && 64 & h) ? J(c, e, n, !1, !0) : (o === qn && 384 & h || !i && 16 & u) && J(l, e, n), r && G(t)
				}(p && (g = a && a.onVnodeUnmounted) || d) && Pn((() => {
					g && _n(g, e, t), d && On(t, null, e, "unmounted")
				}), n)
			}, G = t => {
				const {
					type: e,
					el: n,
					anchor: i,
					transition: o
				} = t;
				if (e === qn) return void K(n, i);
				if (e === Kn) return void(({
					el: t,
					anchor: e
				}) => {
					let n;
					for (; t && t !== e;) n = p(t), r(t), t = n;
					r(e)
				})(t);
				const a = () => {
					r(n), o && !o.persisted && o.afterLeave && o.afterLeave()
				};
				if (1 & t.shapeFlag && o && !o.persisted) {
					const {
						leave: e,
						delayLeave: r
					} = o, i = () => e(n, a);
					r ? r(t.el, a, i) : i()
				} else a()
			}, K = (t, e) => {
				let n;
				for (; t !== e;) n = p(t), r(t), t = n;
				r(e)
			}, Z = (t, e, n) => {
				const {
					bum: r,
					scope: i,
					update: o,
					subTree: a,
					um: s
				} = t;
				r && H(r), i.stop(), o && (o.active = !1, X(a, t, e, n)), s && Pn(s, e), Pn((() => {
					t.isUnmounted = !0
				}), e), e && e.pendingBranch && !e.isUnmounted && t.asyncDep && !t.asyncResolved && t.suspenseId === e.pendingId && (e.deps--, 0 === e.deps && e.resolve())
			}, J = (t, e, n, r = !1, i = !1, o = 0) => {
				for (let a = o; a < t.length; a++) X(t[a], e, n, r, i)
			}, Q = t => 6 & t.shapeFlag ? Q(t.component.subTree) : 128 & t.shapeFlag ? t.suspense.next() : p(t.anchor || t.el), $ = (t, e, n) => {
				null == t ? e._vnode && X(e._vnode, null, null, !0) : y(e._vnode || null, t, e, null, null, null, n), fi(), e._vnode = t
			}, tt = {
				p: y,
				um: X,
				m: U,
				r: G,
				mt: D,
				mc: k,
				pc: L,
				pbc: P,
				n: Q,
				o: t
			};
			let et, nt;
			return e && ([et, nt] = e(tt)), {
				render: $,
				hydrate: et,
				createApp: Fn($, et)
			}
		}

		function An(t, e, n, r, i = !1) {
			if (C(t)) return void t.forEach(((t, o) => An(t, e && (C(e) ? e[o] : e), n, r, i)));
			if (Je(r) && !i) return;
			const o = 4 & r.shapeFlag ? Br(r.component) || r.component.proxy : r.el,
				a = i ? null : o,
				{
					i: s,
					r: l
				} = t,
				c = e && e.r,
				u = s.refs === h ? s.refs = {} : s.refs,
				f = s.setupState;
			if (null != c && c !== l && (k(c) ? (u[c] = null, w(f, c) && (f[c] = null)) : ge(c) && (c.value = null)), k(l)) {
				const t = () => {
					u[l] = a, w(f, l) && (f[l] = a)
				};
				a ? (t.id = -1, Pn(t, n)) : t()
			} else if (ge(l)) {
				const t = () => {
					l.value = a
				};
				a ? (t.id = -1, Pn(t, n)) : t()
			} else T(l) && qr(l, s, 12, [a, u])
		}

		function _n(t, e, n, r = null) {
			Xr(t, e, 7, [n, r])
		}

		function En(t, e, n = !1) {
			const r = t.children,
				i = e.children;
			if (C(r) && C(i))
				for (let t = 0; t < r.length; t++) {
					const e = r[t];
					let o = i[t];
					1 & o.shapeFlag && !o.dynamicChildren && ((o.patchFlag <= 0 || 32 === o.patchFlag) && (o = i[t] = pr(i[t]), o.el = e.el), n || En(e, o))
				}
		}
		const Dn = t => t && (t.disabled || "" === t.disabled),
			Mn = t => "undefined" != typeof SVGElement && t instanceof SVGElement,
			In = (t, e) => {
				const n = t && t.to;
				if (k(n)) {
					if (e) {
						return e(n)
					}
					return null
				}
				return n
			},
			Rn = {
				__isTeleport: !0,
				process(t, e, n, r, i, o, a, s, l, c) {
					const {
						mc: u,
						pc: h,
						pbc: f,
						o: {
							insert: d,
							querySelector: p,
							createText: g,
							createComment: v
						}
					} = c, m = Dn(e.props);
					let {
						shapeFlag: y,
						children: b,
						dynamicChildren: x
					} = e;
					if (null == t) {
						const t = e.el = g(""),
							c = e.anchor = g("");
						d(t, n, r), d(c, n, r);
						const h = e.target = In(e.props, p),
							f = e.targetAnchor = g("");
						h && (d(f, h), a = a || Mn(h));
						const v = (t, e) => {
							16 & y && u(b, t, e, i, o, a, s, l)
						};
						m ? v(n, c) : h && v(h, f)
					} else {
						e.el = t.el;
						const r = e.anchor = t.anchor,
							u = e.target = t.target,
							d = e.targetAnchor = t.targetAnchor,
							g = Dn(t.props),
							v = g ? n : u,
							y = g ? r : d;
						if (a = a || Mn(u), x ? (f(t.dynamicChildren, x, v, i, o, a, s), En(t, e, !0)) : l || h(t, e, v, y, i, o, a, s, !1), m) g || Bn(e, n, r, c, 1);
						else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
							const t = e.target = In(e.props, p);
							t && Bn(e, t, null, c, 0)
						} else g && Bn(e, u, d, c, 1)
					}
				},
				remove(t, e, n, r, {
					um: i,
					o: {
						remove: o
					}
				}, a) {
					const {
						shapeFlag: s,
						children: l,
						anchor: c,
						targetAnchor: u,
						target: h,
						props: f
					} = t;
					if (h && o(u), (a || !Dn(f)) && (o(c), 16 & s))
						for (let t = 0; t < l.length; t++) {
							const r = l[t];
							i(r, e, n, !0, !!r.dynamicChildren)
						}
				},
				move: Bn,
				hydrate: function(t, e, n, r, i, o, {
					o: {
						nextSibling: a,
						parentNode: s,
						querySelector: l
					}
				}, c) {
					const u = e.target = In(e.props, l);
					if (u) {
						const l = u._lpa || u.firstChild;
						16 & e.shapeFlag && (Dn(e.props) ? (e.anchor = c(a(t), e, s(t), n, r, i, o), e.targetAnchor = l) : (e.anchor = a(t), e.targetAnchor = c(l, e, u, n, r, i, o)), u._lpa = e.targetAnchor && a(e.targetAnchor))
					}
					return e.anchor && a(e.anchor)
				}
			};

		function Bn(t, e, n, {
			o: {
				insert: r
			},
			m: i
		}, o = 2) {
			0 === o && r(t.targetAnchor, e, n);
			const {
				el: a,
				anchor: s,
				shapeFlag: l,
				children: c,
				props: u
			} = t, h = 2 === o;
			if (h && r(a, e, n), (!h || Dn(u)) && 16 & l)
				for (let t = 0; t < c.length; t++) i(c[t], e, n, 2);
			h && r(s, e, n)
		}
		const Nn = Rn,
			Ln = "components";

		function zn(t, e) {
			return Un(Ln, t, !0, e) || t
		}
		const Wn = Symbol();

		function Vn(t) {
			return k(t) ? Un(Ln, t, !1) || t : t || Wn
		}

		function Un(t, e, n = !0, r = !1) {
			const i = Ee || kr;
			if (i) {
				const n = i.type;
				if (t === Ln) {
					const t = zr(n);
					if (t && (t === e || t === N(e) || t === W(N(e)))) return n
				}
				const o = Hn(i[t] || n[t], e) || Hn(i.appContext[t], e);
				return !o && r ? n : o
			}
		}

		function Hn(t, e) {
			return t && (t[e] || t[N(e)] || t[W(N(e))])
		}
		const qn = Symbol(void 0),
			Xn = Symbol(void 0),
			Gn = Symbol(void 0),
			Kn = Symbol(void 0),
			Yn = [];
		let Zn = null;

		function Jn(t = !1) {
			Yn.push(Zn = t ? null : [])
		}
		let Qn = 1;

		function $n(t) {
			Qn += t
		}

		function tr(t) {
			return t.dynamicChildren = Qn > 0 ? Zn || f : null, Yn.pop(), Zn = Yn[Yn.length - 1] || null, Qn > 0 && Zn && Zn.push(t), t
		}

		function er(t, e, n, r, i, o) {
			return tr(lr(t, e, n, r, i, o, !0))
		}

		function nr(t, e, n, r, i) {
			return tr(cr(t, e, n, r, i, !0))
		}

		function rr(t) {
			return !!t && !0 === t.__v_isVNode
		}

		function ir(t, e) {
			return t.type === e.type && t.key === e.key
		}
		const or = "__vInternal",
			ar = ({
				key: t
			}) => null != t ? t : null,
			sr = ({
				ref: t
			}) => null != t ? k(t) || ge(t) || T(t) ? {
				i: Ee,
				r: t
			} : t : null;

		function lr(t, e = null, n = null, r = 0, i = null, o = (t === qn ? 0 : 1), a = !1, s = !1) {
			const l = {
				__v_isVNode: !0,
				__v_skip: !0,
				type: t,
				props: e,
				key: e && ar(e),
				ref: e && sr(e),
				scopeId: De,
				slotScopeIds: null,
				children: n,
				component: null,
				suspense: null,
				ssContent: null,
				ssFallback: null,
				dirs: null,
				transition: null,
				el: null,
				anchor: null,
				target: null,
				targetAnchor: null,
				staticCount: 0,
				shapeFlag: o,
				patchFlag: r,
				dynamicProps: i,
				dynamicChildren: null,
				appContext: null
			};
			return s ? (gr(l, n), 128 & o && t.normalize(l)) : n && (l.shapeFlag |= k(n) ? 8 : 16), Qn > 0 && !a && Zn && (l.patchFlag > 0 || 6 & o) && 32 !== l.patchFlag && Zn.push(l), l
		}
		const cr = function(t, e = null, n = null, r = 0, o = null, a = !1) {
			if (t && t !== Wn || (t = Gn), rr(t)) {
				const r = ur(t, e, !0);
				return n && gr(r, n), r
			}
			if (s = t, T(s) && "__vccOpts" in s && (t = t.__vccOpts), e) {
				e = function(t) {
					return t ? ce(t) || or in t ? y({}, t) : t : null
				}(e);
				let {
					class: t,
					style: n
				} = e;
				t && !k(t) && (e.class = l(t)), P(n) && (ce(n) && !C(n) && (n = y({}, n)), e.style = i(n))
			}
			var s;
			return lr(t, e, n, r, o, k(t) ? 1 : (t => t.__isSuspense)(t) ? 128 : (t => t.__isTeleport)(t) ? 64 : P(t) ? 4 : T(t) ? 2 : 0, a, !0)
		};

		function ur(t, e, n = !1) {
			const {
				props: r,
				ref: i,
				patchFlag: o,
				children: a
			} = t, s = e ? vr(r || {}, e) : r;
			return {
				__v_isVNode: !0,
				__v_skip: !0,
				type: t.type,
				props: s,
				key: s && ar(s),
				ref: e && e.ref ? n && i ? C(i) ? i.concat(sr(e)) : [i, sr(e)] : sr(e) : i,
				scopeId: t.scopeId,
				slotScopeIds: t.slotScopeIds,
				children: a,
				target: t.target,
				targetAnchor: t.targetAnchor,
				staticCount: t.staticCount,
				shapeFlag: t.shapeFlag,
				patchFlag: e && t.type !== qn ? -1 === o ? 16 : 16 | o : o,
				dynamicProps: t.dynamicProps,
				dynamicChildren: t.dynamicChildren,
				appContext: t.appContext,
				dirs: t.dirs,
				transition: t.transition,
				component: t.component,
				suspense: t.suspense,
				ssContent: t.ssContent && ur(t.ssContent),
				ssFallback: t.ssFallback && ur(t.ssFallback),
				el: t.el,
				anchor: t.anchor
			}
		}

		function hr(t = " ", e = 0) {
			return cr(Xn, null, t, e)
		}

		function fr(t = "", e = !1) {
			return e ? (Jn(), nr(Gn, null, t)) : cr(Gn, null, t)
		}

		function dr(t) {
			return null == t || "boolean" == typeof t ? cr(Gn) : C(t) ? cr(qn, null, t.slice()) : "object" == typeof t ? pr(t) : cr(Xn, null, String(t))
		}

		function pr(t) {
			return null === t.el || t.memo ? t : ur(t)
		}

		function gr(t, e) {
			let n = 0;
			const {
				shapeFlag: r
			} = t;
			if (null == e) e = null;
			else if (C(e)) n = 16;
			else if ("object" == typeof e) {
				if (65 & r) {
					const n = e.default;
					return void(n && (n._c && (n._d = !1), gr(t, n()), n._c && (n._d = !0)))
				} {
					n = 32;
					const r = e._;
					r || or in e ? 3 === r && Ee && (1 === Ee.slots._ ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024)) : e._ctx = Ee
				}
			} else T(e) ? (e = {
				default: e,
				_ctx: Ee
			}, n = 32) : (e = String(e), 64 & r ? (n = 16, e = [hr(e)]) : n = 8);
			t.children = e, t.shapeFlag |= n
		}

		function vr(...t) {
			const e = {};
			for (let n = 0; n < t.length; n++) {
				const r = t[n];
				for (const t in r)
					if ("class" === t) e.class !== r.class && (e.class = l([e.class, r.class]));
					else if ("style" === t) e.style = i([e.style, r.style]);
				else if (v(t)) {
					const n = e[t],
						i = r[t];
					n !== i && (e[t] = n ? [].concat(n, i) : i)
				} else "" !== t && (e[t] = r[t])
			}
			return e
		}

		function mr(t, e, n, r) {
			let i;
			const o = n && n[r];
			if (C(t) || k(t)) {
				i = new Array(t.length);
				for (let n = 0, r = t.length; n < r; n++) i[n] = e(t[n], n, void 0, o && o[n])
			} else if ("number" == typeof t) {
				i = new Array(t);
				for (let n = 0; n < t; n++) i[n] = e(n + 1, n, void 0, o && o[n])
			} else if (P(t))
				if (t[Symbol.iterator]) i = Array.from(t, ((t, n) => e(t, n, void 0, o && o[n])));
				else {
					const n = Object.keys(t);
					i = new Array(n.length);
					for (let r = 0, a = n.length; r < a; r++) {
						const a = n[r];
						i[r] = e(t[a], a, r, o && o[r])
					}
				}
			else i = [];
			return n && (n[r] = i), i
		}

		function yr(t, e) {
			for (let n = 0; n < e.length; n++) {
				const r = e[n];
				if (C(r))
					for (let e = 0; e < r.length; e++) t[r[e].name] = r[e].fn;
				else r && (t[r.name] = r.fn)
			}
			return t
		}

		function br(t, e, n = {}, r, i) {
			if (Ee.isCE) return cr("slot", "default" === e ? null : {
				name: e
			}, r && r());
			let o = t[e];
			o && o._c && (o._d = !1), Jn();
			const a = o && xr(o(n)),
				s = nr(qn, {
					key: n.key || `_${e}`
				}, a || (r ? r() : []), a && 1 === t._ ? 64 : -2);
			return !i && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), o && o._c && (o._d = !0), s
		}

		function xr(t) {
			return t.some((t => !rr(t) || t.type !== Gn && !(t.type === qn && !xr(t.children)))) ? t : null
		}
		const wr = t => t ? Ar(t) ? Br(t) || t.proxy : wr(t.parent) : null,
			Cr = y(Object.create(null), {
				$: t => t,
				$el: t => t.vnode.el,
				$data: t => t.data,
				$props: t => t.props,
				$attrs: t => t.attrs,
				$slots: t => t.slots,
				$refs: t => t.refs,
				$parent: t => wr(t.parent),
				$root: t => wr(t.root),
				$emit: t => t.emit,
				$options: t => t.type,
				$forceUpdate: t => () => li(t.update),
				$nextTick: t => si.bind(t.proxy),
				$watch: t => d
			}),
			Sr = {
				get({
					_: t
				}, e) {
					const {
						ctx: n,
						setupState: r,
						data: i,
						props: o,
						accessCache: a,
						type: s,
						appContext: l
					} = t;
					let c;
					if ("$" !== e[0]) {
						const s = a[e];
						if (void 0 !== s) switch (s) {
							case 0:
								return r[e];
							case 1:
								return i[e];
							case 3:
								return n[e];
							case 2:
								return o[e]
						} else {
							if (r !== h && w(r, e)) return a[e] = 0, r[e];
							if (i !== h && w(i, e)) return a[e] = 1, i[e];
							if ((c = t.propsOptions[0]) && w(c, e)) return a[e] = 2, o[e];
							if (n !== h && w(n, e)) return a[e] = 3, n[e];
							a[e] = 4
						}
					}
					const u = Cr[e];
					let f, d;
					return u ? ("$attrs" === e && dt(t, 0, e), u(t)) : (f = s.__cssModules) && (f = f[e]) ? f : n !== h && w(n, e) ? (a[e] = 3, n[e]) : (d = l.config.globalProperties, w(d, e) ? d[e] : void 0)
				},
				set({
					_: t
				}, e, n) {
					const {
						data: r,
						setupState: i,
						ctx: o
					} = t;
					if (i !== h && w(i, e)) i[e] = n;
					else if (r !== h && w(r, e)) r[e] = n;
					else if (w(t.props, e)) return !1;
					return !("$" === e[0] && e.slice(1) in t || (o[e] = n, 0))
				},
				has({
					_: {
						data: t,
						setupState: e,
						accessCache: n,
						ctx: r,
						appContext: i,
						propsOptions: o
					}
				}, a) {
					let s;
					return void 0 !== n[a] || t !== h && w(t, a) || e !== h && w(e, a) || (s = o[0]) && w(s, a) || w(r, a) || w(Cr, a) || w(i.config.globalProperties, a)
				}
			},
			Or = Tn();
		let Tr = 0;
		let kr = null;
		const Fr = () => kr || Ee,
			Pr = t => {
				kr = t, t.scope.on()
			},
			jr = () => {
				kr && kr.scope.off(), kr = null
			};

		function Ar(t) {
			return 4 & t.vnode.shapeFlag
		}
		let _r, Er, Dr = !1;

		function Mr(t, e, n) {
			T(e) ? t.render = e : P(e) && (t.setupState = Se(e)), Ir(t)
		}

		function Ir(t, e, n) {
			const r = t.type;
			if (!t.render) {
				if (_r && !r.render) {
					const e = r.template;
					if (e) {
						const {
							isCustomElement: n,
							compilerOptions: i
						} = t.appContext.config, {
							delimiters: o,
							compilerOptions: a
						} = r, s = y(y({
							isCustomElement: n,
							delimiters: o
						}, i), a);
						r.render = _r(e, s)
					}
				}
				t.render = r.render || d, Er && Er(t)
			}
		}

		function Rr(t) {
			let e;
			return {
				get attrs() {
					return e || (e = function(t) {
						return new Proxy(t.attrs, {
							get: (e, n) => (dt(t, 0, "$attrs"), e[n])
						})
					}(t))
				},
				slots: t.slots,
				emit: t.emit,
				expose: e => {
					t.exposed = e || {}
				}
			}
		}

		function Br(t) {
			if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(Se(he(t.exposed)), {
				get: (e, n) => n in e ? e[n] : n in Cr ? Cr[n](t) : void 0
			}))
		}
		const Nr = /(?:^|[-_])(\w)/g,
			Lr = t => t.replace(Nr, (t => t.toUpperCase())).replace(/[-_]/g, "");

		function zr(t) {
			return T(t) && t.displayName || t.name
		}

		function Wr(t, e, n = !1) {
			let r = zr(e);
			if (!r && e.__file) {
				const t = e.__file.match(/([^/\\]+)\.\w+$/);
				t && (r = t[1])
			}
			if (!r && t && t.parent) {
				const n = t => {
					for (const n in t)
						if (t[n] === e) return n
				};
				r = n(t.components || t.parent.type.components) || n(t.appContext.components)
			}
			return r ? Lr(r) : n ? "App" : "Anonymous"
		}
		const Vr = [];

		function Ur(t) {
			const e = [],
				n = Object.keys(t);
			return n.slice(0, 3).forEach((n => {
				e.push(...Hr(n, t[n]))
			})), n.length > 3 && e.push(" ..."), e
		}

		function Hr(t, e, n) {
			return k(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : "number" == typeof e || "boolean" == typeof e || null == e ? n ? e : [`${t}=${e}`] : ge(e) ? (e = Hr(t, ue(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : T(e) ? [`${t}=fn${e.name?`<${e.name}>`:""}`] : (e = ue(e), n ? e : [`${t}=`, e])
		}

		function qr(t, e, n, r) {
			let i;
			try {
				i = r ? t(...r) : t()
			} catch (t) {
				Gr(t, e, n)
			}
			return i
		}

		function Xr(t, e, n, r) {
			if (T(t)) {
				const i = qr(t, e, n, r);
				return i && j(i) && i.catch((t => {
					Gr(t, e, n)
				})), i
			}
			const i = [];
			for (let o = 0; o < t.length; o++) i.push(Xr(t[o], e, n, r));
			return i
		}

		function Gr(t, e, n, r = !0) {
			if (e && e.vnode, e) {
				let r = e.parent;
				const i = e.proxy,
					o = n;
				for (; r;) {
					const e = r.ec;
					if (e)
						for (let n = 0; n < e.length; n++)
							if (!1 === e[n](t, i, o)) return;
					r = r.parent
				}
				const a = e.appContext.config.errorHandler;
				if (a) return void qr(a, null, 10, [t, i, o])
			}! function(t, e, n, r = !0) {
				console.error(t)
			}(t, 0, 0, r)
		}
		let Kr = !1,
			Yr = !1;
		const Zr = [];
		let Jr = 0;
		const Qr = [];
		let $r = null,
			ti = 0;
		const ei = [];
		let ni = null,
			ri = 0;
		const ii = Promise.resolve();
		let oi = null,
			ai = null;

		function si(t) {
			const e = oi || ii;
			return t ? e.then(this ? t.bind(this) : t) : e
		}

		function li(t) {
			Zr.length && Zr.includes(t, Kr && t.allowRecurse ? Jr + 1 : Jr) || t === ai || (null == t.id ? Zr.push(t) : Zr.splice(function(t) {
				let e = Jr + 1,
					n = Zr.length;
				for (; e < n;) {
					const r = e + n >>> 1;
					di(Zr[r]) < t ? e = r + 1 : n = r
				}
				return e
			}(t.id), 0, t), ci())
		}

		function ci() {
			Kr || Yr || (Yr = !0, oi = ii.then(pi))
		}

		function ui(t, e, n, r) {
			C(t) ? n.push(...t) : e && e.includes(t, t.allowRecurse ? r + 1 : r) || n.push(t), ci()
		}

		function hi(t, e = null) {
			if (Qr.length) {
				for (ai = e, $r = [...new Set(Qr)], Qr.length = 0, ti = 0; ti < $r.length; ti++) $r[ti]();
				$r = null, ti = 0, ai = null, hi(t, e)
			}
		}

		function fi(t) {
			if (ei.length) {
				const t = [...new Set(ei)];
				if (ei.length = 0, ni) return void ni.push(...t);
				for (ni = t, ni.sort(((t, e) => di(t) - di(e))), ri = 0; ri < ni.length; ri++) ni[ri]();
				ni = null, ri = 0
			}
		}
		const di = t => null == t.id ? 1 / 0 : t.id;

		function pi(t) {
			Yr = !1, Kr = !0, hi(t), Zr.sort(((t, e) => di(t) - di(e)));
			try {
				for (Jr = 0; Jr < Zr.length; Jr++) {
					const t = Zr[Jr];
					t && !1 !== t.active && qr(t, null, 14)
				}
			} finally {
				Jr = 0, Zr.length = 0, fi(), Kr = !1, oi = null, (Zr.length || Qr.length || ei.length) && pi(t)
			}
		}
		const gi = {};

		function vi(t, e, n) {
			return mi(t, e, n)
		}

		function mi(t, e, {
			immediate: n,
			deep: r,
			flush: i,
			onTrack: o,
			onTrigger: a
		} = h) {
			const s = kr;
			let l, c, u = !1,
				f = !1;
			if (ge(t) ? (l = () => t.value, u = !!t._shallow) : se(t) ? (l = () => t, r = !0) : C(t) ? (f = !0, u = t.some(se), l = () => t.map((t => ge(t) ? t.value : se(t) ? yi(t) : T(t) ? qr(t, s, 2) : void 0))) : l = T(t) ? e ? () => qr(t, s, 2) : () => {
					if (!s || !s.isUnmounted) return c && c(), Xr(t, s, 3, [p])
				} : d, e && r) {
				const t = l;
				l = () => yi(t())
			}
			let p = t => {
					c = y.onStop = () => {
						qr(t, s, 4)
					}
				},
				g = f ? [] : gi;
			const v = () => {
				if (y.active)
					if (e) {
						const t = y.run();
						(r || u || (f ? t.some(((t, e) => U(t, g[e]))) : U(t, g))) && (c && c(), Xr(e, s, 3, [t, g === gi ? void 0 : g, p]), g = t)
					} else y.run()
			};
			let m;
			v.allowRecurse = !!e, m = "sync" === i ? v : "post" === i ? () => Pn(v, s && s.suspense) : () => {
				!s || s.isMounted ? function(t) {
					ui(t, $r, Qr, ti)
				}(v) : v()
			};
			const y = new st(l, m);
			return e ? n ? v() : g = y.run() : "post" === i ? Pn(y.run.bind(y), s && s.suspense) : y.run(), () => {
				y.stop(), s && s.scope && b(s.scope.effects, y)
			}
		}

		function yi(t, e = new Set) {
			if (!P(t) || t.__v_skip) return t;
			if ((e = e || new Set).has(t)) return t;
			if (e.add(t), ge(t)) yi(t.value, e);
			else if (C(t))
				for (let n = 0; n < t.length; n++) yi(t[n], e);
			else if (O(t) || S(t)) t.forEach((t => {
				yi(t, e)
			}));
			else if (D(t))
				for (const n in t) yi(t[n], e);
			return t
		}

		function bi() {
			return xi().slots
		}

		function xi() {
			const t = Fr();
			return t.setupContext || (t.setupContext = Rr(t))
		}
		Symbol("");
		const wi = "3.2.4",
			Ci = "undefined" != typeof document ? document : null,
			Si = new Map,
			Oi = {
				insert: (t, e, n) => {
					e.insertBefore(t, n || null)
				},
				remove: t => {
					const e = t.parentNode;
					e && e.removeChild(t)
				},
				createElement: (t, e, n, r) => {
					const i = e ? Ci.createElementNS("http://www.w3.org/2000/svg", t) : Ci.createElement(t, n ? {
						is: n
					} : void 0);
					return "select" === t && r && null != r.multiple && i.setAttribute("multiple", r.multiple), i
				},
				createText: t => Ci.createTextNode(t),
				createComment: t => Ci.createComment(t),
				setText: (t, e) => {
					t.nodeValue = e
				},
				setElementText: (t, e) => {
					t.textContent = e
				},
				parentNode: t => t.parentNode,
				nextSibling: t => t.nextSibling,
				querySelector: t => Ci.querySelector(t),
				setScopeId(t, e) {
					t.setAttribute(e, "")
				},
				cloneNode(t) {
					const e = t.cloneNode(!0);
					return "_value" in t && (e._value = t._value), e
				},
				insertStaticContent(t, e, n, r) {
					const i = n ? n.previousSibling : e.lastChild;
					let o = Si.get(t);
					if (!o) {
						const e = Ci.createElement("template");
						if (e.innerHTML = r ? `<svg>${t}</svg>` : t, o = e.content, r) {
							const t = o.firstChild;
							for (; t.firstChild;) o.appendChild(t.firstChild);
							o.removeChild(t)
						}
						Si.set(t, o)
					}
					return e.insertBefore(o.cloneNode(!0), n), [i ? i.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
				}
			},
			Ti = /\s*!important$/;

		function ki(t, e, n) {
			if (C(n)) n.forEach((n => ki(t, e, n)));
			else if (e.startsWith("--")) t.setProperty(e, n);
			else {
				const r = function(t, e) {
					const n = Pi[e];
					if (n) return n;
					let r = N(e);
					if ("filter" !== r && r in t) return Pi[e] = r;
					r = W(r);
					for (let n = 0; n < Fi.length; n++) {
						const i = Fi[n] + r;
						if (i in t) return Pi[e] = i
					}
					return e
				}(t, e);
				Ti.test(n) ? t.setProperty(z(r), n.replace(Ti, ""), "important") : t[r] = n
			}
		}
		const Fi = ["Webkit", "Moz", "ms"],
			Pi = {},
			ji = "http://www.w3.org/1999/xlink";
		let Ai = Date.now,
			_i = !1;
		if ("undefined" != typeof window) {
			Ai() > document.createEvent("Event").timeStamp && (Ai = () => performance.now());
			const t = navigator.userAgent.match(/firefox\/(\d+)/i);
			_i = !!(t && Number(t[1]) <= 53)
		}
		let Ei = 0;
		const Di = Promise.resolve(),
			Mi = () => {
				Ei = 0
			};

		function Ii(t, e, n, r) {
			t.addEventListener(e, n, r)
		}

		function Ri(t, e, n, r, i = null) {
			const o = t._vei || (t._vei = {}),
				a = o[e];
			if (r && a) a.value = r;
			else {
				const [n, s] = function(t) {
					let e;
					if (Bi.test(t)) {
						let n;
						for (e = {}; n = t.match(Bi);) t = t.slice(0, t.length - n[0].length), e[n[0].toLowerCase()] = !0
					}
					return [z(t.slice(2)), e]
				}(e);
				if (r) {
					const a = o[e] = function(t, e) {
						const n = t => {
							const r = t.timeStamp || Ai();
							(_i || r >= n.attached - 1) && Xr(function(t, e) {
								if (C(e)) {
									const n = t.stopImmediatePropagation;
									return t.stopImmediatePropagation = () => {
										n.call(t), t._stopped = !0
									}, e.map((t => e => !e._stopped && t(e)))
								}
								return e
							}(t, n.value), e, 5, [t])
						};
						return n.value = t, n.attached = Ei || (Di.then(Mi), Ei = Ai()), n
					}(r, i);
					Ii(t, n, a, s)
				} else a && (function(t, e, n, r) {
					t.removeEventListener(e, n, r)
				}(t, n, a, s), o[e] = void 0)
			}
		}
		const Bi = /(?:Once|Passive|Capture)$/,
			Ni = /^on[a-z]/;

		function Li(t) {
			const e = Fr();
			if (!e) return;
			const n = () => zi(e.subTree, t(e.proxy));
			mi(n, null, {
				flush: "post"
			}), on((() => {
				const t = new MutationObserver(n);
				t.observe(e.subTree.el.parentNode, {
					childList: !0
				}), ln((() => t.disconnect()))
			}))
		}

		function zi(t, e) {
			if (128 & t.shapeFlag) {
				const n = t.suspense;
				t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push((() => {
					zi(n.activeBranch, e)
				}))
			}
			for (; t.component;) t = t.component.subTree;
			if (1 & t.shapeFlag && t.el) Wi(t.el, e);
			else if (t.type === qn) t.children.forEach((t => zi(t, e)));
			else if (t.type === Kn) {
				let {
					el: n,
					anchor: r
				} = t;
				for (; n && (Wi(n, e), n !== r);) n = n.nextSibling
			}
		}

		function Wi(t, e) {
			if (1 === t.nodeType) {
				const n = t.style;
				for (const t in e) n.setProperty(`--${t}`, e[t])
			}
		}
		"undefined" != typeof HTMLElement && HTMLElement;
		const Vi = "transition",
			Ui = "animation",
			Hi = (t, {
				slots: e
			}) => function(t, e, n) {
				const r = arguments.length;
				return 2 === r ? P(e) && !C(e) ? rr(e) ? cr(t, null, [e]) : cr(t, e) : cr(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && rr(n) && (n = [n]), cr(t, e, n))
			}(Ue, function(t) {
				const e = {};
				for (const n in t) n in qi || (e[n] = t[n]);
				if (!1 === t.css) return e;
				const {
					name: n = "v",
					type: r,
					duration: i,
					enterFromClass: o = `${n}-enter-from`,
					enterActiveClass: a = `${n}-enter-active`,
					enterToClass: s = `${n}-enter-to`,
					appearFromClass: l = o,
					appearActiveClass: c = a,
					appearToClass: u = s,
					leaveFromClass: h = `${n}-leave-from`,
					leaveActiveClass: f = `${n}-leave-active`,
					leaveToClass: d = `${n}-leave-to`
				} = t, p = function(t) {
					if (null == t) return null;
					if (P(t)) return [Ki(t.enter), Ki(t.leave)];
					{
						const e = Ki(t);
						return [e, e]
					}
				}(i), g = p && p[0], v = p && p[1], {
					onBeforeEnter: m,
					onEnter: b,
					onEnterCancelled: x,
					onLeave: w,
					onLeaveCancelled: C,
					onBeforeAppear: S = m,
					onAppear: O = b,
					onAppearCancelled: T = x
				} = e, k = (t, e, n) => {
					Zi(t, e ? u : s), Zi(t, e ? c : a), n && n()
				}, F = (t, e) => {
					Zi(t, d), Zi(t, f), e && e()
				}, j = t => (e, n) => {
					const i = t ? O : b,
						a = () => k(e, t, n);
					Xi(i, [e, a]), Ji((() => {
						Zi(e, t ? l : o), Yi(e, t ? u : s), Gi(i) || $i(e, r, g, a)
					}))
				};
				return y(e, {
					onBeforeEnter(t) {
						Xi(m, [t]), Yi(t, o), Yi(t, a)
					},
					onBeforeAppear(t) {
						Xi(S, [t]), Yi(t, l), Yi(t, c)
					},
					onEnter: j(!1),
					onAppear: j(!0),
					onLeave(t, e) {
						const n = () => F(t, e);
						Yi(t, h), document.body.offsetHeight, Yi(t, f), Ji((() => {
							Zi(t, h), Yi(t, d), Gi(w) || $i(t, r, v, n)
						})), Xi(w, [t, n])
					},
					onEnterCancelled(t) {
						k(t, !1), Xi(x, [t])
					},
					onAppearCancelled(t) {
						k(t, !0), Xi(T, [t])
					},
					onLeaveCancelled(t) {
						F(t), Xi(C, [t])
					}
				})
			}(t), e);
		Hi.displayName = "Transition";
		const qi = {
				name: String,
				type: String,
				css: {
					type: Boolean,
					default: !0
				},
				duration: [String, Number, Object],
				enterFromClass: String,
				enterActiveClass: String,
				enterToClass: String,
				appearFromClass: String,
				appearActiveClass: String,
				appearToClass: String,
				leaveFromClass: String,
				leaveActiveClass: String,
				leaveToClass: String
			},
			Xi = (Hi.props = y({}, Ue.props, qi), (t, e = []) => {
				C(t) ? t.forEach((t => t(...e))) : t && t(...e)
			}),
			Gi = t => !!t && (C(t) ? t.some((t => t.length > 1)) : t.length > 1);

		function Ki(t) {
			return X(t)
		}

		function Yi(t, e) {
			e.split(/\s+/).forEach((e => e && t.classList.add(e))), (t._vtc || (t._vtc = new Set)).add(e)
		}

		function Zi(t, e) {
			e.split(/\s+/).forEach((e => e && t.classList.remove(e)));
			const {
				_vtc: n
			} = t;
			n && (n.delete(e), n.size || (t._vtc = void 0))
		}

		function Ji(t) {
			requestAnimationFrame((() => {
				requestAnimationFrame(t)
			}))
		}
		let Qi = 0;

		function $i(t, e, n, r) {
			const i = t._endId = ++Qi,
				o = () => {
					i === t._endId && r()
				};
			if (n) return setTimeout(o, n);
			const {
				type: a,
				timeout: s,
				propCount: l
			} = function(t, e) {
				const n = window.getComputedStyle(t),
					r = t => (n[t] || "").split(", "),
					i = r(Vi + "Delay"),
					o = r(Vi + "Duration"),
					a = to(i, o),
					s = r(Ui + "Delay"),
					l = r(Ui + "Duration"),
					c = to(s, l);
				let u = null,
					h = 0,
					f = 0;
				return e === Vi ? a > 0 && (u = Vi, h = a, f = o.length) : e === Ui ? c > 0 && (u = Ui, h = c, f = l.length) : (h = Math.max(a, c), u = h > 0 ? a > c ? Vi : Ui : null, f = u ? u === Vi ? o.length : l.length : 0), {
					type: u,
					timeout: h,
					propCount: f,
					hasTransform: u === Vi && /\b(transform|all)(,|$)/.test(n[Vi + "Property"])
				}
			}(t, e);
			if (!a) return r();
			const c = a + "end";
			let u = 0;
			const h = () => {
					t.removeEventListener(c, f), o()
				},
				f = e => {
					e.target === t && ++u >= l && h()
				};
			setTimeout((() => {
				u < l && h()
			}), s + 1), t.addEventListener(c, f)
		}

		function to(t, e) {
			for (; t.length < e.length;) t = t.concat(t);
			return Math.max(...e.map(((e, n) => eo(e) + eo(t[n]))))
		}

		function eo(t) {
			return 1e3 * Number(t.slice(0, -1).replace(",", "."))
		}
		new WeakMap, new WeakMap;
		const no = t => {
			const e = t.props["onUpdate:modelValue"];
			return C(e) ? t => H(e, t) : e
		};

		function ro(t) {
			t.target.composing = !0
		}

		function io(t) {
			const e = t.target;
			e.composing && (e.composing = !1, function(t, e) {
				const n = document.createEvent("HTMLEvents");
				n.initEvent("input", !0, !0), t.dispatchEvent(n)
			}(e))
		}
		const oo = {
				created(t, {
					modifiers: {
						lazy: e,
						trim: n,
						number: r
					}
				}, i) {
					t._assign = no(i);
					const o = r || i.props && "number" === i.props.type;
					Ii(t, e ? "change" : "input", (e => {
						if (e.target.composing) return;
						let r = t.value;
						n ? r = r.trim() : o && (r = X(r)), t._assign(r)
					})), n && Ii(t, "change", (() => {
						t.value = t.value.trim()
					})), e || (Ii(t, "compositionstart", ro), Ii(t, "compositionend", io), Ii(t, "change", io))
				},
				mounted(t, {
					value: e
				}) {
					t.value = null == e ? "" : e
				},
				beforeUpdate(t, {
					value: e,
					modifiers: {
						lazy: n,
						trim: r,
						number: i
					}
				}, o) {
					if (t._assign = no(o), t.composing) return;
					if (document.activeElement === t) {
						if (n) return;
						if (r && t.value.trim() === e) return;
						if ((i || "number" === t.type) && X(t.value) === e) return
					}
					const a = null == e ? "" : e;
					t.value !== a && (t.value = a)
				}
			},
			ao = ["ctrl", "shift", "alt", "meta"],
			so = {
				stop: t => t.stopPropagation(),
				prevent: t => t.preventDefault(),
				self: t => t.target !== t.currentTarget,
				ctrl: t => !t.ctrlKey,
				shift: t => !t.shiftKey,
				alt: t => !t.altKey,
				meta: t => !t.metaKey,
				left: t => "button" in t && 0 !== t.button,
				middle: t => "button" in t && 1 !== t.button,
				right: t => "button" in t && 2 !== t.button,
				exact: (t, e) => ao.some((n => t[`${n}Key`] && !e.includes(n)))
			},
			lo = (t, e) => (n, ...r) => {
				for (let t = 0; t < e.length; t++) {
					const r = so[e[t]];
					if (r && r(n, e)) return
				}
				return t(n, ...r)
			},
			co = {
				esc: "escape",
				space: " ",
				up: "arrow-up",
				left: "arrow-left",
				right: "arrow-right",
				down: "arrow-down",
				delete: "backspace"
			},
			uo = (t, e) => n => {
				if (!("key" in n)) return;
				const r = z(n.key);
				return e.some((t => t === r || co[t] === r)) ? t(n) : void 0
			},
			ho = {
				beforeMount(t, {
					value: e
				}, {
					transition: n
				}) {
					t._vod = "none" === t.style.display ? "" : t.style.display, n && e ? n.beforeEnter(t) : fo(t, e)
				},
				mounted(t, {
					value: e
				}, {
					transition: n
				}) {
					n && e && n.enter(t)
				},
				updated(t, {
					value: e,
					oldValue: n
				}, {
					transition: r
				}) {
					!e != !n && (r ? e ? (r.beforeEnter(t), fo(t, !0), r.enter(t)) : r.leave(t, (() => {
						fo(t, !1)
					})) : fo(t, e))
				},
				beforeUnmount(t, {
					value: e
				}) {
					fo(t, e)
				}
			};

		function fo(t, e) {
			t.style.display = e ? t._vod : "none"
		}
		const po = y({
			patchProp: (t, n, i, o, a = !1, s, l, c, u) => {
				"class" === n ? function(t, e, n) {
					const r = t._vtc;
					r && (e = (e ? [e, ...r] : [...r]).join(" ")), null == e ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
				}(t, o, a) : "style" === n ? function(t, e, n) {
					const r = t.style;
					if (n)
						if (k(n)) {
							if (e !== n) {
								const e = r.display;
								r.cssText = n, "_vod" in t && (r.display = e)
							}
						} else {
							for (const t in n) ki(r, t, n[t]);
							if (e && !k(e))
								for (const t in e) null == n[t] && ki(r, t, "")
						}
					else t.removeAttribute("style")
				}(t, i, o) : v(n) ? m(n) || Ri(t, n, 0, o, l) : ("." === n[0] ? (n = n.slice(1), 1) : "^" === n[0] ? (n = n.slice(1), 0) : function(t, e, n, r) {
					return r ? "innerHTML" === e || "textContent" === e || !!(e in t && Ni.test(e) && T(n)) : "spellcheck" !== e && "draggable" !== e && ("form" !== e && (("list" !== e || "INPUT" !== t.tagName) && (("type" !== e || "TEXTAREA" !== t.tagName) && ((!Ni.test(e) || !k(n)) && e in t))))
				}(t, n, o, a)) ? function(t, e, n, i, o, a, s) {
					if ("innerHTML" === e || "textContent" === e) return i && s(i, o, a), void(t[e] = null == n ? "" : n);
					if ("value" === e && "PROGRESS" !== t.tagName) {
						t._value = n;
						const r = null == n ? "" : n;
						return t.value !== r && (t.value = r), void(null == n && t.removeAttribute(e))
					}
					if ("" === n || null == n) {
						const i = typeof t[e];
						if ("boolean" === i) return void(t[e] = r(n));
						if (null == n && "string" === i) return t[e] = "", void t.removeAttribute(e);
						if ("number" === i) {
							try {
								t[e] = 0
							} catch (t) {}
							return void t.removeAttribute(e)
						}
					}
					try {
						t[e] = n
					} catch (t) {}
				}(t, n, o, s, l, c, u) : ("true-value" === n ? t._trueValue = o : "false-value" === n && (t._falseValue = o), function(t, n, i, o, a) {
					if (o && n.startsWith("xlink:")) null == i ? t.removeAttributeNS(ji, n.slice(6, n.length)) : t.setAttributeNS(ji, n, i);
					else {
						const o = e(n);
						null == i || o && !r(i) ? t.removeAttribute(n) : t.setAttribute(n, o ? "" : i)
					}
				}(t, n, o, a))
			}
		}, Oi);
		let go;

		function vo() {
			return go || (go = jn(po))
		}
		const mo = (...t) => {
			vo().render(...t)
		};

		function yo(t, e, n, r, i, o, a) {
			try {
				var s = t[o](a),
					l = s.value
			} catch (t) {
				return void n(t)
			}
			s.done ? e(l) : Promise.resolve(l).then(r, i)
		}

		function bo(t) {
			return function() {
				var e = this,
					n = arguments;
				return new Promise((function(r, i) {
					var o = t.apply(e, n);

					function a(t) {
						yo(o, r, i, a, s, "next", t)
					}

					function s(t) {
						yo(o, r, i, a, s, "throw", t)
					}
					a(void 0)
				}))
			}
		}

		function xo(t) {
			return xo = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
				return typeof t
			} : function(t) {
				return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
			}, xo(t)
		}

		function wo(t) {
			var e = function(t, e) {
				if ("object" != xo(t) || !t) return t;
				var n = t[Symbol.toPrimitive];
				if (void 0 !== n) {
					var r = n.call(t, "string");
					if ("object" != xo(r)) return r;
					throw new TypeError("@@toPrimitive must return a primitive value.")
				}
				return String(t)
			}(t);
			return "symbol" == xo(e) ? e : String(e)
		}

		function Co(t, e, n) {
			return (e = wo(e)) in t ? Object.defineProperty(t, e, {
				value: n,
				enumerable: !0,
				configurable: !0,
				writable: !0
			}) : t[e] = n, t
		}
		var So = n(117),
			Oo = n.n(So);
		var To = n(513),
			ko = n.n(To);

		function Fo(t, e) {
			var n = t.getContext("2d");
			switch (e.type) {
				case "all":
					return function(t, e, n) {
						return new Promise((function(r, i) {
							t.height = n.pageHeight * devicePixelRatio, t.width = n.pageWidth * devicePixelRatio, t.style = "height:".concat(n.pageHeight, "px; width:").concat(n.pageWidth, "px;"), n.screen.forEach((function(i, o) {
								! function(t, e) {
									var n = new Image;
									n.onload = function() {
										t.drawImage(n, 0, e.data.top * devicePixelRatio, n.width, n.height)
									}, n.src = e.base64
								}(e, i), o >= n.screen.length - 1 && r({
									height: t.height,
									width: t.width
								})
							}))
						}))
					}(t, n, e);
				case "visible":
				case "upload":
					return function(t, e, n) {
						return new Promise((function(r, i) {
							var o = new Image;
							o.onload = function() {
								t.height = o.height, t.width = o.width, t.style = "height:".concat(o.height / devicePixelRatio, "px; width:").concat(o.width / devicePixelRatio, "px;"), e.drawImage(o, 0, 0, o.width, o.height), r({
									height: t.height,
									width: t.width
								})
							}, o.src = n.screen[0].base64
						}))
					}(t, n, e);
				case "area":
					return function(t, e, n) {
						return new Promise((function(r, i) {
							t.height = n.pageHeight * devicePixelRatio, t.width = n.pageWidth * devicePixelRatio, t.style = "height:".concat(n.pageHeight, "px; width:").concat(n.pageWidth, "px;"), n.screen.forEach((function(n, i) {
								var o = new Image;
								o.onload = function() {
									e.drawImage(o, n.data.offsetLeft * devicePixelRatio, n.data.offsetTop * devicePixelRatio, n.data.width * devicePixelRatio, n.data.height * devicePixelRatio, 0, n.data.top * devicePixelRatio, n.data.width * devicePixelRatio, n.data.height * devicePixelRatio), r({
										height: t.height,
										width: t.width
									})
								}, o.src = n.base64
							}))
						}))
					}(t, n, e)
			}
		}

		function Po(t, e) {
			(null == e || e > t.length) && (e = t.length);
			for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
			return r
		}

		function jo(t, e) {
			if (t) {
				if ("string" == typeof t) return Po(t, e);
				var n = Object.prototype.toString.call(t).slice(8, -1);
				return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Po(t, e) : void 0
			}
		}
		var Ao = n(438),
			_o = n(96),
			Eo = function(t, e) {
				return Eo = Object.setPrototypeOf || {
					__proto__: []
				}
				instanceof Array && function(t, e) {
					t.__proto__ = e
				} || function(t, e) {
					for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
				}, Eo(t, e)
			};

		function Do(t, e) {
			function n() {
				this.constructor = t
			}
			Eo(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
		}
		var Mo = function() {
			return Mo = Object.assign || function(t) {
				for (var e, n = 1, r = arguments.length; n < r; n++)
					for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				return t
			}, Mo.apply(this, arguments)
		};

		function Io(t, e, n, r) {
			return new(n || (n = Promise))((function(i, o) {
				function a(t) {
					try {
						l(r.next(t))
					} catch (t) {
						o(t)
					}
				}

				function s(t) {
					try {
						l(r.throw(t))
					} catch (t) {
						o(t)
					}
				}

				function l(t) {
					var e;
					t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n((function(t) {
						t(e)
					}))).then(a, s)
				}
				l((r = r.apply(t, e || [])).next())
			}))
		}

		function Ro(t, e) {
			var n, r, i, o, a = {
				label: 0,
				sent: function() {
					if (1 & i[0]) throw i[1];
					return i[1]
				},
				trys: [],
				ops: []
			};
			return o = {
				next: s(0),
				throw: s(1),
				return: s(2)
			}, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
				return this
			}), o;

			function s(o) {
				return function(s) {
					return function(o) {
						if (n) throw new TypeError("Generator is already executing.");
						for (; a;) try {
							if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
							switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
								case 0:
								case 1:
									i = o;
									break;
								case 4:
									return a.label++, {
										value: o[1],
										done: !1
									};
								case 5:
									a.label++, r = o[1], o = [0];
									continue;
								case 7:
									o = a.ops.pop(), a.trys.pop();
									continue;
								default:
									if (!((i = (i = a.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
										a = 0;
										continue
									}
									if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
										a.label = o[1];
										break
									}
									if (6 === o[0] && a.label < i[1]) {
										a.label = i[1], i = o;
										break
									}
									if (i && a.label < i[2]) {
										a.label = i[2], a.ops.push(o);
										break
									}
									i[2] && a.ops.pop(), a.trys.pop();
									continue
							}
							o = e.call(t, a)
						} catch (t) {
							o = [6, t], r = 0
						} finally {
							n = i = 0
						}
						if (5 & o[0]) throw o[1];
						return {
							value: o[0] ? o[1] : void 0,
							done: !0
						}
					}([o, s])
				}
			}
		}

		function Bo() {
			for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
			var r = Array(t),
				i = 0;
			for (e = 0; e < n; e++)
				for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];
			return r
		}
		for (var No = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Lo = new Uint8Array(256), zo = 0; zo < 64; zo++) Lo[No.charCodeAt(zo)] = zo;
		var Wo, Vo = function(t) {
				var e, n, r, i, o, a = .75 * t.length,
					s = t.length,
					l = 0;
				"=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
				var c = new Uint8Array(a);
				for (e = 0; e < s; e += 4) n = Lo[t.charCodeAt(e)], r = Lo[t.charCodeAt(e + 1)], i = Lo[t.charCodeAt(e + 2)], o = Lo[t.charCodeAt(e + 3)], c[l++] = n << 2 | r >> 4, c[l++] = (15 & r) << 4 | i >> 2, c[l++] = (3 & i) << 6 | 63 & o;
				return c
			},
			Uo = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i,
			Ho = function(t) {
				return t.charCodeAt(0)
			},
			qo = function(t, e) {
				return Ko(t.toString(16), e, "0").toUpperCase()
			},
			Xo = function(t) {
				return qo(t, 2)
			},
			Go = function(t) {
				return String.fromCharCode(t)
			},
			Ko = function(t, e, n) {
				for (var r = "", i = 0, o = e - t.length; i < o; i++) r += n;
				return r + t
			},
			Yo = function(t, e, n) {
				for (var r = t.length, i = 0; i < r; i++) e[n++] = t.charCodeAt(i);
				return r
			},
			Zo = function(t) {
				return t.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "")
			},
			Jo = ["\\n", "\\f", "\\r", "\\u000B"],
			Qo = function(t) {
				return /^[\n\f\r\u000B]$/.test(t)
			},
			$o = function(t) {
				return t.split(/[\n\f\r\u000B]/)
			},
			ta = function(t) {
				return t.replace(/[\n\f\r\u000B]/g, " ")
			},
			ea = function(t, e) {
				var n, r = t.charCodeAt(e),
					i = e + 1,
					o = 1;
				return r >= 55296 && r <= 56319 && t.length > i && (n = t.charCodeAt(i)) >= 56320 && n <= 57343 && (o = 2), [t.slice(e, e + o), o]
			},
			na = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/,
			ra = function(t) {
				var e = t.match(na);
				if (e) {
					var n = e[1],
						r = e[2],
						i = void 0 === r ? "01" : r,
						o = e[3],
						a = void 0 === o ? "01" : o,
						s = e[4],
						l = void 0 === s ? "00" : s,
						c = e[5],
						u = void 0 === c ? "00" : c,
						h = e[6],
						f = void 0 === h ? "00" : h,
						d = e[7],
						p = void 0 === d ? "Z" : d,
						g = e[8],
						v = void 0 === g ? "00" : g,
						m = e[9];
					return new Date(n + "-" + i + "-" + a + "T" + l + ":" + u + ":" + f + ("Z" === p ? "Z" : "" + p + v + ":" + (void 0 === m ? "00" : m)))
				}
			},
			ia = function(t, e) {
				for (var n, r, i = 0; i < t.length;) {
					var o = t.substring(i).match(e);
					if (!o) return {
						match: r,
						pos: i
					};
					r = o, i += (null !== (n = o.index) && void 0 !== n ? n : 0) + o[0].length
				}
				return {
					match: r,
					pos: i
				}
			},
			oa = function(t) {
				return t[t.length - 1]
			},
			aa = function(t) {
				if (t instanceof Uint8Array) return t;
				for (var e = t.length, n = new Uint8Array(e), r = 0; r < e; r++) n[r] = t.charCodeAt(r);
				return n
			},
			sa = function() {
				for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
				for (var n = t.length, r = [], i = 0; i < n; i++) {
					var o = t[i];
					r[i] = o instanceof Uint8Array ? o : aa(o)
				}
				var a = 0;
				for (i = 0; i < n; i++) a += t[i].length;
				for (var s = new Uint8Array(a), l = 0, c = 0; c < n; c++)
					for (var u = r[c], h = 0, f = u.length; h < f; h++) s[l++] = u[h];
				return s
			},
			la = function(t) {
				for (var e = "", n = 0, r = t.length; n < r; n++) e += Go(t[n]);
				return e
			},
			ca = function(t, e) {
				return t.id - e.id
			},
			ua = function(t) {
				for (var e = t.length, n = 0, r = Math.floor(e / 2); n < r; n++) {
					var i = n,
						o = e - n - 1,
						a = t[n];
					t[i] = t[o], t[o] = a
				}
				return t
			},
			ha = function(t) {
				if ("string" == typeof t) return function(t) {
					var e = t.trim(),
						n = e.substring(0, 100).match(Uo);
					if (!n) return Vo(e);
					var r = n[0],
						i = e.substring(r.length);
					return Vo(i)
				}(t);
				if (t instanceof ArrayBuffer) return new Uint8Array(t);
				if (t instanceof Uint8Array) return t;
				throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`")
			},
			fa = function() {
				return new Promise((function(t) {
					setTimeout((function() {
						return t()
					}), 0)
				}))
			},
			da = function(t) {
				return Math.floor((t - 65536) / 1024) + 55296
			},
			pa = function(t) {
				return (t - 65536) % 1024 + 56320
			};
		! function(t) {
			t.BigEndian = "BigEndian", t.LittleEndian = "LittleEndian"
		}(Wo || (Wo = {}));
		for (var ga = "".codePointAt(0), va = function(t, e) {
				if (void 0 === e && (e = !0), t.length <= 1) return String.fromCodePoint(ga);
				for (var n = e ? xa(t) : Wo.BigEndian, r = e ? 2 : 0, i = []; t.length - r >= 2;) {
					var o = ba(t[r++], t[r++], n);
					if (ma(o))
						if (t.length - r < 2) i.push(ga);
						else {
							var a = ba(t[r++], t[r++], n);
							ya(a) ? i.push(o, a) : i.push(ga)
						}
					else ya(o) ? (r += 2, i.push(ga)) : i.push(o)
				}
				return r < t.length && i.push(ga), String.fromCodePoint.apply(String, i)
			}, ma = function(t) {
				return t >= 55296 && t <= 56319
			}, ya = function(t) {
				return t >= 56320 && t <= 57343
			}, ba = function(t, e, n) {
				if (n === Wo.LittleEndian) return e << 8 | t;
				if (n === Wo.BigEndian) return t << 8 | e;
				throw new Error("Invalid byteOrder: " + n)
			}, xa = function(t) {
				return wa(t) ? Wo.BigEndian : Ca(t) ? Wo.LittleEndian : Wo.BigEndian
			}, wa = function(t) {
				return 254 === t[0] && 255 === t[1]
			}, Ca = function(t) {
				return 255 === t[0] && 254 === t[1]
			}, Sa = function(t) {
				return wa(t) || Ca(t)
			}, Oa = function(t) {
				return Math.ceil(t.toString(2).length / 8)
			}, Ta = function(t) {
				for (var e = new Uint8Array(Oa(t)), n = 1; n <= e.length; n++) e[n - 1] = t >> 8 * (e.length - n);
				return e
			}, ka = function(t) {
				throw new Error(t)
			}, Fa = n(442), Pa = n.n(Fa), ja = new Uint8Array(256), Aa = 0; Aa < 64; Aa++) ja["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(Aa)] = Aa;
		var _a, Ea = function(t) {
				return function(t) {
					for (var e = "", n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
					return e
				}(Pa().inflate(function(t) {
					var e, n, r, i, o, a = .75 * t.length,
						s = t.length,
						l = 0;
					"=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
					var c = new Uint8Array(a);
					for (e = 0; e < s; e += 4) n = ja[t.charCodeAt(e)], r = ja[t.charCodeAt(e + 1)], i = ja[t.charCodeAt(e + 2)], o = ja[t.charCodeAt(e + 3)], c[l++] = n << 2 | r >> 4, c[l++] = (15 & r) << 4 | i >> 2, c[l++] = (3 & i) << 6 | 63 & o;
					return c
				}(t)))
			},
			Da = {
				Courier: "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",
				"Courier-Bold": "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",
				"Courier-Oblique": "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",
				"Courier-BoldOblique": "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",
				Helvetica: "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",
				"Helvetica-Bold": "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",
				"Helvetica-Oblique": "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",
				"Helvetica-BoldOblique": "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",
				"Times-Roman": "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",
				"Times-Bold": "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",
				"Times-Italic": "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",
				"Times-BoldItalic": "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",
				Symbol: "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",
				ZapfDingbats: "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w=="
			};
		! function(t) {
			t.Courier = "Courier", t.CourierBold = "Courier-Bold", t.CourierOblique = "Courier-Oblique", t.CourierBoldOblique = "Courier-BoldOblique", t.Helvetica = "Helvetica", t.HelveticaBold = "Helvetica-Bold", t.HelveticaOblique = "Helvetica-Oblique", t.HelveticaBoldOblique = "Helvetica-BoldOblique", t.TimesRoman = "Times-Roman", t.TimesRomanBold = "Times-Bold", t.TimesRomanItalic = "Times-Italic", t.TimesRomanBoldItalic = "Times-BoldItalic", t.Symbol = "Symbol", t.ZapfDingbats = "ZapfDingbats"
		}(_a || (_a = {}));
		for (var Ma = {}, Ia = function() {
				function t() {
					var t = this;
					this.getWidthOfGlyph = function(e) {
						return t.CharWidths[e]
					}, this.getXAxisKerningForPair = function(e, n) {
						return (t.KernPairXAmounts[e] || {})[n]
					}
				}
				return t.load = function(e) {
					var n = Ma[e];
					if (n) return n;
					var r = Ea(Da[e]),
						i = Object.assign(new t, JSON.parse(r));
					return i.CharWidths = i.CharMetrics.reduce((function(t, e) {
						return t[e.N] = e.WX, t
					}), {}), i.KernPairXAmounts = i.KernPairs.reduce((function(t, e) {
						var n = e[0],
							r = e[1],
							i = e[2];
						return t[n] || (t[n] = {}), t[n][r] = i, t
					}), {}), Ma[e] = i, i
				}, t
			}(), Ra = Ea("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"), Ba = JSON.parse(Ra), Na = function(t, e) {
				var n = this;
				this.canEncodeUnicodeCodePoint = function(t) {
					return t in n.unicodeMappings
				}, this.encodeUnicodeCodePoint = function(t) {
					var e = n.unicodeMappings[t];
					if (!e) {
						var r = String.fromCharCode(t),
							i = "0x" + function(t, e, n) {
								for (var r = "", i = 0, o = 4 - t.length; i < o; i++) r += "0";
								return r + t
							}(t.toString(16)),
							o = n.name + ' cannot encode "' + r + '" (' + i + ")";
						throw new Error(o)
					}
					return {
						code: e[0],
						name: e[1]
					}
				}, this.name = t, this.supportedCodePoints = Object.keys(e).map(Number).sort((function(t, e) {
					return t - e
				})), this.unicodeMappings = e
			}, La = {
				Symbol: new Na("Symbol", Ba.symbol),
				ZapfDingbats: new Na("ZapfDingbats", Ba.zapfdingbats),
				WinAnsi: new Na("WinAnsi", Ba.win1252)
			}, za = function(t) {
				return Object.keys(t).map((function(e) {
					return t[e]
				}))
			}, Wa = za(_a), Va = function(t) {
				return Wa.includes(t)
			}, Ua = function(t, e) {
				return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
			}, Ha = function(t) {
				return "`" + t + "`"
			}, qa = function(t) {
				var e = typeof t;
				return "string" === e ? "'" + t + "'" : "undefined" === e ? Ha(t) : t
			}, Xa = function(t, e, n) {
				Array.isArray(n) || (n = za(n));
				for (var r = 0, i = n.length; r < i; r++)
					if (t === n[r]) return;
				throw new TypeError(function(t, e, n) {
					for (var r = new Array(n.length), i = 0, o = n.length; i < o; i++) {
						var a = n[i];
						r[i] = qa(a)
					}
					var s = r.join(" or ");
					return Ha(e) + " must be one of " + s + ", but was actually " + qa(t)
				}(t, e, n))
			}, Ga = function(t, e, n) {
				Array.isArray(n) || (n = za(n)), Xa(t, e, n.concat(void 0))
			}, Ka = function(t, e) {
				return "null" === e ? null === t : "undefined" === e ? void 0 === t : "string" === e ? "string" == typeof t : "number" === e ? "number" == typeof t && !isNaN(t) : "boolean" === e ? "boolean" == typeof t : "symbol" === e ? "symbol" == typeof t : "bigint" === e ? "bigint" == typeof t : e === Date ? t instanceof Date : e === Array ? t instanceof Array : e === Uint8Array ? t instanceof Uint8Array : e === ArrayBuffer ? t instanceof ArrayBuffer : e === Function ? t instanceof Function : t instanceof e[0]
			}, Ya = function(t, e, n) {
				for (var r = 0, i = n.length; r < i; r++)
					if (Ka(t, n[r])) return;
				throw new TypeError(function(t, e, n) {
					for (var r = new Array(n.length), i = 0, o = n.length; i < o; i++) {
						var a = n[i];
						"null" === a && (r[i] = Ha("null")), "undefined" === a && (r[i] = Ha("undefined")), "string" === a ? r[i] = Ha("string") : "number" === a ? r[i] = Ha("number") : "boolean" === a ? r[i] = Ha("boolean") : "symbol" === a ? r[i] = Ha("symbol") : "bigint" === a ? r[i] = Ha("bigint") : a === Array ? r[i] = Ha("Array") : a === Uint8Array ? r[i] = Ha("Uint8Array") : a === ArrayBuffer ? r[i] = Ha("ArrayBuffer") : r[i] = Ha(a[1])
					}
					var s, l = r.join(" or ");
					return Ha(e) + " must be of type " + l + ", but was actually of type " + Ha(null === (s = t) ? "null" : void 0 === s ? "undefined" : "string" == typeof s ? "string" : isNaN(s) ? "NaN" : "number" == typeof s ? "number" : "boolean" == typeof s ? "boolean" : "symbol" == typeof s ? "symbol" : "bigint" == typeof s ? "bigint" : s.constructor && s.constructor.name ? s.constructor.name : s.name ? s.name : s.constructor ? String(s.constructor) : String(s))
				}(t, e, n))
			}, Za = function(t, e, n) {
				Ya(t, e, n.concat("undefined"))
			}, Ja = function(t, e, n) {
				for (var r = 0, i = t.length; r < i; r++) Ya(t[r], e, n)
			}, Qa = function(t, e, n, r) {
				if (Ya(t, e, ["number"]), Ya(n, "min", ["number"]), Ya(r, "max", ["number"]), r = Math.max(n, r), t < n || t > r) throw new Error(Ha(e) + " must be at least " + n + " and at most " + r + ", but was actually " + t)
			}, $a = function(t, e, n, r) {
				Ya(t, e, ["number", "undefined"]), "number" == typeof t && Qa(t, e, n, r)
			}, ts = function(t, e, n) {
				if (Ya(t, e, ["number"]), t % n != 0) throw new Error(Ha(e) + " must be a multiple of " + n + ", but was actually " + t)
			}, es = function(t, e) {
				if (![1, 0].includes(Math.sign(t))) throw new Error(Ha(e) + " must be a positive number or 0, but was actually " + t)
			}, ns = new Uint16Array(256), rs = 0; rs < 256; rs++) ns[rs] = rs;
		ns[22] = Ho(""), ns[24] = Ho(""), ns[25] = Ho(""), ns[26] = Ho(""), ns[27] = Ho(""), ns[28] = Ho(""), ns[29] = Ho(""), ns[30] = Ho(""), ns[31] = Ho(""), ns[127] = Ho(""), ns[128] = Ho(""), ns[129] = Ho(""), ns[130] = Ho(""), ns[131] = Ho(""), ns[132] = Ho(""), ns[133] = Ho(""), ns[134] = Ho(""), ns[135] = Ho(""), ns[136] = Ho(""), ns[137] = Ho(""), ns[138] = Ho(""), ns[139] = Ho(""), ns[140] = Ho(""), ns[141] = Ho(""), ns[142] = Ho(""), ns[143] = Ho(""), ns[144] = Ho(""), ns[145] = Ho(""), ns[146] = Ho(""), ns[147] = Ho(""), ns[148] = Ho(""), ns[149] = Ho(""), ns[150] = Ho(""), ns[151] = Ho(""), ns[152] = Ho(""), ns[153] = Ho(""), ns[154] = Ho(""), ns[155] = Ho(""), ns[156] = Ho(""), ns[157] = Ho(""), ns[158] = Ho(""), ns[159] = Ho(""), ns[160] = Ho(""), ns[173] = Ho("");
		var is = function(t) {
			for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = ns[t[n]];
			return String.fromCodePoint.apply(String, e)
		};
		const os = function() {
			function t(t) {
				this.populate = t, this.value = void 0
			}
			return t.prototype.getValue = function() {
				return this.value
			}, t.prototype.access = function() {
				return this.value || (this.value = this.populate()), this.value
			}, t.prototype.invalidate = function() {
				this.value = void 0
			}, t.populatedBy = function(e) {
				return new t(e)
			}, t
		}();
		var as, ss, ls = function(t) {
				function e(e, n) {
					var r = "Method " + e + "." + n + "() not implemented";
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			cs = function(t) {
				function e(e) {
					var n = "Cannot construct " + e + " - it has a private constructor";
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			us = function(t) {
				function e(e, n) {
					var r = function(t) {
							var e, n;
							return null !== (e = null == t ? void 0 : t.name) && void 0 !== e ? e : null === (n = null == t ? void 0 : t.constructor) || void 0 === n ? void 0 : n.name
						},
						i = "Expected instance of " + (Array.isArray(e) ? e.map(r) : [r(e)]).join(" or ") + ", but got instance of " + (n ? r(n) : n);
					return t.call(this, i) || this
				}
				return Do(e, t), e
			}(Error),
			hs = function(t) {
				function e(e) {
					var n = e + " stream encoding not supported";
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			fs = function(t) {
				function e(e, n) {
					var r = "Cannot call " + e + "." + n + "() more than once";
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			ds = (Do((function(t) {
				var e = "Missing catalog (ref=" + t + ")";
				return ss.call(this, e) || this
			}), ss = Error), function(t) {
				function e() {
					return t.call(this, "Can't embed page with missing Contents") || this
				}
				return Do(e, t), e
			}(Error)),
			ps = function(t) {
				function e(e) {
					var n, r, i, o = "Unrecognized stream type: " + (null !== (i = null !== (r = null === (n = null == e ? void 0 : e.contructor) || void 0 === n ? void 0 : n.name) && void 0 !== r ? r : null == e ? void 0 : e.name) && void 0 !== i ? i : e);
					return t.call(this, o) || this
				}
				return Do(e, t), e
			}(Error),
			gs = function(t) {
				function e() {
					return t.call(this, "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.") || this
				}
				return Do(e, t), e
			}(Error),
			vs = function(t) {
				function e(e) {
					var n = "Attempted to convert PDFArray with " + e + " elements to rectangle, but must have exactly 4 elements.";
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			ms = function(t) {
				function e(e) {
					var n = 'Attempted to convert "' + e + '" to a date, but it does not match the PDF date string format.';
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			ys = function(t) {
				function e(e, n) {
					var r = "Invalid targetIndex specified: targetIndex=" + e + " must be less than Count=" + n;
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			bs = function(t) {
				function e(e, n) {
					var r = "Failed to " + n + " at targetIndex=" + e + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			xs = function(t) {
				function e(e, n, r) {
					var i = "index should be at least " + n + " and at most " + r + ", but was actually " + e;
					return t.call(this, i) || this
				}
				return Do(e, t), e
			}(Error),
			ws = function(t) {
				function e() {
					return t.call(this, "Attempted to set invalid field value") || this
				}
				return Do(e, t), e
			}(Error),
			Cs = function(t) {
				function e() {
					return t.call(this, "Attempted to select multiple values for single-select field") || this
				}
				return Do(e, t), e
			}(Error),
			Ss = function(t) {
				function e(e) {
					var n = "No /DA (default appearance) entry found for field: " + e;
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			Os = function(t) {
				function e(e) {
					var n = "No Tf operator found for DA of field: " + e;
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			Ts = function(t) {
				function e(e, n) {
					var r = "Failed to parse number (line:" + e.line + " col:" + e.column + " offset=" + e.offset + '): "' + n + '"';
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			ks = function(t) {
				function e(e, n) {
					var r = "Failed to parse PDF document (line:" + e.line + " col:" + e.column + " offset=" + e.offset + "): " + n;
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			Fs = function(t) {
				function e(e, n, r) {
					var i = "Expected next byte to be " + n + " but it was actually " + r;
					return t.call(this, e, i) || this
				}
				return Do(e, t), e
			}(ks),
			Ps = function(t) {
				function e(e, n) {
					var r = "Failed to parse PDF object starting with the following byte: " + n;
					return t.call(this, e, r) || this
				}
				return Do(e, t), e
			}(ks),
			js = function(t) {
				function e(e) {
					return t.call(this, e, "Failed to parse invalid PDF object") || this
				}
				return Do(e, t), e
			}(ks),
			As = function(t) {
				function e(e) {
					return t.call(this, e, "Failed to parse PDF stream") || this
				}
				return Do(e, t), e
			}(ks),
			_s = function(t) {
				function e(e) {
					return t.call(this, e, "Failed to parse PDF literal string due to unbalanced parenthesis") || this
				}
				return Do(e, t), e
			}(ks),
			Es = function(t) {
				function e(e) {
					return t.call(this, e, "Parser stalled") || this
				}
				return Do(e, t), e
			}(ks),
			Ds = function(t) {
				function e(e) {
					return t.call(this, e, "No PDF header found") || this
				}
				return Do(e, t), e
			}(ks),
			Ms = function(t) {
				function e(e, n) {
					var r = "Did not find expected keyword '" + la(n) + "'";
					return t.call(this, e, r) || this
				}
				return Do(e, t), e
			}(ks);
		! function(t) {
			t[t.Null = 0] = "Null", t[t.Backspace = 8] = "Backspace", t[t.Tab = 9] = "Tab", t[t.Newline = 10] = "Newline", t[t.FormFeed = 12] = "FormFeed", t[t.CarriageReturn = 13] = "CarriageReturn", t[t.Space = 32] = "Space", t[t.ExclamationPoint = 33] = "ExclamationPoint", t[t.Hash = 35] = "Hash", t[t.Percent = 37] = "Percent", t[t.LeftParen = 40] = "LeftParen", t[t.RightParen = 41] = "RightParen", t[t.Plus = 43] = "Plus", t[t.Minus = 45] = "Minus", t[t.Dash = 45] = "Dash", t[t.Period = 46] = "Period", t[t.ForwardSlash = 47] = "ForwardSlash", t[t.Zero = 48] = "Zero", t[t.One = 49] = "One", t[t.Two = 50] = "Two", t[t.Three = 51] = "Three", t[t.Four = 52] = "Four", t[t.Five = 53] = "Five", t[t.Six = 54] = "Six", t[t.Seven = 55] = "Seven", t[t.Eight = 56] = "Eight", t[t.Nine = 57] = "Nine", t[t.LessThan = 60] = "LessThan", t[t.GreaterThan = 62] = "GreaterThan", t[t.A = 65] = "A", t[t.D = 68] = "D", t[t.E = 69] = "E", t[t.F = 70] = "F", t[t.O = 79] = "O", t[t.P = 80] = "P", t[t.R = 82] = "R", t[t.LeftSquareBracket = 91] = "LeftSquareBracket", t[t.BackSlash = 92] = "BackSlash", t[t.RightSquareBracket = 93] = "RightSquareBracket", t[t.a = 97] = "a", t[t.b = 98] = "b", t[t.d = 100] = "d", t[t.e = 101] = "e", t[t.f = 102] = "f", t[t.i = 105] = "i", t[t.j = 106] = "j", t[t.l = 108] = "l", t[t.m = 109] = "m", t[t.n = 110] = "n", t[t.o = 111] = "o", t[t.r = 114] = "r", t[t.s = 115] = "s", t[t.t = 116] = "t", t[t.u = 117] = "u", t[t.x = 120] = "x", t[t.LeftCurly = 123] = "LeftCurly", t[t.RightCurly = 125] = "RightCurly", t[t.Tilde = 126] = "Tilde"
		}(as || (as = {}));
		const Is = as,
			Rs = function() {
				function t(t, e) {
					this.major = String(t), this.minor = String(e)
				}
				return t.prototype.toString = function() {
					var t = Go(129);
					return "%PDF-" + this.major + "." + this.minor + "\n%" + t + t + t + t
				}, t.prototype.sizeInBytes = function() {
					return 12 + this.major.length + this.minor.length
				}, t.prototype.copyBytesInto = function(t, e) {
					var n = e;
					return t[e++] = Is.Percent, t[e++] = Is.P, t[e++] = Is.D, t[e++] = Is.F, t[e++] = Is.Dash, e += Yo(this.major, t, e), t[e++] = Is.Period, e += Yo(this.minor, t, e), t[e++] = Is.Newline, t[e++] = Is.Percent, t[e++] = 129, t[e++] = 129, t[e++] = 129, t[e++] = 129, e - n
				}, t.forVersion = function(e, n) {
					return new t(e, n)
				}, t
			}(),
			Bs = function() {
				function t() {}
				return t.prototype.clone = function(t) {
					throw new ls(this.constructor.name, "clone")
				}, t.prototype.toString = function() {
					throw new ls(this.constructor.name, "toString")
				}, t.prototype.sizeInBytes = function() {
					throw new ls(this.constructor.name, "sizeInBytes")
				}, t.prototype.copyBytesInto = function(t, e) {
					throw new ls(this.constructor.name, "copyBytesInto")
				}, t
			}(),
			Ns = function(t) {
				function e(e) {
					var n = t.call(this) || this;
					return n.numberValue = e, n.stringValue = function(t) {
						var e, n = String(t);
						if (Math.abs(t) < 1) {
							if (e = parseInt(t.toString().split("e-")[1])) {
								var r = t < 0;
								r && (t *= -1), t *= Math.pow(10, e - 1), n = "0." + new Array(e).join("0") + t.toString().substring(2), r && (n = "-" + n)
							}
						} else(e = parseInt(t.toString().split("+")[1])) > 20 && (e -= 20, n = (t /= Math.pow(10, e)).toString() + new Array(e + 1).join("0"));
						return n
					}(e), n
				}
				return Do(e, t), e.prototype.asNumber = function() {
					return this.numberValue
				}, e.prototype.value = function() {
					return this.numberValue
				}, e.prototype.clone = function() {
					return e.of(this.numberValue)
				}, e.prototype.toString = function() {
					return this.stringValue
				}, e.prototype.sizeInBytes = function() {
					return this.stringValue.length
				}, e.prototype.copyBytesInto = function(t, e) {
					return e += Yo(this.stringValue, t, e), this.stringValue.length
				}, e.of = function(t) {
					return new e(t)
				}, e
			}(Bs);
		var Ls = function(t) {
			function e(e) {
				var n = t.call(this) || this;
				return n.array = [], n.context = e, n
			}
			return Do(e, t), e.prototype.size = function() {
				return this.array.length
			}, e.prototype.push = function(t) {
				this.array.push(t)
			}, e.prototype.insert = function(t, e) {
				this.array.splice(t, 0, e)
			}, e.prototype.indexOf = function(t) {
				var e = this.array.indexOf(t);
				return -1 === e ? void 0 : e
			}, e.prototype.remove = function(t) {
				this.array.splice(t, 1)
			}, e.prototype.set = function(t, e) {
				this.array[t] = e
			}, e.prototype.get = function(t) {
				return this.array[t]
			}, e.prototype.lookupMaybe = function(t) {
				for (var e, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
				return (e = this.context).lookupMaybe.apply(e, Bo([this.get(t)], n))
			}, e.prototype.lookup = function(t) {
				for (var e, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
				return (e = this.context).lookup.apply(e, Bo([this.get(t)], n))
			}, e.prototype.asRectangle = function() {
				if (4 !== this.size()) throw new vs(this.size());
				var t = this.lookup(0, Ns).asNumber(),
					e = this.lookup(1, Ns).asNumber();
				return {
					x: t,
					y: e,
					width: this.lookup(2, Ns).asNumber() - t,
					height: this.lookup(3, Ns).asNumber() - e
				}
			}, e.prototype.asArray = function() {
				return this.array.slice()
			}, e.prototype.clone = function(t) {
				for (var n = e.withContext(t || this.context), r = 0, i = this.size(); r < i; r++) n.push(this.array[r]);
				return n
			}, e.prototype.toString = function() {
				for (var t = "[ ", e = 0, n = this.size(); e < n; e++) t += this.get(e).toString(), t += " ";
				return t + "]"
			}, e.prototype.sizeInBytes = function() {
				for (var t = 3, e = 0, n = this.size(); e < n; e++) t += this.get(e).sizeInBytes() + 1;
				return t
			}, e.prototype.copyBytesInto = function(t, e) {
				var n = e;
				t[e++] = Is.LeftSquareBracket, t[e++] = Is.Space;
				for (var r = 0, i = this.size(); r < i; r++) e += this.get(r).copyBytesInto(t, e), t[e++] = Is.Space;
				return t[e++] = Is.RightSquareBracket, e - n
			}, e.prototype.scalePDFNumbers = function(t, e) {
				for (var n = 0, r = this.size(); n < r; n++) {
					var i = this.lookup(n);
					if (i instanceof Ns) {
						var o = n % 2 == 0 ? t : e;
						this.set(n, Ns.of(i.asNumber() * o))
					}
				}
			}, e.withContext = function(t) {
				return new e(t)
			}, e
		}(Bs);
		const zs = Ls;
		var Ws = {};
		const Vs = function(t) {
			function e(e, n) {
				var r = this;
				if (e !== Ws) throw new cs("PDFBool");
				return (r = t.call(this) || this).value = n, r
			}
			return Do(e, t), e.prototype.asBoolean = function() {
				return this.value
			}, e.prototype.clone = function() {
				return this
			}, e.prototype.toString = function() {
				return String(this.value)
			}, e.prototype.sizeInBytes = function() {
				return this.value ? 4 : 5
			}, e.prototype.copyBytesInto = function(t, e) {
				return this.value ? (t[e++] = Is.t, t[e++] = Is.r, t[e++] = Is.u, t[e++] = Is.e, 4) : (t[e++] = Is.f, t[e++] = Is.a, t[e++] = Is.l, t[e++] = Is.s, t[e++] = Is.e, 5)
			}, e.True = new e(Ws, !0), e.False = new e(Ws, !1), e
		}(Bs);
		var Us = new Uint8Array(256);
		Us[Is.LeftParen] = 1, Us[Is.RightParen] = 1, Us[Is.LessThan] = 1, Us[Is.GreaterThan] = 1, Us[Is.LeftSquareBracket] = 1, Us[Is.RightSquareBracket] = 1, Us[Is.LeftCurly] = 1, Us[Is.RightCurly] = 1, Us[Is.ForwardSlash] = 1, Us[Is.Percent] = 1;
		var Hs = new Uint8Array(256);
		Hs[Is.Null] = 1, Hs[Is.Tab] = 1, Hs[Is.Newline] = 1, Hs[Is.FormFeed] = 1, Hs[Is.CarriageReturn] = 1, Hs[Is.Space] = 1;
		for (var qs = new Uint8Array(256), Xs = 0; Xs < 256; Xs++) qs[Xs] = Hs[Xs] || Us[Xs] ? 1 : 0;
		qs[Is.Hash] = 1;
		var Gs = {},
			Ks = new Map,
			Ys = function(t) {
				function e(e, n) {
					var r = this;
					if (e !== Gs) throw new cs("PDFName");
					r = t.call(this) || this;
					for (var i, o = "/", a = 0, s = n.length; a < s; a++) {
						var l = n[a],
							c = Ho(l);
						o += (i = c) >= Is.ExclamationPoint && i <= Is.Tilde && !qs[i] ? l : "#" + Xo(c)
					}
					return r.encodedName = o, r
				}
				return Do(e, t), e.prototype.asBytes = function() {
					for (var t = [], e = "", n = !1, r = function(e) {
							void 0 !== e && t.push(e), n = !1
						}, i = 1, o = this.encodedName.length; i < o; i++) {
						var a = this.encodedName[i],
							s = Ho(a),
							l = this.encodedName[i + 1];
						n ? s >= Is.Zero && s <= Is.Nine || s >= Is.a && s <= Is.f || s >= Is.A && s <= Is.F ? 2 !== (e += a).length && (l >= "0" && l <= "9" || l >= "a" && l <= "f" || l >= "A" && l <= "F") || (r(parseInt(e, 16)), e = "") : r(s) : s === Is.Hash ? n = !0 : r(s)
					}
					return new Uint8Array(t)
				}, e.prototype.decodeText = function() {
					var t = this.asBytes();
					return String.fromCharCode.apply(String, Array.from(t))
				}, e.prototype.asString = function() {
					return this.encodedName
				}, e.prototype.value = function() {
					return this.encodedName
				}, e.prototype.clone = function() {
					return this
				}, e.prototype.toString = function() {
					return this.encodedName
				}, e.prototype.sizeInBytes = function() {
					return this.encodedName.length
				}, e.prototype.copyBytesInto = function(t, e) {
					return e += Yo(this.encodedName, t, e), this.encodedName.length
				}, e.of = function(t) {
					var n = function(t) {
							return t.replace(/#([\dABCDEF]{2})/g, (function(t, e) {
								return function(t) {
									return Go(parseInt(t, 16))
								}(e)
							}))
						}(t),
						r = Ks.get(n);
					return r || (r = new e(Gs, n), Ks.set(n, r)), r
				}, e.Length = e.of("Length"), e.FlateDecode = e.of("FlateDecode"), e.Resources = e.of("Resources"), e.Font = e.of("Font"), e.XObject = e.of("XObject"), e.ExtGState = e.of("ExtGState"), e.Contents = e.of("Contents"), e.Type = e.of("Type"), e.Parent = e.of("Parent"), e.MediaBox = e.of("MediaBox"), e.Page = e.of("Page"), e.Annots = e.of("Annots"), e.TrimBox = e.of("TrimBox"), e.ArtBox = e.of("ArtBox"), e.BleedBox = e.of("BleedBox"), e.CropBox = e.of("CropBox"), e.Rotate = e.of("Rotate"), e.Title = e.of("Title"), e.Author = e.of("Author"), e.Subject = e.of("Subject"), e.Creator = e.of("Creator"), e.Keywords = e.of("Keywords"), e.Producer = e.of("Producer"), e.CreationDate = e.of("CreationDate"), e.ModDate = e.of("ModDate"), e
			}(Bs);
		const Zs = Ys,
			Js = new(function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.prototype.asNull = function() {
					return null
				}, e.prototype.clone = function() {
					return this
				}, e.prototype.toString = function() {
					return "null"
				}, e.prototype.sizeInBytes = function() {
					return 4
				}, e.prototype.copyBytesInto = function(t, e) {
					return t[e++] = Is.n, t[e++] = Is.u, t[e++] = Is.l, t[e++] = Is.l, 4
				}, e
			}(Bs));
		var Qs = function(t) {
			function e(e, n) {
				var r = t.call(this) || this;
				return r.dict = e, r.context = n, r
			}
			return Do(e, t), e.prototype.keys = function() {
				return Array.from(this.dict.keys())
			}, e.prototype.values = function() {
				return Array.from(this.dict.values())
			}, e.prototype.entries = function() {
				return Array.from(this.dict.entries())
			}, e.prototype.set = function(t, e) {
				this.dict.set(t, e)
			}, e.prototype.get = function(t, e) {
				void 0 === e && (e = !1);
				var n = this.dict.get(t);
				if (n !== Js || e) return n
			}, e.prototype.has = function(t) {
				var e = this.dict.get(t);
				return void 0 !== e && e !== Js
			}, e.prototype.lookupMaybe = function(t) {
				for (var e, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
				var i = n.includes(Js),
					o = (e = this.context).lookupMaybe.apply(e, Bo([this.get(t, i)], n));
				if (o !== Js || i) return o
			}, e.prototype.lookup = function(t) {
				for (var e, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
				var i = n.includes(Js),
					o = (e = this.context).lookup.apply(e, Bo([this.get(t, i)], n));
				if (o !== Js || i) return o
			}, e.prototype.delete = function(t) {
				return this.dict.delete(t)
			}, e.prototype.asMap = function() {
				return new Map(this.dict)
			}, e.prototype.uniqueKey = function(t) {
				void 0 === t && (t = "");
				for (var e = this.keys(), n = Zs.of(this.context.addRandomSuffix(t, 10)); e.includes(n);) n = Zs.of(this.context.addRandomSuffix(t, 10));
				return n
			}, e.prototype.clone = function(t) {
				for (var n = e.withContext(t || this.context), r = this.entries(), i = 0, o = r.length; i < o; i++) {
					var a = r[i],
						s = a[0],
						l = a[1];
					n.set(s, l)
				}
				return n
			}, e.prototype.toString = function() {
				for (var t = "<<\n", e = this.entries(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i[0],
						a = i[1];
					t += o.toString() + " " + a.toString() + "\n"
				}
				return t + ">>"
			}, e.prototype.sizeInBytes = function() {
				for (var t = 5, e = this.entries(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i[0],
						a = i[1];
					t += o.sizeInBytes() + a.sizeInBytes() + 2
				}
				return t
			}, e.prototype.copyBytesInto = function(t, e) {
				var n = e;
				t[e++] = Is.LessThan, t[e++] = Is.LessThan, t[e++] = Is.Newline;
				for (var r = this.entries(), i = 0, o = r.length; i < o; i++) {
					var a = r[i],
						s = a[0],
						l = a[1];
					e += s.copyBytesInto(t, e), t[e++] = Is.Space, e += l.copyBytesInto(t, e), t[e++] = Is.Newline
				}
				return t[e++] = Is.GreaterThan, t[e++] = Is.GreaterThan, e - n
			}, e.withContext = function(t) {
				return new e(new Map, t)
			}, e.fromMapWithContext = function(t, n) {
				return new e(t, n)
			}, e
		}(Bs);
		const $s = Qs;
		var tl = function(t) {
			function e(e) {
				var n = t.call(this) || this;
				return n.dict = e, n
			}
			return Do(e, t), e.prototype.clone = function(t) {
				throw new ls(this.constructor.name, "clone")
			}, e.prototype.getContentsString = function() {
				throw new ls(this.constructor.name, "getContentsString")
			}, e.prototype.getContents = function() {
				throw new ls(this.constructor.name, "getContents")
			}, e.prototype.getContentsSize = function() {
				throw new ls(this.constructor.name, "getContentsSize")
			}, e.prototype.updateDict = function() {
				var t = this.getContentsSize();
				this.dict.set(Zs.Length, Ns.of(t))
			}, e.prototype.sizeInBytes = function() {
				return this.updateDict(), this.dict.sizeInBytes() + this.getContentsSize() + 18
			}, e.prototype.toString = function() {
				this.updateDict();
				var t = this.dict.toString();
				return t += "\nstream\n", (t += this.getContentsString()) + "\nendstream"
			}, e.prototype.copyBytesInto = function(t, e) {
				this.updateDict();
				var n = e;
				e += this.dict.copyBytesInto(t, e), t[e++] = Is.Newline, t[e++] = Is.s, t[e++] = Is.t, t[e++] = Is.r, t[e++] = Is.e, t[e++] = Is.a, t[e++] = Is.m, t[e++] = Is.Newline;
				for (var r = this.getContents(), i = 0, o = r.length; i < o; i++) t[e++] = r[i];
				return t[e++] = Is.Newline, t[e++] = Is.e, t[e++] = Is.n, t[e++] = Is.d, t[e++] = Is.s, t[e++] = Is.t, t[e++] = Is.r, t[e++] = Is.e, t[e++] = Is.a, t[e++] = Is.m, e - n
			}, e
		}(Bs);
		const el = tl,
			nl = function(t) {
				function e(e, n) {
					var r = t.call(this, e) || this;
					return r.contents = n, r
				}
				return Do(e, t), e.prototype.asUint8Array = function() {
					return this.contents.slice()
				}, e.prototype.clone = function(t) {
					return e.of(this.dict.clone(t), this.contents.slice())
				}, e.prototype.getContentsString = function() {
					return la(this.contents)
				}, e.prototype.getContents = function() {
					return this.contents
				}, e.prototype.getContentsSize = function() {
					return this.contents.length
				}, e.of = function(t, n) {
					return new e(t, n)
				}, e
			}(el);
		var rl = {},
			il = new Map;
		const ol = function(t) {
			function e(e, n, r) {
				var i = this;
				if (e !== rl) throw new cs("PDFRef");
				return (i = t.call(this) || this).objectNumber = n, i.generationNumber = r, i.tag = n + " " + r + " R", i
			}
			return Do(e, t), e.prototype.clone = function() {
				return this
			}, e.prototype.toString = function() {
				return this.tag
			}, e.prototype.sizeInBytes = function() {
				return this.tag.length
			}, e.prototype.copyBytesInto = function(t, e) {
				return e += Yo(this.tag, t, e), this.tag.length
			}, e.of = function(t, n) {
				void 0 === n && (n = 0);
				var r = t + " " + n + " R",
					i = il.get(r);
				return i || (i = new e(rl, t, n), il.set(r, i)), i
			}, e
		}(Bs);
		var al = function() {
			function t(t, e) {
				this.name = t, this.args = e || []
			}
			return t.prototype.clone = function(e) {
				for (var n = new Array(this.args.length), r = 0, i = n.length; r < i; r++) {
					var o = this.args[r];
					n[r] = o instanceof Bs ? o.clone(e) : o
				}
				return t.of(this.name, n)
			}, t.prototype.toString = function() {
				for (var t = "", e = 0, n = this.args.length; e < n; e++) t += String(this.args[e]) + " ";
				return t + this.name
			}, t.prototype.sizeInBytes = function() {
				for (var t = 0, e = 0, n = this.args.length; e < n; e++) {
					var r = this.args[e];
					t += (r instanceof Bs ? r.sizeInBytes() : r.length) + 1
				}
				return t + this.name.length
			}, t.prototype.copyBytesInto = function(t, e) {
				for (var n = e, r = 0, i = this.args.length; r < i; r++) {
					var o = this.args[r];
					e += o instanceof Bs ? o.copyBytesInto(t, e) : Yo(o, t, e), t[e++] = Is.Space
				}
				return (e += Yo(this.name, t, e)) - n
			}, t.of = function(e, n) {
				return new t(e, n)
			}, t
		}();
		const sl = al;
		var ll;
		! function(t) {
			t.NonStrokingColor = "sc", t.NonStrokingColorN = "scn", t.NonStrokingColorRgb = "rg", t.NonStrokingColorGray = "g", t.NonStrokingColorCmyk = "k", t.NonStrokingColorspace = "cs", t.StrokingColor = "SC", t.StrokingColorN = "SCN", t.StrokingColorRgb = "RG", t.StrokingColorGray = "G", t.StrokingColorCmyk = "K", t.StrokingColorspace = "CS", t.BeginMarkedContentSequence = "BDC", t.BeginMarkedContent = "BMC", t.EndMarkedContent = "EMC", t.MarkedContentPointWithProps = "DP", t.MarkedContentPoint = "MP", t.DrawObject = "Do", t.ConcatTransformationMatrix = "cm", t.PopGraphicsState = "Q", t.PushGraphicsState = "q", t.SetFlatness = "i", t.SetGraphicsStateParams = "gs", t.SetLineCapStyle = "J", t.SetLineDashPattern = "d", t.SetLineJoinStyle = "j", t.SetLineMiterLimit = "M", t.SetLineWidth = "w", t.SetTextMatrix = "Tm", t.SetRenderingIntent = "ri", t.AppendRectangle = "re", t.BeginInlineImage = "BI", t.BeginInlineImageData = "ID", t.EndInlineImage = "EI", t.ClipEvenOdd = "W*", t.ClipNonZero = "W", t.CloseAndStroke = "s", t.CloseFillEvenOddAndStroke = "b*", t.CloseFillNonZeroAndStroke = "b", t.ClosePath = "h", t.AppendBezierCurve = "c", t.CurveToReplicateFinalPoint = "y", t.CurveToReplicateInitialPoint = "v", t.EndPath = "n", t.FillEvenOddAndStroke = "B*", t.FillEvenOdd = "f*", t.FillNonZeroAndStroke = "B", t.FillNonZero = "f", t.LegacyFillNonZero = "F", t.LineTo = "l", t.MoveTo = "m", t.ShadingFill = "sh", t.StrokePath = "S", t.BeginText = "BT", t.EndText = "ET", t.MoveText = "Td", t.MoveTextSetLeading = "TD", t.NextLine = "T*", t.SetCharacterSpacing = "Tc", t.SetFontAndSize = "Tf", t.SetTextHorizontalScaling = "Tz", t.SetTextLineHeight = "TL", t.SetTextRenderingMode = "Tr", t.SetTextRise = "Ts", t.SetWordSpacing = "Tw", t.ShowText = "Tj", t.ShowTextAdjusted = "TJ", t.ShowTextLine = "'", t.ShowTextLineAndSpace = '"', t.Type3D0 = "d0", t.Type3D1 = "d1", t.BeginCompatibilitySection = "BX", t.EndCompatibilitySection = "EX"
		}(ll || (ll = {}));
		const cl = ll,
			ul = function(t) {
				function e(e, n) {
					var r = t.call(this, e) || this;
					return r.computeContents = function() {
						var t = r.getUnencodedContents();
						return r.encode ? Pa().deflate(t) : t
					}, r.encode = n, n && e.set(Zs.of("Filter"), Zs.of("FlateDecode")), r.contentsCache = os.populatedBy(r.computeContents), r
				}
				return Do(e, t), e.prototype.getContents = function() {
					return this.contentsCache.access()
				}, e.prototype.getContentsSize = function() {
					return this.contentsCache.access().length
				}, e.prototype.getUnencodedContents = function() {
					throw new ls(this.constructor.name, "getUnencodedContents")
				}, e
			}(el);
		var hl = function(t) {
			function e(e, n, r) {
				void 0 === r && (r = !0);
				var i = t.call(this, e, r) || this;
				return i.operators = n, i
			}
			return Do(e, t), e.prototype.push = function() {
				for (var t, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
				(t = this.operators).push.apply(t, e)
			}, e.prototype.clone = function(t) {
				for (var n = new Array(this.operators.length), r = 0, i = this.operators.length; r < i; r++) n[r] = this.operators[r].clone(t);
				var o = this.dict,
					a = this.encode;
				return e.of(o.clone(t), n, a)
			}, e.prototype.getContentsString = function() {
				for (var t = "", e = 0, n = this.operators.length; e < n; e++) t += this.operators[e] + "\n";
				return t
			}, e.prototype.getUnencodedContents = function() {
				for (var t = new Uint8Array(this.getUnencodedContentsSize()), e = 0, n = 0, r = this.operators.length; n < r; n++) e += this.operators[n].copyBytesInto(t, e), t[e++] = Is.Newline;
				return t
			}, e.prototype.getUnencodedContentsSize = function() {
				for (var t = 0, e = 0, n = this.operators.length; e < n; e++) t += this.operators[e].sizeInBytes() + 1;
				return t
			}, e.of = function(t, n, r) {
				return void 0 === r && (r = !0), new e(t, n, r)
			}, e
		}(ul);
		const fl = hl;
		var dl = function() {
				function t(t) {
					this.seed = t
				}
				return t.prototype.nextInt = function() {
					var t = 1e4 * Math.sin(this.seed++);
					return t - Math.floor(t)
				}, t.withSeed = function(e) {
					return new t(e)
				}, t
			}(),
			pl = function(t, e) {
				var n = t[0],
					r = e[0];
				return n.objectNumber - r.objectNumber
			},
			gl = function() {
				function t() {
					this.largestObjectNumber = 0, this.header = Rs.forVersion(1, 7), this.trailerInfo = {}, this.indirectObjects = new Map, this.rng = dl.withSeed(1)
				}
				return t.prototype.assign = function(t, e) {
					this.indirectObjects.set(t, e), t.objectNumber > this.largestObjectNumber && (this.largestObjectNumber = t.objectNumber)
				}, t.prototype.nextRef = function() {
					return this.largestObjectNumber += 1, ol.of(this.largestObjectNumber)
				}, t.prototype.register = function(t) {
					var e = this.nextRef();
					return this.assign(e, t), e
				}, t.prototype.delete = function(t) {
					return this.indirectObjects.delete(t)
				}, t.prototype.lookupMaybe = function(t) {
					for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
					var r = e.includes(Js),
						i = t instanceof ol ? this.indirectObjects.get(t) : t;
					if (i && (i !== Js || r)) {
						for (var o = 0, a = e.length; o < a; o++) {
							var s = e[o];
							if (s === Js) {
								if (i === Js) return i
							} else if (i instanceof s) return i
						}
						throw new us(e, i)
					}
				}, t.prototype.lookup = function(t) {
					for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
					var r = t instanceof ol ? this.indirectObjects.get(t) : t;
					if (0 === e.length) return r;
					for (var i = 0, o = e.length; i < o; i++) {
						var a = e[i];
						if (a === Js) {
							if (r === Js) return r
						} else if (r instanceof a) return r
					}
					throw new us(e, r)
				}, t.prototype.getObjectRef = function(t) {
					for (var e = Array.from(this.indirectObjects.entries()), n = 0, r = e.length; n < r; n++) {
						var i = e[n],
							o = i[0];
						if (i[1] === t) return o
					}
				}, t.prototype.enumerateIndirectObjects = function() {
					return Array.from(this.indirectObjects.entries()).sort(pl)
				}, t.prototype.obj = function(t) {
					if (t instanceof Bs) return t;
					if (null == t) return Js;
					if ("string" == typeof t) return Zs.of(t);
					if ("number" == typeof t) return Ns.of(t);
					if ("boolean" == typeof t) return t ? Vs.True : Vs.False;
					if (Array.isArray(t)) {
						for (var e = zs.withContext(this), n = 0, r = t.length; n < r; n++) e.push(this.obj(t[n]));
						return e
					}
					var i = $s.withContext(this),
						o = Object.keys(t);
					for (n = 0, r = o.length; n < r; n++) {
						var a = o[n],
							s = t[a];
						void 0 !== s && i.set(Zs.of(a), this.obj(s))
					}
					return i
				}, t.prototype.stream = function(t, e) {
					return void 0 === e && (e = {}), nl.of(this.obj(e), aa(t))
				}, t.prototype.flateStream = function(t, e) {
					return void 0 === e && (e = {}), this.stream(Pa().deflate(aa(t)), Mo(Mo({}, e), {
						Filter: "FlateDecode"
					}))
				}, t.prototype.contentStream = function(t, e) {
					return void 0 === e && (e = {}), fl.of(this.obj(e), t)
				}, t.prototype.formXObject = function(t, e) {
					return void 0 === e && (e = {}), this.contentStream(t, Mo(Mo({
						BBox: this.obj([0, 0, 0, 0]),
						Matrix: this.obj([1, 0, 0, 1, 0, 0])
					}, e), {
						Type: "XObject",
						Subtype: "Form"
					}))
				}, t.prototype.getPushGraphicsStateContentStream = function() {
					if (this.pushGraphicsStateContentStreamRef) return this.pushGraphicsStateContentStreamRef;
					var t = this.obj({}),
						e = sl.of(cl.PushGraphicsState),
						n = fl.of(t, [e]);
					return this.pushGraphicsStateContentStreamRef = this.register(n), this.pushGraphicsStateContentStreamRef
				}, t.prototype.getPopGraphicsStateContentStream = function() {
					if (this.popGraphicsStateContentStreamRef) return this.popGraphicsStateContentStreamRef;
					var t = this.obj({}),
						e = sl.of(cl.PopGraphicsState),
						n = fl.of(t, [e]);
					return this.popGraphicsStateContentStreamRef = this.register(n), this.popGraphicsStateContentStreamRef
				}, t.prototype.addRandomSuffix = function(t, e) {
					return void 0 === e && (e = 4), t + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, e))
				}, t.create = function() {
					return new t
				}, t
			}();
		const vl = gl;
		var ml = function(t) {
			function e(e, n, r) {
				void 0 === r && (r = !0);
				var i = t.call(this, e, n) || this;
				return i.normalized = !1, i.autoNormalizeCTM = r, i
			}
			return Do(e, t), e.prototype.clone = function(t) {
				for (var n = e.fromMapWithContext(new Map, t || this.context, this.autoNormalizeCTM), r = this.entries(), i = 0, o = r.length; i < o; i++) {
					var a = r[i],
						s = a[0],
						l = a[1];
					n.set(s, l)
				}
				return n
			}, e.prototype.Parent = function() {
				return this.lookupMaybe(Zs.Parent, $s)
			}, e.prototype.Contents = function() {
				return this.lookup(Zs.of("Contents"))
			}, e.prototype.Annots = function() {
				return this.lookupMaybe(Zs.Annots, zs)
			}, e.prototype.BleedBox = function() {
				return this.lookupMaybe(Zs.BleedBox, zs)
			}, e.prototype.TrimBox = function() {
				return this.lookupMaybe(Zs.TrimBox, zs)
			}, e.prototype.ArtBox = function() {
				return this.lookupMaybe(Zs.ArtBox, zs)
			}, e.prototype.Resources = function() {
				var t = this.getInheritableAttribute(Zs.Resources);
				return this.context.lookupMaybe(t, $s)
			}, e.prototype.MediaBox = function() {
				var t = this.getInheritableAttribute(Zs.MediaBox);
				return this.context.lookup(t, zs)
			}, e.prototype.CropBox = function() {
				var t = this.getInheritableAttribute(Zs.CropBox);
				return this.context.lookupMaybe(t, zs)
			}, e.prototype.Rotate = function() {
				var t = this.getInheritableAttribute(Zs.Rotate);
				return this.context.lookupMaybe(t, Ns)
			}, e.prototype.getInheritableAttribute = function(t) {
				var e;
				return this.ascend((function(n) {
					e || (e = n.get(t))
				})), e
			}, e.prototype.setParent = function(t) {
				this.set(Zs.Parent, t)
			}, e.prototype.addContentStream = function(t) {
				var e = this.normalizedEntries().Contents || this.context.obj([]);
				this.set(Zs.Contents, e), e.push(t)
			}, e.prototype.wrapContentStreams = function(t, e) {
				var n = this.Contents();
				return n instanceof zs && (n.insert(0, t), n.push(e), !0)
			}, e.prototype.addAnnot = function(t) {
				this.normalizedEntries().Annots.push(t)
			}, e.prototype.removeAnnot = function(t) {
				var e = this.normalizedEntries().Annots,
					n = e.indexOf(t);
				void 0 !== n && e.remove(n)
			}, e.prototype.setFontDictionary = function(t, e) {
				this.normalizedEntries().Font.set(t, e)
			}, e.prototype.newFontDictionaryKey = function(t) {
				return this.normalizedEntries().Font.uniqueKey(t)
			}, e.prototype.newFontDictionary = function(t, e) {
				var n = this.newFontDictionaryKey(t);
				return this.setFontDictionary(n, e), n
			}, e.prototype.setXObject = function(t, e) {
				this.normalizedEntries().XObject.set(t, e)
			}, e.prototype.newXObjectKey = function(t) {
				return this.normalizedEntries().XObject.uniqueKey(t)
			}, e.prototype.newXObject = function(t, e) {
				var n = this.newXObjectKey(t);
				return this.setXObject(n, e), n
			}, e.prototype.setExtGState = function(t, e) {
				this.normalizedEntries().ExtGState.set(t, e)
			}, e.prototype.newExtGStateKey = function(t) {
				return this.normalizedEntries().ExtGState.uniqueKey(t)
			}, e.prototype.newExtGState = function(t, e) {
				var n = this.newExtGStateKey(t);
				return this.setExtGState(n, e), n
			}, e.prototype.ascend = function(t) {
				t(this);
				var e = this.Parent();
				e && e.ascend(t)
			}, e.prototype.normalize = function() {
				if (!this.normalized) {
					var t = this.context,
						e = this.get(Zs.Contents);
					this.context.lookup(e) instanceof el && this.set(Zs.Contents, t.obj([e])), this.autoNormalizeCTM && this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
					var n = this.getInheritableAttribute(Zs.Resources),
						r = t.lookupMaybe(n, $s) || t.obj({});
					this.set(Zs.Resources, r);
					var i = r.lookupMaybe(Zs.Font, $s) || t.obj({});
					r.set(Zs.Font, i);
					var o = r.lookupMaybe(Zs.XObject, $s) || t.obj({});
					r.set(Zs.XObject, o);
					var a = r.lookupMaybe(Zs.ExtGState, $s) || t.obj({});
					r.set(Zs.ExtGState, a);
					var s = this.Annots() || t.obj([]);
					this.set(Zs.Annots, s), this.normalized = !0
				}
			}, e.prototype.normalizedEntries = function() {
				this.normalize();
				var t = this.Annots(),
					e = this.Resources();
				return {
					Annots: t,
					Resources: e,
					Contents: this.Contents(),
					Font: e.lookup(Zs.Font, $s),
					XObject: e.lookup(Zs.XObject, $s),
					ExtGState: e.lookup(Zs.ExtGState, $s)
				}
			}, e.InheritableEntries = ["Resources", "MediaBox", "CropBox", "Rotate"], e.withContextAndParent = function(t, n) {
				var r = new Map;
				return r.set(Zs.Type, Zs.Page), r.set(Zs.Parent, n), r.set(Zs.Resources, t.obj({})), r.set(Zs.MediaBox, t.obj([0, 0, 612, 792])), new e(r, t, !1)
			}, e.fromMapWithContext = function(t, n, r) {
				return void 0 === r && (r = !0), new e(t, n, r)
			}, e
		}($s);
		const yl = ml;
		var bl = function() {
			function t(t, e) {
				var n = this;
				this.traversedObjects = new Map, this.copy = function(t) {
					return t instanceof yl ? n.copyPDFPage(t) : t instanceof $s ? n.copyPDFDict(t) : t instanceof zs ? n.copyPDFArray(t) : t instanceof el ? n.copyPDFStream(t) : t instanceof ol ? n.copyPDFIndirectObject(t) : t.clone()
				}, this.copyPDFPage = function(t) {
					for (var e = t.clone(), r = yl.InheritableEntries, i = 0, o = r.length; i < o; i++) {
						var a = Zs.of(r[i]),
							s = e.getInheritableAttribute(a);
						!e.get(a) && s && e.set(a, s)
					}
					return e.delete(Zs.of("Parent")), n.copyPDFDict(e)
				}, this.copyPDFDict = function(t) {
					if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
					var e = t.clone(n.dest);
					n.traversedObjects.set(t, e);
					for (var r = t.entries(), i = 0, o = r.length; i < o; i++) {
						var a = r[i],
							s = a[0],
							l = a[1];
						e.set(s, n.copy(l))
					}
					return e
				}, this.copyPDFArray = function(t) {
					if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
					var e = t.clone(n.dest);
					n.traversedObjects.set(t, e);
					for (var r = 0, i = t.size(); r < i; r++) {
						var o = t.get(r);
						e.set(r, n.copy(o))
					}
					return e
				}, this.copyPDFStream = function(t) {
					if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
					var e = t.clone(n.dest);
					n.traversedObjects.set(t, e);
					for (var r = t.dict.entries(), i = 0, o = r.length; i < o; i++) {
						var a = r[i],
							s = a[0],
							l = a[1];
						e.dict.set(s, n.copy(l))
					}
					return e
				}, this.copyPDFIndirectObject = function(t) {
					if (!n.traversedObjects.has(t)) {
						var e = n.dest.nextRef();
						n.traversedObjects.set(t, e);
						var r = n.src.lookup(t);
						if (r) {
							var i = n.copy(r);
							n.dest.assign(e, i)
						}
					}
					return n.traversedObjects.get(t)
				}, this.src = t, this.dest = e
			}
			return t.for = function(e, n) {
				return new t(e, n)
			}, t
		}();
		const xl = bl;
		var wl = function() {
			function t(t) {
				this.subsections = t ? [
					[t]
				] : [], this.chunkIdx = 0, this.chunkLength = t ? 1 : 0
			}
			return t.prototype.addEntry = function(t, e) {
				this.append({
					ref: t,
					offset: e,
					deleted: !1
				})
			}, t.prototype.addDeletedEntry = function(t, e) {
				this.append({
					ref: t,
					offset: e,
					deleted: !0
				})
			}, t.prototype.toString = function() {
				for (var t = "xref\n", e = 0, n = this.subsections.length; e < n; e++) {
					var r = this.subsections[e];
					t += r[0].ref.objectNumber + " " + r.length + "\n";
					for (var i = 0, o = r.length; i < o; i++) {
						var a = r[i];
						t += Ko(String(a.offset), 10, "0"), t += " ", t += Ko(String(a.ref.generationNumber), 5, "0"), t += " ", t += a.deleted ? "f" : "n", t += " \n"
					}
				}
				return t
			}, t.prototype.sizeInBytes = function() {
				for (var t = 5, e = 0, n = this.subsections.length; e < n; e++) {
					var r = this.subsections[e],
						i = r.length,
						o = r[0];
					t += 2, t += String(o.ref.objectNumber).length, t += String(i).length, t += 20 * i
				}
				return t
			}, t.prototype.copyBytesInto = function(t, e) {
				var n = e;
				return t[e++] = Is.x, t[e++] = Is.r, t[e++] = Is.e, t[e++] = Is.f, t[e++] = Is.Newline, (e += this.copySubsectionsIntoBuffer(this.subsections, t, e)) - n
			}, t.prototype.copySubsectionsIntoBuffer = function(t, e, n) {
				for (var r = n, i = t.length, o = 0; o < i; o++) {
					var a = this.subsections[o],
						s = String(a[0].ref.objectNumber);
					n += Yo(s, e, n), e[n++] = Is.Space;
					var l = String(a.length);
					n += Yo(l, e, n), e[n++] = Is.Newline, n += this.copyEntriesIntoBuffer(a, e, n)
				}
				return n - r
			}, t.prototype.copyEntriesIntoBuffer = function(t, e, n) {
				for (var r = t.length, i = 0; i < r; i++) {
					var o = t[i],
						a = Ko(String(o.offset), 10, "0");
					n += Yo(a, e, n), e[n++] = Is.Space;
					var s = Ko(String(o.ref.generationNumber), 5, "0");
					n += Yo(s, e, n), e[n++] = Is.Space, e[n++] = o.deleted ? Is.f : Is.n, e[n++] = Is.Space, e[n++] = Is.Newline
				}
				return 20 * r
			}, t.prototype.append = function(t) {
				if (0 === this.chunkLength) return this.subsections.push([t]), this.chunkIdx = 0, void(this.chunkLength = 1);
				var e = this.subsections[this.chunkIdx],
					n = e[this.chunkLength - 1];
				t.ref.objectNumber - n.ref.objectNumber > 1 ? (this.subsections.push([t]), this.chunkIdx += 1, this.chunkLength = 1) : (e.push(t), this.chunkLength += 1)
			}, t.create = function() {
				return new t({
					ref: ol.of(0, 65535),
					offset: 0,
					deleted: !0
				})
			}, t.createEmpty = function() {
				return new t
			}, t
		}();
		const Cl = wl,
			Sl = function() {
				function t(t) {
					this.lastXRefOffset = String(t)
				}
				return t.prototype.toString = function() {
					return "startxref\n" + this.lastXRefOffset + "\n%%EOF"
				}, t.prototype.sizeInBytes = function() {
					return 16 + this.lastXRefOffset.length
				}, t.prototype.copyBytesInto = function(t, e) {
					var n = e;
					return t[e++] = Is.s, t[e++] = Is.t, t[e++] = Is.a, t[e++] = Is.r, t[e++] = Is.t, t[e++] = Is.x, t[e++] = Is.r, t[e++] = Is.e, t[e++] = Is.f, t[e++] = Is.Newline, e += Yo(this.lastXRefOffset, t, e), t[e++] = Is.Newline, t[e++] = Is.Percent, t[e++] = Is.Percent, t[e++] = Is.E, t[e++] = Is.O, t[e++] = Is.F, e - n
				}, t.forLastCrossRefSectionOffset = function(e) {
					return new t(e)
				}, t
			}(),
			Ol = function() {
				function t(t) {
					this.dict = t
				}
				return t.prototype.toString = function() {
					return "trailer\n" + this.dict.toString()
				}, t.prototype.sizeInBytes = function() {
					return 8 + this.dict.sizeInBytes()
				}, t.prototype.copyBytesInto = function(t, e) {
					var n = e;
					return t[e++] = Is.t, t[e++] = Is.r, t[e++] = Is.a, t[e++] = Is.i, t[e++] = Is.l, t[e++] = Is.e, t[e++] = Is.r, t[e++] = Is.Newline, (e += this.dict.copyBytesInto(t, e)) - n
				}, t.of = function(e) {
					return new t(e)
				}, t
			}();
		var Tl = function(t) {
			function e(e, n, r) {
				void 0 === r && (r = !0);
				var i = t.call(this, e.obj({}), r) || this;
				return i.objects = n, i.offsets = i.computeObjectOffsets(), i.offsetsString = i.computeOffsetsString(), i.dict.set(Zs.of("Type"), Zs.of("ObjStm")), i.dict.set(Zs.of("N"), Ns.of(i.objects.length)), i.dict.set(Zs.of("First"), Ns.of(i.offsetsString.length)), i
			}
			return Do(e, t), e.prototype.getObjectsCount = function() {
				return this.objects.length
			}, e.prototype.clone = function(t) {
				return e.withContextAndObjects(t || this.dict.context, this.objects.slice(), this.encode)
			}, e.prototype.getContentsString = function() {
				for (var t = this.offsetsString, e = 0, n = this.objects.length; e < n; e++) t += this.objects[e][1] + "\n";
				return t
			}, e.prototype.getUnencodedContents = function() {
				for (var t = new Uint8Array(this.getUnencodedContentsSize()), e = Yo(this.offsetsString, t, 0), n = 0, r = this.objects.length; n < r; n++) e += this.objects[n][1].copyBytesInto(t, e), t[e++] = Is.Newline;
				return t
			}, e.prototype.getUnencodedContentsSize = function() {
				return this.offsetsString.length + oa(this.offsets)[1] + oa(this.objects)[1].sizeInBytes() + 1
			}, e.prototype.computeOffsetsString = function() {
				for (var t = "", e = 0, n = this.offsets.length; e < n; e++) {
					var r = this.offsets[e];
					t += r[0] + " " + r[1] + " "
				}
				return t
			}, e.prototype.computeObjectOffsets = function() {
				for (var t = 0, e = new Array(this.objects.length), n = 0, r = this.objects.length; n < r; n++) {
					var i = this.objects[n],
						o = i[0],
						a = i[1];
					e[n] = [o.objectNumber, t], t += a.sizeInBytes() + 1
				}
				return e
			}, e.withContextAndObjects = function(t, n, r) {
				return void 0 === r && (r = !0), new e(t, n, r)
			}, e
		}(ul);
		const kl = Tl;
		var Fl = function() {
			function t(t, e) {
				var n = this;
				this.parsedObjects = 0, this.shouldWaitForTick = function(t) {
					return n.parsedObjects += t, n.parsedObjects % n.objectsPerTick == 0
				}, this.context = t, this.objectsPerTick = e
			}
			return t.prototype.serializeToBuffer = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r, i, o, a, s, l, c, u, h, f, d, p, g, v;
					return Ro(this, (function(m) {
						switch (m.label) {
							case 0:
								return [4, this.computeBufferSize()];
							case 1:
								t = m.sent(), e = t.size, n = t.header, r = t.indirectObjects, i = t.xref, o = t.trailerDict, a = t.trailer, s = 0, l = new Uint8Array(e), s += n.copyBytesInto(l, s), l[s++] = Is.Newline, l[s++] = Is.Newline, c = 0, u = r.length, m.label = 2;
							case 2:
								return c < u ? (h = r[c], f = h[0], d = h[1], p = String(f.objectNumber), s += Yo(p, l, s), l[s++] = Is.Space, g = String(f.generationNumber), s += Yo(g, l, s), l[s++] = Is.Space, l[s++] = Is.o, l[s++] = Is.b, l[s++] = Is.j, l[s++] = Is.Newline, s += d.copyBytesInto(l, s), l[s++] = Is.Newline, l[s++] = Is.e, l[s++] = Is.n, l[s++] = Is.d, l[s++] = Is.o, l[s++] = Is.b, l[s++] = Is.j, l[s++] = Is.Newline, l[s++] = Is.Newline, v = d instanceof kl ? d.getObjectsCount() : 1, this.shouldWaitForTick(v) ? [4, fa()] : [3, 4]) : [3, 5];
							case 3:
								m.sent(), m.label = 4;
							case 4:
								return c++, [3, 2];
							case 5:
								return i && (s += i.copyBytesInto(l, s), l[s++] = Is.Newline), o && (s += o.copyBytesInto(l, s), l[s++] = Is.Newline, l[s++] = Is.Newline), s += a.copyBytesInto(l, s), [2, l]
						}
					}))
				}))
			}, t.prototype.computeIndirectObjectSize = function(t) {
				var e = t[0],
					n = t[1];
				return e.sizeInBytes() + 3 + (n.sizeInBytes() + 9)
			}, t.prototype.createTrailerDict = function() {
				return this.context.obj({
					Size: this.context.largestObjectNumber + 1,
					Root: this.context.trailerInfo.Root,
					Encrypt: this.context.trailerInfo.Encrypt,
					Info: this.context.trailerInfo.Info,
					ID: this.context.trailerInfo.ID
				})
			}, t.prototype.computeBufferSize = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r, i, o, a, s, l, c, u;
					return Ro(this, (function(h) {
						switch (h.label) {
							case 0:
								t = Rs.forVersion(1, 7), e = t.sizeInBytes() + 2, n = Cl.create(), r = this.context.enumerateIndirectObjects(), i = 0, o = r.length, h.label = 1;
							case 1:
								return i < o ? (a = r[i], s = a[0], n.addEntry(s, e), e += this.computeIndirectObjectSize(a), this.shouldWaitForTick(1) ? [4, fa()] : [3, 3]) : [3, 4];
							case 2:
								h.sent(), h.label = 3;
							case 3:
								return i++, [3, 1];
							case 4:
								return l = e, e += n.sizeInBytes() + 1, c = Ol.of(this.createTrailerDict()), e += c.sizeInBytes() + 2, u = Sl.forLastCrossRefSectionOffset(l), [2, {
									size: e += u.sizeInBytes(),
									header: t,
									indirectObjects: r,
									xref: n,
									trailerDict: c,
									trailer: u
								}]
						}
					}))
				}))
			}, t.forContext = function(e, n) {
				return new t(e, n)
			}, t
		}();
		const Pl = Fl;
		var jl = function(t) {
			function e(e) {
				var n = t.call(this) || this;
				return n.data = e, n
			}
			return Do(e, t), e.prototype.clone = function() {
				return e.of(this.data.slice())
			}, e.prototype.toString = function() {
				return "PDFInvalidObject(" + this.data.length + " bytes)"
			}, e.prototype.sizeInBytes = function() {
				return this.data.length
			}, e.prototype.copyBytesInto = function(t, e) {
				for (var n = this.data.length, r = 0; r < n; r++) t[e++] = this.data[r];
				return n
			}, e.of = function(t) {
				return new e(t)
			}, e
		}(Bs);
		const Al = jl;
		var _l;
		! function(t) {
			t[t.Deleted = 0] = "Deleted", t[t.Uncompressed = 1] = "Uncompressed", t[t.Compressed = 2] = "Compressed"
		}(_l || (_l = {}));
		var El = function(t) {
			function e(e, n, r) {
				void 0 === r && (r = !0);
				var i = t.call(this, e, r) || this;
				return i.computeIndex = function() {
					for (var t = [], e = 0, n = 0, r = i.entries.length; n < r; n++) {
						var o = i.entries[n],
							a = i.entries[n - 1];
						0 === n ? t.push(o.ref.objectNumber) : o.ref.objectNumber - a.ref.objectNumber > 1 && (t.push(e), t.push(o.ref.objectNumber), e = 0), e += 1
					}
					return t.push(e), t
				}, i.computeEntryTuples = function() {
					for (var t = new Array(i.entries.length), e = 0, n = i.entries.length; e < n; e++) {
						var r = i.entries[e];
						if (r.type === _l.Deleted) {
							var o = r.type,
								a = r.nextFreeObjectNumber,
								s = r.ref;
							t[e] = [o, a, s.generationNumber]
						}
						if (r.type === _l.Uncompressed) {
							o = r.type;
							var l = r.offset;
							s = r.ref, t[e] = [o, l, s.generationNumber]
						}
						if (r.type === _l.Compressed) {
							o = r.type;
							var c = r.objectStreamRef,
								u = r.index;
							t[e] = [o, c.objectNumber, u]
						}
					}
					return t
				}, i.computeMaxEntryByteWidths = function() {
					for (var t = i.entryTuplesCache.access(), e = [0, 0, 0], n = 0, r = t.length; n < r; n++) {
						var o = t[n],
							a = o[0],
							s = o[1],
							l = o[2],
							c = Oa(a),
							u = Oa(s),
							h = Oa(l);
						c > e[0] && (e[0] = c), u > e[1] && (e[1] = u), h > e[2] && (e[2] = h)
					}
					return e
				}, i.entries = n || [], i.entryTuplesCache = os.populatedBy(i.computeEntryTuples), i.maxByteWidthsCache = os.populatedBy(i.computeMaxEntryByteWidths), i.indexCache = os.populatedBy(i.computeIndex), e.set(Zs.of("Type"), Zs.of("XRef")), i
			}
			return Do(e, t), e.prototype.addDeletedEntry = function(t, e) {
				var n = _l.Deleted;
				this.entries.push({
					type: n,
					ref: t,
					nextFreeObjectNumber: e
				}), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate()
			}, e.prototype.addUncompressedEntry = function(t, e) {
				var n = _l.Uncompressed;
				this.entries.push({
					type: n,
					ref: t,
					offset: e
				}), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate()
			}, e.prototype.addCompressedEntry = function(t, e, n) {
				var r = _l.Compressed;
				this.entries.push({
					type: r,
					ref: t,
					objectStreamRef: e,
					index: n
				}), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate()
			}, e.prototype.clone = function(t) {
				var n = this,
					r = n.dict,
					i = n.entries,
					o = n.encode;
				return e.of(r.clone(t), i.slice(), o)
			}, e.prototype.getContentsString = function() {
				for (var t = this.entryTuplesCache.access(), e = this.maxByteWidthsCache.access(), n = "", r = 0, i = t.length; r < i; r++) {
					for (var o = t[r], a = o[0], s = o[1], l = o[2], c = ua(Ta(a)), u = ua(Ta(s)), h = ua(Ta(l)), f = e[0] - 1; f >= 0; f--) n += (c[f] || 0).toString(2);
					for (f = e[1] - 1; f >= 0; f--) n += (u[f] || 0).toString(2);
					for (f = e[2] - 1; f >= 0; f--) n += (h[f] || 0).toString(2)
				}
				return n
			}, e.prototype.getUnencodedContents = function() {
				for (var t = this.entryTuplesCache.access(), e = this.maxByteWidthsCache.access(), n = new Uint8Array(this.getUnencodedContentsSize()), r = 0, i = 0, o = t.length; i < o; i++) {
					for (var a = t[i], s = a[0], l = a[1], c = a[2], u = ua(Ta(s)), h = ua(Ta(l)), f = ua(Ta(c)), d = e[0] - 1; d >= 0; d--) n[r++] = u[d] || 0;
					for (d = e[1] - 1; d >= 0; d--) n[r++] = h[d] || 0;
					for (d = e[2] - 1; d >= 0; d--) n[r++] = f[d] || 0
				}
				return n
			}, e.prototype.getUnencodedContentsSize = function() {
				var t = function(t) {
					for (var e = 0, n = 0, r = t.length; n < r; n++) e += t[n];
					return e
				}(this.maxByteWidthsCache.access());
				return t * this.entries.length
			}, e.prototype.updateDict = function() {
				t.prototype.updateDict.call(this);
				var e = this.maxByteWidthsCache.access(),
					n = this.indexCache.access(),
					r = this.dict.context;
				this.dict.set(Zs.of("W"), r.obj(e)), this.dict.set(Zs.of("Index"), r.obj(n))
			}, e.create = function(t, n) {
				void 0 === n && (n = !0);
				var r = new e(t, [], n);
				return r.addDeletedEntry(ol.of(0, 65535), 0), r
			}, e.of = function(t, n, r) {
				return void 0 === r && (r = !0), new e(t, n, r)
			}, e
		}(ul);
		const Dl = El;
		var Ml = function(t) {
			function e(e, n, r, i) {
				var o = t.call(this, e, n) || this;
				return o.encodeStreams = r, o.objectsPerStream = i, o
			}
			return Do(e, t), e.prototype.computeBufferSize = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r, i, o, a, s, l, c, u, h, f, d, p, g, v, m, y;
					return Ro(this, (function(b) {
						switch (b.label) {
							case 0:
								t = this.context.largestObjectNumber + 1, e = Rs.forVersion(1, 7), n = e.sizeInBytes() + 2, r = Dl.create(this.createTrailerDict(), this.encodeStreams), i = [], o = [], a = [], s = this.context.enumerateIndirectObjects(), h = 0, f = s.length, b.label = 1;
							case 1:
								return h < f ? (l = s[h], p = l[0], c = l[1], p === this.context.trailerInfo.Encrypt || c instanceof el || c instanceof Al || 0 !== p.generationNumber ? (i.push(l), r.addUncompressedEntry(p, n), n += this.computeIndirectObjectSize(l), this.shouldWaitForTick(1) ? [4, fa()] : [3, 3]) : [3, 4]) : [3, 6];
							case 2:
								b.sent(), b.label = 3;
							case 3:
								return [3, 5];
							case 4:
								d = oa(o), u = oa(a), d && d.length % this.objectsPerStream != 0 || (d = [], o.push(d), u = ol.of(t++), a.push(u)), r.addCompressedEntry(p, u, d.length), d.push(l), b.label = 5;
							case 5:
								return h++, [3, 1];
							case 6:
								h = 0, f = o.length, b.label = 7;
							case 7:
								return h < f ? (d = o[h], p = a[h], g = kl.withContextAndObjects(this.context, d, this.encodeStreams), r.addUncompressedEntry(p, n), n += this.computeIndirectObjectSize([p, g]), i.push([p, g]), this.shouldWaitForTick(d.length) ? [4, fa()] : [3, 9]) : [3, 10];
							case 8:
								b.sent(), b.label = 9;
							case 9:
								return h++, [3, 7];
							case 10:
								return v = ol.of(t++), r.dict.set(Zs.of("Size"), Ns.of(t)), r.addUncompressedEntry(v, n), m = n, n += this.computeIndirectObjectSize([v, r]), i.push([v, r]), y = Sl.forLastCrossRefSectionOffset(m), [2, {
									size: n += y.sizeInBytes(),
									header: e,
									indirectObjects: i,
									trailer: y
								}]
						}
					}))
				}))
			}, e.forContext = function(t, n, r, i) {
				return void 0 === r && (r = !0), void 0 === i && (i = 50), new e(t, n, r, i)
			}, e
		}(Pl);
		const Il = Ml;
		var Rl = function(t) {
			function e(e) {
				var n = t.call(this) || this;
				return n.value = e, n
			}
			return Do(e, t), e.prototype.asBytes = function() {
				for (var t = this.value + (this.value.length % 2 == 1 ? "0" : ""), e = t.length, n = new Uint8Array(t.length / 2), r = 0, i = 0; r < e;) {
					var o = parseInt(t.substring(r, r + 2), 16);
					n[i] = o, r += 2, i += 1
				}
				return n
			}, e.prototype.decodeText = function() {
				var t = this.asBytes();
				return Sa(t) ? va(t) : is(t)
			}, e.prototype.decodeDate = function() {
				var t = this.decodeText(),
					e = ra(t);
				if (!e) throw new ms(t);
				return e
			}, e.prototype.asString = function() {
				return this.value
			}, e.prototype.clone = function() {
				return e.of(this.value)
			}, e.prototype.toString = function() {
				return "<" + this.value + ">"
			}, e.prototype.sizeInBytes = function() {
				return this.value.length + 2
			}, e.prototype.copyBytesInto = function(t, e) {
				return t[e++] = Is.LessThan, e += Yo(this.value, t, e), t[e++] = Is.GreaterThan, this.value.length + 2
			}, e.of = function(t) {
				return new e(t)
			}, e.fromText = function(t) {
				for (var n = function(t, e) {
						void 0 === e && (e = !0);
						var n = [];
						e && n.push(65279);
						for (var r = 0, i = t.length; r < i;) {
							var o = t.codePointAt(r);
							if (o < 65536) n.push(o), r += 1;
							else {
								if (!(o < 1114112)) throw new Error("Invalid code point: 0x" + Xo(o));
								n.push(da(o), pa(o)), r += 2
							}
						}
						return new Uint16Array(n)
					}(t), r = "", i = 0, o = n.length; i < o; i++) r += qo(n[i], 4);
				return new e(r)
			}, e
		}(Bs);
		const Bl = Rl;
		var Nl = function() {
			function t(t, e) {
				this.encoding = t === _a.ZapfDingbats ? La.ZapfDingbats : t === _a.Symbol ? La.Symbol : La.WinAnsi, this.font = Ia.load(t), this.fontName = this.font.FontName, this.customName = e
			}
			return t.prototype.encodeText = function(t) {
				for (var e = this.encodeTextAsGlyphs(t), n = new Array(e.length), r = 0, i = e.length; r < i; r++) n[r] = Xo(e[r].code);
				return Bl.of(n.join(""))
			}, t.prototype.widthOfTextAtSize = function(t, e) {
				for (var n = this.encodeTextAsGlyphs(t), r = 0, i = 0, o = n.length; i < o; i++) {
					var a = n[i].name,
						s = (n[i + 1] || {}).name,
						l = this.font.getXAxisKerningForPair(a, s) || 0;
					r += this.widthOfGlyph(a) + l
				}
				return r * (e / 1e3)
			}, t.prototype.heightOfFontAtSize = function(t, e) {
				void 0 === e && (e = {});
				var n = e.descender,
					r = void 0 === n || n,
					i = this.font,
					o = i.Ascender,
					a = i.Descender,
					s = i.FontBBox,
					l = (o || s[3]) - (a || s[1]);
				return r || (l += a || 0), l / 1e3 * t
			}, t.prototype.sizeOfFontAtHeight = function(t) {
				var e = this.font,
					n = e.Ascender,
					r = e.Descender,
					i = e.FontBBox;
				return 1e3 * t / ((n || i[3]) - (r || i[1]))
			}, t.prototype.embedIntoContext = function(t, e) {
				var n = t.obj({
					Type: "Font",
					Subtype: "Type1",
					BaseFont: this.customName || this.fontName,
					Encoding: this.encoding === La.WinAnsi ? "WinAnsiEncoding" : void 0
				});
				return e ? (t.assign(e, n), e) : t.register(n)
			}, t.prototype.widthOfGlyph = function(t) {
				return this.font.getWidthOfGlyph(t) || 250
			}, t.prototype.encodeTextAsGlyphs = function(t) {
				for (var e = Array.from(t), n = new Array(e.length), r = 0, i = e.length; r < i; r++) {
					var o = e[r].codePointAt(0);
					n[r] = this.encoding.encodeUnicodeCodePoint(o)
				}
				return n
			}, t.for = function(e, n) {
				return new t(e, n)
			}, t
		}();
		const Ll = Nl;
		var zl = function() {
				for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
				return "<" + t.join("") + ">"
			},
			Wl = function(t) {
				return qo(t, 4)
			},
			Vl = function(t) {
				if (function(t) {
						return t >= 0 && t <= 65535
					}(t)) return Wl(t);
				if (function(t) {
						return t >= 65536 && t <= 1114111
					}(t)) {
					var e = da(t),
						n = pa(t);
					return "" + Wl(e) + Wl(n)
				}
				var r = Xo(t);
				throw new Error("0x" + r + " is not a valid UTF-8 or UTF-16 codepoint.")
			},
			Ul = function(t) {
				function e(e) {
					var n = t.call(this) || this;
					return n.value = e, n
				}
				return Do(e, t), e.prototype.asBytes = function() {
					for (var t = [], e = "", n = !1, r = function(e) {
							void 0 !== e && t.push(e), n = !1
						}, i = 0, o = this.value.length; i < o; i++) {
						var a = this.value[i],
							s = Ho(a),
							l = this.value[i + 1];
						n ? s === Is.Newline || s === Is.CarriageReturn ? r() : s === Is.n ? r(Is.Newline) : s === Is.r ? r(Is.CarriageReturn) : s === Is.t ? r(Is.Tab) : s === Is.b ? r(Is.Backspace) : s === Is.f ? r(Is.FormFeed) : s === Is.LeftParen ? r(Is.LeftParen) : s === Is.RightParen ? r(Is.RightParen) : s === Is.Backspace ? r(Is.BackSlash) : s >= Is.Zero && s <= Is.Seven ? 3 !== (e += a).length && l >= "0" && l <= "7" || (r(parseInt(e, 8)), e = "") : r(s) : s === Is.BackSlash ? n = !0 : r(s)
					}
					return new Uint8Array(t)
				}, e.prototype.decodeText = function() {
					var t = this.asBytes();
					return Sa(t) ? va(t) : is(t)
				}, e.prototype.decodeDate = function() {
					var t = this.decodeText(),
						e = ra(t);
					if (!e) throw new ms(t);
					return e
				}, e.prototype.asString = function() {
					return this.value
				}, e.prototype.clone = function() {
					return e.of(this.value)
				}, e.prototype.toString = function() {
					return "(" + this.value + ")"
				}, e.prototype.sizeInBytes = function() {
					return this.value.length + 2
				}, e.prototype.copyBytesInto = function(t, e) {
					return t[e++] = Is.LeftParen, e += Yo(this.value, t, e), t[e++] = Is.RightParen, this.value.length + 2
				}, e.of = function(t) {
					return new e(t)
				}, e.fromDate = function(t) {
					return new e("D:" + Ko(String(t.getUTCFullYear()), 4, "0") + Ko(String(t.getUTCMonth() + 1), 2, "0") + Ko(String(t.getUTCDate()), 2, "0") + Ko(String(t.getUTCHours()), 2, "0") + Ko(String(t.getUTCMinutes()), 2, "0") + Ko(String(t.getUTCSeconds()), 2, "0") + "Z")
				}, e
			}(Bs);
		const Hl = Ul;
		var ql = function() {
			function t(t, e, n, r) {
				var i = this;
				this.allGlyphsInFontSortedById = function() {
					for (var t = new Array(i.font.characterSet.length), e = 0, n = t.length; e < n; e++) {
						var r = i.font.characterSet[e];
						t[e] = i.font.glyphForCodePoint(r)
					}
					return function(t, e) {
						for (var n = [], r = 0, i = t.length; r < i; r++) {
							var o = t[r],
								a = t[r - 1];
							0 !== r && e(o) === e(a) || n.push(o)
						}
						return n
					}(t.sort(ca), (function(t) {
						return t.id
					}))
				}, this.font = t, this.scale = 1e3 / this.font.unitsPerEm, this.fontData = e, this.fontName = this.font.postscriptName || "Font", this.customName = n, this.fontFeatures = r, this.baseFontName = "", this.glyphCache = os.populatedBy(this.allGlyphsInFontSortedById)
			}
			return t.for = function(e, n, r, i) {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return [4, e.create(n)];
							case 1:
								return [2, new t(o.sent(), n, r, i)]
						}
					}))
				}))
			}, t.prototype.encodeText = function(t) {
				for (var e = this.font.layout(t, this.fontFeatures).glyphs, n = new Array(e.length), r = 0, i = e.length; r < i; r++) n[r] = qo(e[r].id, 4);
				return Bl.of(n.join(""))
			}, t.prototype.widthOfTextAtSize = function(t, e) {
				for (var n = this.font.layout(t, this.fontFeatures).glyphs, r = 0, i = 0, o = n.length; i < o; i++) r += n[i].advanceWidth * this.scale;
				return r * (e / 1e3)
			}, t.prototype.heightOfFontAtSize = function(t, e) {
				void 0 === e && (e = {});
				var n = e.descender,
					r = void 0 === n || n,
					i = this.font,
					o = i.ascent,
					a = i.descent,
					s = i.bbox,
					l = (o || s.maxY) * this.scale - (a || s.minY) * this.scale;
				return r || (l -= Math.abs(a) || 0), l / 1e3 * t
			}, t.prototype.sizeOfFontAtHeight = function(t) {
				var e = this.font,
					n = e.ascent,
					r = e.descent,
					i = e.bbox;
				return 1e3 * t / ((n || i.maxY) * this.scale - (r || i.minY) * this.scale)
			}, t.prototype.embedIntoContext = function(t, e) {
				return this.baseFontName = this.customName || t.addRandomSuffix(this.fontName), this.embedFontDict(t, e)
			}, t.prototype.embedFontDict = function(t, e) {
				return Io(this, void 0, void 0, (function() {
					var n, r, i;
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return [4, this.embedCIDFontDict(t)];
							case 1:
								return n = o.sent(), r = this.embedUnicodeCmap(t), i = t.obj({
									Type: "Font",
									Subtype: "Type0",
									BaseFont: this.baseFontName,
									Encoding: "Identity-H",
									DescendantFonts: [n],
									ToUnicode: r
								}), e ? (t.assign(e, i), [2, e]) : [2, t.register(i)]
						}
					}))
				}))
			}, t.prototype.isCFF = function() {
				return this.font.cff
			}, t.prototype.embedCIDFontDict = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n;
					return Ro(this, (function(r) {
						switch (r.label) {
							case 0:
								return [4, this.embedFontDescriptor(t)];
							case 1:
								return e = r.sent(), n = t.obj({
									Type: "Font",
									Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
									CIDToGIDMap: "Identity",
									BaseFont: this.baseFontName,
									CIDSystemInfo: {
										Registry: Hl.of("Adobe"),
										Ordering: Hl.of("Identity"),
										Supplement: 0
									},
									FontDescriptor: e,
									W: this.computeWidths()
								}), [2, t.register(n)]
						}
					}))
				}))
			}, t.prototype.embedFontDescriptor = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n, r, i, o, a, s, l, c, u, h, f, d, p, g;
					return Ro(this, (function(v) {
						switch (v.label) {
							case 0:
								return [4, this.embedFontStream(t)];
							case 1:
								return e = v.sent(), n = this.scale, r = this.font, i = r.italicAngle, o = r.ascent, a = r.descent, s = r.capHeight, l = r.xHeight, c = this.font.bbox, u = c.minX, h = c.minY, f = c.maxX, d = c.maxY, p = t.obj(((g = {
									Type: "FontDescriptor",
									FontName: this.baseFontName,
									Flags: (x = this.font, w = x["OS/2"] ? x["OS/2"].sFamilyClass : 0, m = {
										fixedPitch: x.post.isFixedPitch,
										serif: 1 <= w && w <= 7,
										symbolic: !0,
										script: 10 === w,
										italic: x.head.macStyle.italic
									}, y = 0, b = function(t) {
										y |= 1 << t - 1
									}, m.fixedPitch && b(1), m.serif && b(2), m.symbolic && b(3), m.script && b(4), m.nonsymbolic && b(6), m.italic && b(7), m.allCap && b(17), m.smallCap && b(18), m.forceBold && b(19), y),
									FontBBox: [u * n, h * n, f * n, d * n],
									ItalicAngle: i,
									Ascent: o * n,
									Descent: a * n,
									CapHeight: (s || o) * n,
									XHeight: (l || 0) * n,
									StemV: 0
								})[this.isCFF() ? "FontFile3" : "FontFile2"] = e, g)), [2, t.register(p)]
						}
						var m, y, b, x, w
					}))
				}))
			}, t.prototype.serializeFont = function() {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(t) {
						return [2, this.fontData]
					}))
				}))
			}, t.prototype.embedFontStream = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n, r;
					return Ro(this, (function(i) {
						switch (i.label) {
							case 0:
								return r = (n = t).flateStream, [4, this.serializeFont()];
							case 1:
								return e = r.apply(n, [i.sent(), {
									Subtype: this.isCFF() ? "CIDFontType0C" : void 0
								}]), [2, t.register(e)]
						}
					}))
				}))
			}, t.prototype.embedUnicodeCmap = function(t) {
				var e = function(t, e) {
						for (var n = new Array(t.length), r = 0, i = t.length; r < i; r++) {
							var o = t[r],
								a = zl(Wl(e(o))),
								s = zl.apply(void 0, o.codePoints.map(Vl));
							n[r] = [a, s]
						}
						return function(t) {
							return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + t.length + " beginbfchar\n" + t.map((function(t) {
								return t[0] + " " + t[1]
							})).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"
						}(n)
					}(this.glyphCache.access(), this.glyphId.bind(this)),
					n = t.flateStream(e);
				return t.register(n)
			}, t.prototype.glyphId = function(t) {
				return t ? t.id : -1
			}, t.prototype.computeWidths = function() {
				for (var t = this.glyphCache.access(), e = [], n = [], r = 0, i = t.length; r < i; r++) {
					var o = t[r],
						a = t[r - 1],
						s = this.glyphId(o),
						l = this.glyphId(a);
					0 === r ? e.push(s) : s - l != 1 && (e.push(n), e.push(s), n = []), n.push(o.advanceWidth * this.scale)
				}
				return e.push(n), e
			}, t
		}();
		const Xl = ql;
		var Gl = function(t) {
			function e(e, n, r, i) {
				var o = t.call(this, e, n, r, i) || this;
				return o.subset = o.font.createSubset(), o.glyphs = [], o.glyphCache = os.populatedBy((function() {
					return o.glyphs
				})), o.glyphIdMap = new Map, o
			}
			return Do(e, t), e.for = function(t, n, r, i) {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return [4, t.create(n)];
							case 1:
								return [2, new e(o.sent(), n, r, i)]
						}
					}))
				}))
			}, e.prototype.encodeText = function(t) {
				for (var e = this.font.layout(t, this.fontFeatures).glyphs, n = new Array(e.length), r = 0, i = e.length; r < i; r++) {
					var o = e[r],
						a = this.subset.includeGlyph(o);
					this.glyphs[a - 1] = o, this.glyphIdMap.set(o.id, a), n[r] = qo(a, 4)
				}
				return this.glyphCache.invalidate(), Bl.of(n.join(""))
			}, e.prototype.isCFF = function() {
				return this.subset.cff
			}, e.prototype.glyphId = function(t) {
				return t ? this.glyphIdMap.get(t.id) : -1
			}, e.prototype.serializeFont = function() {
				var t = this;
				return new Promise((function(e, n) {
					var r = [];
					t.subset.encodeStream().on("data", (function(t) {
						return r.push(t)
					})).on("end", (function() {
						return e(function(t) {
							for (var e = 0, n = 0, r = t.length; n < r; n++) e += t[n].length;
							var i = new Uint8Array(e),
								o = 0;
							for (n = 0, r = t.length; n < r; n++) {
								var a = t[n];
								i.set(a, o), o += a.length
							}
							return i
						}(r))
					})).on("error", (function(t) {
						return n(t)
					}))
				}))
			}, e
		}(Xl);
		const Kl = Gl;
		var Yl;
		! function(t) {
			t.Source = "Source", t.Data = "Data", t.Alternative = "Alternative", t.Supplement = "Supplement", t.EncryptedPayload = "EncryptedPayload", t.FormData = "EncryptedPayload", t.Schema = "Schema", t.Unspecified = "Unspecified"
		}(Yl || (Yl = {}));
		const Zl = function() {
			function t(t, e, n) {
				void 0 === n && (n = {}), this.fileData = t, this.fileName = e, this.options = n
			}
			return t.for = function(e, n, r) {
				return void 0 === r && (r = {}), new t(e, n, r)
			}, t.prototype.embedIntoContext = function(t, e) {
				return Io(this, void 0, void 0, (function() {
					var n, r, i, o, a, s, l, c, u;
					return Ro(this, (function(h) {
						return n = this.options, r = n.mimeType, i = n.description, o = n.creationDate, a = n.modificationDate, s = n.afRelationship, l = t.flateStream(this.fileData, {
							Type: "EmbeddedFile",
							Subtype: null != r ? r : void 0,
							Params: {
								Size: this.fileData.length,
								CreationDate: o ? Hl.fromDate(o) : void 0,
								ModDate: a ? Hl.fromDate(a) : void 0
							}
						}), c = t.register(l), u = t.obj({
							Type: "Filespec",
							F: Hl.of(this.fileName),
							UF: Bl.fromText(this.fileName),
							EF: {
								F: c
							},
							Desc: i ? Bl.fromText(i) : void 0,
							AFRelationship: null != s ? s : void 0
						}), e ? (t.assign(e, u), [2, e]) : [2, t.register(u)]
					}))
				}))
			}, t
		}();
		var Jl, Ql = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487];
		! function(t) {
			t.DeviceGray = "DeviceGray", t.DeviceRGB = "DeviceRGB", t.DeviceCMYK = "DeviceCMYK"
		}(Jl || (Jl = {}));
		var $l = {
			1: Jl.DeviceGray,
			3: Jl.DeviceRGB,
			4: Jl.DeviceCMYK
		};
		const tc = function() {
			function t(t, e, n, r, i) {
				this.imageData = t, this.bitsPerComponent = e, this.width = n, this.height = r, this.colorSpace = i
			}
			return t.for = function(e) {
				return Io(this, void 0, void 0, (function() {
					var n, r, i, o, a, s, l, c;
					return Ro(this, (function(u) {
						if (65496 !== (n = new DataView(e.buffer)).getUint16(0)) throw new Error("SOI not found in JPEG");
						for (r = 2; r < n.byteLength && (i = n.getUint16(r), r += 2, !Ql.includes(i));) r += n.getUint16(r);
						if (!Ql.includes(i)) throw new Error("Invalid JPEG");
						if (r += 2, o = n.getUint8(r++), a = n.getUint16(r), r += 2, s = n.getUint16(r), r += 2, l = n.getUint8(r++), !(c = $l[l])) throw new Error("Unknown JPEG channel.");
						return [2, new t(e, o, s, a, c)]
					}))
				}))
			}, t.prototype.embedIntoContext = function(t, e) {
				return Io(this, void 0, void 0, (function() {
					var n;
					return Ro(this, (function(r) {
						return n = t.stream(this.imageData, {
							Type: "XObject",
							Subtype: "Image",
							BitsPerComponent: this.bitsPerComponent,
							Width: this.width,
							Height: this.height,
							ColorSpace: this.colorSpace,
							Filter: "DCTDecode",
							Decode: this.colorSpace === Jl.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
						}), e ? (t.assign(e, n), [2, e]) : [2, t.register(n)]
					}))
				}))
			}, t
		}();
		var ec = {
			toRGBA8: function(t) {
				var e = t.width,
					n = t.height;
				if (null == t.tabs.acTL) return [ec.toRGBA8.decodeImage(t.data, e, n, t).buffer];
				var r = [];
				null == t.frames[0].data && (t.frames[0].data = t.data);
				for (var i = e * n * 4, o = new Uint8Array(i), a = new Uint8Array(i), s = new Uint8Array(i), l = 0; l < t.frames.length; l++) {
					var c = t.frames[l],
						u = c.rect.x,
						h = c.rect.y,
						f = c.rect.width,
						d = c.rect.height,
						p = ec.toRGBA8.decodeImage(c.data, f, d, t);
					if (0 != l)
						for (var g = 0; g < i; g++) s[g] = o[g];
					if (0 == c.blend ? ec._copyTile(p, f, d, o, e, n, u, h, 0) : 1 == c.blend && ec._copyTile(p, f, d, o, e, n, u, h, 1), r.push(o.buffer.slice(0)), 0 == c.dispose);
					else if (1 == c.dispose) ec._copyTile(a, f, d, o, e, n, u, h, 0);
					else if (2 == c.dispose)
						for (g = 0; g < i; g++) o[g] = s[g]
				}
				return r
			}
		};
		ec.toRGBA8.decodeImage = function(t, e, n, r) {
			var i = e * n,
				o = ec.decode._getBPP(r),
				a = Math.ceil(e * o / 8),
				s = new Uint8Array(4 * i),
				l = new Uint32Array(s.buffer),
				c = r.ctype,
				u = r.depth,
				h = ec._bin.readUshort;
			if (Date.now(), 6 == c) {
				var f = i << 2;
				if (8 == u)
					for (var d = 0; d < f; d += 4) s[d] = t[d], s[d + 1] = t[d + 1], s[d + 2] = t[d + 2], s[d + 3] = t[d + 3];
				if (16 == u)
					for (d = 0; d < f; d++) s[d] = t[d << 1]
			} else if (2 == c) {
				var p = r.tabs.tRNS;
				if (null == p) {
					if (8 == u)
						for (d = 0; d < i; d++) {
							var g = 3 * d;
							l[d] = 255 << 24 | t[g + 2] << 16 | t[g + 1] << 8 | t[g]
						}
					if (16 == u)
						for (d = 0; d < i; d++) g = 6 * d, l[d] = 255 << 24 | t[g + 4] << 16 | t[g + 2] << 8 | t[g]
				} else {
					var v = p[0],
						m = p[1],
						y = p[2];
					if (8 == u)
						for (d = 0; d < i; d++) {
							var b = d << 2;
							g = 3 * d, l[d] = 255 << 24 | t[g + 2] << 16 | t[g + 1] << 8 | t[g], t[g] == v && t[g + 1] == m && t[g + 2] == y && (s[b + 3] = 0)
						}
					if (16 == u)
						for (d = 0; d < i; d++) b = d << 2, g = 6 * d, l[d] = 255 << 24 | t[g + 4] << 16 | t[g + 2] << 8 | t[g], h(t, g) == v && h(t, g + 2) == m && h(t, g + 4) == y && (s[b + 3] = 0)
				}
			} else if (3 == c) {
				var x = r.tabs.PLTE,
					w = r.tabs.tRNS,
					C = w ? w.length : 0;
				if (1 == u)
					for (var S = 0; S < n; S++) {
						var O = S * a,
							T = S * e;
						for (d = 0; d < e; d++) {
							b = T + d << 2;
							var k = 3 * (F = t[O + (d >> 3)] >> 7 - ((7 & d) << 0) & 1);
							s[b] = x[k], s[b + 1] = x[k + 1], s[b + 2] = x[k + 2], s[b + 3] = F < C ? w[F] : 255
						}
					}
				if (2 == u)
					for (S = 0; S < n; S++)
						for (O = S * a, T = S * e, d = 0; d < e; d++) b = T + d << 2, k = 3 * (F = t[O + (d >> 2)] >> 6 - ((3 & d) << 1) & 3), s[b] = x[k], s[b + 1] = x[k + 1], s[b + 2] = x[k + 2], s[b + 3] = F < C ? w[F] : 255;
				if (4 == u)
					for (S = 0; S < n; S++)
						for (O = S * a, T = S * e, d = 0; d < e; d++) b = T + d << 2, k = 3 * (F = t[O + (d >> 1)] >> 4 - ((1 & d) << 2) & 15), s[b] = x[k], s[b + 1] = x[k + 1], s[b + 2] = x[k + 2], s[b + 3] = F < C ? w[F] : 255;
				if (8 == u)
					for (d = 0; d < i; d++) {
						var F;
						b = d << 2, k = 3 * (F = t[d]), s[b] = x[k], s[b + 1] = x[k + 1], s[b + 2] = x[k + 2], s[b + 3] = F < C ? w[F] : 255
					}
			} else if (4 == c) {
				if (8 == u)
					for (d = 0; d < i; d++) {
						b = d << 2;
						var P = t[j = d << 1];
						s[b] = P, s[b + 1] = P, s[b + 2] = P, s[b + 3] = t[j + 1]
					}
				if (16 == u)
					for (d = 0; d < i; d++) {
						var j;
						b = d << 2, P = t[j = d << 2], s[b] = P, s[b + 1] = P, s[b + 2] = P, s[b + 3] = t[j + 2]
					}
			} else if (0 == c)
				for (v = r.tabs.tRNS ? r.tabs.tRNS : -1, S = 0; S < n; S++) {
					var A = S * a,
						_ = S * e;
					if (1 == u)
						for (var E = 0; E < e; E++) {
							var D = (P = 255 * (t[A + (E >>> 3)] >>> 7 - (7 & E) & 1)) == 255 * v ? 0 : 255;
							l[_ + E] = D << 24 | P << 16 | P << 8 | P
						} else if (2 == u)
							for (E = 0; E < e; E++) D = (P = 85 * (t[A + (E >>> 2)] >>> 6 - ((3 & E) << 1) & 3)) == 85 * v ? 0 : 255, l[_ + E] = D << 24 | P << 16 | P << 8 | P;
						else if (4 == u)
						for (E = 0; E < e; E++) D = (P = 17 * (t[A + (E >>> 1)] >>> 4 - ((1 & E) << 2) & 15)) == 17 * v ? 0 : 255, l[_ + E] = D << 24 | P << 16 | P << 8 | P;
					else if (8 == u)
						for (E = 0; E < e; E++) D = (P = t[A + E]) == v ? 0 : 255, l[_ + E] = D << 24 | P << 16 | P << 8 | P;
					else if (16 == u)
						for (E = 0; E < e; E++) P = t[A + (E << 1)], D = h(t, A + (E << d)) == v ? 0 : 255, l[_ + E] = D << 24 | P << 16 | P << 8 | P
				}
			return s
		}, ec.decode = function(t) {
			for (var e, n = new Uint8Array(t), r = 8, i = ec._bin, o = i.readUshort, a = i.readUint, s = {
					tabs: {},
					frames: []
				}, l = new Uint8Array(n.length), c = 0, u = 0, h = [137, 80, 78, 71, 13, 10, 26, 10], f = 0; f < 8; f++)
				if (n[f] != h[f]) throw "The input is not a PNG file!";
			for (; r < n.length;) {
				var d = i.readUint(n, r);
				r += 4;
				var p = i.readASCII(n, r, 4);
				if (r += 4, "IHDR" == p) ec.decode._IHDR(n, r, s);
				else if ("IDAT" == p) {
					for (f = 0; f < d; f++) l[c + f] = n[r + f];
					c += d
				} else if ("acTL" == p) s.tabs[p] = {
					num_frames: a(n, r),
					num_plays: a(n, r + 4)
				}, e = new Uint8Array(n.length);
				else if ("fcTL" == p) {
					var g;
					0 != u && ((g = s.frames[s.frames.length - 1]).data = ec.decode._decompress(s, e.slice(0, u), g.rect.width, g.rect.height), u = 0);
					var v = {
							x: a(n, r + 12),
							y: a(n, r + 16),
							width: a(n, r + 4),
							height: a(n, r + 8)
						},
						m = o(n, r + 22);
					m = o(n, r + 20) / (0 == m ? 100 : m);
					var y = {
						rect: v,
						delay: Math.round(1e3 * m),
						dispose: n[r + 24],
						blend: n[r + 25]
					};
					s.frames.push(y)
				} else if ("fdAT" == p) {
					for (f = 0; f < d - 4; f++) e[u + f] = n[r + f + 4];
					u += d - 4
				} else if ("pHYs" == p) s.tabs[p] = [i.readUint(n, r), i.readUint(n, r + 4), n[r + 8]];
				else if ("cHRM" == p)
					for (s.tabs[p] = [], f = 0; f < 8; f++) s.tabs[p].push(i.readUint(n, r + 4 * f));
				else if ("tEXt" == p) {
					null == s.tabs[p] && (s.tabs[p] = {});
					var b = i.nextZero(n, r),
						x = i.readASCII(n, r, b - r),
						w = i.readASCII(n, b + 1, r + d - b - 1);
					s.tabs[p][x] = w
				} else if ("iTXt" == p) {
					null == s.tabs[p] && (s.tabs[p] = {}), b = 0;
					var C = r;
					b = i.nextZero(n, C), x = i.readASCII(n, C, b - C), n[C = b + 1], n[C + 1], C += 2, b = i.nextZero(n, C), i.readASCII(n, C, b - C), C = b + 1, b = i.nextZero(n, C), i.readUTF8(n, C, b - C), C = b + 1, w = i.readUTF8(n, C, d - (C - r)), s.tabs[p][x] = w
				} else if ("PLTE" == p) s.tabs[p] = i.readBytes(n, r, d);
				else if ("hIST" == p) {
					var S = s.tabs.PLTE.length / 3;
					for (s.tabs[p] = [], f = 0; f < S; f++) s.tabs[p].push(o(n, r + 2 * f))
				} else if ("tRNS" == p) 3 == s.ctype ? s.tabs[p] = i.readBytes(n, r, d) : 0 == s.ctype ? s.tabs[p] = o(n, r) : 2 == s.ctype && (s.tabs[p] = [o(n, r), o(n, r + 2), o(n, r + 4)]);
				else if ("gAMA" == p) s.tabs[p] = i.readUint(n, r) / 1e5;
				else if ("sRGB" == p) s.tabs[p] = n[r];
				else if ("bKGD" == p) 0 == s.ctype || 4 == s.ctype ? s.tabs[p] = [o(n, r)] : 2 == s.ctype || 6 == s.ctype ? s.tabs[p] = [o(n, r), o(n, r + 2), o(n, r + 4)] : 3 == s.ctype && (s.tabs[p] = n[r]);
				else if ("IEND" == p) break;
				r += d, i.readUint(n, r), r += 4
			}
			return 0 != u && ((g = s.frames[s.frames.length - 1]).data = ec.decode._decompress(s, e.slice(0, u), g.rect.width, g.rect.height), u = 0), s.data = ec.decode._decompress(s, l, s.width, s.height), delete s.compress, delete s.interlace, delete s.filter, s
		}, ec.decode._decompress = function(t, e, n, r) {
			Date.now();
			var i = ec.decode._getBPP(t),
				o = Math.ceil(n * i / 8),
				a = new Uint8Array((o + 1 + t.interlace) * r);
			return e = ec.decode._inflate(e, a), Date.now(), 0 == t.interlace ? e = ec.decode._filterZero(e, t, 0, n, r) : 1 == t.interlace && (e = ec.decode._readInterlace(e, t)), e
		}, ec.decode._inflate = function(t, e) {
			return ec.inflateRaw(new Uint8Array(t.buffer, 2, t.length - 6), e)
		}, ec.inflateRaw = function() {
			var t = {
				H: {}
			};
			return t.H.N = function(e, n) {
					var r, i, o = Uint8Array,
						a = 0,
						s = 0,
						l = 0,
						c = 0,
						u = 0,
						h = 0,
						f = 0,
						d = 0,
						p = 0;
					if (3 == e[0] && 0 == e[1]) return n || new o(0);
					var g = t.H,
						v = g.b,
						m = g.e,
						y = g.R,
						b = g.n,
						x = g.A,
						w = g.Z,
						C = g.m,
						S = null == n;
					for (S && (n = new o(e.length >>> 2 << 3)); 0 == a;)
						if (a = v(e, p, 1), s = v(e, p + 1, 2), p += 3, 0 != s) {
							if (S && (n = t.H.W(n, d + (1 << 17))), 1 == s && (r = C.J, i = C.h, h = 511, f = 31), 2 == s) {
								l = m(e, p, 5) + 257, c = m(e, p + 5, 5) + 1, u = m(e, p + 10, 4) + 4, p += 14;
								for (var O = 1, T = 0; T < 38; T += 2) C.Q[T] = 0, C.Q[T + 1] = 0;
								for (T = 0; T < u; T++) {
									var k = m(e, p + 3 * T, 3);
									C.Q[1 + (C.X[T] << 1)] = k, k > O && (O = k)
								}
								p += 3 * u, b(C.Q, O), x(C.Q, O, C.u), r = C.w, i = C.d, p = y(C.u, (1 << O) - 1, l + c, e, p, C.v);
								var F = g.V(C.v, 0, l, C.C);
								h = (1 << F) - 1;
								var P = g.V(C.v, l, c, C.D);
								f = (1 << P) - 1, b(C.C, F), x(C.C, F, r), b(C.D, P), x(C.D, P, i)
							}
							for (;;) {
								var j = r[w(e, p) & h];
								p += 15 & j;
								var A = j >>> 4;
								if (A >>> 8 == 0) n[d++] = A;
								else {
									if (256 == A) break;
									var _ = d + A - 254;
									if (A > 264) {
										var E = C.q[A - 257];
										_ = d + (E >>> 3) + m(e, p, 7 & E), p += 7 & E
									}
									var D = i[w(e, p) & f];
									p += 15 & D;
									var M = D >>> 4,
										I = C.c[M],
										R = (I >>> 4) + v(e, p, 15 & I);
									for (p += 15 & I; d < _;) n[d] = n[d++ - R], n[d] = n[d++ - R], n[d] = n[d++ - R], n[d] = n[d++ - R];
									d = _
								}
							}
						} else {
							0 != (7 & p) && (p += 8 - (7 & p));
							var B = 4 + (p >>> 3),
								N = e[B - 4] | e[B - 3] << 8;
							S && (n = t.H.W(n, d + N)), n.set(new o(e.buffer, e.byteOffset + B, N), d), p = B + N << 3, d += N
						} return n.length == d ? n : n.slice(0, d)
				}, t.H.W = function(t, e) {
					var n = t.length;
					if (e <= n) return t;
					var r = new Uint8Array(n << 1);
					return r.set(t, 0), r
				}, t.H.R = function(e, n, r, i, o, a) {
					for (var s = t.H.e, l = t.H.Z, c = 0; c < r;) {
						var u = e[l(i, o) & n];
						o += 15 & u;
						var h = u >>> 4;
						if (h <= 15) a[c] = h, c++;
						else {
							var f = 0,
								d = 0;
							16 == h ? (d = 3 + s(i, o, 2), o += 2, f = a[c - 1]) : 17 == h ? (d = 3 + s(i, o, 3), o += 3) : 18 == h && (d = 11 + s(i, o, 7), o += 7);
							for (var p = c + d; c < p;) a[c] = f, c++
						}
					}
					return o
				}, t.H.V = function(t, e, n, r) {
					for (var i = 0, o = 0, a = r.length >>> 1; o < n;) {
						var s = t[o + e];
						r[o << 1] = 0, r[1 + (o << 1)] = s, s > i && (i = s), o++
					}
					for (; o < a;) r[o << 1] = 0, r[1 + (o << 1)] = 0, o++;
					return i
				}, t.H.n = function(e, n) {
					for (var r, i, o, a, s = t.H.m, l = e.length, c = s.j, u = 0; u <= n; u++) c[u] = 0;
					for (u = 1; u < l; u += 2) c[e[u]]++;
					var h = s.K;
					for (r = 0, c[0] = 0, i = 1; i <= n; i++) r = r + c[i - 1] << 1, h[i] = r;
					for (o = 0; o < l; o += 2) 0 != (a = e[o + 1]) && (e[o] = h[a], h[a]++)
				}, t.H.A = function(e, n, r) {
					for (var i = e.length, o = t.H.m.r, a = 0; a < i; a += 2)
						if (0 != e[a + 1])
							for (var s = a >> 1, l = e[a + 1], c = s << 4 | l, u = n - l, h = e[a] << u, f = h + (1 << u); h != f;) r[o[h] >>> 15 - n] = c, h++
				}, t.H.l = function(e, n) {
					for (var r = t.H.m.r, i = 15 - n, o = 0; o < e.length; o += 2) {
						var a = e[o] << n - e[o + 1];
						e[o] = r[a] >>> i
					}
				}, t.H.M = function(t, e, n) {
					n <<= 7 & e;
					var r = e >>> 3;
					t[r] |= n, t[r + 1] |= n >>> 8
				}, t.H.I = function(t, e, n) {
					n <<= 7 & e;
					var r = e >>> 3;
					t[r] |= n, t[r + 1] |= n >>> 8, t[r + 2] |= n >>> 16
				}, t.H.e = function(t, e, n) {
					return (t[e >>> 3] | t[1 + (e >>> 3)] << 8) >>> (7 & e) & (1 << n) - 1
				}, t.H.b = function(t, e, n) {
					return (t[e >>> 3] | t[1 + (e >>> 3)] << 8 | t[2 + (e >>> 3)] << 16) >>> (7 & e) & (1 << n) - 1
				}, t.H.Z = function(t, e) {
					return (t[e >>> 3] | t[1 + (e >>> 3)] << 8 | t[2 + (e >>> 3)] << 16) >>> (7 & e)
				}, t.H.i = function(t, e) {
					return (t[e >>> 3] | t[1 + (e >>> 3)] << 8 | t[2 + (e >>> 3)] << 16 | t[3 + (e >>> 3)] << 24) >>> (7 & e)
				}, t.H.m = function() {
					var t = Uint16Array,
						e = Uint32Array;
					return {
						K: new t(16),
						j: new t(16),
						X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
						S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
						T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
						q: new t(32),
						p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
						z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
						c: new e(32),
						J: new t(512),
						_: [],
						h: new t(32),
						$: [],
						w: new t(32768),
						C: [],
						v: [],
						d: new t(32768),
						D: [],
						u: new t(512),
						Q: [],
						r: new t(32768),
						s: new e(286),
						Y: new e(30),
						a: new e(19),
						t: new e(15e3),
						k: new t(65536),
						g: new t(32768)
					}
				}(),
				function() {
					for (var e = t.H.m, n = 0; n < 32768; n++) {
						var r = n;
						r = (4278255360 & (r = (4042322160 & (r = (3435973836 & (r = (2863311530 & r) >>> 1 | (1431655765 & r) << 1)) >>> 2 | (858993459 & r) << 2)) >>> 4 | (252645135 & r) << 4)) >>> 8 | (16711935 & r) << 8, e.r[n] = (r >>> 16 | r << 16) >>> 17
					}

					function i(t, e, n) {
						for (; 0 != e--;) t.push(0, n)
					}
					for (n = 0; n < 32; n++) e.q[n] = e.S[n] << 3 | e.T[n], e.c[n] = e.p[n] << 4 | e.z[n];
					i(e._, 144, 8), i(e._, 112, 9), i(e._, 24, 7), i(e._, 8, 8), t.H.n(e._, 9), t.H.A(e._, 9, e.J), t.H.l(e._, 9), i(e.$, 32, 5), t.H.n(e.$, 5), t.H.A(e.$, 5, e.h), t.H.l(e.$, 5), i(e.Q, 19, 0), i(e.C, 286, 0), i(e.D, 30, 0), i(e.v, 320, 0)
				}(), t.H.N
		}(), ec.decode._readInterlace = function(t, e) {
			for (var n = e.width, r = e.height, i = ec.decode._getBPP(e), o = i >> 3, a = Math.ceil(n * i / 8), s = new Uint8Array(r * a), l = 0, c = [0, 0, 4, 0, 2, 0, 1], u = [0, 4, 0, 2, 0, 1, 0], h = [8, 8, 8, 4, 4, 2, 2], f = [8, 8, 4, 4, 2, 2, 1], d = 0; d < 7;) {
				for (var p = h[d], g = f[d], v = 0, m = 0, y = c[d]; y < r;) y += p, m++;
				for (var b = u[d]; b < n;) b += g, v++;
				var x = Math.ceil(v * i / 8);
				ec.decode._filterZero(t, e, l, v, m);
				for (var w = 0, C = c[d]; C < r;) {
					for (var S = u[d], O = l + w * x << 3; S < n;) {
						var T;
						if (1 == i && (T = (T = t[O >> 3]) >> 7 - (7 & O) & 1, s[C * a + (S >> 3)] |= T << 7 - ((7 & S) << 0)), 2 == i && (T = (T = t[O >> 3]) >> 6 - (7 & O) & 3, s[C * a + (S >> 2)] |= T << 6 - ((3 & S) << 1)), 4 == i && (T = (T = t[O >> 3]) >> 4 - (7 & O) & 15, s[C * a + (S >> 1)] |= T << 4 - ((1 & S) << 2)), i >= 8)
							for (var k = C * a + S * o, F = 0; F < o; F++) s[k + F] = t[(O >> 3) + F];
						O += i, S += g
					}
					w++, C += p
				}
				v * m != 0 && (l += m * (1 + x)), d += 1
			}
			return s
		}, ec.decode._getBPP = function(t) {
			return [1, null, 3, 1, 2, null, 4][t.ctype] * t.depth
		}, ec.decode._filterZero = function(t, e, n, r, i) {
			var o = ec.decode._getBPP(e),
				a = Math.ceil(r * o / 8),
				s = ec.decode._paeth;
			o = Math.ceil(o / 8);
			var l = 0,
				c = 1,
				u = t[n],
				h = 0;
			if (u > 1 && (t[n] = [0, 0, 1][u - 2]), 3 == u)
				for (h = o; h < a; h++) t[h + 1] = t[h + 1] + (t[h + 1 - o] >>> 1) & 255;
			for (var f = 0; f < i; f++)
				if (h = 0, 0 == (u = t[(c = (l = n + f * a) + f + 1) - 1]))
					for (; h < a; h++) t[l + h] = t[c + h];
				else if (1 == u) {
				for (; h < o; h++) t[l + h] = t[c + h];
				for (; h < a; h++) t[l + h] = t[c + h] + t[l + h - o]
			} else if (2 == u)
				for (; h < a; h++) t[l + h] = t[c + h] + t[l + h - a];
			else if (3 == u) {
				for (; h < o; h++) t[l + h] = t[c + h] + (t[l + h - a] >>> 1);
				for (; h < a; h++) t[l + h] = t[c + h] + (t[l + h - a] + t[l + h - o] >>> 1)
			} else {
				for (; h < o; h++) t[l + h] = t[c + h] + s(0, t[l + h - a], 0);
				for (; h < a; h++) t[l + h] = t[c + h] + s(t[l + h - o], t[l + h - a], t[l + h - o - a])
			}
			return t
		}, ec.decode._paeth = function(t, e, n) {
			var r = t + e - n,
				i = r - t,
				o = r - e,
				a = r - n;
			return i * i <= o * o && i * i <= a * a ? t : o * o <= a * a ? e : n
		}, ec.decode._IHDR = function(t, e, n) {
			var r = ec._bin;
			n.width = r.readUint(t, e), e += 4, n.height = r.readUint(t, e), e += 4, n.depth = t[e], e++, n.ctype = t[e], e++, n.compress = t[e], e++, n.filter = t[e], e++, n.interlace = t[e], e++
		}, ec._bin = {
			nextZero: function(t, e) {
				for (; 0 != t[e];) e++;
				return e
			},
			readUshort: function(t, e) {
				return t[e] << 8 | t[e + 1]
			},
			writeUshort: function(t, e, n) {
				t[e] = n >> 8 & 255, t[e + 1] = 255 & n
			},
			readUint: function(t, e) {
				return 16777216 * t[e] + (t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3])
			},
			writeUint: function(t, e, n) {
				t[e] = n >> 24 & 255, t[e + 1] = n >> 16 & 255, t[e + 2] = n >> 8 & 255, t[e + 3] = 255 & n
			},
			readASCII: function(t, e, n) {
				for (var r = "", i = 0; i < n; i++) r += String.fromCharCode(t[e + i]);
				return r
			},
			writeASCII: function(t, e, n) {
				for (var r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r)
			},
			readBytes: function(t, e, n) {
				for (var r = [], i = 0; i < n; i++) r.push(t[e + i]);
				return r
			},
			pad: function(t) {
				return t.length < 2 ? "0" + t : t
			},
			readUTF8: function(t, e, n) {
				for (var r, i = "", o = 0; o < n; o++) i += "%" + ec._bin.pad(t[e + o].toString(16));
				try {
					r = decodeURIComponent(i)
				} catch (r) {
					return ec._bin.readASCII(t, e, n)
				}
				return r
			}
		}, ec._copyTile = function(t, e, n, r, i, o, a, s, l) {
			for (var c = Math.min(e, i), u = Math.min(n, o), h = 0, f = 0, d = 0; d < u; d++)
				for (var p = 0; p < c; p++)
					if (a >= 0 && s >= 0 ? (h = d * e + p << 2, f = (s + d) * i + a + p << 2) : (h = (-s + d) * e - a + p << 2, f = d * i + p << 2), 0 == l) r[f] = t[h], r[f + 1] = t[h + 1], r[f + 2] = t[h + 2], r[f + 3] = t[h + 3];
					else if (1 == l) {
				var g = t[h + 3] * (1 / 255),
					v = t[h] * g,
					m = t[h + 1] * g,
					y = t[h + 2] * g,
					b = r[f + 3] * (1 / 255),
					x = r[f] * b,
					w = r[f + 1] * b,
					C = r[f + 2] * b,
					S = 1 - g,
					O = g + b * S,
					T = 0 == O ? 0 : 1 / O;
				r[f + 3] = 255 * O, r[f + 0] = (v + x * S) * T, r[f + 1] = (m + w * S) * T, r[f + 2] = (y + C * S) * T
			} else if (2 == l) g = t[h + 3], v = t[h], m = t[h + 1], y = t[h + 2], b = r[f + 3], x = r[f], w = r[f + 1], C = r[f + 2], g == b && v == x && m == w && y == C ? (r[f] = 0, r[f + 1] = 0, r[f + 2] = 0, r[f + 3] = 0) : (r[f] = v, r[f + 1] = m, r[f + 2] = y, r[f + 3] = g);
			else if (3 == l) {
				if (g = t[h + 3], v = t[h], m = t[h + 1], y = t[h + 2], b = r[f + 3], x = r[f], w = r[f + 1], C = r[f + 2], g == b && v == x && m == w && y == C) continue;
				if (g < 220 && b > 20) return !1
			}
			return !0
		}, ec.encode = function(t, e, n, r, i, o, a) {
			null == r && (r = 0), null == a && (a = !1);
			var s = ec.encode.compress(t, e, n, r, [!1, !1, !1, 0, a]);
			return ec.encode.compressPNG(s, -1), ec.encode._main(s, e, n, i, o)
		}, ec.encodeLL = function(t, e, n, r, i, o, a, s) {
			for (var l = {
					ctype: 0 + (1 == r ? 0 : 2) + (0 == i ? 0 : 4),
					depth: o,
					frames: []
				}, c = (Date.now(), (r + i) * o), u = c * e, h = 0; h < t.length; h++) l.frames.push({
				rect: {
					x: 0,
					y: 0,
					width: e,
					height: n
				},
				img: new Uint8Array(t[h]),
				blend: 0,
				dispose: 1,
				bpp: Math.ceil(c / 8),
				bpl: Math.ceil(u / 8)
			});
			return ec.encode.compressPNG(l, 0, !0), ec.encode._main(l, e, n, a, s)
		}, ec.encode._main = function(t, e, n, r, i) {
			null == i && (i = {});
			var o = ec.crc.crc,
				a = ec._bin.writeUint,
				s = ec._bin.writeUshort,
				l = ec._bin.writeASCII,
				c = 8,
				u = t.frames.length > 1,
				h = !1,
				f = 33 + (u ? 20 : 0);
			if (null != i.sRGB && (f += 13), null != i.pHYs && (f += 21), 3 == t.ctype) {
				for (var d = t.plte.length, p = 0; p < d; p++) t.plte[p] >>> 24 != 255 && (h = !0);
				f += 8 + 3 * d + 4 + (h ? 8 + 1 * d + 4 : 0)
			}
			for (var g = 0; g < t.frames.length; g++) u && (f += 38), f += (O = t.frames[g]).cimg.length + 12, 0 != g && (f += 4);
			f += 12;
			var v = new Uint8Array(f),
				m = [137, 80, 78, 71, 13, 10, 26, 10];
			for (p = 0; p < 8; p++) v[p] = m[p];
			if (a(v, c, 13), l(v, c += 4, "IHDR"), a(v, c += 4, e), a(v, c += 4, n), v[c += 4] = t.depth, v[++c] = t.ctype, v[++c] = 0, v[++c] = 0, v[++c] = 0, a(v, ++c, o(v, c - 17, 17)), c += 4, null != i.sRGB && (a(v, c, 1), l(v, c += 4, "sRGB"), v[c += 4] = i.sRGB, a(v, ++c, o(v, c - 5, 5)), c += 4), null != i.pHYs && (a(v, c, 9), l(v, c += 4, "pHYs"), a(v, c += 4, i.pHYs[0]), a(v, c += 4, i.pHYs[1]), v[c += 4] = i.pHYs[2], a(v, ++c, o(v, c - 13, 13)), c += 4), u && (a(v, c, 8), l(v, c += 4, "acTL"), a(v, c += 4, t.frames.length), a(v, c += 4, null != i.loop ? i.loop : 0), a(v, c += 4, o(v, c - 12, 12)), c += 4), 3 == t.ctype) {
				for (a(v, c, 3 * (d = t.plte.length)), l(v, c += 4, "PLTE"), c += 4, p = 0; p < d; p++) {
					var y = 3 * p,
						b = t.plte[p],
						x = 255 & b,
						w = b >>> 8 & 255,
						C = b >>> 16 & 255;
					v[c + y + 0] = x, v[c + y + 1] = w, v[c + y + 2] = C
				}
				if (a(v, c += 3 * d, o(v, c - 3 * d - 4, 3 * d + 4)), c += 4, h) {
					for (a(v, c, d), l(v, c += 4, "tRNS"), c += 4, p = 0; p < d; p++) v[c + p] = t.plte[p] >>> 24 & 255;
					a(v, c += d, o(v, c - d - 4, d + 4)), c += 4
				}
			}
			var S = 0;
			for (g = 0; g < t.frames.length; g++) {
				var O = t.frames[g];
				u && (a(v, c, 26), l(v, c += 4, "fcTL"), a(v, c += 4, S++), a(v, c += 4, O.rect.width), a(v, c += 4, O.rect.height), a(v, c += 4, O.rect.x), a(v, c += 4, O.rect.y), s(v, c += 4, r[g]), s(v, c += 2, 1e3), v[c += 2] = O.dispose, v[++c] = O.blend, a(v, ++c, o(v, c - 30, 30)), c += 4);
				var T = O.cimg;
				a(v, c, (d = T.length) + (0 == g ? 0 : 4));
				var k = c += 4;
				l(v, c, 0 == g ? "IDAT" : "fdAT"), c += 4, 0 != g && (a(v, c, S++), c += 4), v.set(T, c), a(v, c += d, o(v, k, c - k)), c += 4
			}
			return a(v, c, 0), l(v, c += 4, "IEND"), a(v, c += 4, o(v, c - 4, 4)), c += 4, v.buffer
		}, ec.encode.compressPNG = function(t, e, n) {
			for (var r = 0; r < t.frames.length; r++) {
				var i = t.frames[r],
					o = (i.rect.width, i.rect.height),
					a = new Uint8Array(o * i.bpl + o);
				i.cimg = ec.encode._filterZero(i.img, o, i.bpp, i.bpl, a, e, n)
			}
		}, ec.encode.compress = function(t, e, n, r, i) {
			for (var o = i[0], a = i[1], s = i[2], l = i[3], c = i[4], u = 6, h = 8, f = 255, d = 0; d < t.length; d++)
				for (var p = new Uint8Array(t[d]), g = p.length, v = 0; v < g; v += 4) f &= p[v + 3];
			var m = 255 != f,
				y = ec.encode.framize(t, e, n, o, a, s),
				b = {},
				x = [],
				w = [];
			if (0 != r) {
				var C = [];
				for (v = 0; v < y.length; v++) C.push(y[v].img.buffer);
				var S = ec.encode.concatRGBA(C),
					O = ec.quantize(S, r),
					T = 0,
					k = new Uint8Array(O.abuf);
				for (v = 0; v < y.length; v++) {
					var F = (q = y[v].img).length;
					for (w.push(new Uint8Array(O.inds.buffer, T >> 2, F >> 2)), d = 0; d < F; d += 4) q[d] = k[T + d], q[d + 1] = k[T + d + 1], q[d + 2] = k[T + d + 2], q[d + 3] = k[T + d + 3];
					T += F
				}
				for (v = 0; v < O.plte.length; v++) x.push(O.plte[v].est.rgba)
			} else
				for (d = 0; d < y.length; d++) {
					var P = y[d],
						j = new Uint32Array(P.img.buffer),
						A = P.rect.width,
						_ = (g = j.length, new Uint8Array(g));
					for (w.push(_), v = 0; v < g; v++) {
						var E = j[v];
						if (0 != v && E == j[v - 1]) _[v] = _[v - 1];
						else if (v > A && E == j[v - A]) _[v] = _[v - A];
						else {
							var D = b[E];
							if (null == D && (b[E] = D = x.length, x.push(E), x.length >= 300)) break;
							_[v] = D
						}
					}
				}
			var M = x.length;
			for (M <= 256 && 0 == c && (h = M <= 2 ? 1 : M <= 4 ? 2 : M <= 16 ? 4 : 8, h = Math.max(h, l)), d = 0; d < y.length; d++) {
				(P = y[d]).rect.x, P.rect.y, A = P.rect.width;
				var I = P.rect.height,
					R = P.img,
					B = (new Uint32Array(R.buffer), 4 * A),
					N = 4;
				if (M <= 256 && 0 == c) {
					B = Math.ceil(h * A / 8);
					for (var L = new Uint8Array(B * I), z = w[d], W = 0; W < I; W++) {
						v = W * B;
						var V = W * A;
						if (8 == h)
							for (var U = 0; U < A; U++) L[v + U] = z[V + U];
						else if (4 == h)
							for (U = 0; U < A; U++) L[v + (U >> 1)] |= z[V + U] << 4 - 4 * (1 & U);
						else if (2 == h)
							for (U = 0; U < A; U++) L[v + (U >> 2)] |= z[V + U] << 6 - 2 * (3 & U);
						else if (1 == h)
							for (U = 0; U < A; U++) L[v + (U >> 3)] |= z[V + U] << 7 - 1 * (7 & U)
					}
					R = L, u = 3, N = 1
				} else if (0 == m && 1 == y.length) {
					L = new Uint8Array(A * I * 3);
					var H = A * I;
					for (v = 0; v < H; v++) {
						var q, X = 4 * v;
						L[q = 3 * v] = R[X], L[q + 1] = R[X + 1], L[q + 2] = R[X + 2]
					}
					R = L, u = 2, N = 3, B = 3 * A
				}
				P.img = R, P.bpl = B, P.bpp = N
			}
			return {
				ctype: u,
				depth: h,
				plte: x,
				frames: y
			}
		}, ec.encode.framize = function(t, e, n, r, i, o) {
			for (var a = [], s = 0; s < t.length; s++) {
				var l, c = new Uint8Array(t[s]),
					u = new Uint32Array(c.buffer),
					h = 0,
					f = 0,
					d = e,
					p = n,
					g = r ? 1 : 0;
				if (0 != s) {
					for (var v = o || r || 1 == s || 0 != a[s - 2].dispose ? 1 : 2, m = 0, y = 1e9, b = 0; b < v; b++) {
						for (var x = new Uint8Array(t[s - 1 - b]), w = new Uint32Array(t[s - 1 - b]), C = e, S = n, O = -1, T = -1, k = 0; k < n; k++)
							for (var F = 0; F < e; F++) u[M = k * e + F] != w[M] && (F < C && (C = F), F > O && (O = F), k < S && (S = k), k > T && (T = k)); - 1 == O && (C = S = O = T = 0), i && (1 == (1 & C) && C--, 1 == (1 & S) && S--);
						var P = (O - C + 1) * (T - S + 1);
						P < y && (y = P, m = b, h = C, f = S, d = O - C + 1, p = T - S + 1)
					}
					x = new Uint8Array(t[s - 1 - m]), 1 == m && (a[s - 1].dispose = 2), l = new Uint8Array(d * p * 4), ec._copyTile(x, e, n, l, d, p, -h, -f, 0), 1 == (g = ec._copyTile(c, e, n, l, d, p, -h, -f, 3) ? 1 : 0) ? ec.encode._prepareDiff(c, e, n, l, {
						x: h,
						y: f,
						width: d,
						height: p
					}) : ec._copyTile(c, e, n, l, d, p, -h, -f, 0)
				} else l = c.slice(0);
				a.push({
					rect: {
						x: h,
						y: f,
						width: d,
						height: p
					},
					img: l,
					blend: g,
					dispose: 0
				})
			}
			if (r)
				for (s = 0; s < a.length; s++)
					if (1 != (I = a[s]).blend) {
						var j = I.rect,
							A = a[s - 1].rect,
							_ = Math.min(j.x, A.x),
							E = Math.min(j.y, A.y),
							D = {
								x: _,
								y: E,
								width: Math.max(j.x + j.width, A.x + A.width) - _,
								height: Math.max(j.y + j.height, A.y + A.height) - E
							};
						a[s - 1].dispose = 1, s - 1 != 0 && ec.encode._updateFrame(t, e, n, a, s - 1, D, i), ec.encode._updateFrame(t, e, n, a, s, D, i)
					} if (1 != t.length)
				for (var M = 0; M < a.length; M++) {
					var I;
					(I = a[M]).rect.width, I.rect.height
				}
			return a
		}, ec.encode._updateFrame = function(t, e, n, r, i, o, a) {
			for (var s = Uint8Array, l = Uint32Array, c = new s(t[i - 1]), u = new l(t[i - 1]), h = i + 1 < t.length ? new s(t[i + 1]) : null, f = new s(t[i]), d = new l(f.buffer), p = e, g = n, v = -1, m = -1, y = 0; y < o.height; y++)
				for (var b = 0; b < o.width; b++) {
					var x = o.x + b,
						w = o.y + y,
						C = w * e + x,
						S = d[C];
					0 == S || 0 == r[i - 1].dispose && u[C] == S && (null == h || 0 != h[4 * C + 3]) || (x < p && (p = x), x > v && (v = x), w < g && (g = w), w > m && (m = w))
				} - 1 == v && (p = g = v = m = 0), a && (1 == (1 & p) && p--, 1 == (1 & g) && g--), o = {
					x: p,
					y: g,
					width: v - p + 1,
					height: m - g + 1
				};
			var O = r[i];
			O.rect = o, O.blend = 1, O.img = new Uint8Array(o.width * o.height * 4), 0 == r[i - 1].dispose ? (ec._copyTile(c, e, n, O.img, o.width, o.height, -o.x, -o.y, 0), ec.encode._prepareDiff(f, e, n, O.img, o)) : ec._copyTile(f, e, n, O.img, o.width, o.height, -o.x, -o.y, 0)
		}, ec.encode._prepareDiff = function(t, e, n, r, i) {
			ec._copyTile(t, e, n, r, i.width, i.height, -i.x, -i.y, 2)
		}, ec.encode._filterZero = function(t, e, n, r, i, o, a) {
			var s, l = [],
				c = [0, 1, 2, 3, 4]; - 1 != o ? c = [o] : (e * r > 5e5 || 1 == n) && (c = [0]), a && (s = {
				level: 0
			});
			for (var u = a && null != UZIP ? UZIP : Pa(), h = 0; h < c.length; h++) {
				for (var f = 0; f < e; f++) ec.encode._filterLine(i, t, f, r, n, c[h]);
				l.push(u.deflate(i, s))
			}
			var d, p = 1e9;
			for (h = 0; h < l.length; h++) l[h].length < p && (d = h, p = l[h].length);
			return l[d]
		}, ec.encode._filterLine = function(t, e, n, r, i, o) {
			var a = n * r,
				s = a + n,
				l = ec.decode._paeth;
			if (t[s] = o, s++, 0 == o)
				if (r < 500)
					for (var c = 0; c < r; c++) t[s + c] = e[a + c];
				else t.set(new Uint8Array(e.buffer, a, r), s);
			else if (1 == o) {
				for (c = 0; c < i; c++) t[s + c] = e[a + c];
				for (c = i; c < r; c++) t[s + c] = e[a + c] - e[a + c - i] + 256 & 255
			} else if (0 == n) {
				for (c = 0; c < i; c++) t[s + c] = e[a + c];
				if (2 == o)
					for (c = i; c < r; c++) t[s + c] = e[a + c];
				if (3 == o)
					for (c = i; c < r; c++) t[s + c] = e[a + c] - (e[a + c - i] >> 1) + 256 & 255;
				if (4 == o)
					for (c = i; c < r; c++) t[s + c] = e[a + c] - l(e[a + c - i], 0, 0) + 256 & 255
			} else {
				if (2 == o)
					for (c = 0; c < r; c++) t[s + c] = e[a + c] + 256 - e[a + c - r] & 255;
				if (3 == o) {
					for (c = 0; c < i; c++) t[s + c] = e[a + c] + 256 - (e[a + c - r] >> 1) & 255;
					for (c = i; c < r; c++) t[s + c] = e[a + c] + 256 - (e[a + c - r] + e[a + c - i] >> 1) & 255
				}
				if (4 == o) {
					for (c = 0; c < i; c++) t[s + c] = e[a + c] + 256 - l(0, e[a + c - r], 0) & 255;
					for (c = i; c < r; c++) t[s + c] = e[a + c] + 256 - l(e[a + c - i], e[a + c - r], e[a + c - i - r]) & 255
				}
			}
		}, ec.crc = {
			table: function() {
				for (var t = new Uint32Array(256), e = 0; e < 256; e++) {
					for (var n = e, r = 0; r < 8; r++) 1 & n ? n = 3988292384 ^ n >>> 1 : n >>>= 1;
					t[e] = n
				}
				return t
			}(),
			update: function(t, e, n, r) {
				for (var i = 0; i < r; i++) t = ec.crc.table[255 & (t ^ e[n + i])] ^ t >>> 8;
				return t
			},
			crc: function(t, e, n) {
				return 4294967295 ^ ec.crc.update(4294967295, t, e, n)
			}
		}, ec.quantize = function(t, e) {
			for (var n = new Uint8Array(t), r = n.slice(0), i = new Uint32Array(r.buffer), o = ec.quantize.getKDtree(r, e), a = o[0], s = o[1], l = (ec.quantize.planeDst, n), c = i, u = l.length, h = new Uint8Array(n.length >> 2), f = 0; f < u; f += 4) {
				var d = l[f] * (1 / 255),
					p = l[f + 1] * (1 / 255),
					g = l[f + 2] * (1 / 255),
					v = l[f + 3] * (1 / 255),
					m = ec.quantize.getNearest(a, d, p, g, v);
				h[f >> 2] = m.ind, c[f >> 2] = m.est.rgba
			}
			return {
				abuf: r.buffer,
				inds: h,
				plte: s
			}
		}, ec.quantize.getKDtree = function(t, e, n) {
			null == n && (n = 1e-4);
			var r = new Uint32Array(t.buffer),
				i = {
					i0: 0,
					i1: t.length,
					bst: null,
					est: null,
					tdst: 0,
					left: null,
					right: null
				};
			i.bst = ec.quantize.stats(t, i.i0, i.i1), i.est = ec.quantize.estats(i.bst);
			for (var o = [i]; o.length < e;) {
				for (var a = 0, s = 0, l = 0; l < o.length; l++) o[l].est.L > a && (a = o[l].est.L, s = l);
				if (a < n) break;
				var c = o[s],
					u = ec.quantize.splitPixels(t, r, c.i0, c.i1, c.est.e, c.est.eMq255);
				if (c.i0 >= u || c.i1 <= u) c.est.L = 0;
				else {
					var h = {
						i0: c.i0,
						i1: u,
						bst: null,
						est: null,
						tdst: 0,
						left: null,
						right: null
					};
					h.bst = ec.quantize.stats(t, h.i0, h.i1), h.est = ec.quantize.estats(h.bst);
					var f = {
						i0: u,
						i1: c.i1,
						bst: null,
						est: null,
						tdst: 0,
						left: null,
						right: null
					};
					for (f.bst = {
							R: [],
							m: [],
							N: c.bst.N - h.bst.N
						}, l = 0; l < 16; l++) f.bst.R[l] = c.bst.R[l] - h.bst.R[l];
					for (l = 0; l < 4; l++) f.bst.m[l] = c.bst.m[l] - h.bst.m[l];
					f.est = ec.quantize.estats(f.bst), c.left = h, c.right = f, o[s] = h, o.push(f)
				}
			}
			for (o.sort((function(t, e) {
					return e.bst.N - t.bst.N
				})), l = 0; l < o.length; l++) o[l].ind = l;
			return [i, o]
		}, ec.quantize.getNearest = function(t, e, n, r, i) {
			if (null == t.left) return t.tdst = ec.quantize.dist(t.est.q, e, n, r, i), t;
			var o = ec.quantize.planeDst(t.est, e, n, r, i),
				a = t.left,
				s = t.right;
			o > 0 && (a = t.right, s = t.left);
			var l = ec.quantize.getNearest(a, e, n, r, i);
			if (l.tdst <= o * o) return l;
			var c = ec.quantize.getNearest(s, e, n, r, i);
			return c.tdst < l.tdst ? c : l
		}, ec.quantize.planeDst = function(t, e, n, r, i) {
			var o = t.e;
			return o[0] * e + o[1] * n + o[2] * r + o[3] * i - t.eMq
		}, ec.quantize.dist = function(t, e, n, r, i) {
			var o = e - t[0],
				a = n - t[1],
				s = r - t[2],
				l = i - t[3];
			return o * o + a * a + s * s + l * l
		}, ec.quantize.splitPixels = function(t, e, n, r, i, o) {
			var a = ec.quantize.vecDot;
			for (r -= 4; n < r;) {
				for (; a(t, n, i) <= o;) n += 4;
				for (; a(t, r, i) > o;) r -= 4;
				if (n >= r) break;
				var s = e[n >> 2];
				e[n >> 2] = e[r >> 2], e[r >> 2] = s, n += 4, r -= 4
			}
			for (; a(t, n, i) > o;) n -= 4;
			return n + 4
		}, ec.quantize.vecDot = function(t, e, n) {
			return t[e] * n[0] + t[e + 1] * n[1] + t[e + 2] * n[2] + t[e + 3] * n[3]
		}, ec.quantize.stats = function(t, e, n) {
			for (var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i = [0, 0, 0, 0], o = n - e >> 2, a = e; a < n; a += 4) {
				var s = t[a] * (1 / 255),
					l = t[a + 1] * (1 / 255),
					c = t[a + 2] * (1 / 255),
					u = t[a + 3] * (1 / 255);
				i[0] += s, i[1] += l, i[2] += c, i[3] += u, r[0] += s * s, r[1] += s * l, r[2] += s * c, r[3] += s * u, r[5] += l * l, r[6] += l * c, r[7] += l * u, r[10] += c * c, r[11] += c * u, r[15] += u * u
			}
			return r[4] = r[1], r[8] = r[2], r[9] = r[6], r[12] = r[3], r[13] = r[7], r[14] = r[11], {
				R: r,
				m: i,
				N: o
			}
		}, ec.quantize.estats = function(t) {
			var e = t.R,
				n = t.m,
				r = t.N,
				i = n[0],
				o = n[1],
				a = n[2],
				s = n[3],
				l = 0 == r ? 0 : 1 / r,
				c = [e[0] - i * i * l, e[1] - i * o * l, e[2] - i * a * l, e[3] - i * s * l, e[4] - o * i * l, e[5] - o * o * l, e[6] - o * a * l, e[7] - o * s * l, e[8] - a * i * l, e[9] - a * o * l, e[10] - a * a * l, e[11] - a * s * l, e[12] - s * i * l, e[13] - s * o * l, e[14] - s * a * l, e[15] - s * s * l],
				u = c,
				h = ec.M4,
				f = [.5, .5, .5, .5],
				d = 0,
				p = 0;
			if (0 != r)
				for (var g = 0; g < 10 && (f = h.multVec(u, f), p = Math.sqrt(h.dot(f, f)), f = h.sml(1 / p, f), !(Math.abs(p - d) < 1e-9)); g++) d = p;
			var v = [i * l, o * l, a * l, s * l];
			return {
				Cov: c,
				q: v,
				e: f,
				L: d,
				eMq255: h.dot(h.sml(255, v), f),
				eMq: h.dot(f, v),
				rgba: (Math.round(255 * v[3]) << 24 | Math.round(255 * v[2]) << 16 | Math.round(255 * v[1]) << 8 | Math.round(255 * v[0]) << 0) >>> 0
			}
		}, ec.M4 = {
			multVec: function(t, e) {
				return [t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3], t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3], t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3], t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3]]
			},
			dot: function(t, e) {
				return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
			},
			sml: function(t, e) {
				return [t * e[0], t * e[1], t * e[2], t * e[3]]
			}
		}, ec.encode.concatRGBA = function(t) {
			for (var e = 0, n = 0; n < t.length; n++) e += t[n].byteLength;
			var r = new Uint8Array(e),
				i = 0;
			for (n = 0; n < t.length; n++) {
				for (var o = new Uint8Array(t[n]), a = o.length, s = 0; s < a; s += 4) {
					var l = o[s],
						c = o[s + 1],
						u = o[s + 2],
						h = o[s + 3];
					0 == h && (l = c = u = 0), r[i + s] = l, r[i + s + 1] = c, r[i + s + 2] = u, r[i + s + 3] = h
				}
				i += a
			}
			return r.buffer
		};
		const nc = ec;
		var rc;
		! function(t) {
			t.Greyscale = "Greyscale", t.Truecolour = "Truecolour", t.IndexedColour = "IndexedColour", t.GreyscaleWithAlpha = "GreyscaleWithAlpha", t.TruecolourWithAlpha = "TruecolourWithAlpha"
		}(rc || (rc = {}));
		var ic = function() {
			function t(t) {
				var e = nc.decode(t),
					n = nc.toRGBA8(e);
				if (n.length > 1) throw new Error("Animated PNGs are not supported");
				var r = function(t) {
						for (var e = Math.floor(t.length / 4), n = new Uint8Array(3 * e), r = new Uint8Array(1 * e), i = 0, o = 0, a = 0; i < t.length;) n[o++] = t[i++], n[o++] = t[i++], n[o++] = t[i++], r[a++] = t[i++];
						return {
							rgbChannel: n,
							alphaChannel: r
						}
					}(new Uint8Array(n[0])),
					i = r.rgbChannel,
					o = r.alphaChannel;
				this.rgbChannel = i, o.some((function(t) {
					return t < 255
				})) && (this.alphaChannel = o), this.type = function(t) {
					if (0 === t) return rc.Greyscale;
					if (2 === t) return rc.Truecolour;
					if (3 === t) return rc.IndexedColour;
					if (4 === t) return rc.GreyscaleWithAlpha;
					if (6 === t) return rc.TruecolourWithAlpha;
					throw new Error("Unknown color type: " + t)
				}(e.ctype), this.width = e.width, this.height = e.height, this.bitsPerComponent = 8
			}
			return t.load = function(e) {
				return new t(e)
			}, t
		}();
		const oc = function() {
				function t(t) {
					this.image = t, this.bitsPerComponent = t.bitsPerComponent, this.width = t.width, this.height = t.height, this.colorSpace = "DeviceRGB"
				}
				return t.for = function(e) {
					return Io(this, void 0, void 0, (function() {
						return Ro(this, (function(n) {
							return [2, new t(ic.load(e))]
						}))
					}))
				}, t.prototype.embedIntoContext = function(t, e) {
					return Io(this, void 0, void 0, (function() {
						var n, r;
						return Ro(this, (function(i) {
							return n = this.embedAlphaChannel(t), r = t.flateStream(this.image.rgbChannel, {
								Type: "XObject",
								Subtype: "Image",
								BitsPerComponent: this.image.bitsPerComponent,
								Width: this.image.width,
								Height: this.image.height,
								ColorSpace: this.colorSpace,
								SMask: n
							}), e ? (t.assign(e, r), [2, e]) : [2, t.register(r)]
						}))
					}))
				}, t.prototype.embedAlphaChannel = function(t) {
					if (this.image.alphaChannel) {
						var e = t.flateStream(this.image.alphaChannel, {
							Type: "XObject",
							Subtype: "Image",
							Height: this.image.height,
							Width: this.image.width,
							BitsPerComponent: this.image.bitsPerComponent,
							ColorSpace: "DeviceGray",
							Decode: [0, 1]
						});
						return t.register(e)
					}
				}, t
			}(),
			ac = function() {
				function t(t, e, n) {
					this.bytes = t, this.start = e || 0, this.pos = this.start, this.end = e && n ? e + n : this.bytes.length
				}
				return Object.defineProperty(t.prototype, "length", {
					get: function() {
						return this.end - this.start
					},
					enumerable: !1,
					configurable: !0
				}), Object.defineProperty(t.prototype, "isEmpty", {
					get: function() {
						return 0 === this.length
					},
					enumerable: !1,
					configurable: !0
				}), t.prototype.getByte = function() {
					return this.pos >= this.end ? -1 : this.bytes[this.pos++]
				}, t.prototype.getUint16 = function() {
					var t = this.getByte(),
						e = this.getByte();
					return -1 === t || -1 === e ? -1 : (t << 8) + e
				}, t.prototype.getInt32 = function() {
					return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte()
				}, t.prototype.getBytes = function(t, e) {
					void 0 === e && (e = !1);
					var n = this.bytes,
						r = this.pos,
						i = this.end;
					if (t) {
						var o = r + t;
						return o > i && (o = i), this.pos = o, a = n.subarray(r, o), e ? new Uint8ClampedArray(a) : a
					}
					var a = n.subarray(r, i);
					return e ? new Uint8ClampedArray(a) : a
				}, t.prototype.peekByte = function() {
					var t = this.getByte();
					return this.pos--, t
				}, t.prototype.peekBytes = function(t, e) {
					void 0 === e && (e = !1);
					var n = this.getBytes(t, e);
					return this.pos -= n.length, n
				}, t.prototype.skip = function(t) {
					t || (t = 1), this.pos += t
				}, t.prototype.reset = function() {
					this.pos = this.start
				}, t.prototype.moveStart = function() {
					this.start = this.pos
				}, t.prototype.makeSubStream = function(e, n) {
					return new t(this.bytes, e, n)
				}, t.prototype.decode = function() {
					return this.bytes
				}, t
			}();
		var sc = new Uint8Array(0),
			lc = function() {
				function t(t) {
					if (this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = sc, this.minBufferLength = 512, t)
						for (; this.minBufferLength < t;) this.minBufferLength *= 2
				}
				return Object.defineProperty(t.prototype, "isEmpty", {
					get: function() {
						for (; !this.eof && 0 === this.bufferLength;) this.readBlock();
						return 0 === this.bufferLength
					},
					enumerable: !1,
					configurable: !0
				}), t.prototype.getByte = function() {
					for (var t = this.pos; this.bufferLength <= t;) {
						if (this.eof) return -1;
						this.readBlock()
					}
					return this.buffer[this.pos++]
				}, t.prototype.getUint16 = function() {
					var t = this.getByte(),
						e = this.getByte();
					return -1 === t || -1 === e ? -1 : (t << 8) + e
				}, t.prototype.getInt32 = function() {
					return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte()
				}, t.prototype.getBytes = function(t, e) {
					var n;
					void 0 === e && (e = !1);
					var r = this.pos;
					if (t) {
						for (this.ensureBuffer(r + t), n = r + t; !this.eof && this.bufferLength < n;) this.readBlock();
						var i = this.bufferLength;
						n > i && (n = i)
					} else {
						for (; !this.eof;) this.readBlock();
						n = this.bufferLength
					}
					this.pos = n;
					var o = this.buffer.subarray(r, n);
					return !e || o instanceof Uint8ClampedArray ? o : new Uint8ClampedArray(o)
				}, t.prototype.peekByte = function() {
					var t = this.getByte();
					return this.pos--, t
				}, t.prototype.peekBytes = function(t, e) {
					void 0 === e && (e = !1);
					var n = this.getBytes(t, e);
					return this.pos -= n.length, n
				}, t.prototype.skip = function(t) {
					t || (t = 1), this.pos += t
				}, t.prototype.reset = function() {
					this.pos = 0
				}, t.prototype.makeSubStream = function(t, e) {
					for (var n = t + e; this.bufferLength <= n && !this.eof;) this.readBlock();
					return new ac(this.buffer, t, e)
				}, t.prototype.decode = function() {
					for (; !this.eof;) this.readBlock();
					return this.buffer.subarray(0, this.bufferLength)
				}, t.prototype.readBlock = function() {
					throw new ls(this.constructor.name, "readBlock")
				}, t.prototype.ensureBuffer = function(t) {
					var e = this.buffer;
					if (t <= e.byteLength) return e;
					for (var n = this.minBufferLength; n < t;) n *= 2;
					var r = new Uint8Array(n);
					return r.set(e), this.buffer = r
				}, t
			}();
		const cc = lc;
		var uc = function(t) {
				return 32 === t || 9 === t || 13 === t || 10 === t
			},
			hc = function(t) {
				function e(e, n) {
					var r = t.call(this, n) || this;
					return r.stream = e, r.input = new Uint8Array(5), n && (n *= .8), r
				}
				return Do(e, t), e.prototype.readBlock = function() {
					for (var t = this.stream, e = t.getByte(); uc(e);) e = t.getByte();
					if (-1 !== e && 126 !== e) {
						var n, r, i = this.bufferLength;
						if (122 === e) {
							for (n = this.ensureBuffer(i + 4), r = 0; r < 4; ++r) n[i + r] = 0;
							this.bufferLength += 4
						} else {
							var o = this.input;
							for (o[0] = e, r = 1; r < 5; ++r) {
								for (e = t.getByte(); uc(e);) e = t.getByte();
								if (o[r] = e, -1 === e || 126 === e) break
							}
							if (n = this.ensureBuffer(i + r - 1), this.bufferLength += r - 1, r < 5) {
								for (; r < 5; ++r) o[r] = 117;
								this.eof = !0
							}
							var a = 0;
							for (r = 0; r < 5; ++r) a = 85 * a + (o[r] - 33);
							for (r = 3; r >= 0; --r) n[i + r] = 255 & a, a >>= 8
						}
					} else this.eof = !0
				}, e
			}(cc);
		const fc = hc;
		var dc = function(t) {
			function e(e, n) {
				var r = t.call(this, n) || this;
				return r.stream = e, r.firstDigit = -1, n && (n *= .5), r
			}
			return Do(e, t), e.prototype.readBlock = function() {
				var t = this.stream.getBytes(8e3);
				if (t.length) {
					for (var e = t.length + 1 >> 1, n = this.ensureBuffer(this.bufferLength + e), r = this.bufferLength, i = this.firstDigit, o = 0, a = t.length; o < a; o++) {
						var s = t[o],
							l = void 0;
						if (s >= 48 && s <= 57) l = 15 & s;
						else {
							if (!(s >= 65 && s <= 70 || s >= 97 && s <= 102)) {
								if (62 === s) {
									this.eof = !0;
									break
								}
								continue
							}
							l = 9 + (15 & s)
						}
						i < 0 ? i = l : (n[r++] = i << 4 | l, i = -1)
					}
					i >= 0 && this.eof && (n[r++] = i << 4, i = -1), this.firstDigit = i, this.bufferLength = r
				} else this.eof = !0
			}, e
		}(cc);
		const pc = dc;
		var gc = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
			vc = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]),
			mc = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]),
			yc = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9],
			bc = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5],
			xc = function(t) {
				function e(e, n) {
					var r = t.call(this, n) || this;
					r.stream = e;
					var i = e.getByte(),
						o = e.getByte();
					if (-1 === i || -1 === o) throw new Error("Invalid header in flate stream: " + i + ", " + o);
					if (8 != (15 & i)) throw new Error("Unknown compression method in flate stream: " + i + ", " + o);
					if (((i << 8) + o) % 31 != 0) throw new Error("Bad FCHECK in flate stream: " + i + ", " + o);
					if (32 & o) throw new Error("FDICT bit set in flate stream: " + i + ", " + o);
					return r.codeSize = 0, r.codeBuf = 0, r
				}
				return Do(e, t), e.prototype.readBlock = function() {
					var t, e, n = this.stream,
						r = this.getBits(3);
					if (1 & r && (this.eof = !0), 0 != (r >>= 1)) {
						var i, o;
						if (1 === r) i = yc, o = bc;
						else {
							if (2 !== r) throw new Error("Unknown block type in flate stream");
							var a = this.getBits(5) + 257,
								s = this.getBits(5) + 1,
								l = this.getBits(4) + 4,
								c = new Uint8Array(gc.length),
								u = void 0;
							for (u = 0; u < l; ++u) c[gc[u]] = this.getBits(3);
							var h = this.generateHuffmanTable(c);
							e = 0, u = 0;
							for (var f = a + s, d = new Uint8Array(f), p = void 0, g = void 0, v = void 0; u < f;) {
								var m = this.getCode(h);
								if (16 === m) p = 2, g = 3, v = e;
								else if (17 === m) p = 3, g = 3, v = e = 0;
								else {
									if (18 !== m) {
										d[u++] = e = m;
										continue
									}
									p = 7, g = 11, v = e = 0
								}
								for (var y = this.getBits(p) + g; y-- > 0;) d[u++] = v
							}
							i = this.generateHuffmanTable(d.subarray(0, a)), o = this.generateHuffmanTable(d.subarray(a, f))
						}
						for (var b = (t = this.buffer) ? t.length : 0, x = this.bufferLength;;) {
							var w = this.getCode(i);
							if (w < 256) x + 1 >= b && (b = (t = this.ensureBuffer(x + 1)).length), t[x++] = w;
							else {
								if (256 === w) return void(this.bufferLength = x);
								var C = (w = vc[w -= 257]) >> 16;
								C > 0 && (C = this.getBits(C)), e = (65535 & w) + C, w = this.getCode(o), (C = (w = mc[w]) >> 16) > 0 && (C = this.getBits(C));
								var S = (65535 & w) + C;
								x + e >= b && (b = (t = this.ensureBuffer(x + e)).length);
								for (var O = 0; O < e; ++O, ++x) t[x] = t[x - S]
							}
						}
					} else {
						var T = void 0;
						if (-1 === (T = n.getByte())) throw new Error("Bad block header in flate stream");
						var k = T;
						if (-1 === (T = n.getByte())) throw new Error("Bad block header in flate stream");
						if (k |= T << 8, -1 === (T = n.getByte())) throw new Error("Bad block header in flate stream");
						var F = T;
						if (-1 === (T = n.getByte())) throw new Error("Bad block header in flate stream");
						if ((F |= T << 8) != (65535 & ~k) && (0 !== k || 0 !== F)) throw new Error("Bad uncompressed block length in flate stream");
						this.codeBuf = 0, this.codeSize = 0;
						var P = this.bufferLength;
						t = this.ensureBuffer(P + k);
						var j = P + k;
						if (this.bufferLength = j, 0 === k) - 1 === n.peekByte() && (this.eof = !0);
						else
							for (var A = P; A < j; ++A) {
								if (-1 === (T = n.getByte())) {
									this.eof = !0;
									break
								}
								t[A] = T
							}
					}
				}, e.prototype.getBits = function(t) {
					for (var e, n = this.stream, r = this.codeSize, i = this.codeBuf; r < t;) {
						if (-1 === (e = n.getByte())) throw new Error("Bad encoding in flate stream");
						i |= e << r, r += 8
					}
					return e = i & (1 << t) - 1, this.codeBuf = i >> t, this.codeSize = r -= t, e
				}, e.prototype.getCode = function(t) {
					for (var e, n = this.stream, r = t[0], i = t[1], o = this.codeSize, a = this.codeBuf; o < i && -1 !== (e = n.getByte());) a |= e << o, o += 8;
					var s = r[a & (1 << i) - 1];
					"number" == typeof r && console.log("FLATE:", s);
					var l = s >> 16,
						c = 65535 & s;
					if (l < 1 || o < l) throw new Error("Bad encoding in flate stream");
					return this.codeBuf = a >> l, this.codeSize = o - l, c
				}, e.prototype.generateHuffmanTable = function(t) {
					var e, n = t.length,
						r = 0;
					for (e = 0; e < n; ++e) t[e] > r && (r = t[e]);
					for (var i = 1 << r, o = new Int32Array(i), a = 1, s = 0, l = 2; a <= r; ++a, s <<= 1, l <<= 1)
						for (var c = 0; c < n; ++c)
							if (t[c] === a) {
								var u = 0,
									h = s;
								for (e = 0; e < a; ++e) u = u << 1 | 1 & h, h >>= 1;
								for (e = u; e < i; e += l) o[e] = a << 16 | c;
								++s
							} return [o, r]
				}, e
			}(cc);
		const wc = xc;
		var Cc = function(t) {
			function e(e, n, r) {
				var i = t.call(this, n) || this;
				i.stream = e, i.cachedData = 0, i.bitsCached = 0;
				for (var o = 4096, a = {
						earlyChange: r,
						codeLength: 9,
						nextCode: 258,
						dictionaryValues: new Uint8Array(o),
						dictionaryLengths: new Uint16Array(o),
						dictionaryPrevCodes: new Uint16Array(o),
						currentSequence: new Uint8Array(o),
						currentSequenceLength: 0
					}, s = 0; s < 256; ++s) a.dictionaryValues[s] = s, a.dictionaryLengths[s] = 1;
				return i.lzwState = a, i
			}
			return Do(e, t), e.prototype.readBlock = function() {
				var t, e, n, r = 1024,
					i = this.lzwState;
				if (i) {
					var o = i.earlyChange,
						a = i.nextCode,
						s = i.dictionaryValues,
						l = i.dictionaryLengths,
						c = i.dictionaryPrevCodes,
						u = i.codeLength,
						h = i.prevCode,
						f = i.currentSequence,
						d = i.currentSequenceLength,
						p = 0,
						g = this.bufferLength,
						v = this.ensureBuffer(this.bufferLength + r);
					for (t = 0; t < 512; t++) {
						var m = this.readBits(u),
							y = d > 0;
						if (!m || m < 256) f[0] = m, d = 1;
						else {
							if (!(m >= 258)) {
								if (256 === m) {
									u = 9, a = 258, d = 0;
									continue
								}
								this.eof = !0, delete this.lzwState;
								break
							}
							if (m < a)
								for (e = (d = l[m]) - 1, n = m; e >= 0; e--) f[e] = s[n], n = c[n];
							else f[d++] = f[0]
						}
						if (y && (c[a] = h, l[a] = l[h] + 1, s[a] = f[0], u = ++a + o & a + o - 1 ? u : 0 | Math.min(Math.log(a + o) / .6931471805599453 + 1, 12)), h = m, r < (p += d)) {
							do {
								r += 512
							} while (r < p);
							v = this.ensureBuffer(this.bufferLength + r)
						}
						for (e = 0; e < d; e++) v[g++] = f[e]
					}
					i.nextCode = a, i.codeLength = u, i.prevCode = h, i.currentSequenceLength = d, this.bufferLength = g
				}
			}, e.prototype.readBits = function(t) {
				for (var e = this.bitsCached, n = this.cachedData; e < t;) {
					var r = this.stream.getByte();
					if (-1 === r) return this.eof = !0, null;
					n = n << 8 | r, e += 8
				}
				return this.bitsCached = e -= t, this.cachedData = n, n >>> e & (1 << t) - 1
			}, e
		}(cc);
		const Sc = Cc;
		var Oc = function(t) {
			function e(e, n) {
				var r = t.call(this, n) || this;
				return r.stream = e, r
			}
			return Do(e, t), e.prototype.readBlock = function() {
				var t = this.stream.getBytes(2);
				if (!t || t.length < 2 || 128 === t[0]) this.eof = !0;
				else {
					var e, n = this.bufferLength,
						r = t[0];
					if (r < 128) {
						if ((e = this.ensureBuffer(n + r + 1))[n++] = t[1], r > 0) {
							var i = this.stream.getBytes(r);
							e.set(i, n), n += r
						}
					} else {
						r = 257 - r;
						var o = t[1];
						e = this.ensureBuffer(n + r + 1);
						for (var a = 0; a < r; a++) e[n++] = o
					}
					this.bufferLength = n
				}
			}, e
		}(cc);
		const Tc = Oc;
		var kc = function(t, e, n) {
				if (e === Zs.of("FlateDecode")) return new wc(t);
				if (e === Zs.of("LZWDecode")) {
					var r = 1;
					if (n instanceof $s) {
						var i = n.lookup(Zs.of("EarlyChange"));
						i instanceof Ns && (r = i.asNumber())
					}
					return new Sc(t, void 0, r)
				}
				if (e === Zs.of("ASCII85Decode")) return new fc(t);
				if (e === Zs.of("ASCIIHexDecode")) return new pc(t);
				if (e === Zs.of("RunLengthDecode")) return new Tc(t);
				throw new hs(e.asString())
			},
			Fc = function(t) {
				var e = t.dict,
					n = t.contents,
					r = new ac(n),
					i = e.lookup(Zs.of("Filter")),
					o = e.lookup(Zs.of("DecodeParms"));
				if (i instanceof Zs) r = kc(r, i, o);
				else if (i instanceof zs)
					for (var a = 0, s = i.size(); a < s; a++) r = kc(r, i.lookup(a, Zs), o && o.lookupMaybe(a, $s));
				else if (i) throw new us([Zs, zs], i);
				return r
			},
			Pc = function() {
				function t(t, e, n) {
					this.page = t;
					var r = null != e ? e : function(t) {
						var e = t.MediaBox();
						return {
							left: 0,
							bottom: 0,
							right: e.lookup(2, Ns).asNumber() - e.lookup(0, Ns).asNumber(),
							top: e.lookup(3, Ns).asNumber() - e.lookup(1, Ns).asNumber()
						}
					}(t);
					this.width = r.right - r.left, this.height = r.top - r.bottom, this.boundingBox = r, this.transformationMatrix = null != n ? n : function(t) {
						return [1, 0, 0, 1, -t.left, -t.bottom]
					}(r)
				}
				return t.for = function(e, n, r) {
					return Io(this, void 0, void 0, (function() {
						return Ro(this, (function(i) {
							return [2, new t(e, n, r)]
						}))
					}))
				}, t.prototype.embedIntoContext = function(t, e) {
					return Io(this, void 0, void 0, (function() {
						var n, r, i, o, a, s, l, c, u, h;
						return Ro(this, (function(f) {
							if (n = this.page.normalizedEntries(), r = n.Contents, i = n.Resources, !r) throw new ds;
							return o = this.decodeContents(r), a = this.boundingBox, s = a.left, l = a.bottom, c = a.right, u = a.top, h = t.flateStream(o, {
								Type: "XObject",
								Subtype: "Form",
								FormType: 1,
								BBox: [s, l, c, u],
								Matrix: this.transformationMatrix,
								Resources: i
							}), e ? (t.assign(e, h), [2, e]) : [2, t.register(h)]
						}))
					}))
				}, t.prototype.decodeContents = function(t) {
					for (var e = Uint8Array.of(Is.Newline), n = [], r = 0, i = t.size(); r < i; r++) {
						var o = t.lookup(r, el),
							a = void 0;
						if (o instanceof nl) a = Fc(o).decode();
						else {
							if (!(o instanceof fl)) throw new ps(o);
							a = o.getUnencodedContents()
						}
						n.push(a, e)
					}
					return sa.apply(void 0, n)
				}, t
			}();
		const jc = Pc;
		var Ac, _c, Ec, Dc, Mc = function(t, e) {
			if (void 0 !== t) return e[t]
		};
		! function(t) {
			t.UseNone = "UseNone", t.UseOutlines = "UseOutlines", t.UseThumbs = "UseThumbs", t.UseOC = "UseOC"
		}(Ac || (Ac = {})),
		function(t) {
			t.L2R = "L2R", t.R2L = "R2L"
		}(_c || (_c = {})),
		function(t) {
			t.None = "None", t.AppDefault = "AppDefault"
		}(Ec || (Ec = {})),
		function(t) {
			t.Simplex = "Simplex", t.DuplexFlipShortEdge = "DuplexFlipShortEdge", t.DuplexFlipLongEdge = "DuplexFlipLongEdge"
		}(Dc || (Dc = {}));
		var Ic = function() {
			function t(t) {
				this.dict = t
			}
			return t.prototype.lookupBool = function(t) {
				var e = this.dict.lookup(Zs.of(t));
				if (e instanceof Vs) return e
			}, t.prototype.lookupName = function(t) {
				var e = this.dict.lookup(Zs.of(t));
				if (e instanceof Zs) return e
			}, t.prototype.HideToolbar = function() {
				return this.lookupBool("HideToolbar")
			}, t.prototype.HideMenubar = function() {
				return this.lookupBool("HideMenubar")
			}, t.prototype.HideWindowUI = function() {
				return this.lookupBool("HideWindowUI")
			}, t.prototype.FitWindow = function() {
				return this.lookupBool("FitWindow")
			}, t.prototype.CenterWindow = function() {
				return this.lookupBool("CenterWindow")
			}, t.prototype.DisplayDocTitle = function() {
				return this.lookupBool("DisplayDocTitle")
			}, t.prototype.NonFullScreenPageMode = function() {
				return this.lookupName("NonFullScreenPageMode")
			}, t.prototype.Direction = function() {
				return this.lookupName("Direction")
			}, t.prototype.PrintScaling = function() {
				return this.lookupName("PrintScaling")
			}, t.prototype.Duplex = function() {
				return this.lookupName("Duplex")
			}, t.prototype.PickTrayByPDFSize = function() {
				return this.lookupBool("PickTrayByPDFSize")
			}, t.prototype.PrintPageRange = function() {
				var t = this.dict.lookup(Zs.of("PrintPageRange"));
				if (t instanceof zs) return t
			}, t.prototype.NumCopies = function() {
				var t = this.dict.lookup(Zs.of("NumCopies"));
				if (t instanceof Ns) return t
			}, t.prototype.getHideToolbar = function() {
				var t, e;
				return null !== (e = null === (t = this.HideToolbar()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getHideMenubar = function() {
				var t, e;
				return null !== (e = null === (t = this.HideMenubar()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getHideWindowUI = function() {
				var t, e;
				return null !== (e = null === (t = this.HideWindowUI()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getFitWindow = function() {
				var t, e;
				return null !== (e = null === (t = this.FitWindow()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getCenterWindow = function() {
				var t, e;
				return null !== (e = null === (t = this.CenterWindow()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getDisplayDocTitle = function() {
				var t, e;
				return null !== (e = null === (t = this.DisplayDocTitle()) || void 0 === t ? void 0 : t.asBoolean()) && void 0 !== e && e
			}, t.prototype.getNonFullScreenPageMode = function() {
				var t, e, n = null === (t = this.NonFullScreenPageMode()) || void 0 === t ? void 0 : t.decodeText();
				return null !== (e = Mc(n, Ac)) && void 0 !== e ? e : Ac.UseNone
			}, t.prototype.getReadingDirection = function() {
				var t, e, n = null === (t = this.Direction()) || void 0 === t ? void 0 : t.decodeText();
				return null !== (e = Mc(n, _c)) && void 0 !== e ? e : _c.L2R
			}, t.prototype.getPrintScaling = function() {
				var t, e, n = null === (t = this.PrintScaling()) || void 0 === t ? void 0 : t.decodeText();
				return null !== (e = Mc(n, Ec)) && void 0 !== e ? e : Ec.AppDefault
			}, t.prototype.getDuplex = function() {
				var t, e = null === (t = this.Duplex()) || void 0 === t ? void 0 : t.decodeText();
				return Mc(e, Dc)
			}, t.prototype.getPickTrayByPDFSize = function() {
				var t;
				return null === (t = this.PickTrayByPDFSize()) || void 0 === t ? void 0 : t.asBoolean()
			}, t.prototype.getPrintPageRange = function() {
				var t = this.PrintPageRange();
				if (!t) return [];
				for (var e = [], n = 0; n < t.size(); n += 2) {
					var r = t.lookup(n, Ns).asNumber(),
						i = t.lookup(n + 1, Ns).asNumber();
					e.push({
						start: r,
						end: i
					})
				}
				return e
			}, t.prototype.getNumCopies = function() {
				var t, e;
				return null !== (e = null === (t = this.NumCopies()) || void 0 === t ? void 0 : t.asNumber()) && void 0 !== e ? e : 1
			}, t.prototype.setHideToolbar = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("HideToolbar"), e)
			}, t.prototype.setHideMenubar = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("HideMenubar"), e)
			}, t.prototype.setHideWindowUI = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("HideWindowUI"), e)
			}, t.prototype.setFitWindow = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("FitWindow"), e)
			}, t.prototype.setCenterWindow = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("CenterWindow"), e)
			}, t.prototype.setDisplayDocTitle = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("DisplayDocTitle"), e)
			}, t.prototype.setNonFullScreenPageMode = function(t) {
				Xa(t, "nonFullScreenPageMode", Ac);
				var e = Zs.of(t);
				this.dict.set(Zs.of("NonFullScreenPageMode"), e)
			}, t.prototype.setReadingDirection = function(t) {
				Xa(t, "readingDirection", _c);
				var e = Zs.of(t);
				this.dict.set(Zs.of("Direction"), e)
			}, t.prototype.setPrintScaling = function(t) {
				Xa(t, "printScaling", Ec);
				var e = Zs.of(t);
				this.dict.set(Zs.of("PrintScaling"), e)
			}, t.prototype.setDuplex = function(t) {
				Xa(t, "duplex", Dc);
				var e = Zs.of(t);
				this.dict.set(Zs.of("Duplex"), e)
			}, t.prototype.setPickTrayByPDFSize = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("PickTrayByPDFSize"), e)
			}, t.prototype.setPrintPageRange = function(t) {
				Array.isArray(t) || (t = [t]);
				for (var e = [], n = 0, r = t.length; n < r; n++) e.push(t[n].start), e.push(t[n].end);
				Ja(e, "printPageRange", ["number"]);
				var i = this.dict.context.obj(e);
				this.dict.set(Zs.of("PrintPageRange"), i)
			}, t.prototype.setNumCopies = function(t) {
				Qa(t, "numCopies", 1, Number.MAX_VALUE),
					function(t, e) {
						if (!Number.isInteger(t)) throw new Error(Ha("numCopies") + " must be an integer, but was actually " + t)
					}(t);
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("NumCopies"), e)
			}, t.fromDict = function(e) {
				return new t(e)
			}, t.create = function(e) {
				return new t(e.obj({}))
			}, t
		}();
		const Rc = Ic;
		var Bc = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/,
			Nc = function() {
				function t(t, e) {
					this.dict = t, this.ref = e
				}
				return t.prototype.T = function() {
					return this.dict.lookupMaybe(Zs.of("T"), Hl, Bl)
				}, t.prototype.Ff = function() {
					var t = this.getInheritableAttribute(Zs.of("Ff"));
					return this.dict.context.lookupMaybe(t, Ns)
				}, t.prototype.V = function() {
					var t = this.getInheritableAttribute(Zs.of("V"));
					return this.dict.context.lookup(t)
				}, t.prototype.Kids = function() {
					return this.dict.lookupMaybe(Zs.of("Kids"), zs)
				}, t.prototype.DA = function() {
					var t = this.dict.lookup(Zs.of("DA"));
					if (t instanceof Hl || t instanceof Bl) return t
				}, t.prototype.setKids = function(t) {
					this.dict.set(Zs.of("Kids"), this.dict.context.obj(t))
				}, t.prototype.getParent = function() {
					var e = this.dict.get(Zs.of("Parent"));
					if (e instanceof ol) return new t(this.dict.lookup(Zs.of("Parent"), $s), e)
				}, t.prototype.setParent = function(t) {
					t ? this.dict.set(Zs.of("Parent"), t) : this.dict.delete(Zs.of("Parent"))
				}, t.prototype.getFullyQualifiedName = function() {
					var t = this.getParent();
					return t ? t.getFullyQualifiedName() + "." + this.getPartialName() : this.getPartialName()
				}, t.prototype.getPartialName = function() {
					var t;
					return null === (t = this.T()) || void 0 === t ? void 0 : t.decodeText()
				}, t.prototype.setPartialName = function(t) {
					t ? this.dict.set(Zs.of("T"), Bl.fromText(t)) : this.dict.delete(Zs.of("T"))
				}, t.prototype.setDefaultAppearance = function(t) {
					this.dict.set(Zs.of("DA"), Hl.of(t))
				}, t.prototype.getDefaultAppearance = function() {
					var t = this.DA();
					return t instanceof Bl ? t.decodeText() : null == t ? void 0 : t.asString()
				}, t.prototype.setFontSize = function(t) {
					var e, n = null !== (e = this.getFullyQualifiedName()) && void 0 !== e ? e : "",
						r = this.getDefaultAppearance();
					if (!r) throw new Ss(n);
					var i = ia(r, Bc);
					if (!i.match) throw new Os(n);
					var o = r.slice(0, i.pos - i.match[0].length),
						a = i.pos <= r.length ? r.slice(i.pos) : "",
						s = o + " /" + i.match[1] + " " + t + " Tf " + a;
					this.setDefaultAppearance(s)
				}, t.prototype.getFlags = function() {
					var t, e;
					return null !== (e = null === (t = this.Ff()) || void 0 === t ? void 0 : t.asNumber()) && void 0 !== e ? e : 0
				}, t.prototype.setFlags = function(t) {
					this.dict.set(Zs.of("Ff"), Ns.of(t))
				}, t.prototype.hasFlag = function(t) {
					return 0 != (this.getFlags() & t)
				}, t.prototype.setFlag = function(t) {
					var e = this.getFlags();
					this.setFlags(e | t)
				}, t.prototype.clearFlag = function(t) {
					var e = this.getFlags();
					this.setFlags(e & ~t)
				}, t.prototype.setFlagTo = function(t, e) {
					e ? this.setFlag(t) : this.clearFlag(t)
				}, t.prototype.getInheritableAttribute = function(t) {
					var e;
					return this.ascend((function(n) {
						e || (e = n.dict.get(t))
					})), e
				}, t.prototype.ascend = function(t) {
					t(this);
					var e = this.getParent();
					e && e.ascend(t)
				}, t
			}();
		const Lc = Nc;
		var zc = function() {
			function t(t) {
				this.dict = t
			}
			return t.prototype.W = function() {
				var t = this.dict.lookup(Zs.of("W"));
				if (t instanceof Ns) return t
			}, t.prototype.getWidth = function() {
				var t, e;
				return null !== (e = null === (t = this.W()) || void 0 === t ? void 0 : t.asNumber()) && void 0 !== e ? e : 1
			}, t.prototype.setWidth = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("W"), e)
			}, t.fromDict = function(e) {
				return new t(e)
			}, t
		}();
		const Wc = zc;
		var Vc = function() {
			function t(t) {
				this.dict = t
			}
			return t.prototype.Rect = function() {
				return this.dict.lookup(Zs.of("Rect"), zs)
			}, t.prototype.AP = function() {
				return this.dict.lookupMaybe(Zs.of("AP"), $s)
			}, t.prototype.F = function() {
				var t = this.dict.lookup(Zs.of("F"));
				return this.dict.context.lookupMaybe(t, Ns)
			}, t.prototype.getRectangle = function() {
				var t, e = this.Rect();
				return null !== (t = null == e ? void 0 : e.asRectangle()) && void 0 !== t ? t : {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				}
			}, t.prototype.setRectangle = function(t) {
				var e = t.x,
					n = t.y,
					r = t.width,
					i = t.height,
					o = this.dict.context.obj([e, n, e + r, n + i]);
				this.dict.set(Zs.of("Rect"), o)
			}, t.prototype.getAppearanceState = function() {
				var t = this.dict.lookup(Zs.of("AS"));
				if (t instanceof Zs) return t
			}, t.prototype.setAppearanceState = function(t) {
				this.dict.set(Zs.of("AS"), t)
			}, t.prototype.setAppearances = function(t) {
				this.dict.set(Zs.of("AP"), t)
			}, t.prototype.ensureAP = function() {
				var t = this.AP();
				return t || (t = this.dict.context.obj({}), this.dict.set(Zs.of("AP"), t)), t
			}, t.prototype.getNormalAppearance = function() {
				var t = this.ensureAP().get(Zs.of("N"));
				if (t instanceof ol || t instanceof $s) return t;
				throw new Error("Unexpected N type: " + (null == t ? void 0 : t.constructor.name))
			}, t.prototype.setNormalAppearance = function(t) {
				this.ensureAP().set(Zs.of("N"), t)
			}, t.prototype.setRolloverAppearance = function(t) {
				this.ensureAP().set(Zs.of("R"), t)
			}, t.prototype.setDownAppearance = function(t) {
				this.ensureAP().set(Zs.of("D"), t)
			}, t.prototype.removeRolloverAppearance = function() {
				var t = this.AP();
				null == t || t.delete(Zs.of("R"))
			}, t.prototype.removeDownAppearance = function() {
				var t = this.AP();
				null == t || t.delete(Zs.of("D"))
			}, t.prototype.getAppearances = function() {
				var t = this.AP();
				if (t) return {
					normal: t.lookup(Zs.of("N"), $s, el),
					rollover: t.lookupMaybe(Zs.of("R"), $s, el),
					down: t.lookupMaybe(Zs.of("D"), $s, el)
				}
			}, t.prototype.getFlags = function() {
				var t, e;
				return null !== (e = null === (t = this.F()) || void 0 === t ? void 0 : t.asNumber()) && void 0 !== e ? e : 0
			}, t.prototype.setFlags = function(t) {
				this.dict.set(Zs.of("F"), Ns.of(t))
			}, t.prototype.hasFlag = function(t) {
				return 0 != (this.getFlags() & t)
			}, t.prototype.setFlag = function(t) {
				var e = this.getFlags();
				this.setFlags(e | t)
			}, t.prototype.clearFlag = function(t) {
				var e = this.getFlags();
				this.setFlags(e & ~t)
			}, t.prototype.setFlagTo = function(t, e) {
				e ? this.setFlag(t) : this.clearFlag(t)
			}, t.fromDict = function(e) {
				return new t(e)
			}, t
		}();
		const Uc = Vc;
		var Hc = function() {
			function t(t) {
				this.dict = t
			}
			return t.prototype.R = function() {
				var t = this.dict.lookup(Zs.of("R"));
				if (t instanceof Ns) return t
			}, t.prototype.BC = function() {
				var t = this.dict.lookup(Zs.of("BC"));
				if (t instanceof zs) return t
			}, t.prototype.BG = function() {
				var t = this.dict.lookup(Zs.of("BG"));
				if (t instanceof zs) return t
			}, t.prototype.CA = function() {
				var t = this.dict.lookup(Zs.of("CA"));
				if (t instanceof Bl || t instanceof Hl) return t
			}, t.prototype.RC = function() {
				var t = this.dict.lookup(Zs.of("RC"));
				if (t instanceof Bl || t instanceof Hl) return t
			}, t.prototype.AC = function() {
				var t = this.dict.lookup(Zs.of("AC"));
				if (t instanceof Bl || t instanceof Hl) return t
			}, t.prototype.getRotation = function() {
				var t;
				return null === (t = this.R()) || void 0 === t ? void 0 : t.asNumber()
			}, t.prototype.getBorderColor = function() {
				var t = this.BC();
				if (t) {
					for (var e = [], n = 0, r = null == t ? void 0 : t.size(); n < r; n++) {
						var i = t.get(n);
						i instanceof Ns && e.push(i.asNumber())
					}
					return e
				}
			}, t.prototype.getBackgroundColor = function() {
				var t = this.BG();
				if (t) {
					for (var e = [], n = 0, r = null == t ? void 0 : t.size(); n < r; n++) {
						var i = t.get(n);
						i instanceof Ns && e.push(i.asNumber())
					}
					return e
				}
			}, t.prototype.getCaptions = function() {
				var t = this.CA(),
					e = this.RC(),
					n = this.AC();
				return {
					normal: null == t ? void 0 : t.decodeText(),
					rollover: null == e ? void 0 : e.decodeText(),
					down: null == n ? void 0 : n.decodeText()
				}
			}, t.prototype.setRotation = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("R"), e)
			}, t.prototype.setBorderColor = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("BC"), e)
			}, t.prototype.setBackgroundColor = function(t) {
				var e = this.dict.context.obj(t);
				this.dict.set(Zs.of("BG"), e)
			}, t.prototype.setCaptions = function(t) {
				var e = Bl.fromText(t.normal);
				if (this.dict.set(Zs.of("CA"), e), t.rollover) {
					var n = Bl.fromText(t.rollover);
					this.dict.set(Zs.of("RC"), n)
				} else this.dict.delete(Zs.of("RC"));
				if (t.down) {
					var r = Bl.fromText(t.down);
					this.dict.set(Zs.of("AC"), r)
				} else this.dict.delete(Zs.of("AC"))
			}, t.fromDict = function(e) {
				return new t(e)
			}, t
		}();
		const qc = Hc;
		var Xc = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.MK = function() {
				var t = this.dict.lookup(Zs.of("MK"));
				if (t instanceof $s) return t
			}, e.prototype.BS = function() {
				var t = this.dict.lookup(Zs.of("BS"));
				if (t instanceof $s) return t
			}, e.prototype.DA = function() {
				var t = this.dict.lookup(Zs.of("DA"));
				if (t instanceof Hl || t instanceof Bl) return t
			}, e.prototype.P = function() {
				var t = this.dict.get(Zs.of("P"));
				if (t instanceof ol) return t
			}, e.prototype.setP = function(t) {
				this.dict.set(Zs.of("P"), t)
			}, e.prototype.setDefaultAppearance = function(t) {
				this.dict.set(Zs.of("DA"), Hl.of(t))
			}, e.prototype.getDefaultAppearance = function() {
				var t = this.DA();
				return t instanceof Bl ? t.decodeText() : null == t ? void 0 : t.asString()
			}, e.prototype.getAppearanceCharacteristics = function() {
				var t = this.MK();
				if (t) return qc.fromDict(t)
			}, e.prototype.getOrCreateAppearanceCharacteristics = function() {
				var t = this.MK();
				if (t) return qc.fromDict(t);
				var e = qc.fromDict(this.dict.context.obj({}));
				return this.dict.set(Zs.of("MK"), e.dict), e
			}, e.prototype.getBorderStyle = function() {
				var t = this.BS();
				if (t) return Wc.fromDict(t)
			}, e.prototype.getOrCreateBorderStyle = function() {
				var t = this.BS();
				if (t) return Wc.fromDict(t);
				var e = Wc.fromDict(this.dict.context.obj({}));
				return this.dict.set(Zs.of("BS"), e.dict), e
			}, e.prototype.getOnValue = function() {
				var t, e = null === (t = this.getAppearances()) || void 0 === t ? void 0 : t.normal;
				if (e instanceof $s)
					for (var n = e.keys(), r = 0, i = n.length; r < i; r++) {
						var o = n[r];
						if (o !== Zs.of("Off")) return o
					}
			}, e.fromDict = function(t) {
				return new e(t)
			}, e.create = function(t, n) {
				return new e(t.obj({
					Type: "Annot",
					Subtype: "Widget",
					Rect: [0, 0, 0, 0],
					Parent: n
				}))
			}, e
		}(Uc);
		const Gc = Xc;
		var Kc = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.FT = function() {
				var t = this.getInheritableAttribute(Zs.of("FT"));
				return this.dict.context.lookup(t, Zs)
			}, e.prototype.getWidgets = function() {
				var t = this.Kids();
				if (!t) return [Gc.fromDict(this.dict)];
				for (var e = new Array(t.size()), n = 0, r = t.size(); n < r; n++) {
					var i = t.lookup(n, $s);
					e[n] = Gc.fromDict(i)
				}
				return e
			}, e.prototype.addWidget = function(t) {
				this.normalizedEntries().Kids.push(t)
			}, e.prototype.removeWidget = function(t) {
				var e = this.Kids();
				if (e) {
					if (t < 0 || t > e.size()) throw new xs(t, 0, e.size());
					e.remove(t)
				} else {
					if (0 !== t) throw new xs(t, 0, 0);
					this.setKids([])
				}
			}, e.prototype.normalizedEntries = function() {
				var t = this.Kids();
				return t || (t = this.dict.context.obj([this.ref]), this.dict.set(Zs.of("Kids"), t)), {
					Kids: t
				}
			}, e.fromDict = function(t, n) {
				return new e(t, n)
			}, e
		}(Lc);
		const Yc = Kc;
		var Zc = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.Opt = function() {
				return this.dict.lookupMaybe(Zs.of("Opt"), Hl, Bl, zs)
			}, e.prototype.setOpt = function(t) {
				this.dict.set(Zs.of("Opt"), this.dict.context.obj(t))
			}, e.prototype.getExportValues = function() {
				var t = this.Opt();
				if (t) {
					if (t instanceof Hl || t instanceof Bl) return [t];
					for (var e = [], n = 0, r = t.size(); n < r; n++) {
						var i = t.lookup(n);
						(i instanceof Hl || i instanceof Bl) && e.push(i)
					}
					return e
				}
			}, e.prototype.removeExportValue = function(t) {
				var e = this.Opt();
				if (e)
					if (e instanceof Hl || e instanceof Bl) {
						if (0 !== t) throw new xs(t, 0, 0);
						this.setOpt([])
					} else {
						if (t < 0 || t > e.size()) throw new xs(t, 0, e.size());
						e.remove(t)
					}
			}, e.prototype.normalizeExportValues = function() {
				for (var t, e, n, r, i = null !== (t = this.getExportValues()) && void 0 !== t ? t : [], o = [], a = this.getWidgets(), s = 0, l = a.length; s < l; s++) {
					var c = a[s],
						u = null !== (e = i[s]) && void 0 !== e ? e : Bl.fromText(null !== (r = null === (n = c.getOnValue()) || void 0 === n ? void 0 : n.decodeText()) && void 0 !== r ? r : "");
					o.push(u)
				}
				this.setOpt(o)
			}, e.prototype.addOpt = function(t, e) {
				var n;
				this.normalizeExportValues();
				var r, i = t.decodeText();
				if (e)
					for (var o = null !== (n = this.getExportValues()) && void 0 !== n ? n : [], a = 0, s = o.length; a < s; a++) o[a].decodeText() === i && (r = a);
				var l = this.Opt();
				return l.push(t), null != r ? r : l.size() - 1
			}, e.prototype.addWidgetWithOpt = function(t, e, n) {
				var r = this.addOpt(e, n),
					i = Zs.of(String(r));
				return this.addWidget(t), i
			}, e
		}(Yc);
		const Jc = Zc;
		var Qc = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.setValue = function(t) {
				var e;
				if (t !== (null !== (e = this.getOnValue()) && void 0 !== e ? e : Zs.of("Yes")) && t !== Zs.of("Off")) throw new ws;
				this.dict.set(Zs.of("V"), t);
				for (var n = this.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r],
						a = o.getOnValue() === t ? t : Zs.of("Off");
					o.setAppearanceState(a)
				}
			}, e.prototype.getValue = function() {
				var t = this.V();
				return t instanceof Zs ? t : Zs.of("Off")
			}, e.prototype.getOnValue = function() {
				var t = this.getWidgets()[0];
				return null == t ? void 0 : t.getOnValue()
			}, e.fromDict = function(t, n) {
				return new e(t, n)
			}, e.create = function(t) {
				var n = t.obj({
					FT: "Btn",
					Kids: []
				});
				return new e(n, t.register(n))
			}, e
		}(Jc);
		const $c = Qc;
		var tu, eu, nu, ru, iu = function(t) {
			return 1 << t
		};
		! function(t) {
			t[t.ReadOnly = iu(0)] = "ReadOnly", t[t.Required = iu(1)] = "Required", t[t.NoExport = iu(2)] = "NoExport"
		}(tu || (tu = {})),
		function(t) {
			t[t.NoToggleToOff = iu(14)] = "NoToggleToOff", t[t.Radio = iu(15)] = "Radio", t[t.PushButton = iu(16)] = "PushButton", t[t.RadiosInUnison = iu(25)] = "RadiosInUnison"
		}(eu || (eu = {})),
		function(t) {
			t[t.Multiline = iu(12)] = "Multiline", t[t.Password = iu(13)] = "Password", t[t.FileSelect = iu(20)] = "FileSelect", t[t.DoNotSpellCheck = iu(22)] = "DoNotSpellCheck", t[t.DoNotScroll = iu(23)] = "DoNotScroll", t[t.Comb = iu(24)] = "Comb", t[t.RichText = iu(25)] = "RichText"
		}(nu || (nu = {})),
		function(t) {
			t[t.Combo = iu(17)] = "Combo", t[t.Edit = iu(18)] = "Edit", t[t.Sort = iu(19)] = "Sort", t[t.MultiSelect = iu(21)] = "MultiSelect", t[t.DoNotSpellCheck = iu(22)] = "DoNotSpellCheck", t[t.CommitOnSelChange = iu(26)] = "CommitOnSelChange"
		}(ru || (ru = {}));
		var ou = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.setValues = function(t) {
				if (this.hasFlag(ru.Combo) && !this.hasFlag(ru.Edit) && !this.valuesAreValid(t)) throw new ws;
				if (0 === t.length && this.dict.delete(Zs.of("V")), 1 === t.length && this.dict.set(Zs.of("V"), t[0]), t.length > 1) {
					if (!this.hasFlag(ru.MultiSelect)) throw new Cs;
					this.dict.set(Zs.of("V"), this.dict.context.obj(t))
				}
				this.updateSelectedIndices(t)
			}, e.prototype.valuesAreValid = function(t) {
				for (var e = this.getOptions(), n = function(n, r) {
						var i = t[n].decodeText();
						if (!e.find((function(t) {
								return i === (t.display || t.value).decodeText()
							}))) return {
							value: !1
						}
					}, r = 0, i = t.length; r < i; r++) {
					var o = n(r);
					if ("object" == typeof o) return o.value
				}
				return !0
			}, e.prototype.updateSelectedIndices = function(t) {
				if (t.length > 1) {
					for (var e = new Array(t.length), n = this.getOptions(), r = function(r, i) {
							var o = t[r].decodeText();
							e[r] = n.findIndex((function(t) {
								return o === (t.display || t.value).decodeText()
							}))
						}, i = 0, o = t.length; i < o; i++) r(i);
					this.dict.set(Zs.of("I"), this.dict.context.obj(e.sort()))
				} else this.dict.delete(Zs.of("I"))
			}, e.prototype.getValues = function() {
				var t = this.V();
				if (t instanceof Hl || t instanceof Bl) return [t];
				if (t instanceof zs) {
					for (var e = [], n = 0, r = t.size(); n < r; n++) {
						var i = t.lookup(n);
						(i instanceof Hl || i instanceof Bl) && e.push(i)
					}
					return e
				}
				return []
			}, e.prototype.Opt = function() {
				return this.dict.lookupMaybe(Zs.of("Opt"), Hl, Bl, zs)
			}, e.prototype.setOptions = function(t) {
				for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) {
					var i = t[n],
						o = i.value,
						a = i.display;
					e[n] = this.dict.context.obj([o, a || o])
				}
				this.dict.set(Zs.of("Opt"), this.dict.context.obj(e))
			}, e.prototype.getOptions = function() {
				var t = this.Opt();
				if (t instanceof Hl || t instanceof Bl) return [{
					value: t,
					display: t
				}];
				if (t instanceof zs) {
					for (var e = [], n = 0, r = t.size(); n < r; n++) {
						var i = t.lookup(n);
						if ((i instanceof Hl || i instanceof Bl) && e.push({
								value: i,
								display: i
							}), i instanceof zs && i.size() > 0) {
							var o = i.lookup(0, Hl, Bl),
								a = i.lookupMaybe(1, Hl, Bl);
							e.push({
								value: o,
								display: a || o
							})
						}
					}
					return e
				}
				return []
			}, e
		}(Yc);
		const au = ou,
			su = function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.fromDict = function(t, n) {
					return new e(t, n)
				}, e.create = function(t) {
					var n = t.obj({
						FT: "Ch",
						Ff: ru.Combo,
						Kids: []
					});
					return new e(n, t.register(n))
				}, e
			}(au),
			lu = function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.prototype.addField = function(t) {
					var e = this.normalizedEntries().Kids;
					null == e || e.push(t)
				}, e.prototype.normalizedEntries = function() {
					var t = this.Kids();
					return t || (t = this.dict.context.obj([]), this.dict.set(Zs.of("Kids"), t)), {
						Kids: t
					}
				}, e.fromDict = function(t, n) {
					return new e(t, n)
				}, e.create = function(t) {
					var n = t.obj({});
					return new e(n, t.register(n))
				}, e
			}(Lc),
			cu = function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.fromDict = function(t, n) {
					return new e(t, n)
				}, e
			}(Yc);
		var uu = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.MaxLen = function() {
				var t = this.dict.lookup(Zs.of("MaxLen"));
				if (t instanceof Ns) return t
			}, e.prototype.Q = function() {
				var t = this.dict.lookup(Zs.of("Q"));
				if (t instanceof Ns) return t
			}, e.prototype.setMaxLength = function(t) {
				this.dict.set(Zs.of("MaxLen"), Ns.of(t))
			}, e.prototype.removeMaxLength = function() {
				this.dict.delete(Zs.of("MaxLen"))
			}, e.prototype.getMaxLength = function() {
				var t;
				return null === (t = this.MaxLen()) || void 0 === t ? void 0 : t.asNumber()
			}, e.prototype.setQuadding = function(t) {
				this.dict.set(Zs.of("Q"), Ns.of(t))
			}, e.prototype.getQuadding = function() {
				var t;
				return null === (t = this.Q()) || void 0 === t ? void 0 : t.asNumber()
			}, e.prototype.setValue = function(t) {
				this.dict.set(Zs.of("V"), t)
			}, e.prototype.removeValue = function() {
				this.dict.delete(Zs.of("V"))
			}, e.prototype.getValue = function() {
				var t = this.V();
				if (t instanceof Hl || t instanceof Bl) return t
			}, e.fromDict = function(t, n) {
				return new e(t, n)
			}, e.create = function(t) {
				var n = t.obj({
					FT: "Tx",
					Kids: []
				});
				return new e(n, t.register(n))
			}, e
		}(Yc);
		const hu = uu,
			fu = function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.fromDict = function(t, n) {
					return new e(t, n)
				}, e.create = function(t) {
					var n = t.obj({
						FT: "Btn",
						Ff: eu.PushButton,
						Kids: []
					});
					return new e(n, t.register(n))
				}, e
			}(Jc);
		var du = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.setValue = function(t) {
				if (!this.getOnValues().includes(t) && t !== Zs.of("Off")) throw new ws;
				this.dict.set(Zs.of("V"), t);
				for (var e = this.getWidgets(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i.getOnValue() === t ? t : Zs.of("Off");
					i.setAppearanceState(o)
				}
			}, e.prototype.getValue = function() {
				var t = this.V();
				return t instanceof Zs ? t : Zs.of("Off")
			}, e.prototype.getOnValues = function() {
				for (var t = this.getWidgets(), e = [], n = 0, r = t.length; n < r; n++) {
					var i = t[n].getOnValue();
					i && e.push(i)
				}
				return e
			}, e.fromDict = function(t, n) {
				return new e(t, n)
			}, e.create = function(t) {
				var n = t.obj({
					FT: "Btn",
					Ff: eu.Radio,
					Kids: []
				});
				return new e(n, t.register(n))
			}, e
		}(Jc);
		const pu = du,
			gu = function(t) {
				function e() {
					return null !== t && t.apply(this, arguments) || this
				}
				return Do(e, t), e.fromDict = function(t, n) {
					return new e(t, n)
				}, e.create = function(t) {
					var n = t.obj({
						FT: "Ch",
						Kids: []
					});
					return new e(n, t.register(n))
				}, e
			}(au);
		var vu = function(t) {
				if (!t) return [];
				for (var e = [], n = 0, r = t.size(); n < r; n++) {
					var i = t.get(n),
						o = t.lookup(n);
					i instanceof ol && o instanceof $s && e.push([mu(o, i), i])
				}
				return e
			},
			mu = function(t, e) {
				return yu(t) ? lu.fromDict(t, e) : bu(t, e)
			},
			yu = function(t) {
				var e = t.lookup(Zs.of("Kids"));
				if (e instanceof zs)
					for (var n = 0, r = e.size(); n < r; n++) {
						var i = e.lookup(n);
						if (i instanceof $s && i.has(Zs.of("T"))) return !0
					}
				return !1
			},
			bu = function(t, e) {
				var n = Su(t, Zs.of("FT")),
					r = t.context.lookup(n, Zs);
				return r === Zs.of("Btn") ? xu(t, e) : r === Zs.of("Ch") ? wu(t, e) : r === Zs.of("Tx") ? hu.fromDict(t, e) : r === Zs.of("Sig") ? cu.fromDict(t, e) : Yc.fromDict(t, e)
			},
			xu = function(t, e) {
				var n, r = Su(t, Zs.of("Ff")),
					i = t.context.lookupMaybe(r, Ns),
					o = null !== (n = null == i ? void 0 : i.asNumber()) && void 0 !== n ? n : 0;
				return Cu(o, eu.PushButton) ? fu.fromDict(t, e) : Cu(o, eu.Radio) ? pu.fromDict(t, e) : $c.fromDict(t, e)
			},
			wu = function(t, e) {
				var n, r = Su(t, Zs.of("Ff")),
					i = t.context.lookupMaybe(r, Ns),
					o = null !== (n = null == i ? void 0 : i.asNumber()) && void 0 !== n ? n : 0;
				return Cu(o, ru.Combo) ? su.fromDict(t, e) : gu.fromDict(t, e)
			},
			Cu = function(t, e) {
				return 0 != (t & e)
			},
			Su = function(t, e) {
				var n;
				return Ou(t, (function(t) {
					n || (n = t.get(e))
				})), n
			},
			Ou = function(t, e) {
				e(t);
				var n = t.lookupMaybe(Zs.of("Parent"), $s);
				n && Ou(n, e)
			},
			Tu = function() {
				function t(t) {
					this.dict = t
				}
				return t.prototype.Fields = function() {
					var t = this.dict.lookup(Zs.of("Fields"));
					if (t instanceof zs) return t
				}, t.prototype.getFields = function() {
					for (var t = this.normalizedEntries().Fields, e = new Array(t.size()), n = 0, r = t.size(); n < r; n++) {
						var i = t.get(n),
							o = t.lookup(n, $s);
						e[n] = [mu(o, i), i]
					}
					return e
				}, t.prototype.getAllFields = function() {
					var t = [],
						e = function(n) {
							if (n)
								for (var r = 0, i = n.length; r < i; r++) {
									var o = n[r];
									t.push(o);
									var a = o[0];
									a instanceof lu && e(vu(a.Kids()))
								}
						};
					return e(this.getFields()), t
				}, t.prototype.addField = function(t) {
					var e = this.normalizedEntries().Fields;
					null == e || e.push(t)
				}, t.prototype.removeField = function(t) {
					var e = t.getParent(),
						n = void 0 === e ? this.normalizedEntries().Fields : e.Kids(),
						r = null == n ? void 0 : n.indexOf(t.ref);
					if (void 0 === n || void 0 === r) throw new Error("Tried to remove inexistent field " + t.getFullyQualifiedName());
					n.remove(r), void 0 !== e && 0 === n.size() && this.removeField(e)
				}, t.prototype.normalizedEntries = function() {
					var t = this.Fields();
					return t || (t = this.dict.context.obj([]), this.dict.set(Zs.of("Fields"), t)), {
						Fields: t
					}
				}, t.fromDict = function(e) {
					return new t(e)
				}, t.create = function(e) {
					return new t(e.obj({
						Fields: []
					}))
				}, t
			}();
		const ku = Tu;
		var Fu = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.Pages = function() {
				return this.lookup(Zs.of("Pages"), $s)
			}, e.prototype.AcroForm = function() {
				return this.lookupMaybe(Zs.of("AcroForm"), $s)
			}, e.prototype.getAcroForm = function() {
				var t = this.AcroForm();
				if (t) return ku.fromDict(t)
			}, e.prototype.getOrCreateAcroForm = function() {
				var t = this.getAcroForm();
				if (!t) {
					t = ku.create(this.context);
					var e = this.context.register(t.dict);
					this.set(Zs.of("AcroForm"), e)
				}
				return t
			}, e.prototype.ViewerPreferences = function() {
				return this.lookupMaybe(Zs.of("ViewerPreferences"), $s)
			}, e.prototype.getViewerPreferences = function() {
				var t = this.ViewerPreferences();
				if (t) return Rc.fromDict(t)
			}, e.prototype.getOrCreateViewerPreferences = function() {
				var t = this.getViewerPreferences();
				if (!t) {
					t = Rc.create(this.context);
					var e = this.context.register(t.dict);
					this.set(Zs.of("ViewerPreferences"), e)
				}
				return t
			}, e.prototype.insertLeafNode = function(t, e) {
				var n = this.get(Zs.of("Pages"));
				return this.Pages().insertLeafNode(t, e) || n
			}, e.prototype.removeLeafNode = function(t) {
				this.Pages().removeLeafNode(t)
			}, e.withContextAndPages = function(t, n) {
				var r = new Map;
				return r.set(Zs.of("Type"), Zs.of("Catalog")), r.set(Zs.of("Pages"), n), new e(r, t)
			}, e.fromMapWithContext = function(t, n) {
				return new e(t, n)
			}, e
		}($s);
		const Pu = Fu;
		var ju = function(t) {
			function e() {
				return null !== t && t.apply(this, arguments) || this
			}
			return Do(e, t), e.prototype.Parent = function() {
				return this.lookup(Zs.of("Parent"))
			}, e.prototype.Kids = function() {
				return this.lookup(Zs.of("Kids"), zs)
			}, e.prototype.Count = function() {
				return this.lookup(Zs.of("Count"), Ns)
			}, e.prototype.pushTreeNode = function(t) {
				this.Kids().push(t)
			}, e.prototype.pushLeafNode = function(t) {
				var e = this.Kids();
				this.insertLeafKid(e.size(), t)
			}, e.prototype.insertLeafNode = function(t, n) {
				var r = this.Kids(),
					i = this.Count().asNumber();
				if (n > i) throw new ys(n, i);
				for (var o = n, a = 0, s = r.size(); a < s; a++) {
					if (0 === o) return void this.insertLeafKid(a, t);
					var l = r.get(a),
						c = this.context.lookup(l);
					if (c instanceof e) {
						if (c.Count().asNumber() > o) return c.insertLeafNode(t, o) || l;
						o -= c.Count().asNumber()
					}
					c instanceof yl && (o -= 1)
				}
				if (0 !== o) throw new bs(n, "insertLeafNode");
				this.insertLeafKid(r.size(), t)
			}, e.prototype.removeLeafNode = function(t, n) {
				void 0 === n && (n = !0);
				var r = this.Kids(),
					i = this.Count().asNumber();
				if (t >= i) throw new ys(t, i);
				for (var o = t, a = 0, s = r.size(); a < s; a++) {
					var l = r.get(a),
						c = this.context.lookup(l);
					if (c instanceof e) {
						if (c.Count().asNumber() > o) return c.removeLeafNode(o, n), void(n && 0 === c.Kids().size() && r.remove(a));
						o -= c.Count().asNumber()
					}
					if (c instanceof yl) {
						if (0 === o) return void this.removeKid(a);
						o -= 1
					}
				}
				throw new bs(t, "removeLeafNode")
			}, e.prototype.ascend = function(t) {
				t(this);
				var e = this.Parent();
				e && e.ascend(t)
			}, e.prototype.traverse = function(t) {
				for (var n = this.Kids(), r = 0, i = n.size(); r < i; r++) {
					var o = n.get(r),
						a = this.context.lookup(o);
					a instanceof e && a.traverse(t), t(a, o)
				}
			}, e.prototype.insertLeafKid = function(t, e) {
				var n = this.Kids();
				this.ascend((function(t) {
					var e = t.Count().asNumber() + 1;
					t.set(Zs.of("Count"), Ns.of(e))
				})), n.insert(t, e)
			}, e.prototype.removeKid = function(t) {
				var e = this.Kids();
				e.lookup(t) instanceof yl && this.ascend((function(t) {
					var e = t.Count().asNumber() - 1;
					t.set(Zs.of("Count"), Ns.of(e))
				})), e.remove(t)
			}, e.withContext = function(t, n) {
				var r = new Map;
				return r.set(Zs.of("Type"), Zs.of("Pages")), r.set(Zs.of("Kids"), t.obj([])), r.set(Zs.of("Count"), t.obj(0)), n && r.set(Zs.of("Parent"), n), new e(r, t)
			}, e.fromMapWithContext = function(t, n) {
				return new e(t, n)
			}, e
		}($s);
		const Au = ju;
		var _u = new Uint8Array(256);
		_u[Is.Zero] = 1, _u[Is.One] = 1, _u[Is.Two] = 1, _u[Is.Three] = 1, _u[Is.Four] = 1, _u[Is.Five] = 1, _u[Is.Six] = 1, _u[Is.Seven] = 1, _u[Is.Eight] = 1, _u[Is.Nine] = 1;
		var Eu = new Uint8Array(256);
		Eu[Is.Period] = 1, Eu[Is.Plus] = 1, Eu[Is.Minus] = 1;
		for (var Du = new Uint8Array(256), Mu = 0; Mu < 256; Mu++) Du[Mu] = _u[Mu] || Eu[Mu] ? 1 : 0;
		var Iu = Is.Newline,
			Ru = Is.CarriageReturn,
			Bu = function() {
				function t(t, e) {
					void 0 === e && (e = !1), this.bytes = t, this.capNumbers = e
				}
				return t.prototype.parseRawInt = function() {
					for (var t = ""; !this.bytes.done();) {
						var e = this.bytes.peek();
						if (!_u[e]) break;
						t += Go(this.bytes.next())
					}
					var n = Number(t);
					if (!t || !isFinite(n)) throw new Ts(this.bytes.position(), t);
					return n
				}, t.prototype.parseRawNumber = function() {
					for (var t = ""; !this.bytes.done();) {
						var e = this.bytes.peek();
						if (!Du[e]) break;
						if (t += Go(this.bytes.next()), e === Is.Period) break
					}
					for (; !this.bytes.done() && (e = this.bytes.peek(), _u[e]);) t += Go(this.bytes.next());
					var n = Number(t);
					if (!t || !isFinite(n)) throw new Ts(this.bytes.position(), t);
					if (n > Number.MAX_SAFE_INTEGER) {
						if (this.capNumbers) {
							var r = "Parsed number that is too large for some PDF readers: " + t + ", using Number.MAX_SAFE_INTEGER instead.";
							return console.warn(r), Number.MAX_SAFE_INTEGER
						}
						r = "Parsed number that is too large for some PDF readers: " + t + ", not capping.", console.warn(r)
					}
					return n
				}, t.prototype.skipWhitespace = function() {
					for (; !this.bytes.done() && Hs[this.bytes.peek()];) this.bytes.next()
				}, t.prototype.skipLine = function() {
					for (; !this.bytes.done();) {
						var t = this.bytes.peek();
						if (t === Iu || t === Ru) return;
						this.bytes.next()
					}
				}, t.prototype.skipComment = function() {
					if (this.bytes.peek() !== Is.Percent) return !1;
					for (; !this.bytes.done();) {
						var t = this.bytes.peek();
						if (t === Iu || t === Ru) return !0;
						this.bytes.next()
					}
					return !0
				}, t.prototype.skipWhitespaceAndComments = function() {
					for (this.skipWhitespace(); this.skipComment();) this.skipWhitespace()
				}, t.prototype.matchKeyword = function(t) {
					for (var e = this.bytes.offset(), n = 0, r = t.length; n < r; n++)
						if (this.bytes.done() || this.bytes.next() !== t[n]) return this.bytes.moveTo(e), !1;
					return !0
				}, t
			}();
		const Nu = Bu,
			Lu = function() {
				function t(t) {
					this.idx = 0, this.line = 0, this.column = 0, this.bytes = t, this.length = this.bytes.length
				}
				return t.prototype.moveTo = function(t) {
					this.idx = t
				}, t.prototype.next = function() {
					var t = this.bytes[this.idx++];
					return t === Is.Newline ? (this.line += 1, this.column = 0) : this.column += 1, t
				}, t.prototype.assertNext = function(t) {
					if (this.peek() !== t) throw new Fs(this.position(), t, this.peek());
					return this.next()
				}, t.prototype.peek = function() {
					return this.bytes[this.idx]
				}, t.prototype.peekAhead = function(t) {
					return this.bytes[this.idx + t]
				}, t.prototype.peekAt = function(t) {
					return this.bytes[t]
				}, t.prototype.done = function() {
					return this.idx >= this.length
				}, t.prototype.offset = function() {
					return this.idx
				}, t.prototype.slice = function(t, e) {
					return this.bytes.slice(t, e)
				}, t.prototype.position = function() {
					return {
						line: this.line,
						column: this.column,
						offset: this.idx
					}
				}, t.of = function(e) {
					return new t(e)
				}, t.fromPDFRawStream = function(e) {
					return t.of(Fc(e).decode())
				}, t
			}();
		var zu = Is.Space,
			Wu = Is.CarriageReturn,
			Vu = Is.Newline,
			Uu = [Is.s, Is.t, Is.r, Is.e, Is.a, Is.m],
			Hu = [Is.e, Is.n, Is.d, Is.s, Is.t, Is.r, Is.e, Is.a, Is.m],
			qu = {
				header: [Is.Percent, Is.P, Is.D, Is.F, Is.Dash],
				eof: [Is.Percent, Is.Percent, Is.E, Is.O, Is.F],
				obj: [Is.o, Is.b, Is.j],
				endobj: [Is.e, Is.n, Is.d, Is.o, Is.b, Is.j],
				xref: [Is.x, Is.r, Is.e, Is.f],
				trailer: [Is.t, Is.r, Is.a, Is.i, Is.l, Is.e, Is.r],
				startxref: [Is.s, Is.t, Is.a, Is.r, Is.t, Is.x, Is.r, Is.e, Is.f],
				true: [Is.t, Is.r, Is.u, Is.e],
				false: [Is.f, Is.a, Is.l, Is.s, Is.e],
				null: [Is.n, Is.u, Is.l, Is.l],
				stream: Uu,
				streamEOF1: Bo(Uu, [zu, Wu, Vu]),
				streamEOF2: Bo(Uu, [Wu, Vu]),
				streamEOF3: Bo(Uu, [Wu]),
				streamEOF4: Bo(Uu, [Vu]),
				endstream: Hu,
				EOF1endstream: Bo([Wu, Vu], Hu),
				EOF2endstream: Bo([Wu], Hu),
				EOF3endstream: Bo([Vu], Hu)
			};
		const Xu = function(t) {
			function e(e, n, r) {
				void 0 === r && (r = !1);
				var i = t.call(this, e, r) || this;
				return i.context = n, i
			}
			return Do(e, t), e.prototype.parseObject = function() {
				if (this.skipWhitespaceAndComments(), this.matchKeyword(qu.true)) return Vs.True;
				if (this.matchKeyword(qu.false)) return Vs.False;
				if (this.matchKeyword(qu.null)) return Js;
				var t = this.bytes.peek();
				if (t === Is.LessThan && this.bytes.peekAhead(1) === Is.LessThan) return this.parseDictOrStream();
				if (t === Is.LessThan) return this.parseHexString();
				if (t === Is.LeftParen) return this.parseString();
				if (t === Is.ForwardSlash) return this.parseName();
				if (t === Is.LeftSquareBracket) return this.parseArray();
				if (Du[t]) return this.parseNumberOrRef();
				throw new Ps(this.bytes.position(), t)
			}, e.prototype.parseNumberOrRef = function() {
				var t = this.parseRawNumber();
				this.skipWhitespaceAndComments();
				var e = this.bytes.offset();
				if (_u[this.bytes.peek()]) {
					var n = this.parseRawNumber();
					if (this.skipWhitespaceAndComments(), this.bytes.peek() === Is.R) return this.bytes.assertNext(Is.R), ol.of(t, n)
				}
				return this.bytes.moveTo(e), Ns.of(t)
			}, e.prototype.parseHexString = function() {
				var t = "";
				for (this.bytes.assertNext(Is.LessThan); !this.bytes.done() && this.bytes.peek() !== Is.GreaterThan;) t += Go(this.bytes.next());
				return this.bytes.assertNext(Is.GreaterThan), Bl.of(t)
			}, e.prototype.parseString = function() {
				for (var t = 0, e = !1, n = ""; !this.bytes.done();) {
					var r = this.bytes.next();
					if (n += Go(r), e || (r === Is.LeftParen && (t += 1), r === Is.RightParen && (t -= 1)), r === Is.BackSlash ? e = !e : e && (e = !1), 0 === t) return Hl.of(n.substring(1, n.length - 1))
				}
				throw new _s(this.bytes.position())
			}, e.prototype.parseName = function() {
				this.bytes.assertNext(Is.ForwardSlash);
				for (var t = ""; !this.bytes.done();) {
					var e = this.bytes.peek();
					if (Hs[e] || Us[e]) break;
					t += Go(e), this.bytes.next()
				}
				return Zs.of(t)
			}, e.prototype.parseArray = function() {
				this.bytes.assertNext(Is.LeftSquareBracket), this.skipWhitespaceAndComments();
				for (var t = zs.withContext(this.context); this.bytes.peek() !== Is.RightSquareBracket;) {
					var e = this.parseObject();
					t.push(e), this.skipWhitespaceAndComments()
				}
				return this.bytes.assertNext(Is.RightSquareBracket), t
			}, e.prototype.parseDict = function() {
				this.bytes.assertNext(Is.LessThan), this.bytes.assertNext(Is.LessThan), this.skipWhitespaceAndComments();
				for (var t = new Map; !this.bytes.done() && this.bytes.peek() !== Is.GreaterThan && this.bytes.peekAhead(1) !== Is.GreaterThan;) {
					var e = this.parseName(),
						n = this.parseObject();
					t.set(e, n), this.skipWhitespaceAndComments()
				}
				this.skipWhitespaceAndComments(), this.bytes.assertNext(Is.GreaterThan), this.bytes.assertNext(Is.GreaterThan);
				var r = t.get(Zs.of("Type"));
				return r === Zs.of("Catalog") ? Pu.fromMapWithContext(t, this.context) : r === Zs.of("Pages") ? Au.fromMapWithContext(t, this.context) : r === Zs.of("Page") ? yl.fromMapWithContext(t, this.context) : $s.fromMapWithContext(t, this.context)
			}, e.prototype.parseDictOrStream = function() {
				var t = this.bytes.position(),
					e = this.parseDict();
				if (this.skipWhitespaceAndComments(), !(this.matchKeyword(qu.streamEOF1) || this.matchKeyword(qu.streamEOF2) || this.matchKeyword(qu.streamEOF3) || this.matchKeyword(qu.streamEOF4) || this.matchKeyword(qu.stream))) return e;
				var n, r = this.bytes.offset(),
					i = e.get(Zs.of("Length"));
				i instanceof Ns ? (n = r + i.asNumber(), this.bytes.moveTo(n), this.skipWhitespaceAndComments(), this.matchKeyword(qu.endstream) || (this.bytes.moveTo(r), n = this.findEndOfStreamFallback(t))) : n = this.findEndOfStreamFallback(t);
				var o = this.bytes.slice(r, n);
				return nl.of(e, o)
			}, e.prototype.findEndOfStreamFallback = function(t) {
				for (var e = 1, n = this.bytes.offset(); !this.bytes.done() && (n = this.bytes.offset(), this.matchKeyword(qu.stream) ? e += 1 : this.matchKeyword(qu.EOF1endstream) || this.matchKeyword(qu.EOF2endstream) || this.matchKeyword(qu.EOF3endstream) || this.matchKeyword(qu.endstream) ? e -= 1 : this.bytes.next(), 0 !== e););
				if (0 !== e) throw new As(t);
				return n
			}, e.forBytes = function(t, n, r) {
				return new e(Lu.of(t), n, r)
			}, e.forByteStream = function(t, n, r) {
				return void 0 === r && (r = !1), new e(t, n, r)
			}, e
		}(Nu);
		var Gu = function(t) {
			function e(e, n) {
				var r = t.call(this, Lu.fromPDFRawStream(e), e.dict.context) || this,
					i = e.dict;
				return r.alreadyParsed = !1, r.shouldWaitForTick = n || function() {
					return !1
				}, r.firstOffset = i.lookup(Zs.of("First"), Ns).asNumber(), r.objectCount = i.lookup(Zs.of("N"), Ns).asNumber(), r
			}
			return Do(e, t), e.prototype.parseIntoContext = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r, i, o, a, s;
					return Ro(this, (function(l) {
						switch (l.label) {
							case 0:
								if (this.alreadyParsed) throw new fs("PDFObjectStreamParser", "parseIntoContext");
								this.alreadyParsed = !0, t = this.parseOffsetsAndObjectNumbers(), e = 0, n = t.length, l.label = 1;
							case 1:
								return e < n ? (r = t[e], i = r.objectNumber, o = r.offset, this.bytes.moveTo(this.firstOffset + o), a = this.parseObject(), s = ol.of(i, 0), this.context.assign(s, a), this.shouldWaitForTick() ? [4, fa()] : [3, 3]) : [3, 4];
							case 2:
								l.sent(), l.label = 3;
							case 3:
								return e++, [3, 1];
							case 4:
								return [2]
						}
					}))
				}))
			}, e.prototype.parseOffsetsAndObjectNumbers = function() {
				for (var t = [], e = 0, n = this.objectCount; e < n; e++) {
					this.skipWhitespaceAndComments();
					var r = this.parseRawInt();
					this.skipWhitespaceAndComments();
					var i = this.parseRawInt();
					t.push({
						objectNumber: r,
						offset: i
					})
				}
				return t
			}, e.forStream = function(t, n) {
				return new e(t, n)
			}, e
		}(Xu);
		const Ku = Gu;
		var Yu = function() {
			function t(t) {
				this.alreadyParsed = !1, this.dict = t.dict, this.bytes = Lu.fromPDFRawStream(t), this.context = this.dict.context;
				var e = this.dict.lookup(Zs.of("Size"), Ns),
					n = this.dict.lookup(Zs.of("Index"));
				if (n instanceof zs) {
					this.subsections = [];
					for (var r = 0, i = n.size(); r < i; r += 2) {
						var o = n.lookup(r + 0, Ns).asNumber(),
							a = n.lookup(r + 1, Ns).asNumber();
						this.subsections.push({
							firstObjectNumber: o,
							length: a
						})
					}
				} else this.subsections = [{
					firstObjectNumber: 0,
					length: e.asNumber()
				}];
				var s = this.dict.lookup(Zs.of("W"), zs);
				for (this.byteWidths = [-1, -1, -1], r = 0, i = s.size(); r < i; r++) this.byteWidths[r] = s.lookup(r, Ns).asNumber()
			}
			return t.prototype.parseIntoContext = function() {
				if (this.alreadyParsed) throw new fs("PDFXRefStreamParser", "parseIntoContext");
				return this.alreadyParsed = !0, this.context.trailerInfo = {
					Root: this.dict.get(Zs.of("Root")),
					Encrypt: this.dict.get(Zs.of("Encrypt")),
					Info: this.dict.get(Zs.of("Info")),
					ID: this.dict.get(Zs.of("ID"))
				}, this.parseEntries()
			}, t.prototype.parseEntries = function() {
				for (var t = [], e = this.byteWidths, n = e[0], r = e[1], i = e[2], o = 0, a = this.subsections.length; o < a; o++)
					for (var s = this.subsections[o], l = s.firstObjectNumber, c = s.length, u = 0; u < c; u++) {
						for (var h = 0, f = 0, d = n; f < d; f++) h = h << 8 | this.bytes.next();
						var p = 0;
						for (f = 0, d = r; f < d; f++) p = p << 8 | this.bytes.next();
						var g = 0;
						for (f = 0, d = i; f < d; f++) g = g << 8 | this.bytes.next();
						0 === n && (h = 1);
						var v = l + u,
							m = {
								ref: ol.of(v, g),
								offset: p,
								deleted: 0 === h,
								inObjectStream: 2 === h
							};
						t.push(m)
					}
				return t
			}, t.forStream = function(e) {
				return new t(e)
			}, t
		}();
		const Zu = Yu;
		var Ju = function(t) {
			function e(e, n, r, i) {
				void 0 === n && (n = 1 / 0), void 0 === r && (r = !1), void 0 === i && (i = !1);
				var o = t.call(this, Lu.of(e), vl.create(), i) || this;
				return o.alreadyParsed = !1, o.parsedObjects = 0, o.shouldWaitForTick = function() {
					return o.parsedObjects += 1, o.parsedObjects % o.objectsPerTick == 0
				}, o.objectsPerTick = n, o.throwOnInvalidObject = r, o
			}
			return Do(e, t), e.prototype.parseDocument = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e;
					return Ro(this, (function(n) {
						switch (n.label) {
							case 0:
								if (this.alreadyParsed) throw new fs("PDFParser", "parseDocument");
								this.alreadyParsed = !0, this.context.header = this.parseHeader(), n.label = 1;
							case 1:
								return this.bytes.done() ? [3, 3] : [4, this.parseDocumentSection()];
							case 2:
								if (n.sent(), (e = this.bytes.offset()) === t) throw new Es(this.bytes.position());
								return t = e, [3, 1];
							case 3:
								return this.maybeRecoverRoot(), this.context.lookup(ol.of(0)) && (console.warn("Removing parsed object: 0 0 R"), this.context.delete(ol.of(0))), [2, this.context]
						}
					}))
				}))
			}, e.prototype.maybeRecoverRoot = function() {
				var t = function(t) {
					return t instanceof $s && t.lookup(Zs.of("Type")) === Zs.of("Catalog")
				};
				if (!t(this.context.lookup(this.context.trailerInfo.Root)))
					for (var e = this.context.enumerateIndirectObjects(), n = 0, r = e.length; n < r; n++) {
						var i = e[n],
							o = i[0];
						t(i[1]) && (this.context.trailerInfo.Root = o)
					}
			}, e.prototype.parseHeader = function() {
				for (; !this.bytes.done();) {
					if (this.matchKeyword(qu.header)) {
						var t = this.parseRawInt();
						this.bytes.assertNext(Is.Period);
						var e = this.parseRawInt(),
							n = Rs.forVersion(t, e);
						return this.skipBinaryHeaderComment(), n
					}
					this.bytes.next()
				}
				throw new Ds(this.bytes.position())
			}, e.prototype.parseIndirectObjectHeader = function() {
				this.skipWhitespaceAndComments();
				var t = this.parseRawInt();
				this.skipWhitespaceAndComments();
				var e = this.parseRawInt();
				if (this.skipWhitespaceAndComments(), !this.matchKeyword(qu.obj)) throw new Ms(this.bytes.position(), qu.obj);
				return ol.of(t, e)
			}, e.prototype.matchIndirectObjectHeader = function() {
				var t = this.bytes.offset();
				try {
					return this.parseIndirectObjectHeader(), !0
				} catch (e) {
					return this.bytes.moveTo(t), !1
				}
			}, e.prototype.parseIndirectObject = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e;
					return Ro(this, (function(n) {
						switch (n.label) {
							case 0:
								return t = this.parseIndirectObjectHeader(), this.skipWhitespaceAndComments(), e = this.parseObject(), this.skipWhitespaceAndComments(), this.matchKeyword(qu.endobj), e instanceof nl && e.dict.lookup(Zs.of("Type")) === Zs.of("ObjStm") ? [4, Ku.forStream(e, this.shouldWaitForTick).parseIntoContext()] : [3, 2];
							case 1:
								return n.sent(), [3, 3];
							case 2:
								e instanceof nl && e.dict.lookup(Zs.of("Type")) === Zs.of("XRef") ? Zu.forStream(e).parseIntoContext() : this.context.assign(t, e), n.label = 3;
							case 3:
								return [2, t]
						}
					}))
				}))
			}, e.prototype.tryToParseInvalidIndirectObject = function() {
				var t = this.bytes.position(),
					e = "Trying to parse invalid object: " + JSON.stringify(t) + ")";
				if (this.throwOnInvalidObject) throw new Error(e);
				console.warn(e);
				var n = this.parseIndirectObjectHeader();
				console.warn("Invalid object ref: " + n), this.skipWhitespaceAndComments();
				for (var r = this.bytes.offset(), i = !0; !this.bytes.done() && (this.matchKeyword(qu.endobj) && (i = !1), i);) this.bytes.next();
				if (i) throw new js(t);
				var o = this.bytes.offset() - qu.endobj.length,
					a = Al.of(this.bytes.slice(r, o));
				return this.context.assign(n, a), n
			}, e.prototype.parseIndirectObjects = function() {
				return Io(this, void 0, void 0, (function() {
					var t;
					return Ro(this, (function(e) {
						switch (e.label) {
							case 0:
								this.skipWhitespaceAndComments(), e.label = 1;
							case 1:
								if (this.bytes.done() || !_u[this.bytes.peek()]) return [3, 8];
								t = this.bytes.offset(), e.label = 2;
							case 2:
								return e.trys.push([2, 4, , 5]), [4, this.parseIndirectObject()];
							case 3:
								return e.sent(), [3, 5];
							case 4:
								return e.sent(), this.bytes.moveTo(t), this.tryToParseInvalidIndirectObject(), [3, 5];
							case 5:
								return this.skipWhitespaceAndComments(), this.skipJibberish(), this.shouldWaitForTick() ? [4, fa()] : [3, 7];
							case 6:
								e.sent(), e.label = 7;
							case 7:
								return [3, 1];
							case 8:
								return [2]
						}
					}))
				}))
			}, e.prototype.maybeParseCrossRefSection = function() {
				if (this.skipWhitespaceAndComments(), this.matchKeyword(qu.xref)) {
					this.skipWhitespaceAndComments();
					for (var t = -1, e = Cl.createEmpty(); !this.bytes.done() && _u[this.bytes.peek()];) {
						var n = this.parseRawInt();
						this.skipWhitespaceAndComments();
						var r = this.parseRawInt();
						this.skipWhitespaceAndComments();
						var i = this.bytes.peek();
						if (i === Is.n || i === Is.f) {
							var o = ol.of(t, r);
							this.bytes.next() === Is.n ? e.addEntry(o, n) : e.addDeletedEntry(o, n), t += 1
						} else t = n;
						this.skipWhitespaceAndComments()
					}
					return e
				}
			}, e.prototype.maybeParseTrailerDict = function() {
				if (this.skipWhitespaceAndComments(), this.matchKeyword(qu.trailer)) {
					this.skipWhitespaceAndComments();
					var t = this.parseDict(),
						e = this.context;
					e.trailerInfo = {
						Root: t.get(Zs.of("Root")) || e.trailerInfo.Root,
						Encrypt: t.get(Zs.of("Encrypt")) || e.trailerInfo.Encrypt,
						Info: t.get(Zs.of("Info")) || e.trailerInfo.Info,
						ID: t.get(Zs.of("ID")) || e.trailerInfo.ID
					}
				}
			}, e.prototype.maybeParseTrailer = function() {
				if (this.skipWhitespaceAndComments(), this.matchKeyword(qu.startxref)) {
					this.skipWhitespaceAndComments();
					var t = this.parseRawInt();
					return this.skipWhitespace(), this.matchKeyword(qu.eof), this.skipWhitespaceAndComments(), this.matchKeyword(qu.eof), this.skipWhitespaceAndComments(), Sl.forLastCrossRefSectionOffset(t)
				}
			}, e.prototype.parseDocumentSection = function() {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(t) {
						switch (t.label) {
							case 0:
								return [4, this.parseIndirectObjects()];
							case 1:
								return t.sent(), this.maybeParseCrossRefSection(), this.maybeParseTrailerDict(), this.maybeParseTrailer(), this.skipJibberish(), [2]
						}
					}))
				}))
			}, e.prototype.skipJibberish = function() {
				for (this.skipWhitespaceAndComments(); !this.bytes.done();) {
					var t = this.bytes.offset(),
						e = this.bytes.peek();
					if (e >= Is.Space && e <= Is.Tilde && (this.matchKeyword(qu.xref) || this.matchKeyword(qu.trailer) || this.matchKeyword(qu.startxref) || this.matchIndirectObjectHeader())) {
						this.bytes.moveTo(t);
						break
					}
					this.bytes.next()
				}
			}, e.prototype.skipBinaryHeaderComment = function() {
				this.skipWhitespaceAndComments();
				try {
					var t = this.bytes.offset();
					this.parseIndirectObjectHeader(), this.bytes.moveTo(t)
				} catch (t) {
					this.bytes.next(), this.skipWhitespaceAndComments()
				}
			}, e.forBytesWithOptions = function(t, n, r, i) {
				return new e(t, n, r, i)
			}, e
		}(Xu);
		const Qu = Ju;
		var $u, th = function(t) {
			return 1 << t
		};
		! function(t) {
			t[t.Invisible = th(0)] = "Invisible", t[t.Hidden = th(1)] = "Hidden", t[t.Print = th(2)] = "Print", t[t.NoZoom = th(3)] = "NoZoom", t[t.NoRotate = th(4)] = "NoRotate", t[t.NoView = th(5)] = "NoView", t[t.ReadOnly = th(6)] = "ReadOnly", t[t.Locked = th(7)] = "Locked", t[t.ToggleNoView = th(8)] = "ToggleNoView", t[t.LockedContents = th(9)] = "LockedContents"
		}($u || ($u = {}));
		var eh, nh = function(t) {
				return t instanceof Zs ? t : Zs.of(t)
			},
			rh = function(t) {
				return t instanceof Ns ? t : Ns.of(t)
			},
			ih = function(t) {
				return t instanceof Ns ? t.asNumber() : t
			};
		! function(t) {
			t.Degrees = "degrees", t.Radians = "radians"
		}(eh || (eh = {}));
		var oh, ah = function(t) {
				return Ya(t, "degreeAngle", ["number"]), {
					type: eh.Degrees,
					angle: t
				}
			},
			sh = eh.Radians,
			lh = eh.Degrees,
			ch = function(t) {
				return t * Math.PI / 180
			},
			uh = function(t) {
				return t.type === sh ? t.angle : t.type === lh ? ch(t.angle) : ka("Invalid rotation: " + JSON.stringify(t))
			},
			hh = function(t) {
				return t.type === sh ? 180 * t.angle / Math.PI : t.type === lh ? t.angle : ka("Invalid rotation: " + JSON.stringify(t))
			},
			fh = function(t) {
				void 0 === t && (t = 0);
				var e = t / 90 % 4;
				return 0 === e ? 0 : 1 === e ? 90 : 2 === e ? 180 : 3 === e ? 270 : 0
			},
			dh = function(t, e) {
				void 0 === e && (e = 0);
				var n = fh(e);
				return 90 === n || 270 === n ? {
					width: t.height,
					height: t.width
				} : {
					width: t.width,
					height: t.height
				}
			},
			ph = function() {
				return sl.of(cl.ClipNonZero)
			},
			gh = Math.cos,
			vh = Math.sin,
			mh = Math.tan,
			yh = function(t, e, n, r, i, o) {
				return sl.of(cl.ConcatTransformationMatrix, [rh(t), rh(e), rh(n), rh(r), rh(i), rh(o)])
			},
			bh = function(t, e) {
				return yh(1, 0, 0, 1, t, e)
			},
			xh = function(t, e) {
				return yh(t, 0, 0, e, 0, 0)
			},
			wh = function(t) {
				return yh(gh(ih(t)), vh(ih(t)), -vh(ih(t)), gh(ih(t)), 0, 0)
			},
			Ch = function(t) {
				return wh(ch(ih(t)))
			},
			Sh = function(t, e) {
				return yh(1, mh(ih(t)), mh(ih(e)), 1, 0, 0)
			},
			Oh = function(t, e) {
				return sl.of(cl.SetLineDashPattern, ["[" + t.map(rh).join(" ") + "]", rh(e)])
			};
		! function(t) {
			t[t.Butt = 0] = "Butt", t[t.Round = 1] = "Round", t[t.Projecting = 2] = "Projecting"
		}(oh || (oh = {}));
		var Th, kh = function(t) {
			return sl.of(cl.SetLineCapStyle, [rh(t)])
		};
		! function(t) {
			t[t.Miter = 0] = "Miter", t[t.Round = 1] = "Round", t[t.Bevel = 2] = "Bevel"
		}(Th || (Th = {}));
		var Fh, Ph = function(t) {
				return sl.of(cl.SetGraphicsStateParams, [nh(t)])
			},
			jh = function() {
				return sl.of(cl.PushGraphicsState)
			},
			Ah = function() {
				return sl.of(cl.PopGraphicsState)
			},
			_h = function(t) {
				return sl.of(cl.SetLineWidth, [rh(t)])
			},
			Eh = function(t, e, n, r, i, o) {
				return sl.of(cl.AppendBezierCurve, [rh(t), rh(e), rh(n), rh(r), rh(i), rh(o)])
			},
			Dh = function(t, e, n, r) {
				return sl.of(cl.CurveToReplicateInitialPoint, [rh(t), rh(e), rh(n), rh(r)])
			},
			Mh = function() {
				return sl.of(cl.ClosePath)
			},
			Ih = function(t, e) {
				return sl.of(cl.MoveTo, [rh(t), rh(e)])
			},
			Rh = function(t, e) {
				return sl.of(cl.LineTo, [rh(t), rh(e)])
			},
			Bh = function() {
				return sl.of(cl.StrokePath)
			},
			Nh = function() {
				return sl.of(cl.FillNonZero)
			},
			Lh = function() {
				return sl.of(cl.FillNonZeroAndStroke)
			},
			zh = function() {
				return sl.of(cl.EndPath)
			},
			Wh = function(t) {
				return sl.of(cl.ShowText, [t])
			},
			Vh = function() {
				return sl.of(cl.BeginText)
			},
			Uh = function() {
				return sl.of(cl.EndText)
			},
			Hh = function(t, e) {
				return sl.of(cl.SetFontAndSize, [nh(t), rh(e)])
			};
		! function(t) {
			t[t.Fill = 0] = "Fill", t[t.Outline = 1] = "Outline", t[t.FillAndOutline = 2] = "FillAndOutline", t[t.Invisible = 3] = "Invisible", t[t.FillAndClip = 4] = "FillAndClip", t[t.OutlineAndClip = 5] = "OutlineAndClip", t[t.FillAndOutlineAndClip = 6] = "FillAndOutlineAndClip", t[t.Clip = 7] = "Clip"
		}(Fh || (Fh = {}));
		var qh, Xh = function(t, e, n, r, i) {
				return o = gh(ih(t)), a = vh(ih(t)) + mh(ih(e)), s = -vh(ih(t)) + mh(ih(n)), l = gh(ih(t)), c = r, u = i, sl.of(cl.SetTextMatrix, [rh(o), rh(a), rh(s), rh(l), rh(c), rh(u)]);
				var o, a, s, l, c, u
			},
			Gh = function(t) {
				return sl.of(cl.DrawObject, [nh(t)])
			},
			Kh = function(t) {
				return sl.of(cl.BeginMarkedContent, [nh(t)])
			},
			Yh = function() {
				return sl.of(cl.EndMarkedContent)
			};
		! function(t) {
			t.Grayscale = "Grayscale", t.RGB = "RGB", t.CMYK = "CMYK"
		}(qh || (qh = {}));
		var Zh, Jh = function(t) {
				return Qa(t, "gray", 0, 1), {
					type: qh.Grayscale,
					gray: t
				}
			},
			Qh = function(t, e, n) {
				return Qa(t, "red", 0, 1), Qa(e, "green", 0, 1), Qa(n, "blue", 0, 1), {
					type: qh.RGB,
					red: t,
					green: e,
					blue: n
				}
			},
			$h = function(t, e, n, r) {
				return Qa(t, "cyan", 0, 1), Qa(e, "magenta", 0, 1), Qa(n, "yellow", 0, 1), Qa(r, "key", 0, 1), {
					type: qh.CMYK,
					cyan: t,
					magenta: e,
					yellow: n,
					key: r
				}
			},
			tf = qh.Grayscale,
			ef = qh.RGB,
			nf = qh.CMYK,
			rf = function(t) {
				return t.type === tf ? (l = t.gray, sl.of(cl.NonStrokingColorGray, [rh(l)])) : t.type === ef ? (o = t.red, a = t.green, s = t.blue, sl.of(cl.NonStrokingColorRgb, [rh(o), rh(a), rh(s)])) : t.type === nf ? (e = t.cyan, n = t.magenta, r = t.yellow, i = t.key, sl.of(cl.NonStrokingColorCmyk, [rh(e), rh(n), rh(r), rh(i)])) : ka("Invalid color: " + JSON.stringify(t));
				var e, n, r, i, o, a, s, l
			},
			of = function(t) {
				return t.type === tf ? (l = t.gray, sl.of(cl.StrokingColorGray, [rh(l)])) : t.type === ef ? (o = t.red, a = t.green, s = t.blue, sl.of(cl.StrokingColorRgb, [rh(o), rh(a), rh(s)])) : t.type === nf ? (e = t.cyan, n = t.magenta, r = t.yellow, i = t.key, sl.of(cl.StrokingColorCmyk, [rh(e), rh(n), rh(r), rh(i)])) : ka("Invalid color: " + JSON.stringify(t));
				var e, n, r, i, o, a, s, l
			},
			af = function(t, e) {
				return void 0 === e && (e = 1), 1 === (null == t ? void 0 : t.length) ? Jh(t[0] * e) : 3 === (null == t ? void 0 : t.length) ? Qh(t[0] * e, t[1] * e, t[2] * e) : 4 === (null == t ? void 0 : t.length) ? $h(t[0] * e, t[1] * e, t[2] * e, t[3] * e) : void 0
			},
			sf = function(t) {
				return t.type === tf ? [t.gray] : t.type === ef ? [t.red, t.green, t.blue] : t.type === nf ? [t.cyan, t.magenta, t.yellow, t.key] : ka("Invalid color: " + JSON.stringify(t))
			},
			lf = 0,
			cf = 0,
			uf = 0,
			hf = 0,
			ff = 0,
			df = 0,
			pf = new Map([
				["A", 7],
				["a", 7],
				["C", 6],
				["c", 6],
				["H", 1],
				["h", 1],
				["L", 2],
				["l", 2],
				["M", 2],
				["m", 2],
				["Q", 4],
				["q", 4],
				["S", 4],
				["s", 4],
				["T", 2],
				["t", 2],
				["V", 1],
				["v", 1],
				["Z", 0],
				["z", 0]
			]),
			gf = {
				M: function(t) {
					return lf = t[0], cf = t[1], uf = hf = null, ff = lf, df = cf, Ih(lf, cf)
				},
				m: function(t) {
					return lf += t[0], cf += t[1], uf = hf = null, ff = lf, df = cf, Ih(lf, cf)
				},
				C: function(t) {
					return lf = t[4], cf = t[5], uf = t[2], hf = t[3], Eh(t[0], t[1], t[2], t[3], t[4], t[5])
				},
				c: function(t) {
					var e = Eh(t[0] + lf, t[1] + cf, t[2] + lf, t[3] + cf, t[4] + lf, t[5] + cf);
					return uf = lf + t[2], hf = cf + t[3], lf += t[4], cf += t[5], e
				},
				S: function(t) {
					null !== uf && null !== hf || (uf = lf, hf = cf);
					var e = Eh(lf - (uf - lf), cf - (hf - cf), t[0], t[1], t[2], t[3]);
					return uf = t[0], hf = t[1], lf = t[2], cf = t[3], e
				},
				s: function(t) {
					null !== uf && null !== hf || (uf = lf, hf = cf);
					var e = Eh(lf - (uf - lf), cf - (hf - cf), lf + t[0], cf + t[1], lf + t[2], cf + t[3]);
					return uf = lf + t[0], hf = cf + t[1], lf += t[2], cf += t[3], e
				},
				Q: function(t) {
					return uf = t[0], hf = t[1], lf = t[2], cf = t[3], Dh(t[0], t[1], lf, cf)
				},
				q: function(t) {
					var e = Dh(t[0] + lf, t[1] + cf, t[2] + lf, t[3] + cf);
					return uf = lf + t[0], hf = cf + t[1], lf += t[2], cf += t[3], e
				},
				T: function(t) {
					null === uf || null === hf ? (uf = lf, hf = cf) : (uf = lf - (uf - lf), hf = cf - (hf - cf));
					var e = Dh(uf, hf, t[0], t[1]);
					return uf = lf - (uf - lf), hf = cf - (hf - cf), lf = t[0], cf = t[1], e
				},
				t: function(t) {
					null === uf || null === hf ? (uf = lf, hf = cf) : (uf = lf - (uf - lf), hf = cf - (hf - cf));
					var e = Dh(uf, hf, lf + t[0], cf + t[1]);
					return lf += t[0], cf += t[1], e
				},
				A: function(t) {
					var e = vf(lf, cf, t);
					return lf = t[5], cf = t[6], e
				},
				a: function(t) {
					t[5] += lf, t[6] += cf;
					var e = vf(lf, cf, t);
					return lf = t[5], cf = t[6], e
				},
				L: function(t) {
					return lf = t[0], cf = t[1], uf = hf = null, Rh(lf, cf)
				},
				l: function(t) {
					return lf += t[0], cf += t[1], uf = hf = null, Rh(lf, cf)
				},
				H: function(t) {
					return lf = t[0], uf = hf = null, Rh(lf, cf)
				},
				h: function(t) {
					return lf += t[0], uf = hf = null, Rh(lf, cf)
				},
				V: function(t) {
					return cf = t[0], uf = hf = null, Rh(lf, cf)
				},
				v: function(t) {
					return cf += t[0], uf = hf = null, Rh(lf, cf)
				},
				Z: function() {
					var t = Mh();
					return lf = ff, cf = df, t
				},
				z: function() {
					var t = Mh();
					return lf = ff, cf = df, t
				}
			},
			vf = function(t, e, n) {
				for (var r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5], c = n[6], u = [], h = 0, f = mf(l, c, r, i, a, s, o, t, e); h < f.length; h++) {
					var d = f[h],
						p = yf.apply(void 0, d);
					u.push(Eh.apply(void 0, p))
				}
				return u
			},
			mf = function(t, e, n, r, i, o, a, s, l) {
				var c = a * (Math.PI / 180),
					u = Math.sin(c),
					h = Math.cos(c);
				n = Math.abs(n), r = Math.abs(r);
				var f = (uf = h * (s - t) * .5 + u * (l - e) * .5) * uf / (n * n) + (hf = h * (l - e) * .5 - u * (s - t) * .5) * hf / (r * r);
				f > 1 && (n *= f = Math.sqrt(f), r *= f);
				var d = h / n,
					p = u / n,
					g = -u / r,
					v = h / r,
					m = d * s + p * l,
					y = g * s + v * l,
					b = d * t + p * e,
					x = g * t + v * e,
					w = 1 / ((b - m) * (b - m) + (x - y) * (x - y)) - .25;
				w < 0 && (w = 0);
				var C = Math.sqrt(w);
				o === i && (C = -C);
				var S = .5 * (m + b) - C * (x - y),
					O = .5 * (y + x) + C * (b - m),
					T = Math.atan2(y - O, m - S),
					k = Math.atan2(x - O, b - S) - T;
				k < 0 && 1 === o ? k += 2 * Math.PI : k > 0 && 0 === o && (k -= 2 * Math.PI);
				for (var F = Math.ceil(Math.abs(k / (.5 * Math.PI + .001))), P = [], j = 0; j < F; j++) {
					var A = T + j * k / F,
						_ = T + (j + 1) * k / F;
					P[j] = [S, O, A, _, n, r, u, h]
				}
				return P
			},
			yf = function(t, e, n, r, i, o, a, s) {
				var l = s * i,
					c = -a * o,
					u = a * i,
					h = s * o,
					f = .5 * (r - n),
					d = 8 / 3 * Math.sin(.5 * f) * Math.sin(.5 * f) / Math.sin(f),
					p = t + Math.cos(n) - d * Math.sin(n),
					g = e + Math.sin(n) + d * Math.cos(n),
					v = t + Math.cos(r),
					m = e + Math.sin(r),
					y = v + d * Math.sin(r),
					b = m - d * Math.cos(r);
				return [l * p + c * g, u * p + h * g, l * y + c * b, u * y + h * b, l * v + c * m, u * v + h * m]
			},
			bf = function(t, e) {
				return [jh(), e.graphicsState && Ph(e.graphicsState), bh(e.x, e.y), wh(uh(e.rotate)), xh(e.width, e.height), Sh(uh(e.xSkew), uh(e.ySkew)), Gh(t), Ah()].filter(Boolean)
			},
			xf = function(t) {
				var e, n;
				return [jh(), t.graphicsState && Ph(t.graphicsState), t.color && rf(t.color), t.borderColor && of(t.borderColor), _h(t.borderWidth), t.borderLineCap && kh(t.borderLineCap), Oh(null !== (e = t.borderDashArray) && void 0 !== e ? e : [], null !== (n = t.borderDashPhase) && void 0 !== n ? n : 0), bh(t.x, t.y), wh(uh(t.rotate)), Sh(uh(t.xSkew), uh(t.ySkew)), Ih(0, 0), Rh(0, t.height), Rh(t.width, t.height), Rh(t.width, 0), Mh(), t.color && t.borderWidth ? Lh() : t.color ? Nh() : t.borderColor ? Bh() : Mh(), Ah()].filter(Boolean)
			},
			wf = (Math.sqrt(2) - 1) / 3 * 4,
			Cf = function(t) {
				var e, n, r;
				return Bo([jh(), t.graphicsState && Ph(t.graphicsState), t.color && rf(t.color), t.borderColor && of(t.borderColor), _h(t.borderWidth), t.borderLineCap && kh(t.borderLineCap), Oh(null !== (e = t.borderDashArray) && void 0 !== e ? e : [], null !== (n = t.borderDashPhase) && void 0 !== n ? n : 0)], void 0 === t.rotate ? function(t) {
					var e = ih(t.x),
						n = ih(t.y),
						r = ih(t.xScale),
						i = ih(t.yScale),
						o = r * wf,
						a = i * wf,
						s = (e -= r) + 2 * r,
						l = (n -= i) + 2 * i,
						c = e + r,
						u = n + i;
					return [jh(), Ih(e, u), Eh(e, u - a, c - o, n, c, n), Eh(c + o, n, s, u - a, s, u), Eh(s, u + a, c + o, l, c, l), Eh(c - o, l, e, u + a, e, u), Ah()]
				}({
					x: t.x,
					y: t.y,
					xScale: t.xScale,
					yScale: t.yScale
				}) : function(t) {
					var e = ih(t.x),
						n = ih(t.y),
						r = ih(t.xScale),
						i = ih(t.yScale),
						o = -r,
						a = -i,
						s = r * wf,
						l = i * wf,
						c = o + 2 * r,
						u = a + 2 * i,
						h = o + r,
						f = a + i;
					return [bh(e, n), wh(uh(t.rotate)), Ih(o, f), Eh(o, f - l, h - s, a, h, a), Eh(h + s, a, c, f - l, c, f), Eh(c, f + l, h + s, u, h, u), Eh(h - s, u, o, f + l, o, f)]
				}({
					x: t.x,
					y: t.y,
					xScale: t.xScale,
					yScale: t.yScale,
					rotate: null !== (r = t.rotate) && void 0 !== r ? r : ah(0)
				}), [t.color && t.borderWidth ? Lh() : t.color ? Nh() : t.borderColor ? Bh() : Mh(), Ah()]).filter(Boolean)
			},
			Sf = function(t) {
				return 0 === t.rotation ? [bh(0, 0), Ch(0)] : 90 === t.rotation ? [bh(t.width, 0), Ch(90)] : 180 === t.rotation ? [bh(t.width, t.height), Ch(180)] : 270 === t.rotation ? [bh(0, t.height), Ch(270)] : []
			},
			Of = function(t) {
				var e = xf({
					x: t.x,
					y: t.y,
					width: t.width,
					height: t.height,
					borderWidth: t.borderWidth,
					color: t.color,
					borderColor: t.borderColor,
					rotate: ah(0),
					xSkew: ah(0),
					ySkew: ah(0)
				});
				if (!t.filled) return e;
				var n = ih(t.width),
					r = ih(t.height),
					i = function(t) {
						var e = ih(t.size);
						return [jh(), t.color && of(t.color), _h(t.thickness), bh(t.x, t.y), Ih(-.675 * e, -.07601036269430045 * e), Rh(-.25 * e, -.49 * e), Rh(.69 * e, .475 * e), Bh(), Ah()].filter(Boolean)
					}({
						x: n / 2,
						y: r / 2,
						size: Math.min(n, r) / 2,
						thickness: t.thickness,
						color: t.markColor
					});
				return Bo([jh()], e, i, [Ah()])
			},
			Tf = function(t) {
				var e = ih(t.width),
					n = ih(t.height),
					r = Math.min(e, n) / 2,
					i = Cf({
						x: t.x,
						y: t.y,
						xScale: r,
						yScale: r,
						color: t.color,
						borderColor: t.borderColor,
						borderWidth: t.borderWidth
					});
				if (!t.filled) return i;
				var o = Cf({
					x: t.x,
					y: t.y,
					xScale: .45 * r,
					yScale: .45 * r,
					color: t.dotColor,
					borderColor: void 0,
					borderWidth: 0
				});
				return Bo([jh()], i, o, [Ah()])
			},
			kf = function(t) {
				var e = ih(t.x),
					n = ih(t.y),
					r = ih(t.width),
					i = ih(t.height),
					o = xf({
						x: e,
						y: n,
						width: r,
						height: i,
						borderWidth: t.borderWidth,
						color: t.color,
						borderColor: t.borderColor,
						rotate: ah(0),
						xSkew: ah(0),
						ySkew: ah(0)
					}),
					a = Ff(t.textLines, {
						color: t.textColor,
						font: t.font,
						size: t.fontSize,
						rotate: ah(0),
						xSkew: ah(0),
						ySkew: ah(0)
					});
				return Bo([jh()], o, a, [Ah()])
			},
			Ff = function(t, e) {
				for (var n = [Vh(), rf(e.color), Hh(e.font, e.size)], r = 0, i = t.length; r < i; r++) {
					var o = t[r],
						a = o.encoded,
						s = o.x,
						l = o.y;
					n.push(Xh(uh(e.rotate), uh(e.xSkew), uh(e.ySkew), s, l), Wh(a))
				}
				return n.push(Uh()), n
			},
			Pf = function(t) {
				var e = ih(t.x),
					n = ih(t.y),
					r = ih(t.width),
					i = ih(t.height),
					o = ih(t.borderWidth),
					a = ih(t.padding),
					s = e + o / 2 + a,
					l = n + o / 2 + a,
					c = r - 2 * (o / 2 + a),
					u = i - 2 * (o / 2 + a),
					h = [Ih(s, l), Rh(s, l + u), Rh(s + c, l + u), Rh(s + c, l), Mh(), ph(), zh()],
					f = xf({
						x: e,
						y: n,
						width: r,
						height: i,
						borderWidth: t.borderWidth,
						color: t.color,
						borderColor: t.borderColor,
						rotate: ah(0),
						xSkew: ah(0),
						ySkew: ah(0)
					}),
					d = Ff(t.textLines, {
						color: t.textColor,
						font: t.font,
						size: t.fontSize,
						rotate: ah(0),
						xSkew: ah(0),
						ySkew: ah(0)
					}),
					p = Bo([Kh("Tx"), jh()], d, [Ah(), Yh()]);
				return Bo([jh()], f, h, p, [Ah()])
			},
			jf = function(t) {
				function e() {
					return t.call(this, "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.") || this
				}
				return Do(e, t), e
			}(Error),
			Af = function(t) {
				function e() {
					return t.call(this, "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.") || this
				}
				return Do(e, t), e
			}(Error),
			_f = function(t) {
				function e() {
					return t.call(this, "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.") || this
				}
				return Do(e, t), e
			}(Error),
			Ef = function(t) {
				function e() {
					return t.call(this, "PDFDocument has no pages so `PDFDocument.removePage` cannot be called") || this
				}
				return Do(e, t), e
			}(Error),
			Df = function(t) {
				function e(e) {
					var n = 'PDFDocument has no form field with the name "' + e + '"';
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			Mf = function(t) {
				function e(e, n, r) {
					var i, o, a = 'Expected field "' + e + '" to be of type ' + (null == n ? void 0 : n.name) + ", but it is actually of type " + (null !== (o = null === (i = null == r ? void 0 : r.constructor) || void 0 === i ? void 0 : i.name) && void 0 !== o ? o : r);
					return t.call(this, a) || this
				}
				return Do(e, t), e
			}(Error),
			If = (function(t) {
				Do((function(e) {
					var n = 'Failed to select check box due to missing onValue: "' + e + '"';
					return t.call(this, n) || this
				}), t)
			}(Error), function(t) {
				function e(e) {
					var n = 'A field already exists with the specified name: "' + e + '"';
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error)),
			Rf = function(t) {
				function e(e) {
					var n = 'Field name contains invalid component: "' + e + '"';
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error),
			Bf = (function(t) {
				Do((function(e) {
					var n = 'A non-terminal field already exists with the specified name: "' + e + '"';
					return t.call(this, n) || this
				}), t)
			}(Error), function(t) {
				function e(e) {
					var n = "Reading rich text fields is not supported: Attempted to read rich text field: " + e;
					return t.call(this, n) || this
				}
				return Do(e, t), e
			}(Error)),
			Nf = function(t) {
				function e(e, n) {
					var r = "Failed to layout combed text as lineLength=" + e + " is greater than cellCount=" + n;
					return t.call(this, r) || this
				}
				return Do(e, t), e
			}(Error),
			Lf = function(t) {
				function e(e, n, r) {
					var i = "Attempted to set text with length=" + e + " for TextField with maxLength=" + n + " and name=" + r;
					return t.call(this, i) || this
				}
				return Do(e, t), e
			}(Error),
			zf = function(t) {
				function e(e, n, r) {
					var i = "Attempted to set maxLength=" + n + ", which is less than " + e + ", the length of this field's current value (name=" + r + ")";
					return t.call(this, i) || this
				}
				return Do(e, t), e
			}(Error);
		! function(t) {
			t[t.Left = 0] = "Left", t[t.Center = 1] = "Center", t[t.Right = 2] = "Right"
		}(Zh || (Zh = {}));
		var Wf = function(t, e, n, r) {
				void 0 === r && (r = !1);
				for (var i = 4; i < 500;) {
					for (var o = 0, a = 0, s = t.length; a < s; a++) {
						o += 1;
						for (var l = t[a].split(" "), c = n.width, u = 0, h = l.length; u < h; u++) {
							var f = u === h - 1 ? l[u] : l[u] + " ",
								d = e.widthOfTextAtSize(f, i);
							(c -= d) <= 0 && (o += 1, c = n.width - d)
						}
					}
					if (!r && o > t.length) return i - 1;
					var p = e.heightAtSize(i);
					if ((p + .2 * p) * o > Math.abs(n.height)) return i - 1;
					i += 1
				}
				return i
			},
			Vf = function(t) {
				for (var e = t.length; e > 0; e--)
					if (/\s/.test(t[e])) return e
			},
			Uf = function(t, e, n, r) {
				for (var i, o = t.length; o > 0;) {
					var a = t.substring(0, o),
						s = n.encodeText(a),
						l = n.widthOfTextAtSize(a, r);
					if (l < e) return {
						line: a,
						encoded: s,
						width: l,
						remainder: t.substring(o) || void 0
					};
					o = null !== (i = Vf(a)) && void 0 !== i ? i : 0
				}
				return {
					line: t,
					encoded: n.encodeText(t),
					width: n.widthOfTextAtSize(t, r),
					remainder: void 0
				}
			},
			Hf = function(t, e) {
				var n = e.alignment,
					r = e.fontSize,
					i = e.font,
					o = e.bounds,
					a = $o(Zo(t));
				void 0 !== r && 0 !== r || (r = Wf(a, i, o, !0));
				for (var s = i.heightAtSize(r), l = s + .2 * s, c = [], u = o.x, h = o.y, f = o.x + o.width, d = o.y + o.height, p = o.y + o.height, g = 0, v = a.length; g < v; g++)
					for (var m = a[g]; void 0 !== m;) {
						var y = Uf(m, o.width, i, r),
							b = y.line,
							x = y.encoded,
							w = y.width,
							C = y.remainder,
							S = n === Zh.Left ? o.x : n === Zh.Center ? o.x + o.width / 2 - w / 2 : n === Zh.Right ? o.x + o.width - w : o.x;
						S < u && (u = S), (p -= l) < h && (h = p), S + w > f && (f = S + w), p + s > d && (d = p + s), c.push({
							text: b,
							encoded: x,
							width: w,
							height: s,
							x: S,
							y: p
						}), m = null == C ? void 0 : C.trim()
					}
				return {
					fontSize: r,
					lineHeight: l,
					lines: c,
					bounds: {
						x: u,
						y: h,
						width: f - u,
						height: d - h
					}
				}
			},
			qf = function(t, e) {
				var n = e.alignment,
					r = e.fontSize,
					i = e.font,
					o = e.bounds,
					a = ta(Zo(t));
				void 0 !== r && 0 !== r || (r = Wf([a], i, o));
				var s = i.encodeText(a),
					l = i.widthOfTextAtSize(a, r),
					c = i.heightAtSize(r, {
						descender: !1
					}),
					u = n === Zh.Left ? o.x : n === Zh.Center ? o.x + o.width / 2 - l / 2 : n === Zh.Right ? o.x + o.width - l : o.x,
					h = o.y + (o.height / 2 - c / 2);
				return {
					fontSize: r,
					line: {
						text: a,
						encoded: s,
						width: l,
						height: c,
						x: u,
						y: h
					},
					bounds: {
						x: u,
						y: h,
						width: l,
						height: c
					}
				}
			},
			Xf = function(t) {
				return "normal" in t ? t : {
					normal: t
				}
			},
			Gf = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/,
			Kf = function(t) {
				var e, n, r = null !== (e = t.getDefaultAppearance()) && void 0 !== e ? e : "",
					i = null !== (n = ia(r, Gf).match) && void 0 !== n ? n : [],
					o = Number(i[2]);
				return isFinite(o) ? o : void 0
			},
			Yf = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/,
			Zf = function(t) {
				var e, n = null !== (e = t.getDefaultAppearance()) && void 0 !== e ? e : "",
					r = ia(n, Yf).match,
					i = null != r ? r : [],
					o = i[1],
					a = i[2],
					s = i[3],
					l = i[4],
					c = i[5];
				return "g" === c && o ? Jh(Number(o)) : "rg" === c && o && a && s ? Qh(Number(o), Number(a), Number(s)) : "k" === c && o && a && s && l ? $h(Number(o), Number(a), Number(s), Number(l)) : void 0
			},
			Jf = function(t, e, n, r) {
				var i;
				void 0 === r && (r = 0);
				var o = [rf(e).toString(), Hh(null !== (i = null == n ? void 0 : n.name) && void 0 !== i ? i : "dummy__noop", r).toString()].join("\n");
				t.setDefaultAppearance(o)
			},
			Qf = function(t, e) {
				var n, r, i, o = Zf(e),
					a = Zf(t.acroField),
					s = e.getRectangle(),
					l = e.getAppearanceCharacteristics(),
					c = e.getBorderStyle(),
					u = null !== (n = null == c ? void 0 : c.getWidth()) && void 0 !== n ? n : 0,
					h = fh(null == l ? void 0 : l.getRotation()),
					f = dh(s, h),
					d = f.width,
					p = f.height,
					g = Sf(Mo(Mo({}, s), {
						rotation: h
					})),
					v = Qh(0, 0, 0),
					m = null !== (r = af(null == l ? void 0 : l.getBorderColor())) && void 0 !== r ? r : v,
					y = af(null == l ? void 0 : l.getBackgroundColor()),
					b = af(null == l ? void 0 : l.getBackgroundColor(), .8),
					x = null !== (i = null != o ? o : a) && void 0 !== i ? i : v;
				Jf(o ? e : t.acroField, x);
				var w = {
					x: 0 + u / 2,
					y: 0 + u / 2,
					width: d - u,
					height: p - u,
					thickness: 1.5,
					borderWidth: u,
					borderColor: m,
					markColor: x
				};
				return {
					normal: {
						on: Bo(g, Of(Mo(Mo({}, w), {
							color: y,
							filled: !0
						}))),
						off: Bo(g, Of(Mo(Mo({}, w), {
							color: y,
							filled: !1
						})))
					},
					down: {
						on: Bo(g, Of(Mo(Mo({}, w), {
							color: b,
							filled: !0
						}))),
						off: Bo(g, Of(Mo(Mo({}, w), {
							color: b,
							filled: !1
						})))
					}
				}
			},
			$f = function(t, e) {
				var n, r, i, o = Zf(e),
					a = Zf(t.acroField),
					s = e.getRectangle(),
					l = e.getAppearanceCharacteristics(),
					c = e.getBorderStyle(),
					u = null !== (n = null == c ? void 0 : c.getWidth()) && void 0 !== n ? n : 0,
					h = fh(null == l ? void 0 : l.getRotation()),
					f = dh(s, h),
					d = f.width,
					p = f.height,
					g = Sf(Mo(Mo({}, s), {
						rotation: h
					})),
					v = Qh(0, 0, 0),
					m = null !== (r = af(null == l ? void 0 : l.getBorderColor())) && void 0 !== r ? r : v,
					y = af(null == l ? void 0 : l.getBackgroundColor()),
					b = af(null == l ? void 0 : l.getBackgroundColor(), .8),
					x = null !== (i = null != o ? o : a) && void 0 !== i ? i : v;
				Jf(o ? e : t.acroField, x);
				var w = {
					x: d / 2,
					y: p / 2,
					width: d - u,
					height: p - u,
					borderWidth: u,
					borderColor: m,
					dotColor: x
				};
				return {
					normal: {
						on: Bo(g, Tf(Mo(Mo({}, w), {
							color: y,
							filled: !0
						}))),
						off: Bo(g, Tf(Mo(Mo({}, w), {
							color: y,
							filled: !1
						})))
					},
					down: {
						on: Bo(g, Tf(Mo(Mo({}, w), {
							color: b,
							filled: !0
						}))),
						off: Bo(g, Tf(Mo(Mo({}, w), {
							color: b,
							filled: !1
						})))
					}
				}
			},
			td = function(t, e, n) {
				var r, i, o, a, s, l = Zf(e),
					c = Zf(t.acroField),
					u = Kf(e),
					h = Kf(t.acroField),
					f = e.getRectangle(),
					d = e.getAppearanceCharacteristics(),
					p = e.getBorderStyle(),
					g = null == d ? void 0 : d.getCaptions(),
					v = null !== (r = null == g ? void 0 : g.normal) && void 0 !== r ? r : "",
					m = null !== (o = null !== (i = null == g ? void 0 : g.down) && void 0 !== i ? i : v) && void 0 !== o ? o : "",
					y = null !== (a = null == p ? void 0 : p.getWidth()) && void 0 !== a ? a : 0,
					b = fh(null == d ? void 0 : d.getRotation()),
					x = dh(f, b),
					w = x.width,
					C = x.height,
					S = Sf(Mo(Mo({}, f), {
						rotation: b
					})),
					O = Qh(0, 0, 0),
					T = af(null == d ? void 0 : d.getBorderColor()),
					k = af(null == d ? void 0 : d.getBackgroundColor()),
					F = af(null == d ? void 0 : d.getBackgroundColor(), .8),
					P = {
						x: y,
						y,
						width: w - 2 * y,
						height: C - 2 * y
					},
					j = qf(v, {
						alignment: Zh.Center,
						fontSize: null != u ? u : h,
						font: n,
						bounds: P
					}),
					A = qf(m, {
						alignment: Zh.Center,
						fontSize: null != u ? u : h,
						font: n,
						bounds: P
					}),
					_ = Math.min(j.fontSize, A.fontSize),
					E = null !== (s = null != l ? l : c) && void 0 !== s ? s : O;
				Jf(l || void 0 !== u ? e : t.acroField, E, n, _);
				var D = {
					x: 0 + y / 2,
					y: 0 + y / 2,
					width: w - y,
					height: C - y,
					borderWidth: y,
					borderColor: T,
					textColor: E,
					font: n.name,
					fontSize: _
				};
				return {
					normal: Bo(S, kf(Mo(Mo({}, D), {
						color: k,
						textLines: [j.line]
					}))),
					down: Bo(S, kf(Mo(Mo({}, D), {
						color: F,
						textLines: [A.line]
					})))
				}
			},
			ed = function(t, e, n) {
				var r, i, o, a, s, l, c = Zf(e),
					u = Zf(t.acroField),
					h = Kf(e),
					f = Kf(t.acroField),
					d = e.getRectangle(),
					p = e.getAppearanceCharacteristics(),
					g = e.getBorderStyle(),
					v = null !== (r = t.getText()) && void 0 !== r ? r : "",
					m = null !== (i = null == g ? void 0 : g.getWidth()) && void 0 !== i ? i : 0,
					y = fh(null == p ? void 0 : p.getRotation()),
					b = dh(d, y),
					x = b.width,
					w = b.height,
					C = Sf(Mo(Mo({}, d), {
						rotation: y
					})),
					S = Qh(0, 0, 0),
					O = af(null == p ? void 0 : p.getBorderColor()),
					T = af(null == p ? void 0 : p.getBackgroundColor()),
					k = t.isCombed() ? 0 : 1,
					F = {
						x: m + k,
						y: m + k,
						width: x - 2 * (m + k),
						height: w - 2 * (m + k)
					};
				if (t.isMultiline()) s = (P = Hf(v, {
					alignment: t.getAlignment(),
					fontSize: null != h ? h : f,
					font: n,
					bounds: F
				})).lines, l = P.fontSize;
				else if (t.isCombed()) {
					var P = function(t, e) {
						var n = e.fontSize,
							r = e.font,
							i = e.bounds,
							o = e.cellCount,
							a = ta(Zo(t));
						if (a.length > o) throw new Nf(a.length, o);
						void 0 !== n && 0 !== n || (n = function(t, e, n, r) {
							for (var i = n.width / r, o = n.height, a = 4, s = function(t) {
									for (var e = [], n = 0, r = t.length; n < r;) {
										var i = ea(t, n),
											o = i[0],
											a = i[1];
										e.push(o), n += a
									}
									return e
								}(t); a < 500;) {
								for (var l = 0, c = s.length; l < c; l++) {
									var u = s[l];
									if (e.widthOfTextAtSize(u, a) > .75 * i) return a - 1
								}
								if (e.heightAtSize(a, {
										descender: !1
									}) > o) return a - 1;
								a += 1
							}
							return a
						}(a, r, i, o));
						for (var s = i.width / o, l = r.heightAtSize(n, {
								descender: !1
							}), c = i.y + (i.height / 2 - l / 2), u = [], h = i.x, f = i.y, d = i.x + i.width, p = i.y + i.height, g = 0, v = 0; g < o;) {
							var m = ea(a, v),
								y = m[0],
								b = m[1],
								x = r.encodeText(y),
								w = r.widthOfTextAtSize(y, n),
								C = i.x + (s * g + s / 2) - w / 2;
							C < h && (h = C), c < f && (f = c), C + w > d && (d = C + w), c + l > p && (p = c + l), u.push({
								text: a,
								encoded: x,
								width: w,
								height: l,
								x: C,
								y: c
							}), g += 1, v += b
						}
						return {
							fontSize: n,
							cells: u,
							bounds: {
								x: h,
								y: f,
								width: d - h,
								height: p - f
							}
						}
					}(v, {
						fontSize: null != h ? h : f,
						font: n,
						bounds: F,
						cellCount: null !== (o = t.getMaxLength()) && void 0 !== o ? o : 0
					});
					s = P.cells, l = P.fontSize
				} else s = [(P = qf(v, {
					alignment: t.getAlignment(),
					fontSize: null != h ? h : f,
					font: n,
					bounds: F
				})).line], l = P.fontSize;
				var j = null !== (a = null != c ? c : u) && void 0 !== a ? a : S;
				Jf(c || void 0 !== h ? e : t.acroField, j, n, l);
				var A = {
					x: 0 + m / 2,
					y: 0 + m / 2,
					width: x - m,
					height: w - m,
					borderWidth: null != m ? m : 0,
					borderColor: O,
					textColor: j,
					font: n.name,
					fontSize: l,
					color: T,
					textLines: s,
					padding: k
				};
				return Bo(C, Pf(A))
			},
			nd = function(t, e, n) {
				var r, i, o, a = Zf(e),
					s = Zf(t.acroField),
					l = Kf(e),
					c = Kf(t.acroField),
					u = e.getRectangle(),
					h = e.getAppearanceCharacteristics(),
					f = e.getBorderStyle(),
					d = null !== (r = t.getSelected()[0]) && void 0 !== r ? r : "",
					p = null !== (i = null == f ? void 0 : f.getWidth()) && void 0 !== i ? i : 0,
					g = fh(null == h ? void 0 : h.getRotation()),
					v = dh(u, g),
					m = v.width,
					y = v.height,
					b = Sf(Mo(Mo({}, u), {
						rotation: g
					})),
					x = Qh(0, 0, 0),
					w = af(null == h ? void 0 : h.getBorderColor()),
					C = af(null == h ? void 0 : h.getBackgroundColor()),
					S = {
						x: p + 1,
						y: p + 1,
						width: m - 2 * (p + 1),
						height: y - 2 * (p + 1)
					},
					O = qf(d, {
						alignment: Zh.Left,
						fontSize: null != l ? l : c,
						font: n,
						bounds: S
					}),
					T = O.line,
					k = O.fontSize,
					F = null !== (o = null != a ? a : s) && void 0 !== o ? o : x;
				Jf(a || void 0 !== l ? e : t.acroField, F, n, k);
				var P = {
					x: 0 + p / 2,
					y: 0 + p / 2,
					width: m - p,
					height: y - p,
					borderWidth: null != p ? p : 0,
					borderColor: w,
					textColor: F,
					font: n.name,
					fontSize: k,
					color: C,
					textLines: [T],
					padding: 1
				};
				return Bo(b, Pf(P))
			},
			rd = function(t, e, n) {
				var r, i, o = Zf(e),
					a = Zf(t.acroField),
					s = Kf(e),
					l = Kf(t.acroField),
					c = e.getRectangle(),
					u = e.getAppearanceCharacteristics(),
					h = e.getBorderStyle(),
					f = null !== (r = null == h ? void 0 : h.getWidth()) && void 0 !== r ? r : 0,
					d = fh(null == u ? void 0 : u.getRotation()),
					p = dh(c, d),
					g = p.width,
					v = p.height,
					m = Sf(Mo(Mo({}, c), {
						rotation: d
					})),
					y = Qh(0, 0, 0),
					b = af(null == u ? void 0 : u.getBorderColor()),
					x = af(null == u ? void 0 : u.getBackgroundColor()),
					w = t.getOptions(),
					C = t.getSelected();
				t.isSorted() && w.sort();
				for (var S = "", O = 0, T = w.length; O < T; O++) S += w[O], O < T - 1 && (S += "\n");
				var k = {
						x: f + 1,
						y: f + 1,
						width: g - 2 * (f + 1),
						height: v - 2 * (f + 1)
					},
					F = Hf(S, {
						alignment: Zh.Left,
						fontSize: null != s ? s : l,
						font: n,
						bounds: k
					}),
					P = F.lines,
					j = F.fontSize,
					A = F.lineHeight,
					_ = [];
				for (O = 0, T = P.length; O < T; O++) {
					var E = P[O];
					C.includes(E.text) && _.push(O)
				}
				var D = Qh(.6, 193 / 255, 218 / 255),
					M = null !== (i = null != o ? o : a) && void 0 !== i ? i : y;
				return Jf(o || void 0 !== s ? e : t.acroField, M, n, j), Bo(m, function(t) {
					for (var e = ih(t.x), n = ih(t.y), r = ih(t.width), i = ih(t.height), o = ih(t.lineHeight), a = ih(t.borderWidth), s = ih(t.padding), l = e + a / 2 + s, c = n + a / 2 + s, u = r - 2 * (a / 2 + s), h = i - 2 * (a / 2 + s), f = [Ih(l, c), Rh(l, c + h), Rh(l + u, c + h), Rh(l + u, c), Mh(), ph(), zh()], d = xf({
							x: e,
							y: n,
							width: r,
							height: i,
							borderWidth: t.borderWidth,
							color: t.color,
							borderColor: t.borderColor,
							rotate: ah(0),
							xSkew: ah(0),
							ySkew: ah(0)
						}), p = [], g = 0, v = t.selectedLines.length; g < v; g++) {
						var m = t.textLines[t.selectedLines[g]];
						p.push.apply(p, xf({
							x: m.x - s,
							y: m.y - (o - m.height) / 2,
							width: r - a,
							height: m.height + (o - m.height) / 2,
							borderWidth: 0,
							color: t.selectedColor,
							borderColor: void 0,
							rotate: ah(0),
							xSkew: ah(0),
							ySkew: ah(0)
						}))
					}
					var y = Ff(t.textLines, {
							color: t.textColor,
							font: t.font,
							size: t.fontSize,
							rotate: ah(0),
							xSkew: ah(0),
							ySkew: ah(0)
						}),
						b = Bo([Kh("Tx"), jh()], y, [Ah(), Yh()]);
					return Bo([jh()], d, p, f, b, [Ah()])
				}({
					x: 0 + f / 2,
					y: 0 + f / 2,
					width: g - f,
					height: v - f,
					borderWidth: null != f ? f : 0,
					borderColor: b,
					textColor: M,
					font: n.name,
					fontSize: j,
					color: x,
					textLines: P,
					lineHeight: A,
					selectedColor: D,
					selectedLines: _,
					padding: 1
				}))
			},
			id = function() {
				function t(t, e, n) {
					this.alreadyEmbedded = !1, Ya(t, "ref", [
						[ol, "PDFRef"]
					]), Ya(e, "doc", [
						[zd, "PDFDocument"]
					]), Ya(n, "embedder", [
						[jc, "PDFPageEmbedder"]
					]), this.ref = t, this.doc = e, this.width = n.width, this.height = n.height, this.embedder = n
				}
				return t.prototype.scale = function(t) {
					return Ya(t, "factor", ["number"]), {
						width: this.width * t,
						height: this.height * t
					}
				}, t.prototype.size = function() {
					return this.scale(1)
				}, t.prototype.embed = function() {
					return Io(this, void 0, void 0, (function() {
						return Ro(this, (function(t) {
							switch (t.label) {
								case 0:
									return this.alreadyEmbedded ? [3, 2] : [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
								case 1:
									t.sent(), this.alreadyEmbedded = !0, t.label = 2;
								case 2:
									return [2]
							}
						}))
					}))
				}, t.of = function(e, n, r) {
					return new t(e, n, r)
				}, t
			}();
		const od = id;
		var ad = function() {
			function t(t, e, n) {
				this.modified = !0, Ya(t, "ref", [
					[ol, "PDFRef"]
				]), Ya(e, "doc", [
					[zd, "PDFDocument"]
				]), Ya(n, "embedder", [
					[Xl, "CustomFontEmbedder"],
					[Ll, "StandardFontEmbedder"]
				]), this.ref = t, this.doc = e, this.name = n.fontName, this.embedder = n
			}
			return t.prototype.encodeText = function(t) {
				return Ya(t, "text", ["string"]), this.modified = !0, this.embedder.encodeText(t)
			}, t.prototype.widthOfTextAtSize = function(t, e) {
				return Ya(t, "text", ["string"]), Ya(e, "size", ["number"]), this.embedder.widthOfTextAtSize(t, e)
			}, t.prototype.heightAtSize = function(t, e) {
				var n;
				return Ya(t, "size", ["number"]), Za(null == e ? void 0 : e.descender, "options.descender", ["boolean"]), this.embedder.heightOfFontAtSize(t, {
					descender: null === (n = null == e ? void 0 : e.descender) || void 0 === n || n
				})
			}, t.prototype.sizeAtHeight = function(t) {
				return Ya(t, "height", ["number"]), this.embedder.sizeOfFontAtHeight(t)
			}, t.prototype.getCharacterSet = function() {
				return this.embedder instanceof Ll ? this.embedder.encoding.supportedCodePoints : this.embedder.font.characterSet
			}, t.prototype.embed = function() {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(t) {
						switch (t.label) {
							case 0:
								return this.modified ? [4, this.embedder.embedIntoContext(this.doc.context, this.ref)] : [3, 2];
							case 1:
								t.sent(), this.modified = !1, t.label = 2;
							case 2:
								return [2]
						}
					}))
				}))
			}, t.of = function(e, n, r) {
				return new t(e, n, r)
			}, t
		}();
		const sd = ad;
		var ld = function() {
			function t(t, e, n) {
				Ya(t, "ref", [
					[ol, "PDFRef"]
				]), Ya(e, "doc", [
					[zd, "PDFDocument"]
				]), Ya(n, "embedder", [
					[tc, "JpegEmbedder"],
					[oc, "PngEmbedder"]
				]), this.ref = t, this.doc = e, this.width = n.width, this.height = n.height, this.embedder = n
			}
			return t.prototype.scale = function(t) {
				return Ya(t, "factor", ["number"]), {
					width: this.width * t,
					height: this.height * t
				}
			}, t.prototype.scaleToFit = function(t, e) {
				Ya(t, "width", ["number"]), Ya(e, "height", ["number"]);
				var n = t / this.width,
					r = e / this.height,
					i = Math.min(n, r);
				return this.scale(i)
			}, t.prototype.size = function() {
				return this.scale(1)
			}, t.prototype.embed = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n;
					return Ro(this, (function(r) {
						switch (r.label) {
							case 0:
								return this.embedder ? (this.embedTask || (e = (t = this).doc, n = t.ref, this.embedTask = this.embedder.embedIntoContext(e.context, n)), [4, this.embedTask]) : [2];
							case 1:
								return r.sent(), this.embedder = void 0, [2]
						}
					}))
				}))
			}, t.of = function(e, n, r) {
				return new t(e, n, r)
			}, t
		}();
		const cd = ld;
		var ud;
		! function(t) {
			t[t.Left = 0] = "Left", t[t.Center = 1] = "Center", t[t.Right = 2] = "Right"
		}(ud || (ud = {}));
		var hd = function(t) {
				Za(null == t ? void 0 : t.x, "options.x", ["number"]), Za(null == t ? void 0 : t.y, "options.y", ["number"]), Za(null == t ? void 0 : t.width, "options.width", ["number"]), Za(null == t ? void 0 : t.height, "options.height", ["number"]), Za(null == t ? void 0 : t.textColor, "options.textColor", [
					[Object, "Color"]
				]), Za(null == t ? void 0 : t.backgroundColor, "options.backgroundColor", [
					[Object, "Color"]
				]), Za(null == t ? void 0 : t.borderColor, "options.borderColor", [
					[Object, "Color"]
				]), Za(null == t ? void 0 : t.borderWidth, "options.borderWidth", ["number"]), Za(null == t ? void 0 : t.rotate, "options.rotate", [
					[Object, "Rotation"]
				])
			},
			fd = function() {
				function t(t, e, n) {
					Ya(t, "acroField", [
						[Yc, "PDFAcroTerminal"]
					]), Ya(e, "ref", [
						[ol, "PDFRef"]
					]), Ya(n, "doc", [
						[zd, "PDFDocument"]
					]), this.acroField = t, this.ref = e, this.doc = n
				}
				return t.prototype.getName = function() {
					var t;
					return null !== (t = this.acroField.getFullyQualifiedName()) && void 0 !== t ? t : ""
				}, t.prototype.isReadOnly = function() {
					return this.acroField.hasFlag(tu.ReadOnly)
				}, t.prototype.enableReadOnly = function() {
					this.acroField.setFlagTo(tu.ReadOnly, !0)
				}, t.prototype.disableReadOnly = function() {
					this.acroField.setFlagTo(tu.ReadOnly, !1)
				}, t.prototype.isRequired = function() {
					return this.acroField.hasFlag(tu.Required)
				}, t.prototype.enableRequired = function() {
					this.acroField.setFlagTo(tu.Required, !0)
				}, t.prototype.disableRequired = function() {
					this.acroField.setFlagTo(tu.Required, !1)
				}, t.prototype.isExported = function() {
					return !this.acroField.hasFlag(tu.NoExport)
				}, t.prototype.enableExporting = function() {
					this.acroField.setFlagTo(tu.NoExport, !1)
				}, t.prototype.disableExporting = function() {
					this.acroField.setFlagTo(tu.NoExport, !0)
				}, t.prototype.needsAppearancesUpdate = function() {
					throw new ls(this.constructor.name, "needsAppearancesUpdate")
				}, t.prototype.defaultUpdateAppearances = function(t) {
					throw new ls(this.constructor.name, "defaultUpdateAppearances")
				}, t.prototype.markAsDirty = function() {
					this.doc.getForm().markFieldAsDirty(this.ref)
				}, t.prototype.markAsClean = function() {
					this.doc.getForm().markFieldAsClean(this.ref)
				}, t.prototype.isDirty = function() {
					return this.doc.getForm().fieldIsDirty(this.ref)
				}, t.prototype.createWidget = function(t) {
					var e, n = t.textColor,
						r = t.backgroundColor,
						i = t.borderColor,
						o = t.borderWidth,
						a = hh(t.rotate),
						s = t.caption,
						l = t.x,
						c = t.y,
						u = t.width + o,
						h = t.height + o,
						f = Boolean(t.hidden),
						d = t.page;
					ts(a, "degreesAngle", 90);
					var p = Gc.create(this.doc.context, this.ref),
						g = function(t, e, n) {
							void 0 === e && (e = 0), void 0 === n && (n = 0);
							var r = t.x,
								i = t.y,
								o = t.width,
								a = t.height,
								s = fh(n),
								l = e / 2;
							return 0 === s ? {
								x: r - l,
								y: i - l,
								width: o,
								height: a
							} : 90 === s ? {
								x: r - a + l,
								y: i - l,
								width: a,
								height: o
							} : 180 === s ? {
								x: r - o + l,
								y: i - a + l,
								width: o,
								height: a
							} : 270 === s ? {
								x: r - l,
								y: i - o + l,
								width: a,
								height: o
							} : {
								x: r - l,
								y: i - l,
								width: o,
								height: a
							}
						}({
							x: l,
							y: c,
							width: u,
							height: h
						}, o, a);
					p.setRectangle(g), d && p.setP(d);
					var v = p.getOrCreateAppearanceCharacteristics();
					r && v.setBackgroundColor(sf(r)), v.setRotation(a), s && v.setCaptions({
						normal: s
					}), i && v.setBorderColor(sf(i));
					var m = p.getOrCreateBorderStyle();
					if (void 0 !== o && m.setWidth(o), p.setFlagTo($u.Print, !0), p.setFlagTo($u.Hidden, f), p.setFlagTo($u.Invisible, !1), n) {
						var y = (null !== (e = this.acroField.getDefaultAppearance()) && void 0 !== e ? e : "") + "\n" + rf(n).toString();
						this.acroField.setDefaultAppearance(y)
					}
					return p
				}, t.prototype.updateWidgetAppearanceWithFont = function(t, e, n) {
					var r = n.normal,
						i = n.rollover,
						o = n.down;
					this.updateWidgetAppearances(t, {
						normal: this.createAppearanceStream(t, r, e),
						rollover: i && this.createAppearanceStream(t, i, e),
						down: o && this.createAppearanceStream(t, o, e)
					})
				}, t.prototype.updateOnOffWidgetAppearance = function(t, e, n) {
					var r = n.normal,
						i = n.rollover,
						o = n.down;
					this.updateWidgetAppearances(t, {
						normal: this.createAppearanceDict(t, r, e),
						rollover: i && this.createAppearanceDict(t, i, e),
						down: o && this.createAppearanceDict(t, o, e)
					})
				}, t.prototype.updateWidgetAppearances = function(t, e) {
					var n = e.normal,
						r = e.rollover,
						i = e.down;
					t.setNormalAppearance(n), r ? t.setRolloverAppearance(r) : t.removeRolloverAppearance(), i ? t.setDownAppearance(i) : t.removeDownAppearance()
				}, t.prototype.createAppearanceStream = function(t, e, n) {
					var r, i = this.acroField.dict.context,
						o = t.getRectangle(),
						a = o.width,
						s = o.height,
						l = n && {
							Font: (r = {}, r[n.name] = n.ref, r)
						},
						c = i.formXObject(e, {
							Resources: l,
							BBox: i.obj([0, 0, a, s]),
							Matrix: i.obj([1, 0, 0, 1, 0, 0])
						});
					return i.register(c)
				}, t.prototype.createImageAppearanceStream = function(t, e, n) {
					var r, i, o = this.acroField.dict.context,
						a = t.getRectangle(),
						s = t.getAppearanceCharacteristics(),
						l = t.getBorderStyle(),
						c = null !== (i = null == l ? void 0 : l.getWidth()) && void 0 !== i ? i : 0,
						u = fh(null == s ? void 0 : s.getRotation()),
						h = Sf(Mo(Mo({}, a), {
							rotation: u
						})),
						f = dh(a, u),
						d = e.scaleToFit(f.width - 2 * c, f.height - 2 * c),
						p = {
							x: c,
							y: c,
							width: d.width,
							height: d.height,
							rotate: ah(0),
							xSkew: ah(0),
							ySkew: ah(0)
						};
					n === ud.Center ? (p.x += (f.width - 2 * c) / 2 - d.width / 2, p.y += (f.height - 2 * c) / 2 - d.height / 2) : n === ud.Right && (p.x = f.width - c - d.width, p.y = f.height - c - d.height);
					var g = this.doc.context.addRandomSuffix("Image", 10),
						v = Bo(h, bf(g, p)),
						m = {
							XObject: (r = {}, r[g] = e.ref, r)
						},
						y = o.formXObject(v, {
							Resources: m,
							BBox: o.obj([0, 0, a.width, a.height]),
							Matrix: o.obj([1, 0, 0, 1, 0, 0])
						});
					return o.register(y)
				}, t.prototype.createAppearanceDict = function(t, e, n) {
					var r = this.acroField.dict.context,
						i = this.createAppearanceStream(t, e.on),
						o = this.createAppearanceStream(t, e.off),
						a = r.obj({});
					return a.set(n, i), a.set(Zs.of("Off"), o), a
				}, t
			}();
		const dd = fd;
		var pd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroCheckBox", [
					[$c, "PDFAcroCheckBox"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.check = function() {
				var t, e = null !== (t = this.acroField.getOnValue()) && void 0 !== t ? t : Zs.of("Yes");
				this.markAsDirty(), this.acroField.setValue(e)
			}, e.prototype.uncheck = function() {
				this.markAsDirty(), this.acroField.setValue(Zs.of("Off"))
			}, e.prototype.isChecked = function() {
				var t = this.acroField.getOnValue();
				return !!t && t === this.acroField.getValue()
			}, e.prototype.addToPage = function(t, e) {
				var n, r, i, o, a, s;
				Ya(t, "page", [
					[Hd, "PDFPage"]
				]), hd(e), e || (e = {}), "textColor" in e || (e.textColor = Qh(0, 0, 0)), "backgroundColor" in e || (e.backgroundColor = Qh(1, 1, 1)), "borderColor" in e || (e.borderColor = Qh(0, 0, 0)), "borderWidth" in e || (e.borderWidth = 1);
				var l = this.createWidget({
						x: null !== (n = e.x) && void 0 !== n ? n : 0,
						y: null !== (r = e.y) && void 0 !== r ? r : 0,
						width: null !== (i = e.width) && void 0 !== i ? i : 50,
						height: null !== (o = e.height) && void 0 !== o ? o : 50,
						textColor: e.textColor,
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
						rotate: null !== (s = e.rotate) && void 0 !== s ? s : ah(0),
						hidden: e.hidden,
						page: t.ref
					}),
					c = this.doc.context.register(l.dict);
				this.acroField.addWidget(c), l.setAppearanceState(Zs.of("Off")), this.updateWidgetAppearance(l, Zs.of("Yes")), t.node.addAnnot(c)
			}, e.prototype.needsAppearancesUpdate = function() {
				for (var t, e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i.getAppearanceState(),
						a = null === (t = i.getAppearances()) || void 0 === t ? void 0 : t.normal;
					if (!(a instanceof $s)) return !0;
					if (o && !a.has(o)) return !0
				}
				return !1
			}, e.prototype.defaultUpdateAppearances = function() {
				this.updateAppearances()
			}, e.prototype.updateAppearances = function(t) {
				var e;
				Za(t, "provider", [Function]);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r],
						a = null !== (e = o.getOnValue()) && void 0 !== e ? e : Zs.of("Yes");
					a && this.updateWidgetAppearance(o, a, t)
				}
				this.markAsClean()
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : Qf)(this, t));
				this.updateOnOffWidgetAppearance(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const gd = pd;
		var vd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroComboBox", [
					[su, "PDFAcroComboBox"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.getOptions = function() {
				for (var t = this.acroField.getOptions(), e = new Array(t.length), n = 0, r = e.length; n < r; n++) {
					var i = t[n],
						o = i.display,
						a = i.value;
					e[n] = (null != o ? o : a).decodeText()
				}
				return e
			}, e.prototype.getSelected = function() {
				for (var t = this.acroField.getValues(), e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = t[n].decodeText();
				return e
			}, e.prototype.setOptions = function(t) {
				Ya(t, "options", [Array]);
				for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = {
					value: Bl.fromText(t[n])
				};
				this.acroField.setOptions(e)
			}, e.prototype.addOptions = function(t) {
				Ya(t, "options", ["string", Array]);
				for (var e = Array.isArray(t) ? t : [t], n = this.acroField.getOptions(), r = new Array(e.length), i = 0, o = e.length; i < o; i++) r[i] = {
					value: Bl.fromText(e[i])
				};
				this.acroField.setOptions(n.concat(r))
			}, e.prototype.select = function(t, e) {
				void 0 === e && (e = !1), Ya(t, "options", ["string", Array]), Ya(e, "merge", ["boolean"]);
				var n = Array.isArray(t) ? t : [t],
					r = this.getOptions();
				n.find((function(t) {
					return !r.includes(t)
				})) && this.enableEditing(), this.markAsDirty(), (n.length > 1 || 1 === n.length && e) && this.enableMultiselect();
				for (var i = new Array(n.length), o = 0, a = n.length; o < a; o++) i[o] = Bl.fromText(n[o]);
				if (e) {
					var s = this.acroField.getValues();
					this.acroField.setValues(s.concat(i))
				} else this.acroField.setValues(i)
			}, e.prototype.clear = function() {
				this.markAsDirty(), this.acroField.setValues([])
			}, e.prototype.setFontSize = function(t) {
				es(t, "fontSize"), this.acroField.setFontSize(t), this.markAsDirty()
			}, e.prototype.isEditable = function() {
				return this.acroField.hasFlag(ru.Edit)
			}, e.prototype.enableEditing = function() {
				this.acroField.setFlagTo(ru.Edit, !0)
			}, e.prototype.disableEditing = function() {
				this.acroField.setFlagTo(ru.Edit, !1)
			}, e.prototype.isSorted = function() {
				return this.acroField.hasFlag(ru.Sort)
			}, e.prototype.enableSorting = function() {
				this.acroField.setFlagTo(ru.Sort, !0)
			}, e.prototype.disableSorting = function() {
				this.acroField.setFlagTo(ru.Sort, !1)
			}, e.prototype.isMultiselect = function() {
				return this.acroField.hasFlag(ru.MultiSelect)
			}, e.prototype.enableMultiselect = function() {
				this.acroField.setFlagTo(ru.MultiSelect, !0)
			}, e.prototype.disableMultiselect = function() {
				this.acroField.setFlagTo(ru.MultiSelect, !1)
			}, e.prototype.isSpellChecked = function() {
				return !this.acroField.hasFlag(ru.DoNotSpellCheck)
			}, e.prototype.enableSpellChecking = function() {
				this.acroField.setFlagTo(ru.DoNotSpellCheck, !1)
			}, e.prototype.disableSpellChecking = function() {
				this.acroField.setFlagTo(ru.DoNotSpellCheck, !0)
			}, e.prototype.isSelectOnClick = function() {
				return this.acroField.hasFlag(ru.CommitOnSelChange)
			}, e.prototype.enableSelectOnClick = function() {
				this.acroField.setFlagTo(ru.CommitOnSelChange, !0)
			}, e.prototype.disableSelectOnClick = function() {
				this.acroField.setFlagTo(ru.CommitOnSelChange, !1)
			}, e.prototype.addToPage = function(t, e) {
				var n, r, i, o, a, s, l;
				Ya(t, "page", [
					[Hd, "PDFPage"]
				]), hd(e), e || (e = {}), "textColor" in e || (e.textColor = Qh(0, 0, 0)), "backgroundColor" in e || (e.backgroundColor = Qh(1, 1, 1)), "borderColor" in e || (e.borderColor = Qh(0, 0, 0)), "borderWidth" in e || (e.borderWidth = 1);
				var c = this.createWidget({
						x: null !== (n = e.x) && void 0 !== n ? n : 0,
						y: null !== (r = e.y) && void 0 !== r ? r : 0,
						width: null !== (i = e.width) && void 0 !== i ? i : 200,
						height: null !== (o = e.height) && void 0 !== o ? o : 50,
						textColor: e.textColor,
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
						rotate: null !== (s = e.rotate) && void 0 !== s ? s : ah(0),
						hidden: e.hidden,
						page: t.ref
					}),
					u = this.doc.context.register(c.dict);
				this.acroField.addWidget(u);
				var h = null !== (l = e.font) && void 0 !== l ? l : this.doc.getForm().getDefaultFont();
				this.updateWidgetAppearance(c, h), t.node.addAnnot(u)
			}, e.prototype.needsAppearancesUpdate = function() {
				var t;
				if (this.isDirty()) return !0;
				for (var e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++)
					if (!((null === (t = e[n].getAppearances()) || void 0 === t ? void 0 : t.normal) instanceof el)) return !0;
				return !1
			}, e.prototype.defaultUpdateAppearances = function(t) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), this.updateAppearances(t)
			}, e.prototype.updateAppearances = function(t, e) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), Za(e, "provider", [Function]);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r];
					this.updateWidgetAppearance(o, t, e)
				}
				this.markAsClean()
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : nd)(this, t, e));
				this.updateWidgetAppearanceWithFont(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const md = vd;
		var yd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroListBox", [
					[gu, "PDFAcroListBox"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.getOptions = function() {
				for (var t = this.acroField.getOptions(), e = new Array(t.length), n = 0, r = e.length; n < r; n++) {
					var i = t[n],
						o = i.display,
						a = i.value;
					e[n] = (null != o ? o : a).decodeText()
				}
				return e
			}, e.prototype.getSelected = function() {
				for (var t = this.acroField.getValues(), e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = t[n].decodeText();
				return e
			}, e.prototype.setOptions = function(t) {
				Ya(t, "options", [Array]), this.markAsDirty();
				for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = {
					value: Bl.fromText(t[n])
				};
				this.acroField.setOptions(e)
			}, e.prototype.addOptions = function(t) {
				Ya(t, "options", ["string", Array]), this.markAsDirty();
				for (var e = Array.isArray(t) ? t : [t], n = this.acroField.getOptions(), r = new Array(e.length), i = 0, o = e.length; i < o; i++) r[i] = {
					value: Bl.fromText(e[i])
				};
				this.acroField.setOptions(n.concat(r))
			}, e.prototype.select = function(t, e) {
				void 0 === e && (e = !1), Ya(t, "options", ["string", Array]), Ya(e, "merge", ["boolean"]);
				var n = Array.isArray(t) ? t : [t];
				! function(t, e, n) {
					Array.isArray(n) || (n = za(n));
					for (var r = 0, i = t.length; r < i; r++) Xa(t[r], "option", n)
				}(n, 0, this.getOptions()), this.markAsDirty(), (n.length > 1 || 1 === n.length && e) && this.enableMultiselect();
				for (var r = new Array(n.length), i = 0, o = n.length; i < o; i++) r[i] = Bl.fromText(n[i]);
				if (e) {
					var a = this.acroField.getValues();
					this.acroField.setValues(a.concat(r))
				} else this.acroField.setValues(r)
			}, e.prototype.clear = function() {
				this.markAsDirty(), this.acroField.setValues([])
			}, e.prototype.setFontSize = function(t) {
				es(t, "fontSize"), this.acroField.setFontSize(t), this.markAsDirty()
			}, e.prototype.isSorted = function() {
				return this.acroField.hasFlag(ru.Sort)
			}, e.prototype.enableSorting = function() {
				this.acroField.setFlagTo(ru.Sort, !0)
			}, e.prototype.disableSorting = function() {
				this.acroField.setFlagTo(ru.Sort, !1)
			}, e.prototype.isMultiselect = function() {
				return this.acroField.hasFlag(ru.MultiSelect)
			}, e.prototype.enableMultiselect = function() {
				this.acroField.setFlagTo(ru.MultiSelect, !0)
			}, e.prototype.disableMultiselect = function() {
				this.acroField.setFlagTo(ru.MultiSelect, !1)
			}, e.prototype.isSelectOnClick = function() {
				return this.acroField.hasFlag(ru.CommitOnSelChange)
			}, e.prototype.enableSelectOnClick = function() {
				this.acroField.setFlagTo(ru.CommitOnSelChange, !0)
			}, e.prototype.disableSelectOnClick = function() {
				this.acroField.setFlagTo(ru.CommitOnSelChange, !1)
			}, e.prototype.addToPage = function(t, e) {
				var n, r, i, o, a, s, l;
				Ya(t, "page", [
					[Hd, "PDFPage"]
				]), hd(e), e || (e = {}), "textColor" in e || (e.textColor = Qh(0, 0, 0)), "backgroundColor" in e || (e.backgroundColor = Qh(1, 1, 1)), "borderColor" in e || (e.borderColor = Qh(0, 0, 0)), "borderWidth" in e || (e.borderWidth = 1);
				var c = this.createWidget({
						x: null !== (n = e.x) && void 0 !== n ? n : 0,
						y: null !== (r = e.y) && void 0 !== r ? r : 0,
						width: null !== (i = e.width) && void 0 !== i ? i : 200,
						height: null !== (o = e.height) && void 0 !== o ? o : 100,
						textColor: e.textColor,
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
						rotate: null !== (s = e.rotate) && void 0 !== s ? s : ah(0),
						hidden: e.hidden,
						page: t.ref
					}),
					u = this.doc.context.register(c.dict);
				this.acroField.addWidget(u);
				var h = null !== (l = e.font) && void 0 !== l ? l : this.doc.getForm().getDefaultFont();
				this.updateWidgetAppearance(c, h), t.node.addAnnot(u)
			}, e.prototype.needsAppearancesUpdate = function() {
				var t;
				if (this.isDirty()) return !0;
				for (var e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++)
					if (!((null === (t = e[n].getAppearances()) || void 0 === t ? void 0 : t.normal) instanceof el)) return !0;
				return !1
			}, e.prototype.defaultUpdateAppearances = function(t) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), this.updateAppearances(t)
			}, e.prototype.updateAppearances = function(t, e) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), Za(e, "provider", [Function]);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r];
					this.updateWidgetAppearance(o, t, e)
				}
				this.markAsClean()
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : rd)(this, t, e));
				this.updateWidgetAppearanceWithFont(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const bd = yd;
		var xd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroRadioButton", [
					[pu, "PDFAcroRadioButton"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.getOptions = function() {
				var t = this.acroField.getExportValues();
				if (t) {
					for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) e[n] = t[n].decodeText();
					return e
				}
				var i = this.acroField.getOnValues(),
					o = new Array(i.length);
				for (n = 0, r = o.length; n < r; n++) o[n] = i[n].decodeText();
				return o
			}, e.prototype.getSelected = function() {
				var t = this.acroField.getValue();
				if (t !== Zs.of("Off")) {
					var e = this.acroField.getExportValues();
					if (e)
						for (var n = this.acroField.getOnValues(), r = 0, i = n.length; r < i; r++)
							if (n[r] === t) return e[r].decodeText();
					return t.decodeText()
				}
			}, e.prototype.select = function(t) {
				Ya(t, "option", ["string"]);
				var e = this.getOptions();
				Xa(t, "option", e), this.markAsDirty();
				var n = this.acroField.getOnValues(),
					r = this.acroField.getExportValues();
				if (r)
					for (var i = 0, o = r.length; i < o; i++) r[i].decodeText() === t && this.acroField.setValue(n[i]);
				else
					for (i = 0, o = n.length; i < o; i++) {
						var a = n[i];
						a.decodeText() === t && this.acroField.setValue(a)
					}
			}, e.prototype.clear = function() {
				this.markAsDirty(), this.acroField.setValue(Zs.of("Off"))
			}, e.prototype.isOffToggleable = function() {
				return !this.acroField.hasFlag(eu.NoToggleToOff)
			}, e.prototype.enableOffToggling = function() {
				this.acroField.setFlagTo(eu.NoToggleToOff, !1)
			}, e.prototype.disableOffToggling = function() {
				this.acroField.setFlagTo(eu.NoToggleToOff, !0)
			}, e.prototype.isMutuallyExclusive = function() {
				return !this.acroField.hasFlag(eu.RadiosInUnison)
			}, e.prototype.enableMutualExclusion = function() {
				this.acroField.setFlagTo(eu.RadiosInUnison, !1)
			}, e.prototype.disableMutualExclusion = function() {
				this.acroField.setFlagTo(eu.RadiosInUnison, !0)
			}, e.prototype.addOptionToPage = function(t, e, n) {
				var r, i, o, a, s, l, c, u, h;
				Ya(t, "option", ["string"]), Ya(e, "page", [
					[Hd, "PDFPage"]
				]), hd(n);
				var f = this.createWidget({
						x: null !== (r = null == n ? void 0 : n.x) && void 0 !== r ? r : 0,
						y: null !== (i = null == n ? void 0 : n.y) && void 0 !== i ? i : 0,
						width: null !== (o = null == n ? void 0 : n.width) && void 0 !== o ? o : 50,
						height: null !== (a = null == n ? void 0 : n.height) && void 0 !== a ? a : 50,
						textColor: null !== (s = null == n ? void 0 : n.textColor) && void 0 !== s ? s : Qh(0, 0, 0),
						backgroundColor: null !== (l = null == n ? void 0 : n.backgroundColor) && void 0 !== l ? l : Qh(1, 1, 1),
						borderColor: null !== (c = null == n ? void 0 : n.borderColor) && void 0 !== c ? c : Qh(0, 0, 0),
						borderWidth: null !== (u = null == n ? void 0 : n.borderWidth) && void 0 !== u ? u : 1,
						rotate: null !== (h = null == n ? void 0 : n.rotate) && void 0 !== h ? h : ah(0),
						hidden: null == n ? void 0 : n.hidden,
						page: e.ref
					}),
					d = this.doc.context.register(f.dict),
					p = this.acroField.addWidgetWithOpt(d, Bl.fromText(t), !this.isMutuallyExclusive());
				f.setAppearanceState(Zs.of("Off")), this.updateWidgetAppearance(f, p), e.node.addAnnot(d)
			}, e.prototype.needsAppearancesUpdate = function() {
				for (var t, e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i.getAppearanceState(),
						a = null === (t = i.getAppearances()) || void 0 === t ? void 0 : t.normal;
					if (!(a instanceof $s)) return !0;
					if (o && !a.has(o)) return !0
				}
				return !1
			}, e.prototype.defaultUpdateAppearances = function() {
				this.updateAppearances()
			}, e.prototype.updateAppearances = function(t) {
				Za(t, "provider", [Function]);
				for (var e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i.getOnValue();
					o && this.updateWidgetAppearance(i, o, t)
				}
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : $f)(this, t));
				this.updateOnOffWidgetAppearance(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const wd = xd;
		var Cd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroSignature", [
					[cu, "PDFAcroSignature"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.needsAppearancesUpdate = function() {
				return !1
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const Sd = Cd;
		var Od = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroText", [
					[hu, "PDFAcroText"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.getText = function() {
				var t = this.acroField.getValue();
				if (!t && this.isRichFormatted()) throw new Bf(this.getName());
				return null == t ? void 0 : t.decodeText()
			}, e.prototype.setText = function(t) {
				Za(t, "text", ["string"]);
				var e = this.getMaxLength();
				if (void 0 !== e && t && t.length > e) throw new Lf(t.length, e, this.getName());
				this.markAsDirty(), this.disableRichFormatting(), t ? this.acroField.setValue(Bl.fromText(t)) : this.acroField.removeValue()
			}, e.prototype.getAlignment = function() {
				var t = this.acroField.getQuadding();
				return 0 === t ? Zh.Left : 1 === t ? Zh.Center : 2 === t ? Zh.Right : Zh.Left
			}, e.prototype.setAlignment = function(t) {
				Xa(t, "alignment", Zh), this.markAsDirty(), this.acroField.setQuadding(t)
			}, e.prototype.getMaxLength = function() {
				return this.acroField.getMaxLength()
			}, e.prototype.setMaxLength = function(t) {
				if ($a(t, "maxLength", 0, Number.MAX_SAFE_INTEGER), this.markAsDirty(), void 0 === t) this.acroField.removeMaxLength();
				else {
					var e = this.getText();
					if (e && e.length > t) throw new zf(e.length, t, this.getName());
					this.acroField.setMaxLength(t)
				}
			}, e.prototype.removeMaxLength = function() {
				this.markAsDirty(), this.acroField.removeMaxLength()
			}, e.prototype.setImage = function(t) {
				for (var e = this.getAlignment(), n = e === Zh.Center ? ud.Center : e === Zh.Right ? ud.Right : ud.Left, r = this.acroField.getWidgets(), i = 0, o = r.length; i < o; i++) {
					var a = r[i],
						s = this.createImageAppearanceStream(a, t, n);
					this.updateWidgetAppearances(a, {
						normal: s
					})
				}
				this.markAsClean()
			}, e.prototype.setFontSize = function(t) {
				es(t, "fontSize"), this.acroField.setFontSize(t), this.markAsDirty()
			}, e.prototype.isMultiline = function() {
				return this.acroField.hasFlag(nu.Multiline)
			}, e.prototype.enableMultiline = function() {
				this.markAsDirty(), this.acroField.setFlagTo(nu.Multiline, !0)
			}, e.prototype.disableMultiline = function() {
				this.markAsDirty(), this.acroField.setFlagTo(nu.Multiline, !1)
			}, e.prototype.isPassword = function() {
				return this.acroField.hasFlag(nu.Password)
			}, e.prototype.enablePassword = function() {
				this.acroField.setFlagTo(nu.Password, !0)
			}, e.prototype.disablePassword = function() {
				this.acroField.setFlagTo(nu.Password, !1)
			}, e.prototype.isFileSelector = function() {
				return this.acroField.hasFlag(nu.FileSelect)
			}, e.prototype.enableFileSelection = function() {
				this.acroField.setFlagTo(nu.FileSelect, !0)
			}, e.prototype.disableFileSelection = function() {
				this.acroField.setFlagTo(nu.FileSelect, !1)
			}, e.prototype.isSpellChecked = function() {
				return !this.acroField.hasFlag(nu.DoNotSpellCheck)
			}, e.prototype.enableSpellChecking = function() {
				this.acroField.setFlagTo(nu.DoNotSpellCheck, !1)
			}, e.prototype.disableSpellChecking = function() {
				this.acroField.setFlagTo(nu.DoNotSpellCheck, !0)
			}, e.prototype.isScrollable = function() {
				return !this.acroField.hasFlag(nu.DoNotScroll)
			}, e.prototype.enableScrolling = function() {
				this.acroField.setFlagTo(nu.DoNotScroll, !1)
			}, e.prototype.disableScrolling = function() {
				this.acroField.setFlagTo(nu.DoNotScroll, !0)
			}, e.prototype.isCombed = function() {
				return this.acroField.hasFlag(nu.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && void 0 !== this.getMaxLength()
			}, e.prototype.enableCombing = function() {
				void 0 === this.getMaxLength() && console.warn("PDFTextFields must have a max length in order to be combed"), this.markAsDirty(), this.disableMultiline(), this.disablePassword(), this.disableFileSelection(), this.acroField.setFlagTo(nu.Comb, !0)
			}, e.prototype.disableCombing = function() {
				this.markAsDirty(), this.acroField.setFlagTo(nu.Comb, !1)
			}, e.prototype.isRichFormatted = function() {
				return this.acroField.hasFlag(nu.RichText)
			}, e.prototype.enableRichFormatting = function() {
				this.acroField.setFlagTo(nu.RichText, !0)
			}, e.prototype.disableRichFormatting = function() {
				this.acroField.setFlagTo(nu.RichText, !1)
			}, e.prototype.addToPage = function(t, e) {
				var n, r, i, o, a, s, l;
				Ya(t, "page", [
					[Hd, "PDFPage"]
				]), hd(e), e || (e = {}), "textColor" in e || (e.textColor = Qh(0, 0, 0)), "backgroundColor" in e || (e.backgroundColor = Qh(1, 1, 1)), "borderColor" in e || (e.borderColor = Qh(0, 0, 0)), "borderWidth" in e || (e.borderWidth = 1);
				var c = this.createWidget({
						x: null !== (n = e.x) && void 0 !== n ? n : 0,
						y: null !== (r = e.y) && void 0 !== r ? r : 0,
						width: null !== (i = e.width) && void 0 !== i ? i : 200,
						height: null !== (o = e.height) && void 0 !== o ? o : 50,
						textColor: e.textColor,
						backgroundColor: e.backgroundColor,
						borderColor: e.borderColor,
						borderWidth: null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
						rotate: null !== (s = e.rotate) && void 0 !== s ? s : ah(0),
						hidden: e.hidden,
						page: t.ref
					}),
					u = this.doc.context.register(c.dict);
				this.acroField.addWidget(u);
				var h = null !== (l = e.font) && void 0 !== l ? l : this.doc.getForm().getDefaultFont();
				this.updateWidgetAppearance(c, h), t.node.addAnnot(u)
			}, e.prototype.needsAppearancesUpdate = function() {
				var t;
				if (this.isDirty()) return !0;
				for (var e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++)
					if (!((null === (t = e[n].getAppearances()) || void 0 === t ? void 0 : t.normal) instanceof el)) return !0;
				return !1
			}, e.prototype.defaultUpdateAppearances = function(t) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), this.updateAppearances(t)
			}, e.prototype.updateAppearances = function(t, e) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), Za(e, "provider", [Function]);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r];
					this.updateWidgetAppearance(o, t, e)
				}
				this.markAsClean()
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : ed)(this, t, e));
				this.updateWidgetAppearanceWithFont(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const Td = Od;
		var kd;
		! function(t) {
			t.Courier = "Courier", t.CourierBold = "Courier-Bold", t.CourierOblique = "Courier-Oblique", t.CourierBoldOblique = "Courier-BoldOblique", t.Helvetica = "Helvetica", t.HelveticaBold = "Helvetica-Bold", t.HelveticaOblique = "Helvetica-Oblique", t.HelveticaBoldOblique = "Helvetica-BoldOblique", t.TimesRoman = "Times-Roman", t.TimesRomanBold = "Times-Bold", t.TimesRomanItalic = "Times-Italic", t.TimesRomanBoldItalic = "Times-BoldItalic", t.Symbol = "Symbol", t.ZapfDingbats = "ZapfDingbats"
		}(kd || (kd = {}));
		var Fd = function() {
			function t(t, e) {
				var n = this;
				this.embedDefaultFont = function() {
					return n.doc.embedStandardFont(kd.Helvetica)
				}, Ya(t, "acroForm", [
					[ku, "PDFAcroForm"]
				]), Ya(e, "doc", [
					[zd, "PDFDocument"]
				]), this.acroForm = t, this.doc = e, this.dirtyFields = new Set, this.defaultFontCache = os.populatedBy(this.embedDefaultFont)
			}
			return t.prototype.hasXFA = function() {
				return this.acroForm.dict.has(Zs.of("XFA"))
			}, t.prototype.deleteXFA = function() {
				this.acroForm.dict.delete(Zs.of("XFA"))
			}, t.prototype.getFields = function() {
				for (var t = this.acroForm.getAllFields(), e = [], n = 0, r = t.length; n < r; n++) {
					var i = t[n],
						o = i[0],
						a = i[1],
						s = Ad(o, a, this.doc);
					s && e.push(s)
				}
				return e
			}, t.prototype.getFieldMaybe = function(t) {
				Ya(t, "name", ["string"]);
				for (var e = this.getFields(), n = 0, r = e.length; n < r; n++) {
					var i = e[n];
					if (i.getName() === t) return i
				}
			}, t.prototype.getField = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getFieldMaybe(t);
				if (e) return e;
				throw new Df(t)
			}, t.prototype.getButton = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof Xd) return e;
				throw new Mf(t, Xd, e)
			}, t.prototype.getCheckBox = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof gd) return e;
				throw new Mf(t, gd, e)
			}, t.prototype.getDropdown = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof md) return e;
				throw new Mf(t, md, e)
			}, t.prototype.getOptionList = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof bd) return e;
				throw new Mf(t, bd, e)
			}, t.prototype.getRadioGroup = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof wd) return e;
				throw new Mf(t, wd, e)
			}, t.prototype.getSignature = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof Sd) return e;
				throw new Mf(t, Sd, e)
			}, t.prototype.getTextField = function(t) {
				Ya(t, "name", ["string"]);
				var e = this.getField(t);
				if (e instanceof Td) return e;
				throw new Mf(t, Td, e)
			}, t.prototype.createButton = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = fu.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), Xd.of(r, r.ref, this.doc)
			}, t.prototype.createCheckBox = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = $c.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), gd.of(r, r.ref, this.doc)
			}, t.prototype.createDropdown = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = su.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), md.of(r, r.ref, this.doc)
			}, t.prototype.createOptionList = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = gu.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), bd.of(r, r.ref, this.doc)
			}, t.prototype.createRadioGroup = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = pu.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), wd.of(r, r.ref, this.doc)
			}, t.prototype.createTextField = function(t) {
				Ya(t, "name", ["string"]);
				var e = _d(t),
					n = this.findOrCreateNonTerminals(e.nonTerminal),
					r = hu.create(this.doc.context);
				return r.setPartialName(e.terminal), Ed(n, [r, r.ref], e.terminal), Td.of(r, r.ref, this.doc)
			}, t.prototype.flatten = function(t) {
				void 0 === t && (t = {
					updateFieldAppearances: !0
				}), t.updateFieldAppearances && this.updateFieldAppearances();
				for (var e = this.getFields(), n = 0, r = e.length; n < r; n++) {
					for (var i = e[n], o = i.acroField.getWidgets(), a = 0, s = o.length; a < s; a++) {
						var l = o[a],
							c = this.findWidgetPage(l),
							u = this.findWidgetAppearanceRef(i, l),
							h = c.node.newXObject("FlatWidget", u),
							f = l.getRectangle(),
							d = Bo([jh(), bh(f.x, f.y)], Sf(Mo(Mo({}, f), {
								rotation: 0
							})), [Gh(h), Ah()]).filter(Boolean);
						c.pushOperators.apply(c, d)
					}
					this.removeField(i)
				}
			}, t.prototype.removeField = function(t) {
				for (var e = t.acroField.getWidgets(), n = new Set, r = 0, i = e.length; r < i; r++) {
					var o = e[r],
						a = this.findWidgetAppearanceRef(t, o),
						s = this.findWidgetPage(o);
					n.add(s), s.node.removeAnnot(a)
				}
				n.forEach((function(e) {
					return e.node.removeAnnot(t.ref)
				})), this.acroForm.removeField(t.acroField);
				for (var l = t.acroField.normalizedEntries().Kids, c = l.size(), u = 0; u < c; u++) {
					var h = l.get(u);
					h instanceof ol && this.doc.context.delete(h)
				}
				this.doc.context.delete(t.ref)
			}, t.prototype.updateFieldAppearances = function(t) {
				Za(t, "font", [
					[sd, "PDFFont"]
				]), t = null != t ? t : this.getDefaultFont();
				for (var e = this.getFields(), n = 0, r = e.length; n < r; n++) {
					var i = e[n];
					i.needsAppearancesUpdate() && i.defaultUpdateAppearances(t)
				}
			}, t.prototype.markFieldAsDirty = function(t) {
				Za(t, "fieldRef", [
					[ol, "PDFRef"]
				]), this.dirtyFields.add(t)
			}, t.prototype.markFieldAsClean = function(t) {
				Za(t, "fieldRef", [
					[ol, "PDFRef"]
				]), this.dirtyFields.delete(t)
			}, t.prototype.fieldIsDirty = function(t) {
				return Za(t, "fieldRef", [
					[ol, "PDFRef"]
				]), this.dirtyFields.has(t)
			}, t.prototype.getDefaultFont = function() {
				return this.defaultFontCache.access()
			}, t.prototype.findWidgetPage = function(t) {
				var e = t.P(),
					n = this.doc.getPages().find((function(t) {
						return t.ref === e
					}));
				if (void 0 === n) {
					var r = this.doc.context.getObjectRef(t.dict);
					if (void 0 === r) throw new Error("Could not find PDFRef for PDFObject");
					if (void 0 === (n = this.doc.findPageForAnnotationRef(r))) throw new Error("Could not find page for PDFRef " + r)
				}
				return n
			}, t.prototype.findWidgetAppearanceRef = function(t, e) {
				var n, r = e.getNormalAppearance();
				if (r instanceof $s && (t instanceof gd || t instanceof wd)) {
					var i = t.acroField.getValue(),
						o = null !== (n = r.get(i)) && void 0 !== n ? n : r.get(Zs.of("Off"));
					o instanceof ol && (r = o)
				}
				if (!(r instanceof ol)) {
					var a = t.getName();
					throw new Error("Failed to extract appearance ref for: " + a)
				}
				return r
			}, t.prototype.findOrCreateNonTerminals = function(t) {
				for (var e = [this.acroForm], n = 0, r = t.length; n < r; n++) {
					var i = t[n];
					if (!i) throw new Rf(i);
					var o = e[0],
						a = e[1],
						s = this.findNonTerminal(i, o);
					if (s) e = s;
					else {
						var l = lu.create(this.doc.context);
						l.setPartialName(i), l.setParent(a);
						var c = this.doc.context.register(l.dict);
						o.addField(c), e = [l, c]
					}
				}
				return e
			}, t.prototype.findNonTerminal = function(t, e) {
				for (var n = e instanceof ku ? this.acroForm.getFields() : vu(e.Kids()), r = 0, i = n.length; r < i; r++) {
					var o = n[r],
						a = o[0],
						s = o[1];
					if (a.getPartialName() === t) {
						if (a instanceof lu) return [a, s];
						throw new If(t)
					}
				}
			}, t.of = function(e, n) {
				return new t(e, n)
			}, t
		}();
		const Pd = Fd;
		var jd, Ad = function(t, e, n) {
				return t instanceof fu ? Xd.of(t, e, n) : t instanceof $c ? gd.of(t, e, n) : t instanceof su ? md.of(t, e, n) : t instanceof gu ? bd.of(t, e, n) : t instanceof hu ? Td.of(t, e, n) : t instanceof pu ? wd.of(t, e, n) : t instanceof cu ? Sd.of(t, e, n) : void 0
			},
			_d = function(t) {
				if (0 === t.length) throw new Error("PDF field names must not be empty strings");
				for (var e = t.split("."), n = 0, r = e.length; n < r; n++)
					if ("" === e[n]) throw new Error('Periods in PDF field names must be separated by at least one character: "' + t + '"');
				return 1 === e.length ? {
					nonTerminal: [],
					terminal: e[0]
				} : {
					nonTerminal: e.slice(0, e.length - 1),
					terminal: e[e.length - 1]
				}
			},
			Ed = function(t, e, n) {
				for (var r = t[0], i = t[1], o = e[0], a = e[1], s = r.normalizedEntries(), l = (vu("Kids" in s ? s.Kids : s.Fields)), c = 0, u = l.length; c < u; c++)
					if (l[c][0].getPartialName() === n) throw new If(n);
				r.addField(a), o.setParent(i)
			},
			Dd = {
				"4A0": [4767.87, 6740.79],
				"2A0": [3370.39, 4767.87],
				A0: [2383.94, 3370.39],
				A1: [1683.78, 2383.94],
				A2: [1190.55, 1683.78],
				A3: [841.89, 1190.55],
				A4: [595.28, 841.89],
				A5: [419.53, 595.28],
				A6: [297.64, 419.53],
				A7: [209.76, 297.64],
				A8: [147.4, 209.76],
				A9: [104.88, 147.4],
				A10: [73.7, 104.88],
				B0: [2834.65, 4008.19],
				B1: [2004.09, 2834.65],
				B2: [1417.32, 2004.09],
				B3: [1000.63, 1417.32],
				B4: [708.66, 1000.63],
				B5: [498.9, 708.66],
				B6: [354.33, 498.9],
				B7: [249.45, 354.33],
				B8: [175.75, 249.45],
				B9: [124.72, 175.75],
				B10: [87.87, 124.72],
				C0: [2599.37, 3676.54],
				C1: [1836.85, 2599.37],
				C2: [1298.27, 1836.85],
				C3: [918.43, 1298.27],
				C4: [649.13, 918.43],
				C5: [459.21, 649.13],
				C6: [323.15, 459.21],
				C7: [229.61, 323.15],
				C8: [161.57, 229.61],
				C9: [113.39, 161.57],
				C10: [79.37, 113.39],
				RA0: [2437.8, 3458.27],
				RA1: [1729.13, 2437.8],
				RA2: [1218.9, 1729.13],
				RA3: [864.57, 1218.9],
				RA4: [609.45, 864.57],
				SRA0: [2551.18, 3628.35],
				SRA1: [1814.17, 2551.18],
				SRA2: [1275.59, 1814.17],
				SRA3: [907.09, 1275.59],
				SRA4: [637.8, 907.09],
				Executive: [521.86, 756],
				Folio: [612, 936],
				Legal: [612, 1008],
				Letter: [612, 792],
				Tabloid: [792, 1224]
			};
		! function(t) {
			t[t.Fastest = 1 / 0] = "Fastest", t[t.Fast = 1500] = "Fast", t[t.Medium = 500] = "Medium", t[t.Slow = 100] = "Slow"
		}(jd || (jd = {}));
		var Md = function() {
			function t(t, e, n) {
				this.alreadyEmbedded = !1, this.ref = t, this.doc = e, this.embedder = n
			}
			return t.prototype.embed = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r;
					return Ro(this, (function(i) {
						switch (i.label) {
							case 0:
								return this.alreadyEmbedded ? [3, 2] : [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
							case 1:
								t = i.sent(), this.doc.catalog.has(Zs.of("Names")) || this.doc.catalog.set(Zs.of("Names"), this.doc.context.obj({})), (e = this.doc.catalog.lookup(Zs.of("Names"), $s)).has(Zs.of("EmbeddedFiles")) || e.set(Zs.of("EmbeddedFiles"), this.doc.context.obj({})), (n = e.lookup(Zs.of("EmbeddedFiles"), $s)).has(Zs.of("Names")) || n.set(Zs.of("Names"), this.doc.context.obj([])), (r = n.lookup(Zs.of("Names"), zs)).push(Bl.fromText(this.embedder.fileName)), r.push(t), this.doc.catalog.has(Zs.of("AF")) || this.doc.catalog.set(Zs.of("AF"), this.doc.context.obj([])), this.doc.catalog.lookup(Zs.of("AF"), zs).push(t), this.alreadyEmbedded = !0, i.label = 2;
							case 2:
								return [2]
						}
					}))
				}))
			}, t.of = function(e, n, r) {
				return new t(e, n, r)
			}, t
		}();
		const Id = Md;
		var Rd = function() {
			function t(t, e, n) {
				this.alreadyEmbedded = !1, this.ref = t, this.doc = e, this.embedder = n
			}
			return t.prototype.embed = function() {
				return Io(this, void 0, void 0, (function() {
					var t, e, n, r, i, o, a;
					return Ro(this, (function(s) {
						switch (s.label) {
							case 0:
								return this.alreadyEmbedded ? [3, 2] : (t = this.doc, e = t.catalog, n = t.context, [4, this.embedder.embedIntoContext(this.doc.context, this.ref)]);
							case 1:
								r = s.sent(), e.has(Zs.of("Names")) || e.set(Zs.of("Names"), n.obj({})), (i = e.lookup(Zs.of("Names"), $s)).has(Zs.of("JavaScript")) || i.set(Zs.of("JavaScript"), n.obj({})), (o = i.lookup(Zs.of("JavaScript"), $s)).has(Zs.of("Names")) || o.set(Zs.of("Names"), n.obj([])), (a = o.lookup(Zs.of("Names"), zs)).push(Bl.fromText(this.embedder.scriptName)), a.push(r), this.alreadyEmbedded = !0, s.label = 2;
							case 2:
								return [2]
						}
					}))
				}))
			}, t.of = function(e, n, r) {
				return new t(e, n, r)
			}, t
		}();
		const Bd = Rd,
			Nd = function() {
				function t(t, e) {
					this.script = t, this.scriptName = e
				}
				return t.for = function(e, n) {
					return new t(e, n)
				}, t.prototype.embedIntoContext = function(t, e) {
					return Io(this, void 0, void 0, (function() {
						var n;
						return Ro(this, (function(r) {
							return n = t.obj({
								Type: "Action",
								S: "JavaScript",
								JS: Bl.fromText(this.script)
							}), e ? (t.assign(e, n), [2, e]) : [2, t.register(n)]
						}))
					}))
				}, t
			}();
		var Ld = function() {
			function t(t, e, n) {
				var r = this;
				if (this.defaultWordBreaks = [" "], this.computePages = function() {
						var t = [];
						return r.catalog.Pages().traverse((function(e, n) {
							if (e instanceof yl) {
								var i = r.pageMap.get(e);
								i || (i = Hd.of(e, n, r), r.pageMap.set(e, i)), t.push(i)
							}
						})), t
					}, this.getOrCreateForm = function() {
						var t = r.catalog.getOrCreateAcroForm();
						return Pd.of(t, r)
					}, Ya(t, "context", [
						[vl, "PDFContext"]
					]), Ya(e, "ignoreEncryption", ["boolean"]), this.context = t, this.catalog = t.lookup(t.trailerInfo.Root), this.isEncrypted = !!t.lookup(t.trailerInfo.Encrypt), this.pageCache = os.populatedBy(this.computePages), this.pageMap = new Map, this.formCache = os.populatedBy(this.getOrCreateForm), this.fonts = [], this.images = [], this.embeddedPages = [], this.embeddedFiles = [], this.javaScripts = [], !e && this.isEncrypted) throw new jf;
				n && this.updateInfoDict()
			}
			return t.load = function(e, n) {
				return void 0 === n && (n = {}), Io(this, void 0, void 0, (function() {
					var r, i, o, a, s, l, c, u, h, f, d;
					return Ro(this, (function(p) {
						switch (p.label) {
							case 0:
								return r = n.ignoreEncryption, i = void 0 !== r && r, o = n.parseSpeed, a = void 0 === o ? jd.Slow : o, s = n.throwOnInvalidObject, l = void 0 !== s && s, c = n.updateMetadata, u = void 0 === c || c, h = n.capNumbers, f = void 0 !== h && h, Ya(e, "pdf", ["string", Uint8Array, ArrayBuffer]), Ya(i, "ignoreEncryption", ["boolean"]), Ya(a, "parseSpeed", ["number"]), Ya(l, "throwOnInvalidObject", ["boolean"]), d = ha(e), [4, Qu.forBytesWithOptions(d, a, l, f).parseDocument()];
							case 1:
								return [2, new t(p.sent(), i, u)]
						}
					}))
				}))
			}, t.create = function(e) {
				return void 0 === e && (e = {}), Io(this, void 0, void 0, (function() {
					var n, r, i, o, a, s;
					return Ro(this, (function(l) {
						return n = e.updateMetadata, r = void 0 === n || n, i = vl.create(), o = Au.withContext(i), a = i.register(o), s = Pu.withContextAndPages(i, a), i.trailerInfo.Root = i.register(s), [2, new t(i, !1, r)]
					}))
				}))
			}, t.prototype.registerFontkit = function(t) {
				this.fontkit = t
			}, t.prototype.getForm = function() {
				var t = this.formCache.access();
				return t.hasXFA() && (console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA"), t.deleteXFA()), t
			}, t.prototype.getTitle = function() {
				var t = this.getInfoDict().lookup(Zs.Title);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getAuthor = function() {
				var t = this.getInfoDict().lookup(Zs.Author);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getSubject = function() {
				var t = this.getInfoDict().lookup(Zs.Subject);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getKeywords = function() {
				var t = this.getInfoDict().lookup(Zs.Keywords);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getCreator = function() {
				var t = this.getInfoDict().lookup(Zs.Creator);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getProducer = function() {
				var t = this.getInfoDict().lookup(Zs.Producer);
				if (t) return Wd(t), t.decodeText()
			}, t.prototype.getCreationDate = function() {
				var t = this.getInfoDict().lookup(Zs.CreationDate);
				if (t) return Wd(t), t.decodeDate()
			}, t.prototype.getModificationDate = function() {
				var t = this.getInfoDict().lookup(Zs.ModDate);
				if (t) return Wd(t), t.decodeDate()
			}, t.prototype.setTitle = function(t, e) {
				Ya(t, "title", ["string"]);
				var n = Zs.of("Title");
				this.getInfoDict().set(n, Bl.fromText(t)), (null == e ? void 0 : e.showInWindowTitleBar) && this.catalog.getOrCreateViewerPreferences().setDisplayDocTitle(!0)
			}, t.prototype.setAuthor = function(t) {
				Ya(t, "author", ["string"]);
				var e = Zs.of("Author");
				this.getInfoDict().set(e, Bl.fromText(t))
			}, t.prototype.setSubject = function(t) {
				Ya(t, "author", ["string"]);
				var e = Zs.of("Subject");
				this.getInfoDict().set(e, Bl.fromText(t))
			}, t.prototype.setKeywords = function(t) {
				Ya(t, "keywords", [Array]);
				var e = Zs.of("Keywords");
				this.getInfoDict().set(e, Bl.fromText(t.join(" ")))
			}, t.prototype.setCreator = function(t) {
				Ya(t, "creator", ["string"]);
				var e = Zs.of("Creator");
				this.getInfoDict().set(e, Bl.fromText(t))
			}, t.prototype.setProducer = function(t) {
				Ya(t, "creator", ["string"]);
				var e = Zs.of("Producer");
				this.getInfoDict().set(e, Bl.fromText(t))
			}, t.prototype.setLanguage = function(t) {
				Ya(t, "language", ["string"]);
				var e = Zs.of("Lang");
				this.catalog.set(e, Hl.of(t))
			}, t.prototype.setCreationDate = function(t) {
				Ya(t, "creationDate", [
					[Date, "Date"]
				]);
				var e = Zs.of("CreationDate");
				this.getInfoDict().set(e, Hl.fromDate(t))
			}, t.prototype.setModificationDate = function(t) {
				Ya(t, "modificationDate", [
					[Date, "Date"]
				]);
				var e = Zs.of("ModDate");
				this.getInfoDict().set(e, Hl.fromDate(t))
			}, t.prototype.getPageCount = function() {
				return void 0 === this.pageCount && (this.pageCount = this.getPages().length), this.pageCount
			}, t.prototype.getPages = function() {
				return this.pageCache.access()
			}, t.prototype.getPage = function(t) {
				var e = this.getPages();
				return Qa(t, "index", 0, e.length - 1), e[t]
			}, t.prototype.getPageIndices = function() {
				return function(t, e) {
					for (var n = new Array(e - 0), r = 0, i = n.length; r < i; r++) n[r] = 0 + r;
					return n
				}(0, this.getPageCount())
			}, t.prototype.removePage = function(t) {
				var e = this.getPageCount();
				if (0 === this.pageCount) throw new Ef;
				Qa(t, "index", 0, e - 1), this.catalog.removeLeafNode(t), this.pageCount = e - 1
			}, t.prototype.addPage = function(t) {
				return Ya(t, "page", ["undefined", [Hd, "PDFPage"], Array]), this.insertPage(this.getPageCount(), t)
			}, t.prototype.insertPage = function(t, e) {
				var n = this.getPageCount();
				if (Qa(t, "index", 0, n), Ya(e, "page", ["undefined", [Hd, "PDFPage"], Array]), !e || Array.isArray(e)) {
					var r = Array.isArray(e) ? e : Dd.A4;
					(e = Hd.create(this)).setSize.apply(e, r)
				} else if (e.doc !== this) throw new _f;
				var i = this.catalog.insertLeafNode(e.ref, t);
				return e.node.setParent(i), this.pageMap.set(e.node, e), this.pageCache.invalidate(), this.pageCount = n + 1, e
			}, t.prototype.copyPages = function(e, n) {
				return Io(this, void 0, void 0, (function() {
					var r, i, o, a, s, l, c, u;
					return Ro(this, (function(h) {
						switch (h.label) {
							case 0:
								return Ya(e, "srcDoc", [
									[t, "PDFDocument"]
								]), Ya(n, "indices", [Array]), [4, e.flush()];
							case 1:
								for (h.sent(), r = xl.for(e.context, this.context), i = e.getPages(), o = new Array(n.length), a = 0, s = n.length; a < s; a++) l = i[n[a]], c = r.copy(l.node), u = this.context.register(c), o[a] = Hd.of(c, u, this);
								return [2, o]
						}
					}))
				}))
			}, t.prototype.copy = function() {
				return Io(this, void 0, void 0, (function() {
					var e, n, r, i;
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return [4, t.create()];
							case 1:
								return [4, (e = o.sent()).copyPages(this, this.getPageIndices())];
							case 2:
								for (n = o.sent(), r = 0, i = n.length; r < i; r++) e.addPage(n[r]);
								return void 0 !== this.getAuthor() && e.setAuthor(this.getAuthor()), void 0 !== this.getCreationDate() && e.setCreationDate(this.getCreationDate()), void 0 !== this.getCreator() && e.setCreator(this.getCreator()), void 0 !== this.getModificationDate() && e.setModificationDate(this.getModificationDate()), void 0 !== this.getProducer() && e.setProducer(this.getProducer()), void 0 !== this.getSubject() && e.setSubject(this.getSubject()), void 0 !== this.getTitle() && e.setTitle(this.getTitle()), e.defaultWordBreaks = this.defaultWordBreaks, [2, e]
						}
					}))
				}))
			}, t.prototype.addJavaScript = function(t, e) {
				Ya(t, "name", ["string"]), Ya(e, "script", ["string"]);
				var n = Nd.for(e, t),
					r = this.context.nextRef(),
					i = Bd.of(r, this, n);
				this.javaScripts.push(i)
			}, t.prototype.attach = function(t, e, n) {
				return void 0 === n && (n = {}), Io(this, void 0, void 0, (function() {
					var r, i, o, a;
					return Ro(this, (function(s) {
						return Ya(t, "attachment", ["string", Uint8Array, ArrayBuffer]), Ya(e, "name", ["string"]), Za(n.mimeType, "mimeType", ["string"]), Za(n.description, "description", ["string"]), Za(n.creationDate, "options.creationDate", [Date]), Za(n.modificationDate, "options.modificationDate", [Date]), Ga(n.afRelationship, "options.afRelationship", Yl), r = ha(t), i = Zl.for(r, e, n), o = this.context.nextRef(), a = Id.of(o, this, i), this.embeddedFiles.push(a), [2]
					}))
				}))
			}, t.prototype.embedFont = function(t, e) {
				return void 0 === e && (e = {}), Io(this, void 0, void 0, (function() {
					var n, r, i, o, a, s, l, c, u, h;
					return Ro(this, (function(f) {
						switch (f.label) {
							case 0:
								return n = e.subset, r = void 0 !== n && n, i = e.customName, o = e.features, Ya(t, "font", ["string", Uint8Array, ArrayBuffer]), Ya(r, "subset", ["boolean"]), Va(t) ? (a = Ll.for(t, i), [3, 7]) : [3, 1];
							case 1:
								return (d = t) instanceof Uint8Array || d instanceof ArrayBuffer || "string" == typeof d ? (s = ha(t), l = this.assertFontkit(), r ? [4, Kl.for(l, s, i, o)] : [3, 3]) : [3, 6];
							case 2:
								return c = f.sent(), [3, 5];
							case 3:
								return [4, Xl.for(l, s, i, o)];
							case 4:
								c = f.sent(), f.label = 5;
							case 5:
								return a = c, [3, 7];
							case 6:
								throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
							case 7:
								return u = this.context.nextRef(), h = sd.of(u, this, a), this.fonts.push(h), [2, h]
						}
						var d
					}))
				}))
			}, t.prototype.embedStandardFont = function(t, e) {
				if (Ya(t, "font", ["string"]), !Va(t)) throw new TypeError("`font` must be one of type `StandardFonts`");
				var n = Ll.for(t, e),
					r = this.context.nextRef(),
					i = sd.of(r, this, n);
				return this.fonts.push(i), i
			}, t.prototype.embedJpg = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n, r, i;
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return Ya(t, "jpg", ["string", Uint8Array, ArrayBuffer]), e = ha(t), [4, tc.for(e)];
							case 1:
								return n = o.sent(), r = this.context.nextRef(), i = cd.of(r, this, n), this.images.push(i), [2, i]
						}
					}))
				}))
			}, t.prototype.embedPng = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n, r, i;
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return Ya(t, "png", ["string", Uint8Array, ArrayBuffer]), e = ha(t), [4, oc.for(e)];
							case 1:
								return n = o.sent(), r = this.context.nextRef(), i = cd.of(r, this, n), this.images.push(i), [2, i]
						}
					}))
				}))
			}, t.prototype.embedPdf = function(e, n) {
				return void 0 === n && (n = [0]), Io(this, void 0, void 0, (function() {
					var r, i;
					return Ro(this, (function(o) {
						switch (o.label) {
							case 0:
								return Ya(e, "pdf", ["string", Uint8Array, ArrayBuffer, [t, "PDFDocument"]]), Ya(n, "indices", [Array]), e instanceof t ? (r = e, [3, 3]) : [3, 1];
							case 1:
								return [4, t.load(e)];
							case 2:
								r = o.sent(), o.label = 3;
							case 3:
								return i = function(t, e) {
									for (var n = new Array(e.length), r = 0, i = e.length; r < i; r++) n[r] = t[e[r]];
									return n
								}(r.getPages(), n), [2, this.embedPages(i)]
						}
					}))
				}))
			}, t.prototype.embedPage = function(t, e, n) {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(r) {
						switch (r.label) {
							case 0:
								return Ya(t, "page", [
									[Hd, "PDFPage"]
								]), [4, this.embedPages([t], [e], [n])];
							case 1:
								return [2, r.sent()[0]]
						}
					}))
				}))
			}, t.prototype.embedPages = function(t, e, n) {
				return void 0 === e && (e = []), void 0 === n && (n = []), Io(this, void 0, void 0, (function() {
					var r, i, o, a, s, l, c, u, h, f, d, p, g;
					return Ro(this, (function(v) {
						switch (v.label) {
							case 0:
								if (0 === t.length) return [2, []];
								for (l = 0, c = t.length - 1; l < c; l++)
									if (r = t[l], i = t[l + 1], r.node.context !== i.node.context) throw new gs;
								o = t[0].node.context, a = o === this.context ? function(t) {
									return t
								} : xl.for(o, this.context).copy, s = new Array(t.length), l = 0, c = t.length, v.label = 1;
							case 1:
								return l < c ? (u = a(t[l].node), h = e[l], f = n[l], [4, jc.for(u, h, f)]) : [3, 4];
							case 2:
								d = v.sent(), p = this.context.nextRef(), s[l] = od.of(p, this, d), v.label = 3;
							case 3:
								return l++, [3, 1];
							case 4:
								return (g = this.embeddedPages).push.apply(g, s), [2, s]
						}
					}))
				}))
			}, t.prototype.flush = function() {
				return Io(this, void 0, void 0, (function() {
					return Ro(this, (function(t) {
						switch (t.label) {
							case 0:
								return [4, this.embedAll(this.fonts)];
							case 1:
								return t.sent(), [4, this.embedAll(this.images)];
							case 2:
								return t.sent(), [4, this.embedAll(this.embeddedPages)];
							case 3:
								return t.sent(), [4, this.embedAll(this.embeddedFiles)];
							case 4:
								return t.sent(), [4, this.embedAll(this.javaScripts)];
							case 5:
								return t.sent(), [2]
						}
					}))
				}))
			}, t.prototype.save = function(t) {
				return void 0 === t && (t = {}), Io(this, void 0, void 0, (function() {
					var e, n, r, i, o, a, s, l, c;
					return Ro(this, (function(u) {
						switch (u.label) {
							case 0:
								return e = t.useObjectStreams, n = void 0 === e || e, r = t.addDefaultPage, i = void 0 === r || r, o = t.objectsPerTick, a = void 0 === o ? 50 : o, s = t.updateFieldAppearances, l = void 0 === s || s, Ya(n, "useObjectStreams", ["boolean"]), Ya(i, "addDefaultPage", ["boolean"]), Ya(a, "objectsPerTick", ["number"]), Ya(l, "updateFieldAppearances", ["boolean"]), i && 0 === this.getPageCount() && this.addPage(), l && (c = this.formCache.getValue()) && c.updateFieldAppearances(), [4, this.flush()];
							case 1:
								return u.sent(), [2, (n ? Il : Pl).forContext(this.context, a).serializeToBuffer()]
						}
					}))
				}))
			}, t.prototype.saveAsBase64 = function(t) {
				return void 0 === t && (t = {}), Io(this, void 0, void 0, (function() {
					var e, n, r, i, o;
					return Ro(this, (function(a) {
						switch (a.label) {
							case 0:
								return e = t.dataUri, n = void 0 !== e && e, r = function(t, e) {
									var n = {};
									for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
									if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
										var i = 0;
										for (r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]])
									}
									return n
								}(t, ["dataUri"]), Ya(n, "dataUri", ["boolean"]), [4, this.save(r)];
							case 1:
								return i = a.sent(), o = function(t) {
									for (var e = "", n = t.length, r = 0; r < n; r += 3) e += No[t[r] >> 2], e += No[(3 & t[r]) << 4 | t[r + 1] >> 4], e += No[(15 & t[r + 1]) << 2 | t[r + 2] >> 6], e += No[63 & t[r + 2]];
									return n % 3 == 2 ? e = e.substring(0, e.length - 1) + "=" : n % 3 == 1 && (e = e.substring(0, e.length - 2) + "=="), e
								}(i), [2, n ? "data:application/pdf;base64," + o : o]
						}
					}))
				}))
			}, t.prototype.findPageForAnnotationRef = function(t) {
				for (var e = this.getPages(), n = 0, r = e.length; n < r; n++) {
					var i = e[n],
						o = i.node.Annots();
					if (void 0 !== (null == o ? void 0 : o.indexOf(t))) return i
				}
			}, t.prototype.embedAll = function(t) {
				return Io(this, void 0, void 0, (function() {
					var e, n;
					return Ro(this, (function(r) {
						switch (r.label) {
							case 0:
								e = 0, n = t.length, r.label = 1;
							case 1:
								return e < n ? [4, t[e].embed()] : [3, 4];
							case 2:
								r.sent(), r.label = 3;
							case 3:
								return e++, [3, 1];
							case 4:
								return [2]
						}
					}))
				}))
			}, t.prototype.updateInfoDict = function() {
				var t = "pdf-lib (https://github.com/Hopding/pdf-lib)",
					e = new Date,
					n = this.getInfoDict();
				this.setProducer(t), this.setModificationDate(e), n.get(Zs.of("Creator")) || this.setCreator(t), n.get(Zs.of("CreationDate")) || this.setCreationDate(e)
			}, t.prototype.getInfoDict = function() {
				var t = this.context.lookup(this.context.trailerInfo.Info);
				if (t instanceof $s) return t;
				var e = this.context.obj({});
				return this.context.trailerInfo.Info = this.context.register(e), e
			}, t.prototype.assertFontkit = function() {
				if (!this.fontkit) throw new Af;
				return this.fontkit
			}, t
		}();
		const zd = Ld;

		function Wd(t) {
			if (!(t instanceof Bl || t instanceof Hl)) throw new us([Bl, Hl], t)
		}
		var Vd;
		! function(t) {
			t.Normal = "Normal", t.Multiply = "Multiply", t.Screen = "Screen", t.Overlay = "Overlay", t.Darken = "Darken", t.Lighten = "Lighten", t.ColorDodge = "ColorDodge", t.ColorBurn = "ColorBurn", t.HardLight = "HardLight", t.SoftLight = "SoftLight", t.Difference = "Difference", t.Exclusion = "Exclusion"
		}(Vd || (Vd = {}));
		var Ud = function() {
			function t(t, e, n) {
				this.fontSize = 24, this.fontColor = Qh(0, 0, 0), this.lineHeight = 24, this.x = 0, this.y = 0, Ya(t, "leafNode", [
					[yl, "PDFPageLeaf"]
				]), Ya(e, "ref", [
					[ol, "PDFRef"]
				]), Ya(n, "doc", [
					[zd, "PDFDocument"]
				]), this.node = t, this.ref = e, this.doc = n
			}
			return t.prototype.setRotation = function(t) {
				var e = hh(t);
				ts(e, "degreesAngle", 90), this.node.set(Zs.of("Rotate"), this.doc.context.obj(e))
			}, t.prototype.getRotation = function() {
				var t = this.node.Rotate();
				return ah(t ? t.asNumber() : 0)
			}, t.prototype.setSize = function(t, e) {
				Ya(t, "width", ["number"]), Ya(e, "height", ["number"]);
				var n = this.getMediaBox();
				this.setMediaBox(n.x, n.y, t, e);
				var r = this.getCropBox(),
					i = this.getBleedBox(),
					o = this.getTrimBox(),
					a = this.getArtBox(),
					s = this.node.CropBox(),
					l = this.node.BleedBox(),
					c = this.node.TrimBox(),
					u = this.node.ArtBox();
				s && Ua(r, n) && this.setCropBox(n.x, n.y, t, e), l && Ua(i, n) && this.setBleedBox(n.x, n.y, t, e), c && Ua(o, n) && this.setTrimBox(n.x, n.y, t, e), u && Ua(a, n) && this.setArtBox(n.x, n.y, t, e)
			}, t.prototype.setWidth = function(t) {
				Ya(t, "width", ["number"]), this.setSize(t, this.getSize().height)
			}, t.prototype.setHeight = function(t) {
				Ya(t, "height", ["number"]), this.setSize(this.getSize().width, t)
			}, t.prototype.setMediaBox = function(t, e, n, r) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), Ya(n, "width", ["number"]), Ya(r, "height", ["number"]);
				var i = this.doc.context.obj([t, e, t + n, e + r]);
				this.node.set(Zs.MediaBox, i)
			}, t.prototype.setCropBox = function(t, e, n, r) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), Ya(n, "width", ["number"]), Ya(r, "height", ["number"]);
				var i = this.doc.context.obj([t, e, t + n, e + r]);
				this.node.set(Zs.CropBox, i)
			}, t.prototype.setBleedBox = function(t, e, n, r) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), Ya(n, "width", ["number"]), Ya(r, "height", ["number"]);
				var i = this.doc.context.obj([t, e, t + n, e + r]);
				this.node.set(Zs.BleedBox, i)
			}, t.prototype.setTrimBox = function(t, e, n, r) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), Ya(n, "width", ["number"]), Ya(r, "height", ["number"]);
				var i = this.doc.context.obj([t, e, t + n, e + r]);
				this.node.set(Zs.TrimBox, i)
			}, t.prototype.setArtBox = function(t, e, n, r) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), Ya(n, "width", ["number"]), Ya(r, "height", ["number"]);
				var i = this.doc.context.obj([t, e, t + n, e + r]);
				this.node.set(Zs.ArtBox, i)
			}, t.prototype.getSize = function() {
				var t = this.getMediaBox();
				return {
					width: t.width,
					height: t.height
				}
			}, t.prototype.getWidth = function() {
				return this.getSize().width
			}, t.prototype.getHeight = function() {
				return this.getSize().height
			}, t.prototype.getMediaBox = function() {
				return this.node.MediaBox().asRectangle()
			}, t.prototype.getCropBox = function() {
				var t, e = this.node.CropBox();
				return null !== (t = null == e ? void 0 : e.asRectangle()) && void 0 !== t ? t : this.getMediaBox()
			}, t.prototype.getBleedBox = function() {
				var t, e = this.node.BleedBox();
				return null !== (t = null == e ? void 0 : e.asRectangle()) && void 0 !== t ? t : this.getCropBox()
			}, t.prototype.getTrimBox = function() {
				var t, e = this.node.TrimBox();
				return null !== (t = null == e ? void 0 : e.asRectangle()) && void 0 !== t ? t : this.getCropBox()
			}, t.prototype.getArtBox = function() {
				var t, e = this.node.ArtBox();
				return null !== (t = null == e ? void 0 : e.asRectangle()) && void 0 !== t ? t : this.getCropBox()
			}, t.prototype.translateContent = function(t, e) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), this.node.normalize(), this.getContentStream();
				var n = this.createContentStream(jh(), bh(t, e)),
					r = this.doc.context.register(n),
					i = this.createContentStream(Ah()),
					o = this.doc.context.register(i);
				this.node.wrapContentStreams(r, o)
			}, t.prototype.scale = function(t, e) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), this.setSize(this.getWidth() * t, this.getHeight() * e), this.scaleContent(t, e), this.scaleAnnotations(t, e)
			}, t.prototype.scaleContent = function(t, e) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), this.node.normalize(), this.getContentStream();
				var n = this.createContentStream(jh(), xh(t, e)),
					r = this.doc.context.register(n),
					i = this.createContentStream(Ah()),
					o = this.doc.context.register(i);
				this.node.wrapContentStreams(r, o)
			}, t.prototype.scaleAnnotations = function(t, e) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]);
				var n = this.node.Annots();
				if (n)
					for (var r = 0; r < n.size(); r++) {
						var i = n.lookup(r);
						i instanceof $s && this.scaleAnnot(i, t, e)
					}
			}, t.prototype.resetPosition = function() {
				this.getContentStream(!1), this.x = 0, this.y = 0
			}, t.prototype.setFont = function(t) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), this.font = t, this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref)
			}, t.prototype.setFontSize = function(t) {
				Ya(t, "fontSize", ["number"]), this.fontSize = t
			}, t.prototype.setFontColor = function(t) {
				Ya(t, "fontColor", [
					[Object, "Color"]
				]), this.fontColor = t
			}, t.prototype.setLineHeight = function(t) {
				Ya(t, "lineHeight", ["number"]), this.lineHeight = t
			}, t.prototype.getPosition = function() {
				return {
					x: this.x,
					y: this.y
				}
			}, t.prototype.getX = function() {
				return this.x
			}, t.prototype.getY = function() {
				return this.y
			}, t.prototype.moveTo = function(t, e) {
				Ya(t, "x", ["number"]), Ya(e, "y", ["number"]), this.x = t, this.y = e
			}, t.prototype.moveDown = function(t) {
				Ya(t, "yDecrease", ["number"]), this.y -= t
			}, t.prototype.moveUp = function(t) {
				Ya(t, "yIncrease", ["number"]), this.y += t
			}, t.prototype.moveLeft = function(t) {
				Ya(t, "xDecrease", ["number"]), this.x -= t
			}, t.prototype.moveRight = function(t) {
				Ya(t, "xIncrease", ["number"]), this.x += t
			}, t.prototype.pushOperators = function() {
				for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
				Ja(t, "operator", [
					[sl, "PDFOperator"]
				]);
				var n = this.getContentStream();
				n.push.apply(n, t)
			}, t.prototype.drawText = function(t, e) {
				var n, r, i, o, a, s, l;
				void 0 === e && (e = {}), Ya(t, "text", ["string"]), Za(e.color, "options.color", [
					[Object, "Color"]
				]), $a(e.opacity, "opacity.opacity", 0, 1), Za(e.font, "options.font", [
					[sd, "PDFFont"]
				]), Za(e.size, "options.size", ["number"]), Za(e.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(e.xSkew, "options.xSkew", [
					[Object, "Rotation"]
				]), Za(e.ySkew, "options.ySkew", [
					[Object, "Rotation"]
				]), Za(e.x, "options.x", ["number"]), Za(e.y, "options.y", ["number"]), Za(e.lineHeight, "options.lineHeight", ["number"]), Za(e.maxWidth, "options.maxWidth", ["number"]), Za(e.wordBreaks, "options.wordBreaks", [Array]), Ga(e.blendMode, "options.blendMode", Vd);
				for (var c = this.setOrEmbedFont(e.font), u = c.oldFont, h = c.newFont, f = c.newFontKey, d = e.size || this.fontSize, p = e.wordBreaks || this.doc.defaultWordBreaks, g = void 0 === e.maxWidth ? $o(Zo(t)) : function(t, e, n, r) {
						for (var i = function(t) {
								for (var e = Jo.join("|"), n = ["$"], r = 0, i = t.length; r < i; r++) {
									var o = t[r];
									if (Qo(o)) throw new TypeError("`wordBreak` must not include " + e);
									n.push("" === o ? "." : o.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"))
								}
								var a = n.join("|");
								return new RegExp("(" + e + ")|((.*?)(" + a + "))", "gm")
							}(e), o = Zo(t).match(i), a = "", s = 0, l = [], c = function() {
								"" !== a && l.push(a), a = "", s = 0
							}, u = 0, h = o.length; u < h; u++) {
							var f = o[u];
							if (Qo(f)) c();
							else {
								var d = r(f);
								s + d > n && c(), a += f, s += d
							}
						}
						return c(), l
					}(t, p, e.maxWidth, (function(t) {
						return h.widthOfTextAtSize(t, d)
					})), v = new Array(g.length), m = 0, y = g.length; m < y; m++) v[m] = h.encodeText(g[m]);
				var b = this.maybeEmbedGraphicsState({
						opacity: e.opacity,
						blendMode: e.blendMode
					}),
					x = this.getContentStream();
				x.push.apply(x, function(t, e) {
					for (var n, r = [jh(), e.graphicsState && Ph(e.graphicsState), Vh(), rf(e.color), Hh(e.font, e.size), (n = e.lineHeight, sl.of(cl.SetTextLineHeight, [rh(n)])), Xh(uh(e.rotate), uh(e.xSkew), uh(e.ySkew), e.x, e.y)].filter(Boolean), i = 0, o = t.length; i < o; i++) r.push(Wh(t[i]), sl.of(cl.NextLine));
					return r.push(Uh(), Ah()), r
				}(v, {
					color: null !== (n = e.color) && void 0 !== n ? n : this.fontColor,
					font: f,
					size: d,
					rotate: null !== (r = e.rotate) && void 0 !== r ? r : ah(0),
					xSkew: null !== (i = e.xSkew) && void 0 !== i ? i : ah(0),
					ySkew: null !== (o = e.ySkew) && void 0 !== o ? o : ah(0),
					x: null !== (a = e.x) && void 0 !== a ? a : this.x,
					y: null !== (s = e.y) && void 0 !== s ? s : this.y,
					lineHeight: null !== (l = e.lineHeight) && void 0 !== l ? l : this.lineHeight,
					graphicsState: b
				})), e.font && (u ? this.setFont(u) : this.resetFont())
			}, t.prototype.drawImage = function(t, e) {
				var n, r, i, o, a, s, l;
				void 0 === e && (e = {}), Ya(t, "image", [
					[cd, "PDFImage"]
				]), Za(e.x, "options.x", ["number"]), Za(e.y, "options.y", ["number"]), Za(e.width, "options.width", ["number"]), Za(e.height, "options.height", ["number"]), Za(e.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(e.xSkew, "options.xSkew", [
					[Object, "Rotation"]
				]), Za(e.ySkew, "options.ySkew", [
					[Object, "Rotation"]
				]), $a(e.opacity, "opacity.opacity", 0, 1), Ga(e.blendMode, "options.blendMode", Vd);
				var c = this.node.newXObject("Image", t.ref),
					u = this.maybeEmbedGraphicsState({
						opacity: e.opacity,
						blendMode: e.blendMode
					}),
					h = this.getContentStream();
				h.push.apply(h, bf(c, {
					x: null !== (n = e.x) && void 0 !== n ? n : this.x,
					y: null !== (r = e.y) && void 0 !== r ? r : this.y,
					width: null !== (i = e.width) && void 0 !== i ? i : t.size().width,
					height: null !== (o = e.height) && void 0 !== o ? o : t.size().height,
					rotate: null !== (a = e.rotate) && void 0 !== a ? a : ah(0),
					xSkew: null !== (s = e.xSkew) && void 0 !== s ? s : ah(0),
					ySkew: null !== (l = e.ySkew) && void 0 !== l ? l : ah(0),
					graphicsState: u
				}))
			}, t.prototype.drawPage = function(t, e) {
				var n, r, i, o, a;
				void 0 === e && (e = {}), Ya(t, "embeddedPage", [
					[od, "PDFEmbeddedPage"]
				]), Za(e.x, "options.x", ["number"]), Za(e.y, "options.y", ["number"]), Za(e.xScale, "options.xScale", ["number"]), Za(e.yScale, "options.yScale", ["number"]), Za(e.width, "options.width", ["number"]), Za(e.height, "options.height", ["number"]), Za(e.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(e.xSkew, "options.xSkew", [
					[Object, "Rotation"]
				]), Za(e.ySkew, "options.ySkew", [
					[Object, "Rotation"]
				]), $a(e.opacity, "opacity.opacity", 0, 1), Ga(e.blendMode, "options.blendMode", Vd);
				var s = this.node.newXObject("EmbeddedPdfPage", t.ref),
					l = this.maybeEmbedGraphicsState({
						opacity: e.opacity,
						blendMode: e.blendMode
					}),
					c = void 0 !== e.width ? e.width / t.width : void 0 !== e.xScale ? e.xScale : 1,
					u = void 0 !== e.height ? e.height / t.height : void 0 !== e.yScale ? e.yScale : 1,
					h = this.getContentStream();
				h.push.apply(h, function(t, e) {
					return [jh(), e.graphicsState && Ph(e.graphicsState), bh(e.x, e.y), wh(uh(e.rotate)), xh(e.xScale, e.yScale), Sh(uh(e.xSkew), uh(e.ySkew)), Gh(t), Ah()].filter(Boolean)
				}(s, {
					x: null !== (n = e.x) && void 0 !== n ? n : this.x,
					y: null !== (r = e.y) && void 0 !== r ? r : this.y,
					xScale: c,
					yScale: u,
					rotate: null !== (i = e.rotate) && void 0 !== i ? i : ah(0),
					xSkew: null !== (o = e.xSkew) && void 0 !== o ? o : ah(0),
					ySkew: null !== (a = e.ySkew) && void 0 !== a ? a : ah(0),
					graphicsState: l
				}))
			}, t.prototype.drawSvgPath = function(t, e) {
				var n, r, i, o, a, s, l, c, u;
				void 0 === e && (e = {}), Ya(t, "path", ["string"]), Za(e.x, "options.x", ["number"]), Za(e.y, "options.y", ["number"]), Za(e.scale, "options.scale", ["number"]), Za(e.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(e.borderWidth, "options.borderWidth", ["number"]), Za(e.color, "options.color", [
					[Object, "Color"]
				]), $a(e.opacity, "opacity.opacity", 0, 1), Za(e.borderColor, "options.borderColor", [
					[Object, "Color"]
				]), Za(e.borderDashArray, "options.borderDashArray", [Array]), Za(e.borderDashPhase, "options.borderDashPhase", ["number"]), Ga(e.borderLineCap, "options.borderLineCap", oh), $a(e.borderOpacity, "options.borderOpacity", 0, 1), Ga(e.blendMode, "options.blendMode", Vd);
				var h = this.maybeEmbedGraphicsState({
					opacity: e.opacity,
					borderOpacity: e.borderOpacity,
					blendMode: e.blendMode
				});
				"color" in e || "borderColor" in e || (e.borderColor = Qh(0, 0, 0));
				var f = this.getContentStream();
				f.push.apply(f, function(t, e) {
					var n, r, i;
					return Bo([jh(), e.graphicsState && Ph(e.graphicsState), bh(e.x, e.y), wh(uh(null !== (n = e.rotate) && void 0 !== n ? n : ah(0))), e.scale ? xh(e.scale, -e.scale) : xh(1, -1), e.color && rf(e.color), e.borderColor && of(e.borderColor), e.borderWidth && _h(e.borderWidth), e.borderLineCap && kh(e.borderLineCap), Oh(null !== (r = e.borderDashArray) && void 0 !== r ? r : [], null !== (i = e.borderDashPhase) && void 0 !== i ? i : 0)], function(t) {
						return function(t) {
							lf = cf = uf = hf = ff = df = 0;
							for (var e = [], n = 0; n < t.length; n++) {
								var r = t[n];
								if (r.cmd && "function" == typeof gf[r.cmd]) {
									var i = gf[r.cmd](r.args);
									Array.isArray(i) ? e = e.concat(i) : e.push(i)
								}
							}
							return e
						}(function(t) {
							for (var e, n = [], r = [], i = "", o = !1, a = 0, s = 0, l = t; s < l.length; s++) {
								var c = l[s];
								if (pf.has(c)) a = pf.get(c), e && (i.length > 0 && (r[r.length] = +i), n[n.length] = {
									cmd: e,
									args: r
								}, r = [], i = "", o = !1), e = c;
								else if ([" ", ","].includes(c) || "-" === c && i.length > 0 && "e" !== i[i.length - 1] || "." === c && o) {
									if (0 === i.length) continue;
									r.length === a ? (n[n.length] = {
										cmd: e,
										args: r
									}, r = [+i], "M" === e && (e = "L"), "m" === e && (e = "l")) : r[r.length] = +i, o = "." === c, i = ["-", "."].includes(c) ? c : ""
								} else i += c, "." === c && (o = !0)
							}
							return i.length > 0 && (r.length === a ? (n[n.length] = {
								cmd: e,
								args: r
							}, r = [+i], "M" === e && (e = "L"), "m" === e && (e = "l")) : r[r.length] = +i), n[n.length] = {
								cmd: e,
								args: r
							}, n
						}(t))
					}(t), [e.color && e.borderWidth ? Lh() : e.color ? Nh() : e.borderColor ? Bh() : Mh(), Ah()]).filter(Boolean)
				}(t, {
					x: null !== (n = e.x) && void 0 !== n ? n : this.x,
					y: null !== (r = e.y) && void 0 !== r ? r : this.y,
					scale: e.scale,
					rotate: null !== (i = e.rotate) && void 0 !== i ? i : ah(0),
					color: null !== (o = e.color) && void 0 !== o ? o : void 0,
					borderColor: null !== (a = e.borderColor) && void 0 !== a ? a : void 0,
					borderWidth: null !== (s = e.borderWidth) && void 0 !== s ? s : 0,
					borderDashArray: null !== (l = e.borderDashArray) && void 0 !== l ? l : void 0,
					borderDashPhase: null !== (c = e.borderDashPhase) && void 0 !== c ? c : void 0,
					borderLineCap: null !== (u = e.borderLineCap) && void 0 !== u ? u : void 0,
					graphicsState: h
				}))
			}, t.prototype.drawLine = function(t) {
				var e, n, r, i, o;
				Ya(t.start, "options.start", [
					[Object, "{ x: number, y: number }"]
				]), Ya(t.end, "options.end", [
					[Object, "{ x: number, y: number }"]
				]), Ya(t.start.x, "options.start.x", ["number"]), Ya(t.start.y, "options.start.y", ["number"]), Ya(t.end.x, "options.end.x", ["number"]), Ya(t.end.y, "options.end.y", ["number"]), Za(t.thickness, "options.thickness", ["number"]), Za(t.color, "options.color", [
					[Object, "Color"]
				]), Za(t.dashArray, "options.dashArray", [Array]), Za(t.dashPhase, "options.dashPhase", ["number"]), Ga(t.lineCap, "options.lineCap", oh), $a(t.opacity, "opacity.opacity", 0, 1), Ga(t.blendMode, "options.blendMode", Vd);
				var a = this.maybeEmbedGraphicsState({
					borderOpacity: t.opacity,
					blendMode: t.blendMode
				});
				"color" in t || (t.color = Qh(0, 0, 0));
				var s = this.getContentStream();
				s.push.apply(s, function(t) {
					var e, n;
					return [jh(), t.graphicsState && Ph(t.graphicsState), t.color && of(t.color), _h(t.thickness), Oh(null !== (e = t.dashArray) && void 0 !== e ? e : [], null !== (n = t.dashPhase) && void 0 !== n ? n : 0), Ih(t.start.x, t.start.y), t.lineCap && kh(t.lineCap), Ih(t.start.x, t.start.y), Rh(t.end.x, t.end.y), Bh(), Ah()].filter(Boolean)
				}({
					start: t.start,
					end: t.end,
					thickness: null !== (e = t.thickness) && void 0 !== e ? e : 1,
					color: null !== (n = t.color) && void 0 !== n ? n : void 0,
					dashArray: null !== (r = t.dashArray) && void 0 !== r ? r : void 0,
					dashPhase: null !== (i = t.dashPhase) && void 0 !== i ? i : void 0,
					lineCap: null !== (o = t.lineCap) && void 0 !== o ? o : void 0,
					graphicsState: a
				}))
			}, t.prototype.drawRectangle = function(t) {
				var e, n, r, i, o, a, s, l, c, u, h, f, d;
				void 0 === t && (t = {}), Za(t.x, "options.x", ["number"]), Za(t.y, "options.y", ["number"]), Za(t.width, "options.width", ["number"]), Za(t.height, "options.height", ["number"]), Za(t.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(t.xSkew, "options.xSkew", [
					[Object, "Rotation"]
				]), Za(t.ySkew, "options.ySkew", [
					[Object, "Rotation"]
				]), Za(t.borderWidth, "options.borderWidth", ["number"]), Za(t.color, "options.color", [
					[Object, "Color"]
				]), $a(t.opacity, "opacity.opacity", 0, 1), Za(t.borderColor, "options.borderColor", [
					[Object, "Color"]
				]), Za(t.borderDashArray, "options.borderDashArray", [Array]), Za(t.borderDashPhase, "options.borderDashPhase", ["number"]), Ga(t.borderLineCap, "options.borderLineCap", oh), $a(t.borderOpacity, "options.borderOpacity", 0, 1), Ga(t.blendMode, "options.blendMode", Vd);
				var p = this.maybeEmbedGraphicsState({
					opacity: t.opacity,
					borderOpacity: t.borderOpacity,
					blendMode: t.blendMode
				});
				"color" in t || "borderColor" in t || (t.color = Qh(0, 0, 0));
				var g = this.getContentStream();
				g.push.apply(g, xf({
					x: null !== (e = t.x) && void 0 !== e ? e : this.x,
					y: null !== (n = t.y) && void 0 !== n ? n : this.y,
					width: null !== (r = t.width) && void 0 !== r ? r : 150,
					height: null !== (i = t.height) && void 0 !== i ? i : 100,
					rotate: null !== (o = t.rotate) && void 0 !== o ? o : ah(0),
					xSkew: null !== (a = t.xSkew) && void 0 !== a ? a : ah(0),
					ySkew: null !== (s = t.ySkew) && void 0 !== s ? s : ah(0),
					borderWidth: null !== (l = t.borderWidth) && void 0 !== l ? l : 0,
					color: null !== (c = t.color) && void 0 !== c ? c : void 0,
					borderColor: null !== (u = t.borderColor) && void 0 !== u ? u : void 0,
					borderDashArray: null !== (h = t.borderDashArray) && void 0 !== h ? h : void 0,
					borderDashPhase: null !== (f = t.borderDashPhase) && void 0 !== f ? f : void 0,
					graphicsState: p,
					borderLineCap: null !== (d = t.borderLineCap) && void 0 !== d ? d : void 0
				}))
			}, t.prototype.drawSquare = function(t) {
				void 0 === t && (t = {});
				var e = t.size;
				Za(e, "size", ["number"]), this.drawRectangle(Mo(Mo({}, t), {
					width: e,
					height: e
				}))
			}, t.prototype.drawEllipse = function(t) {
				var e, n, r, i, o, a, s, l, c, u, h;
				void 0 === t && (t = {}), Za(t.x, "options.x", ["number"]), Za(t.y, "options.y", ["number"]), Za(t.xScale, "options.xScale", ["number"]), Za(t.yScale, "options.yScale", ["number"]), Za(t.rotate, "options.rotate", [
					[Object, "Rotation"]
				]), Za(t.color, "options.color", [
					[Object, "Color"]
				]), $a(t.opacity, "opacity.opacity", 0, 1), Za(t.borderColor, "options.borderColor", [
					[Object, "Color"]
				]), $a(t.borderOpacity, "options.borderOpacity", 0, 1), Za(t.borderWidth, "options.borderWidth", ["number"]), Za(t.borderDashArray, "options.borderDashArray", [Array]), Za(t.borderDashPhase, "options.borderDashPhase", ["number"]), Ga(t.borderLineCap, "options.borderLineCap", oh), Ga(t.blendMode, "options.blendMode", Vd);
				var f = this.maybeEmbedGraphicsState({
					opacity: t.opacity,
					borderOpacity: t.borderOpacity,
					blendMode: t.blendMode
				});
				"color" in t || "borderColor" in t || (t.color = Qh(0, 0, 0));
				var d = this.getContentStream();
				d.push.apply(d, Cf({
					x: null !== (e = t.x) && void 0 !== e ? e : this.x,
					y: null !== (n = t.y) && void 0 !== n ? n : this.y,
					xScale: null !== (r = t.xScale) && void 0 !== r ? r : 100,
					yScale: null !== (i = t.yScale) && void 0 !== i ? i : 100,
					rotate: null !== (o = t.rotate) && void 0 !== o ? o : void 0,
					color: null !== (a = t.color) && void 0 !== a ? a : void 0,
					borderColor: null !== (s = t.borderColor) && void 0 !== s ? s : void 0,
					borderWidth: null !== (l = t.borderWidth) && void 0 !== l ? l : 0,
					borderDashArray: null !== (c = t.borderDashArray) && void 0 !== c ? c : void 0,
					borderDashPhase: null !== (u = t.borderDashPhase) && void 0 !== u ? u : void 0,
					borderLineCap: null !== (h = t.borderLineCap) && void 0 !== h ? h : void 0,
					graphicsState: f
				}))
			}, t.prototype.drawCircle = function(t) {
				void 0 === t && (t = {});
				var e = t.size,
					n = void 0 === e ? 100 : e;
				Za(n, "size", ["number"]), this.drawEllipse(Mo(Mo({}, t), {
					xScale: n,
					yScale: n
				}))
			}, t.prototype.setOrEmbedFont = function(t) {
				var e = this.font,
					n = this.fontKey;
				return t ? this.setFont(t) : this.getFont(), {
					oldFont: e,
					oldFontKey: n,
					newFont: this.font,
					newFontKey: this.fontKey
				}
			}, t.prototype.getFont = function() {
				if (!this.font || !this.fontKey) {
					var t = this.doc.embedStandardFont(kd.Helvetica);
					this.setFont(t)
				}
				return [this.font, this.fontKey]
			}, t.prototype.resetFont = function() {
				this.font = void 0, this.fontKey = void 0
			}, t.prototype.getContentStream = function(t) {
				return void 0 === t && (t = !0), t && this.contentStream || (this.contentStream = this.createContentStream(), this.contentStreamRef = this.doc.context.register(this.contentStream), this.node.addContentStream(this.contentStreamRef)), this.contentStream
			}, t.prototype.createContentStream = function() {
				for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
				var n = this.doc.context.obj({});
				return fl.of(n, t)
			}, t.prototype.maybeEmbedGraphicsState = function(t) {
				var e = t.opacity,
					n = t.borderOpacity,
					r = t.blendMode;
				if (void 0 !== e || void 0 !== n || void 0 !== r) {
					var i = this.doc.context.obj({
						Type: "ExtGState",
						ca: e,
						CA: n,
						BM: r
					});
					return this.node.newExtGState("GS", i)
				}
			}, t.prototype.scaleAnnot = function(t, e, n) {
				for (var r = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"], i = 0, o = r.length; i < o; i++) {
					var a = t.lookup(Zs.of(r[i]));
					a instanceof zs && a.scalePDFNumbers(e, n)
				}
				var s = t.lookup(Zs.of("InkList"));
				if (s instanceof zs)
					for (i = 0, o = s.size(); i < o; i++) {
						var l = s.lookup(i);
						l instanceof zs && l.scalePDFNumbers(e, n)
					}
			}, t.of = function(e, n, r) {
				return new t(e, n, r)
			}, t.create = function(e) {
				Ya(e, "doc", [
					[zd, "PDFDocument"]
				]);
				var n = ol.of(-1),
					r = yl.withContextAndParent(e.context, n);
				return new t(r, e.context.register(r), e)
			}, t
		}();
		const Hd = Ud;
		var qd = function(t) {
			function e(e, n, r) {
				var i = t.call(this, e, n, r) || this;
				return Ya(e, "acroButton", [
					[fu, "PDFAcroPushButton"]
				]), i.acroField = e, i
			}
			return Do(e, t), e.prototype.setImage = function(t, e) {
				void 0 === e && (e = ud.Center);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r],
						a = this.createImageAppearanceStream(o, t, e);
					this.updateWidgetAppearances(o, {
						normal: a
					})
				}
				this.markAsClean()
			}, e.prototype.setFontSize = function(t) {
				es(t, "fontSize"), this.acroField.setFontSize(t), this.markAsDirty()
			}, e.prototype.addToPage = function(t, e, n) {
				var r, i, o, a, s, l, c, u, h, f, d;
				Za(t, "text", ["string"]), Za(e, "page", [
					[Hd, "PDFPage"]
				]), hd(n);
				var p = this.createWidget({
						x: (null !== (r = null == n ? void 0 : n.x) && void 0 !== r ? r : 0) - (null !== (i = null == n ? void 0 : n.borderWidth) && void 0 !== i ? i : 0) / 2,
						y: (null !== (o = null == n ? void 0 : n.y) && void 0 !== o ? o : 0) - (null !== (a = null == n ? void 0 : n.borderWidth) && void 0 !== a ? a : 0) / 2,
						width: null !== (s = null == n ? void 0 : n.width) && void 0 !== s ? s : 100,
						height: null !== (l = null == n ? void 0 : n.height) && void 0 !== l ? l : 50,
						textColor: null !== (c = null == n ? void 0 : n.textColor) && void 0 !== c ? c : Qh(0, 0, 0),
						backgroundColor: null !== (u = null == n ? void 0 : n.backgroundColor) && void 0 !== u ? u : Qh(.75, .75, .75),
						borderColor: null == n ? void 0 : n.borderColor,
						borderWidth: null !== (h = null == n ? void 0 : n.borderWidth) && void 0 !== h ? h : 0,
						rotate: null !== (f = null == n ? void 0 : n.rotate) && void 0 !== f ? f : ah(0),
						caption: t,
						hidden: null == n ? void 0 : n.hidden,
						page: e.ref
					}),
					g = this.doc.context.register(p.dict);
				this.acroField.addWidget(g);
				var v = null !== (d = null == n ? void 0 : n.font) && void 0 !== d ? d : this.doc.getForm().getDefaultFont();
				this.updateWidgetAppearance(p, v), e.node.addAnnot(g)
			}, e.prototype.needsAppearancesUpdate = function() {
				var t;
				if (this.isDirty()) return !0;
				for (var e = this.acroField.getWidgets(), n = 0, r = e.length; n < r; n++)
					if (!((null === (t = e[n].getAppearances()) || void 0 === t ? void 0 : t.normal) instanceof el)) return !0;
				return !1
			}, e.prototype.defaultUpdateAppearances = function(t) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), this.updateAppearances(t)
			}, e.prototype.updateAppearances = function(t, e) {
				Ya(t, "font", [
					[sd, "PDFFont"]
				]), Za(e, "provider", [Function]);
				for (var n = this.acroField.getWidgets(), r = 0, i = n.length; r < i; r++) {
					var o = n[r];
					this.updateWidgetAppearance(o, t, e)
				}
			}, e.prototype.updateWidgetAppearance = function(t, e, n) {
				var r = Xf((null != n ? n : td)(this, t, e));
				this.updateWidgetAppearanceWithFont(t, e, r)
			}, e.of = function(t, n, r) {
				return new e(t, n, r)
			}, e
		}(dd);
		const Xd = qd;
		var Gd, Kd = n(563);

		function Yd(t, e) {
			return function(t) {
				if (Array.isArray(t)) return t
			}(t) || function(t, e) {
				var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
				if (null != n) {
					var r, i, o, a, s = [],
						l = !0,
						c = !1;
					try {
						if (o = (n = n.call(t)).next, 0 === e) {
							if (Object(n) !== n) return;
							l = !1
						} else
							for (; !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); l = !0);
					} catch (t) {
						c = !0, i = t
					} finally {
						try {
							if (!l && null != n.return && (a = n.return(), Object(a) !== a)) return
						} finally {
							if (c) throw i
						}
					}
					return s
				}
			}(t, e) || jo(t, e) || function() {
				throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
			}()
		}
		fabric.Canvas.prototype.initialize = (Gd = fabric.Canvas.prototype.initialize, function() {
			for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
			return Gd.call.apply(Gd, [this].concat(e)), this._historyInit(), this
		}), fabric.Canvas.prototype._historyInit = function() {
			this.canvasPresentGraph = [], this.canvasAbsentGraph = [], this.extraProps = ["selectable"], this.currentGraph = this._historyNext(), this.on(this._historyEvents())
		}, fabric.Canvas.prototype._historyEvents = function() {
			return {
				"object:added": this._added,
				"object:removed": this._removed,
				"object:modified": this._modified
			}
		}, fabric.Canvas.prototype._added = function(t) {
			!t.target || 1 === t.target.width && 1 === t.target.height || "ellipse" === t.target.type && 1 === t.target.rx && 1 === t.target.ry || "textbox" === t.target.type || "group" === t.target.type && t.target._objects[1] && "textbox" === t.target._objects[1].type && t.h || this._historySaveAction(t)
		}, fabric.Canvas.prototype._removed = function(t) {
			t.target && ("textbox" !== t.target.type || "textbox" === t.target.type && t.target.text) && this._historySaveAction(t)
		}, fabric.Canvas.prototype._modified = function(t) {
			t.target && this._historySaveAction(t)
		}, fabric.Canvas.prototype._historySaveAction = function(t) {
			if (!this.historyProcessing) {
				var e = this.currentGraph;
				if ("clipper" === t.target.type) this.canvasPresentGraph.push(e), this.currentGraph = t.target;
				else {
					var n = this.currentGraph;
					this.canvasPresentGraph.push(n), this.currentGraph = this._historyNext()
				}
				this.fire("history:append", {
					json: e
				}), this._publishIcon()
			}
		}, fabric.Canvas.prototype._historyNext = function() {
			return JSON.stringify(this.toDatalessJSON(this.extraProps))
		}, fabric.Canvas.prototype.clearHistory = function() {
			this.canvasPresentGraph = [], this.canvasAbsentGraph = [], this.fire("history:clear")
		}, fabric.Canvas.prototype.undo = function(t) {
			this.historyProcessing = !0;
			var e = this.canvasPresentGraph.pop(),
				n = null;
			if (("clipper" === this.currentGraph.type && void 0 === e.type || "clipper" === this.currentGraph.type && "clipper" === e.type) && (n = this.currentGraph), e) {
				if (n) {
					var r = document.querySelector(".clipper"),
						i = document.querySelector("#image_canvas"),
						o = document.querySelector(".c-pointer-container");
					r.style.width = n.clipper.width * rate + "px", r.style.height = n.clipper.height * rate + "px", Kd(r).data("height", n.clipper.height).data("width", n.clipper.width), Kd(i).data("left", n.canvas.left).data("top", n.canvas.top), o.style.top = i.style.top = n.canvas.top * rate + "px", o.style.left = i.style.left = n.canvas.left * rate + "px"
				}
				this.canvasAbsentGraph.push(this.currentGraph), this.historyNextState = e, this._publishIcon(), this._loadHistory("clipper" === e.type ? this.canvasPresentGraph.slice(-1)[0] : e, "history:undo", t), this.currentGraph = e
			} else this.historyProcessing = !1
		}, fabric.Canvas.prototype.redo = function(t) {
			this.historyProcessing = !0;
			var e = this.canvasAbsentGraph.pop(),
				n = null;
			if ("clipper" === e.type ? n = e : "clipper" === this.currentGraph.type && (n = this.currentGraph), e) {
				if (n) {
					var r = document.querySelector(".clipper"),
						i = document.querySelector("#image_canvas"),
						o = document.querySelector(".c-pointer-container");
					r.style.width = n.clipper.rwidth * rate + "px", r.style.height = n.clipper.rheight * rate + "px", Kd(r).data("height", n.clipper.rheight).data("width", n.clipper.rwidth), Kd(i).data("left", n.canvas.rleft).data("top", n.canvas.rtop), o.style.top = i.style.top = n.canvas.rtop * rate + "px", o.style.left = i.style.left = n.canvas.rleft * rate + "px"
				}
				this.canvasPresentGraph.push(this.currentGraph), this.historyNextState = e, this._publishIcon(), this._loadHistory(e, "history:redo", t)
			} else this.historyProcessing = !1
		}, fabric.Canvas.prototype._loadHistory = function(t, e, n) {
			var r = this;
			this.currentGraph = t, "string" == typeof t && (JSON.parse(t), this.loadFromJSON(t, (function() {
				r.renderAll(), r.fire(e, JSON.parse(t)), r.historyProcessing = !1
			})))
		}, fabric.Canvas.prototype._publishIcon = function() {
			this.canvasPresentGraph.length ? (0, _o.publish)("abledUndo", !1) : (0, _o.publish)("abledUndo", !0), this.canvasAbsentGraph.length ? (0, _o.publish)("abledRedo", !1) : (0, _o.publish)("abledRedo", !0)
		}, Ao.fabric.Object.prototype.set({
			borderColor: "transparent",
			cornerColor: "#0e78dd",
			cornerStrokeColor: "white",
			borderOpacityWhenMoving: 1,
			borderScaleFactor: 1,
			cornerSize: 12,
			hasControls: !1,
			cornerStyle: "circle",
			transparentCorners: !1,
			noScaleCache: !1,
			hasRotatingPoint: !0,
			selectionDashArray: [5, 5]
		}), Ao.fabric.Object.prototype.controls.mtr = Object.assign(Ao.fabric.Object.prototype.controls.mtr, new Ao.fabric.Control({
			withConnection: !1,
			offsetY: -16,
			cursorStyle: "grab",
			render: function(t, e, n) {
				t.beginPath(), t.arc(e, n, 5, 0, 2 * Math.PI, !0), t.closePath(), t.fillStyle = "green", t.fill(), t.strokeStyle = "white", t.stroke()
			}
		}));
		var Zd = Ao.fabric.Object._fromObject;
		Ao.fabric.Object._fromObject = function(t, e, n, r) {
			"path" !== e.type && (e.hasControls = !0), Zd(t, e, n, r)
		};
		var Jd = Ao.fabric.Group.fromObject;
		Ao.fabric.Group.fromObject = function(t, e) {
			try {
				"textbox" === t.objects[1].type && (t.hasControls = !0)
			} catch (t) {}
			Jd(t, e)
		}, Ao.fabric.Canvas.prototype.isInsideBorder = function(t) {
			switch (t.type) {
				case "rect":
					return function(t) {
						try {
							var e = t.getLocalPointer(),
								n = {
									x1: 10,
									y1: 10,
									x2: t.getScaledWidth() - 10,
									y2: t.getScaledHeight() - 10
								},
								r = e.x > 0 && e.x <= n.x1 || e.x >= n.x2 && e.x < t.getScaledWidth(),
								i = e.y > 0 && e.y <= n.y1 || e.y >= n.y2 && e.y < t.getScaledHeight();
							if (r || i) return !0
						} catch (t) {}
					}(t);
				case "ellipse":
					return function(t) {
						try {
							var e = t.rx,
								n = t.ry,
								r = t.getLocalPointer(),
								i = r.x,
								o = r.y,
								a = t.strokeWidth / 2;
							i = i - e - a, o = n - o + a;
							var s = Math.pow(i, 2) / Math.pow(e - a, 2) + Math.pow(o, 2) / Math.pow(n - a, 2),
								l = Math.pow(i, 2) / Math.pow(e + a, 2) + Math.pow(o, 2) / Math.pow(n + a, 2);
							return !(s < 1 || l > 1)
						} catch (t) {}
					}(t);
				default:
					return !0
			}
		};
		var Qd = Ao.fabric.Image.fromObject;
		Ao.fabric.Image.fromObject = function(t, e) {
			t.hasControls = !0, Qd(t, e)
		}, 
		
		
		Ao.fabric.Line.prototype.render = function(t) {
			var e = this.calcLinePoints();
			t.fillStyle = this.stroke, t.beginPath(), t.arc(this.left + e.x1, this.top + e.y1, this.strokeWidth / 2, 0, 2 * Math.PI, !0), t.closePath(), t.fill(), t.lineWidth = this.strokeWidth, t.strokeStyle = this.stroke, t.beginPath(), t.moveTo(this.left + e.x1, this.top + e.y1), t.lineTo(this.left + e.x2, this.top + e.y2), t.closePath(), t.stroke(), t.fillStyle = this.stroke, t.beginPath(), t.arc(this.left + e.x2, this.top + e.y2, this.strokeWidth / 2, 0, 2 * Math.PI, !0), t.closePath(), t.fill()
		}, Ao.fabric.Line.prototype._controlsVisibility = {
			bl: !0,
			tr: !0,
			br: !1,
			mb: !1,
			ml: !1,
			mr: !1,
			mt: !1,
			mtr: !1,
			tl: !1
		};
		var $d = function(t) {
				return function(e, n, r, i, o) {
					var a = o.strokeWidth / 2,
						s = o.calcLinePoints();
					e.beginPath(), "bl" === t ? e.arc(o.left + s.x1, o.top + s.y1, a, 0, 2 * Math.PI, !0) : e.arc(s.x2, s.y2, a, 0, 2 * Math.PI, !0), e.closePath(), e.fillStyle = "#0e78dd", e.fill(), e.strokeStyle = "white", e.stroke(), e.restore()
				}
			},
			tp = $d("bl"),
			ep = $d("tr");
		Ao.fabric.util.object.extend(Ao.fabric.Line.prototype, {
			controls: {
				bl: new Ao.fabric.Control({
					render: tp,
					positionHandler: function(t, e, n, r) {
						var i = n.calcLinePoints();
						return new Ao.fabric.Point(n.left + i.x1, n.top + i.y1)
					},
					actionHandler: function(t, e, n, r) {
						var i = e.target;
						i.set({
							x1: n,
							y1: r,
							x2: i.oCoords.tr.x,
							y2: i.oCoords.tr.y
						}), i.canvas.renderAll()
					},
					cursorStyleHandler: function(t, e, n) {
						return "pointer"
					},
					mouseUpHandler: function(t, e, n, r) {
						if (e) {
							var i = e.target;
							i.canvas.fire("object:modified", {
								target: i
							})
						}
					}
				}),
				tr: new Ao.fabric.Control({
					render: ep,
					positionHandler: function(t, e, n, r) {
						var i = n.calcLinePoints();
						return new Ao.fabric.Point(n.left + i.x2, n.top + i.y2)
					},
					actionHandler: function(t, e, n, r) {
						var i = e.target;
						i.set({
							x1: i.oCoords.bl.x,
							y1: i.oCoords.bl.y,
							x2: n,
							y2: r
						}), i.canvas.renderAll()
					},
					cursorStyleHandler: function(t, e, n) {
						return "pointer"
					},
					mouseUpHandler: function(t, e, n, r) {
						if (e) {
							var i = e.target;
							i.canvas.fire("object:modified", {
								target: i
							})
						}
					}
				})
			}
		}),

		Ao.fabric.Arrow = Ao.fabric.util.createClass(Ao.fabric.Line.prototype, {
			type: "arrow",
			render: function(t) {
				    //    console.log('Rendering ArrowStyle1 with strokeWidth:', this.strokeWidth);

				var e = this.calcLinePoints(),
					n = e.x2 - e.x1,
					r = e.y2 - e.y1,
					i = Math.sqrt(n * n + r * r),
					o = 2 * this.strokeWidth,
					a = o / i * n,
					s = o / i * r,
					l = function(t, e, n, r) {
						var i = -1 / r,
							o = Math.atan(i),
							a = e - i * t,
							s = t + n * Math.cos(o),
							l = s * i + a,
							c = t - n * Math.cos(o);
						return [s, l, c, c * i + a]
					}(e.x2 - 1.5 * o / i * n, e.y2 - 1.5 * o / i * r, .8 * o, r / n),
					c = Yd(l, 4),
					u = c[0],
					h = c[1],
					f = c[2],
					d = c[3];
				t.fillStyle = this.stroke, t.lineWidth = this.strokeWidth, t.strokeStyle = this.stroke, t.beginPath(), t.arc(this.left + e.x1, this.top + e.y1, this.strokeWidth / 2, 0, 2 * Math.PI, !0), t.closePath(), t.fill(), t.beginPath(), t.moveTo(this.left + e.x1, this.top + e.y1), t.lineTo(this.left + e.x2 - a, this.top + e.y2 - s), t.closePath(), t.stroke(), t.fillStyle = this.stroke, t.beginPath(), t.moveTo(this.left + e.x2, this.top + e.y2), t.lineTo(this.left + u, this.top + h), t.lineTo(this.left + e.x2 - a, this.top + e.y2 - s), t.lineTo(this.left + f, this.top + d), t.closePath(), t.fill()
			}
		}), Ao.fabric.Arrow.fromObject = function(t, e) {
			var n = Ao.fabric.util.object.clone(t, !0);
			n.points = [t.x1, t.y1, t.x2, t.y2], Ao.fabric.Object._fromObject("Arrow", n, (function(t) {
				delete t.points, e && e(t)
			}), "points")
		};
		
		
	



	
		// ArrowStyle2 (based on La_advanced_feature_arrow4)
		
Ao.fabric.ArrowStyle2 = Ao.fabric.util.createClass(Ao.fabric.Arrow, {
    type: "arrowStyle2",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage, default to 8 if not found
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 8);
        console.log('ArrowStyle2 initialized with strokeWidth from local storage:', this.strokeWidth);

        this.callSuper('initialize', points, options);
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            // Update local storage when strokeWidth is set programmatically
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage:', value);
        }
        return this;
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage before rendering
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;
       // console.log('Rendering ArrowStyle2 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const startThickness = this.strokeWidth * 0.5;
        const endThickness = startThickness * 6;
        const arrowHeadSize = endThickness * 2;

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const angle = Math.atan2(dy, dx);
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const adjustedLineLength = fullLineLength - arrowHeadSize;

        const directionX = dx / fullLineLength;
        const directionY = dy / fullLineLength;

        ctx.save();
        ctx.translate(this.left, this.top);

        ctx.strokeStyle = this.stroke;
        ctx.fillStyle = this.stroke;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const numSegments = 200;
        for (let i = 0; i < numSegments; i++) {
            const t1 = i / numSegments;
            const t2 = (i + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);

            ctx.lineWidth = currentThickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        const arrowBaseX = startPoint.x + adjustedLineLength * directionX;
        const arrowBaseY = startPoint.y + adjustedLineLength * directionY;
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        const arrowHeadLineLength = arrowHeadSize * 1.2;
        const arrowHeadX1 = arrowBaseX - arrowHeadLineLength * Math.cos(angle - Math.PI / 4);
        const arrowHeadY1 = arrowBaseY - arrowHeadLineLength * Math.sin(angle - Math.PI / 4);
        const arrowHeadX2 = arrowBaseX - arrowHeadLineLength * Math.cos(angle + Math.PI / 4);
        const arrowHeadY2 = arrowBaseY - arrowHeadLineLength * Math.sin(angle + Math.PI / 4);

        ctx.beginPath();
        ctx.moveTo(arrowBaseX, arrowBaseY);
        ctx.lineTo(arrowHeadX1, arrowHeadY1);
        ctx.lineTo(arrowTipX, arrowTipY);
        ctx.lineTo(arrowHeadX2, arrowHeadY2);
        ctx.closePath();

        ctx.fillStyle = this.stroke;
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = this.stroke;
        ctx.stroke();

        ctx.restore();
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle2',
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle2.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = [object.x1, object.y1, object.x2, object.y2];
    Ao.fabric.Object._fromObject("ArrowStyle2", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};





Ao.fabric.ArrowStyle3 = Ao.fabric.util.createClass(Ao.fabric.Arrow, {
    type: "arrowStyle3",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 8);
        console.log('ArrowStyle3 initialized with strokeWidth from local storage:', this.strokeWidth);

        this.points = points || [];
        if (this.points.length >= 2) {
            options = options || {};
            options.x1 = this.points[0].x;
            options.y1 = this.points[0].y;
            options.x2 = this.points[this.points.length - 1].x;
            options.y2 = this.points[this.points.length - 1].y;
        } else {
            this.points = [
                { x: options.x1 || 0, y: options.y1 || 0 },
                { x: options.x2 || 1, y: options.y2 || 1 }
            ];
        }
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[this.points.length - 1].x, this.points[this.points.length - 1].y], options);
        this.isDrawing = true;
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.initialLeft = this.left;
        this.initialTop = this.top;
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle3:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        if (this.points.length < 2) return;

        const startTime = performance.now();

        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

      //  console.log('Rendering ArrowStyle3 with strokeWidth from local storage:', this.strokeWidth);

        const startThickness = this.strokeWidth * 0.5;
        const endThickness = startThickness * 6;
        const arrowHeadSize = endThickness * 2;
        const outlineThickness = this.strokeWidth;
        const outlineColor = "white";

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const numSegments = 50;

        // Draw all segments except the last
        for (let i = 0; i < this.points.length - 2; i++) {
            const start = this.points[i];
            const end = this.points[i + 1];

            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const fullLineLength = Math.sqrt(dx * dx + dy * dy);
            const adjustedLineLength = fullLineLength;
            const directionX = dx / fullLineLength;
            const directionY = dy / fullLineLength;

            // Draw outline
            ctx.strokeStyle = outlineColor;
            for (let j = 0; j < numSegments; j++) {
                const t1 = j / numSegments;
                const t2 = (j + 1) / numSegments;

                const x1 = start.x + t1 * adjustedLineLength * directionX;
                const y1 = start.y + t1 * adjustedLineLength * directionY;
                const x2 = start.x + t2 * adjustedLineLength * directionX;
                const y2 = start.y + t2 * adjustedLineLength * directionY;

                const currentThickness = startThickness + t1 * (endThickness - startThickness);
              //  console.log('Current thickness for segment (outline):', currentThickness + outlineThickness);

                ctx.lineWidth = currentThickness + outlineThickness;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Draw main stroke
            ctx.strokeStyle = this.stroke;
            for (let j = 0; j < numSegments; j++) {
                const t1 = j / numSegments;
                const t2 = (j + 1) / numSegments;

                const x1 = start.x + t1 * adjustedLineLength * directionX;
                const y1 = start.y + t1 * adjustedLineLength * directionY;
                const x2 = start.x + t2 * adjustedLineLength * directionX;
                const y2 = start.y + t2 * adjustedLineLength * directionY;

                const currentThickness = startThickness + t1 * (endThickness - startThickness);
            //    console.log('Current thickness for segment (main):', currentThickness);

                ctx.lineWidth = currentThickness;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        // Draw the last segment using calcLinePoints
        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const adjustedLineLength = fullLineLength - arrowHeadSize;
        const directionX = dx / fullLineLength;
        const directionY = dy / fullLineLength;

        this.points[this.points.length - 1] = { x: endPoint.x, y: endPoint.y };

        // Draw outline for the last segment
        ctx.strokeStyle = outlineColor;
        for (let j = 0; j < numSegments; j++) {
            const t1 = j / numSegments;
            const t2 = (j + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);

            ctx.lineWidth = currentThickness + outlineThickness;

            if (t2 * adjustedLineLength < adjustedLineLength) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        // Draw main stroke for the last segment
        ctx.strokeStyle = this.stroke;
        for (let j = 0; j < numSegments; j++) {
            const t1 = j / numSegments;
            const t2 = (j + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);

            ctx.lineWidth = currentThickness;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // Draw the arrowhead
        const angle = Math.atan2(dy, dx);
        const arrowBaseX = startPoint.x + adjustedLineLength * directionX;
        const arrowBaseY = startPoint.y + adjustedLineLength * directionY;
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        const arrowHeadX1 = arrowBaseX - arrowHeadSize * Math.cos(angle - Math.PI / 4);
        const arrowHeadY1 = arrowBaseY - arrowHeadSize * Math.sin(angle - Math.PI / 4);
        const arrowHeadX2 = arrowBaseX - arrowHeadSize * Math.cos(angle + Math.PI / 4);
        const arrowHeadY2 = arrowBaseY - arrowHeadSize * Math.sin(angle + Math.PI / 4);

        ctx.beginPath();
        ctx.moveTo(arrowBaseX, arrowBaseY);
        ctx.lineTo(arrowHeadX1, arrowHeadY1);
        ctx.lineTo(arrowTipX, arrowTipY);
        ctx.lineTo(arrowHeadX2, arrowHeadY2);
        ctx.closePath();
        ctx.lineWidth = outlineThickness + 2;
        ctx.strokeStyle = outlineColor;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(arrowBaseX, arrowBaseY);
        ctx.lineTo(arrowHeadX1, arrowHeadY1);
        ctx.lineTo(arrowTipX, arrowTipY);
        ctx.lineTo(arrowHeadX2, arrowHeadY2);
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = this.stroke;
        ctx.stroke();

        ctx.restore();

        const endTime = performance.now();
        console.log(`ArrowStyle3 render time: ${endTime - startTime}ms`);

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle3');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.isDrawing = false;
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle3',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle3.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [object.x1, object.y1, object.x2, object.y2];
    Ao.fabric.Object._fromObject("ArrowStyle3", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



 
 
 


 // arrowStyle4
  
Ao.fabric.ArrowStyle4 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle4",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);
        console.log('ArrowStyle4 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle4:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

    //    console.log('Rendering ArrowStyle4 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const startThickness = this.strokeWidth * 1;
        const endThickness = startThickness * 6;
        const arrowHeadSize = endThickness * 2;

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);

        // Calculate the slant offset for the arrowhead's V-shape
        const slantPercentage = 0.11;
        const slantOffset = arrowHeadSize * slantPercentage;

        // Extend the line to the center point of the arrowhead's V-shape
        const adjustedLineLength = fullLineLength - arrowHeadSize + slantOffset;
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);
        const angle = Math.atan2(dy, dx);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;

        // Draw the line with increasing thickness
        const numSegments = 200;
        for (let i = 0; i < numSegments; i++) {
            const t1 = i / numSegments;
            const t2 = (i + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);
         //   console.log('Current thickness for segment:', currentThickness);

            ctx.lineWidth = currentThickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            // Use "butt" cap for the last segment to avoid rounded extension
            if (i === numSegments - 1) {
                ctx.lineCap = "butt";
            }
            ctx.stroke();
        }

        // Draw the arrowhead with a slanted base meeting at the center
        const arrowBaseX = startPoint.x + (fullLineLength - arrowHeadSize) * directionX;
        const arrowBaseY = startPoint.y + (fullLineLength - arrowHeadSize) * directionY;
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        const perpDirectionX = -directionY;
        const perpDirectionY = directionX;

        const arrowBaseWidth = endThickness * 2;
        const halfBaseWidth = arrowBaseWidth / 2;

        // Center point of the V-shape
        const centerX = arrowBaseX + slantOffset * directionX;
        const centerY = arrowBaseY + slantOffset * directionY;

        // Base points at the original adjustedLineLength (before extension)
        const baseX1 = arrowBaseX + halfBaseWidth * perpDirectionX;
        const baseY1 = arrowBaseY + halfBaseWidth * perpDirectionY;
        const baseX2 = arrowBaseX - halfBaseWidth * perpDirectionX;
        const baseY2 = arrowBaseY - halfBaseWidth * perpDirectionY;

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(arrowTipX, arrowTipY);
        ctx.lineTo(baseX1, baseY1);
        ctx.lineTo(centerX, centerY);
        ctx.lineTo(baseX2, baseY2);
        ctx.closePath();
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle4');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle4',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle4.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle4", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};


// ArrowStyle5  

Ao.fabric.ArrowStyle5 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle5",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle5 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle5:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

    //    console.log('Rendering ArrowStyle5 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const startThickness = this.strokeWidth * 1;
        const endThickness = startThickness * 6;
        const arrowHeadSize = endThickness * 2;
        const outlineThickness = this.strokeWidth * 2;

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const adjustedLineLength = fullLineLength - arrowHeadSize;
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);
        const angle = Math.atan2(dy, dx);

        // Calculate outline color based on background luminance
        let backgroundColor = getComputedStyle(document.getElementById("image_canvas")).backgroundColor;
        let rgb = backgroundColor.match(/\d+/g).map(Number);
        let luminance = 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2];
        let outlineColor = luminance < 50 ? "white" : "black";

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Draw the line with outline (thicker stroke in outline color)
        const numSegments = 200;
        ctx.strokeStyle = outlineColor;
        for (let i = 0; i < numSegments; i++) {
            const t1 = i / numSegments;
            const t2 = (i + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);
        //    console.log('Current thickness for segment (outline):', currentThickness + outlineThickness);

            ctx.lineWidth = currentThickness + outlineThickness;

            if (t2 * adjustedLineLength < adjustedLineLength) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        // Draw the line fill (actual stroke color)
        ctx.strokeStyle = this.stroke;
        for (let i = 0; i < numSegments; i++) {
            const t1 = i / numSegments;
            const t2 = (i + 1) / numSegments;

            const x1 = startPoint.x + t1 * adjustedLineLength * directionX;
            const y1 = startPoint.y + t1 * adjustedLineLength * directionY;
            const x2 = startPoint.x + t2 * adjustedLineLength * directionX;
            const y2 = startPoint.y + t2 * adjustedLineLength * directionY;

            const currentThickness = startThickness + t1 * (endThickness - startThickness);
       //     console.log('Current thickness for segment (main):', currentThickness);

            ctx.lineWidth = currentThickness;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // Draw the diamond-shaped arrowhead
        const arrowBaseX = startPoint.x + adjustedLineLength * directionX;
        const arrowBaseY = startPoint.y + adjustedLineLength * directionY;
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        const arrowHeadX1 = arrowBaseX - arrowHeadSize * Math.cos(angle - Math.PI / 4);
        const arrowHeadY1 = arrowBaseY - arrowHeadSize * Math.sin(angle - Math.PI / 4);
        const arrowHeadX2 = arrowBaseX - arrowHeadSize * Math.cos(angle + Math.PI / 4);
        const arrowHeadY2 = arrowBaseY - arrowHeadSize * Math.sin(angle + Math.PI / 4);

        // Draw arrowhead outline
        ctx.beginPath();
        ctx.moveTo(arrowBaseX, arrowBaseY);
        ctx.lineTo(arrowHeadX1, arrowHeadY1);
        ctx.lineTo(arrowTipX, arrowTipY);
        ctx.lineTo(arrowHeadX2, arrowHeadY2);
        ctx.closePath();
        ctx.lineWidth = outlineThickness + 2;
        ctx.strokeStyle = outlineColor;
        ctx.stroke();

        // Draw arrowhead fill
        ctx.beginPath();
        ctx.moveTo(arrowBaseX, arrowBaseY);
        ctx.lineTo(arrowHeadX1, arrowHeadY1);
        ctx.lineTo(arrowTipX, arrowTipY);
        ctx.lineTo(arrowHeadX2, arrowHeadY2);
        ctx.closePath();
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.stroke;
        ctx.stroke();

        // Draw the marker line and highlight
        const markerLength = fullLineLength / 2;
        let markerStartX, markerEndX;

        if (startPoint.x < endPoint.x) {
            markerStartX = arrowTipX;
            markerEndX = markerStartX + markerLength;
        } else {
            markerStartX = arrowTipX - markerLength;
            markerEndX = arrowTipX;
        }

        // Draw marker line
        ctx.beginPath();
        ctx.moveTo(markerStartX, arrowTipY);
        ctx.lineTo(markerEndX, arrowTipY);
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw highlight rectangle beneath the marker
        let baseLineWidth = this.strokeWidth / 2;
        let highlightHeight = baseLineWidth + 65;
        let markerColor = localStorage.getItem("markerColor") || "#ffff00";

        // Convert hex to RGBA with opacity 0.3
        let hex = markerColor.replace("#", "");
        let r = parseInt(hex.substring(0, 2), 16);
        let g = parseInt(hex.substring(2, 4), 16);
        let b = parseInt(hex.substring(4, 6), 16);
        let rgbaMarkerColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

        ctx.fillStyle = rgbaMarkerColor;
        ctx.fillRect(markerStartX, arrowTipY - highlightHeight, markerLength, highlightHeight);

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle5');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle5',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle5.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle5", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



// ArrowStyle6   ArrowStyle2
Ao.fabric.ArrowStyle6 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle6",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle6 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle6:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

     //   console.log('Rendering ArrowStyle6 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
        const scaleFactor = distance / 100;

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = 3 * scaleFactor * this.strokeWidth;
        console.log('Line width for arc and vertical line:', ctx.lineWidth);

        // Draw the arc (semi-circle)
        const arcRadius = 30 * scaleFactor;
        const arcCenterX = startPoint.x;
        const arcCenterY = startPoint.y + arcRadius;

        ctx.beginPath();
        ctx.arc(arcCenterX, arcCenterY, arcRadius, Math.PI + 0.5, 0.5 * Math.PI, false);
        ctx.stroke();

        // Draw the vertical line
        const lineStartX = arcCenterX;
        const lineStartY = arcCenterY + arcRadius;
        const lineEndY = lineStartY + 30 * scaleFactor;

        ctx.beginPath();
        ctx.moveTo(lineStartX, lineStartY);
        ctx.lineTo(lineStartX, lineEndY);
        ctx.stroke();

        // Draw the dot
        const dotRadius = 5 * scaleFactor * this.strokeWidth;
        console.log('Dot radius:', dotRadius);
        ctx.beginPath();
        ctx.arc(lineStartX, lineEndY + 20 * scaleFactor, dotRadius, 0, 2 * Math.PI);
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle6');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle6',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle6.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle6", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};

Ao.fabric.ArrowStyle7 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle7",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle7 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle7:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

     //   console.log('Rendering ArrowStyle7 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const finallwidthhrtrr = this.strokeWidth / 3;

        // Calculate line width for general context (used for corner markers)
        const lineWidth = finallwidthhrtrr * (window.devicePixelRatio || 1);
        console.log('Line width for corner markers:', lineWidth);

        // Calculate rectangle bounds
        const rectX = Math.min(startPoint.x, endPoint.x);
        const rectY = Math.min(startPoint.y, endPoint.y);
        const rectWidth = Math.abs(endPoint.x - startPoint.x);
        const rectHeight = Math.abs(endPoint.y - startPoint.y);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = lineWidth;

        // Draw the filled rectangle (highlight)
        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            let fillStyle;
            if (this.stroke.startsWith("rgb")) {
                fillStyle = this.stroke.replace("rgb", "rgba").replace(")", ", 0.2)");
            } else {
                let markerColor = localStorage.getItem("markerColor") || "#ffff00";
                let hex = markerColor.replace("#", "");
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);
                fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            }

            ctx.fillStyle = fillStyle;
            ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
        }

        // Draw corner markers with thickness controlled by strokeWidth
        const cornerSize = 40; // Fixed as requested
        ctx.lineWidth = this.strokeWidth; // Use strokeWidth for corner line thickness
        console.log('Corner marker thickness:', this.strokeWidth);

        // Top-left corner (startPoint)
        ctx.beginPath();
        ctx.moveTo(rectX, rectY);
        ctx.lineTo(rectX + cornerSize, rectY);
        ctx.moveTo(rectX, rectY);
        ctx.lineTo(rectX, rectY + cornerSize);
        ctx.stroke();

        // Bottom-right corner (endPoint)
        ctx.beginPath();
        ctx.moveTo(rectX + rectWidth, rectY + rectHeight);
        ctx.lineTo(rectX + rectWidth - cornerSize, rectY + rectHeight);
        ctx.moveTo(rectX + rectWidth, rectY + rectHeight);
        ctx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerSize);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle7');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle7',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle7.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle7", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};




//arrowStyle8
Ao.fabric.ArrowStyle8 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle8",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle8 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle8:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

      //  console.log('Rendering ArrowStyle8 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        // Calculate rectangle bounds
        const rectX = Math.min(startPoint.x, endPoint.x);
        const rectY = Math.min(startPoint.y, endPoint.y);
        const rectWidth = Math.abs(endPoint.x - startPoint.x);
        const rectHeight = Math.abs(endPoint.y - startPoint.y);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;

        // Set line width for the rectangle border using strokeWidth directly
        ctx.lineWidth = this.strokeWidth;
        console.log('Rectangle border thickness:', this.strokeWidth);

        // Draw the filled rectangle (highlight)
        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            let fillStyle;
            if (this.stroke.startsWith("rgb")) {
                fillStyle = this.stroke.replace("rgb", "rgba").replace(")", ", 0.2)");
            } else {
                let markerColor = localStorage.getItem("markerColor") || "#ffff00";
                let hex = markerColor.replace("#", "");
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);
                fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            }

            ctx.fillStyle = fillStyle;
            ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
        }

        // Draw the rectangle border
        ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);

        // Draw the diagonal line
        const startX = rectX;
        const startY = rectY + rectHeight;
        const adjustedLineLength = rectWidth * 2;
        // Diagonal line thickness is half of the rectangle border thickness
        ctx.lineWidth = this.strokeWidth / 2;
        console.log('Diagonal line thickness:', this.strokeWidth / 2);

        const endX = startX - adjustedLineLength * Math.cos(Math.PI / 4);
        const endY = startY + adjustedLineLength * Math.sin(Math.PI / 4);

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle8');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle8',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle8.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle8", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



//arrowStyle9
Ao.fabric.ArrowStyle9 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle9",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle9 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle9:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

 //       console.log('Rendering ArrowStyle9 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        // Calculate bounding rectangle
        const rectX = Math.min(startPoint.x, endPoint.x);
        const rectY = Math.min(startPoint.y, endPoint.y);
        const rectWidth = Math.abs(endPoint.x - startPoint.x);
        const rectHeight = Math.abs(endPoint.y - startPoint.y);

        // Calculate circle properties
        const centerX = rectX + rectWidth / 2;
        const centerY = rectY + rectHeight / 2;
        const radius = Math.min(rectWidth, rectHeight) / 2;

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke || "red"; // Default to red if stroke is not set

        // Set line width for the circle border using strokeWidth directly
        ctx.lineWidth = this.strokeWidth;
        console.log('Circle border thickness:', this.strokeWidth);

        // Draw the filled circle (highlight)
        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            let fillStyle;
            if (this.stroke.startsWith("rgb")) {
                fillStyle = this.stroke.replace("rgb", "rgba").replace(")", ", 0.3)");
            } else {
                let markerColor = localStorage.getItem("markerColor") || "#ffff00";
                let hex = markerColor.replace("#", "");
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);
                fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            }

            ctx.fillStyle = fillStyle;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Draw the circle border
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.stroke();

        // Draw the diagonal line
        const angle = Math.PI / 4;
        const startX = centerX - radius * Math.cos(angle);
        const startY = centerY + radius * Math.sin(angle);
        const lineLength = radius * 4;
        const endX = startX - lineLength * Math.sin(angle);
        const endY = startY + lineLength * Math.cos(angle);

        // Diagonal line thickness is half of the circle border thickness
        ctx.lineWidth = this.strokeWidth / 2;
        console.log('Diagonal line thickness:', this.strokeWidth / 2);

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle9');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle9',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle9.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle9", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};


//  ArrowStyle10
Ao.fabric.ArrowStyle10 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle10",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle10 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle10:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

    //    console.log('Rendering ArrowStyle10 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        // Adjust coordinates to ensure startPoint is to the left of endPoint
        const startX = Math.min(startPoint.x, endPoint.x);
        const startY = startPoint.x <= endPoint.x ? startPoint.y : endPoint.y;
        const horizontalEndX = Math.max(startPoint.x, endPoint.x);
        const horizontalLength = horizontalEndX - startX;

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;

        // Set line width for the horizontal line using strokeWidth directly
        ctx.lineWidth = this.strokeWidth;
        console.log('Horizontal line thickness:', this.strokeWidth);

        // Draw the horizontal line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(horizontalEndX, startY);
        ctx.stroke();

        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            // Draw the filled rectangle (highlight)
            const startYyy = startY + 5;
            const highlightHeight = this.strokeWidth + 55; // Already adjusted to use strokeWidth
            console.log('Highlight rectangle height:', highlightHeight);
            let markerColor = localStorage.getItem("markerColor") || "#ffff00";
            let hex = markerColor.replace("#", "");
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            let rgbaMarkerColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

            ctx.fillStyle = rgbaMarkerColor;
            ctx.fillRect(startX, startYyy - highlightHeight, horizontalEndX - startX, highlightHeight);

            // Draw the diagonal line
            ctx.lineWidth = this.strokeWidth / 1.5;
            console.log('Diagonal line thickness (with highlight):', this.strokeWidth / 1.5);
            const diagonalLength = horizontalLength * 2;
            const diagonalEndX = startX - diagonalLength * Math.cos(Math.PI / 4);
            const diagonalEndY = startY + diagonalLength * Math.sin(Math.PI / 4);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(diagonalEndX, diagonalEndY);
            ctx.stroke();
        } else {
            // Draw the diagonal line without the highlight
            ctx.lineWidth = this.strokeWidth / 1.5;
            console.log('Diagonal line thickness (without highlight):', this.strokeWidth / 1.5);
            const diagonalLength = horizontalLength * 2.5;
            const diagonalEndX = startX - diagonalLength * Math.cos(Math.PI / 4);
            const diagonalEndY = startY + diagonalLength * Math.sin(Math.PI / 4);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(diagonalEndX, diagonalEndY);
            ctx.stroke();
        }

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle10');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle10',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle10.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle10", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



// ArrowStyle11 

Ao.fabric.ArrowStyle11 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle11",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle11 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle11:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

     //   console.log('Rendering ArrowStyle11 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        // Adjust coordinates to ensure consistent rendering
        const startX = Math.min(startPoint.x, endPoint.x);
        const startY = startPoint.x <= endPoint.x ? startPoint.y : endPoint.y;
        const braceOffsetX = Math.abs(endPoint.x - startPoint.x) || 100; // Default to 100 if zero
        const braceHeight = Math.abs(endPoint.y - startPoint.y) || 100; // Default to 100 if zero

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;

        // Set line width for the braces using strokeWidth directly
        ctx.lineWidth = this.strokeWidth;
        console.log('Brace thickness:', this.strokeWidth);

        // Draw the filled rectangle (highlight) if enabled
        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            let markerColor = localStorage.getItem("markerColor") || "#ffff00";
            let hex = markerColor.replace("#", "");
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            let rgbaMarkerColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

            ctx.fillStyle = rgbaMarkerColor;
            ctx.fillRect(startX, startY, braceOffsetX, braceHeight);
        }

        // Draw the left curly brace (at startX)
        const braceWidth = 10;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.bezierCurveTo(
            startX - braceWidth * 2, startY + braceHeight * 0.25,
            startX + braceWidth * 2, startY + braceHeight * 0.25,
            startX, startY + braceHeight * 0.5
        );
        ctx.bezierCurveTo(
            startX - braceWidth * 2, startY + braceHeight * 0.75,
            startX + braceWidth * 2, startY + braceHeight * 0.75,
            startX, startY + braceHeight
        );
        ctx.stroke();

        // Draw the right curly brace (at startX + braceOffsetX)
        ctx.beginPath();
        ctx.moveTo(startX + braceOffsetX, startY);
        ctx.bezierCurveTo(
            startX + braceOffsetX + braceWidth * 2, startY + braceHeight * 0.25,
            startX + braceOffsetX - braceWidth * 2, startY + braceHeight * 0.25,
            startX + braceOffsetX, startY + braceHeight * 0.5
        );
        ctx.bezierCurveTo(
            startX + braceOffsetX + braceWidth * 2, startY + braceHeight * 0.75,
            startX + braceOffsetX - braceWidth * 2, startY + braceHeight * 0.75,
            startX + braceOffsetX, startY + braceHeight
        );
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle11');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle11',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle11.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle11", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



Ao.fabric.ArrowStyle12 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle12",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 2);
        console.log('ArrowStyle12 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle12:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    // Update the setStrokeWidth method to align with the set method
    setStrokeWidth: function(newStrokeWidth) {
        this.strokeWidth = newStrokeWidth;
        localStorage.setItem("strokeWidth", newStrokeWidth.toString());
        console.log('setStrokeWidth updated strokeWidth in local storage:', newStrokeWidth);
        this.dirty = true;
        this.setCoords();
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

    //    console.log('Rendering ArrowStyle12 with strokeWidth from local storage:', this.strokeWidth);

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        // Adjust coordinates to ensure consistent rendering
        const startX = Math.min(startPoint.x, endPoint.x);
        const startY = startPoint.x <= endPoint.x ? startPoint.y : endPoint.y;
        const bracketOffsetX = Math.abs(endPoint.x - startPoint.x) || 100; // Default to 100 if zero
        const bracketHeight = Math.abs(endPoint.y - startPoint.y) || 100; // Default to 100 if zero

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.strokeStyle = this.stroke;

        // Set line width for the brackets using strokeWidth directly
        ctx.lineWidth = this.strokeWidth;
        console.log('Bracket thickness:', this.strokeWidth);

        // Draw the filled rectangle (highlight) if enabled
        let markerFillOption5 = localStorage.getItem("markerFillOption5") || "1";
        if (markerFillOption5 === "1") {
            let markerColor = localStorage.getItem("markerColor") || "#ffff00";
            let hex = markerColor.replace("#", "");
            let r = parseInt(hex.substring(0, 2), 16);
            let g = parseInt(hex.substring(2, 4), 16);
            let b = parseInt(hex.substring(4, 6), 16);
            let rgbaMarkerColor = `rgba(${r}, ${g}, ${b}, 0.3)`;

            ctx.fillStyle = rgbaMarkerColor;
            ctx.fillRect(startX, startY, bracketOffsetX, bracketHeight);
        }

        // Draw the left bracket (at startX)
        const bracketWidth = 20;
        ctx.beginPath();
        // Vertical line
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX, startY + bracketHeight);
        // Bottom horizontal line (to the right)
        ctx.moveTo(startX, startY + bracketHeight);
        ctx.lineTo(startX + bracketWidth, startY + bracketHeight);
        // Top horizontal line (to the right)
        ctx.moveTo(startX, startY);
        ctx.lineTo(startX + bracketWidth, startY);
        ctx.stroke();

        // Draw the right bracket (at startX + bracketOffsetX)
        ctx.beginPath();
        // Vertical line
        ctx.moveTo(startX + bracketOffsetX, startY);
        ctx.lineTo(startX + bracketOffsetX, startY + bracketHeight);
        // Bottom horizontal line (to the left)
        ctx.moveTo(startX + bracketOffsetX, startY + bracketHeight);
        ctx.lineTo(startX + bracketOffsetX - bracketWidth, startY + bracketHeight);
        // Top horizontal line (to the left)
        ctx.moveTo(startX + bracketOffsetX, startY);
        ctx.lineTo(startX + bracketOffsetX - bracketWidth, startY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle12');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle12',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle12.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle12", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};




Ao.fabric.ArrowStyle13 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle13",

    initialize: function(points, options) {
        // Retrieve strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);
        console.log('ArrowStyle13 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false; // Disable caching
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle13:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        // Retrieve the latest strokeWidth from local storage
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const startThickness = this.strokeWidth * 1;
        const endThickness = startThickness * 6;
        const arrowHeadSize = endThickness * 2;
        const slantPercentage = 0.11;
        const slantOffset = arrowHeadSize * slantPercentage;

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;

        // Define control points for a Bzier curve
        const controlPoint1 = {
            x: startPoint.x + dx / 3,
            y: startPoint.y + dy / 3 + (Math.abs(dx) * 0.3) // Add a vertical offset for curvature
        };
        const controlPoint2 = {
            x: endPoint.x - dx / 3,
            y: endPoint.y - dy / 3 + (Math.abs(dx) * 0.3) // Add a vertical offset for curvature
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // Adjust the curve length to account for the arrowhead
        const adjustedPathLength = pathLength - arrowHeadSize + slantOffset;
        const tTarget = adjustedPathLength / pathLength;

        // Draw the curved line with increasing thickness
        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        for (let i = 0; i < numSegments; i++) {
            const t1 = i / numSegments;
            const t2 = (i + 1) / numSegments;

            const mt1 = 1 - t1;
            const mt2 = 1 - t2;
            const x1 = mt1 * mt1 * mt1 * startPoint.x + 3 * mt1 * mt1 * t1 * controlPoint1.x + 3 * mt1 * t1 * t1 * controlPoint2.x + t1 * t1 * t1 * endPoint.x;
            const y1 = mt1 * mt1 * mt1 * startPoint.y + 3 * mt1 * mt1 * t1 * controlPoint1.y + 3 * mt1 * t1 * t1 * controlPoint2.y + t1 * t1 * t1 * endPoint.y;
            const x2 = mt2 * mt2 * mt2 * startPoint.x + 3 * mt2 * mt2 * t2 * controlPoint1.x + 3 * mt2 * t2 * t2 * controlPoint2.x + t2 * t2 * t2 * endPoint.x;
            const y2 = mt2 * mt2 * mt2 * startPoint.y + 3 * mt2 * mt2 * t2 * controlPoint1.y + 3 * mt2 * t2 * t2 * controlPoint2.y + t2 * t2 * t2 * endPoint.y;

            const segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            totalLengthDrawn += segmentLength;
            const segmentFraction = totalLengthDrawn / pathLength;

            if (totalLengthDrawn > adjustedPathLength) break;

            const currentThickness = startThickness + segmentFraction * (endThickness - startThickness);
            ctx.lineWidth = currentThickness;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            if (i === numSegments - 1) {
                ctx.lineCap = "butt";
            }
            ctx.stroke();
        }

        // Calculate the arrowhead position and orientation
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        // Find the point on the curve at adjustedPathLength for the arrowhead base
        let arrowBaseX = arrowTipX;
        let arrowBaseY = arrowTipY;
        totalLengthDrawn = 0;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment)+0.2;
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead
        const tEnd = 0.99; // Slightly before the end to approximate the tangent
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const lengthEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd) || 1;
        const directionXEnd = dxEnd / lengthEnd;
        const directionYEnd = dyEnd / lengthEnd;

        const perpDirectionX = -directionYEnd;
        const perpDirectionY = directionXEnd;
        const arrowBaseWidth = endThickness * 2;
        const halfBaseWidth = arrowBaseWidth / 2;

        const centerX = arrowBaseX + slantOffset * directionXEnd;
        const centerY = arrowBaseY + slantOffset * directionYEnd;

        const baseX1 = arrowBaseX + halfBaseWidth * perpDirectionX;
        const baseY1 = arrowBaseY + halfBaseWidth * perpDirectionY;
        const baseX2 = arrowBaseX - halfBaseWidth * perpDirectionX;
        const baseY2 = arrowBaseY - halfBaseWidth * perpDirectionY;

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(arrowTipX, arrowTipY);
        ctx.lineTo(baseX1, baseY1);
        ctx.lineTo(centerX, centerY);
        ctx.lineTo(baseX2, baseY2);
        ctx.closePath();
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle13');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle13',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle13.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle13", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



Ao.fabric.ArrowStyle14 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle14",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);
        console.log('ArrowStyle14 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false;
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle14:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const arrowHeadSize = this.strokeWidth * 3; // Length of the arrowhead lines

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;

        // Define control points for a very smooth Bzier curve
        const controlPoint1 = {
            x: startPoint.x + dx * 0.25,
            y: startPoint.y + dy * 0.25 + (Math.abs(dx) * 0.5) // Increased curvature for a hand-drawn feel
        };
        const controlPoint2 = {
            x: endPoint.x - dx * 0.25,
            y: endPoint.y - dy * 0.25 + (Math.abs(dx) * 0.5) // Increased curvature for a hand-drawn feel
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // Adjust the curve length to account for the arrowhead
        const adjustedPathLength = pathLength - arrowHeadSize;

        // Draw the curved line with consistent thickness
        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.lineWidth = this.strokeWidth;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const segmentLength = Math.sqrt((x - prevX) * (x - prevX) + (y - prevY) * (y - prevY));
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLength) break;

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the arrowhead position and orientation
        let arrowBaseX = 0;
        let arrowBaseY = 0;
        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const lengthEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd) || 1;
        const directionXEnd = dxEnd / lengthEnd;
        const directionYEnd = dyEnd / lengthEnd;

        const perpDirectionX = -directionYEnd;
        const perpDirectionY = directionXEnd;
        const arrowBaseWidth = this.strokeWidth * 1.5; // Width of the arrowhead wings

        // Draw the arrowhead as two simple lines (not filled)
        ctx.beginPath();
        ctx.lineWidth = this.strokeWidth;
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(arrowBaseX + arrowBaseWidth * perpDirectionX, arrowBaseY + arrowBaseWidth * perpDirectionY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(arrowBaseX - arrowBaseWidth * perpDirectionX, arrowBaseY - arrowBaseWidth * perpDirectionY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle14');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle14',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle14.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle14", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};




Ao.fabric.ArrowStyle15 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle15",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);
        console.log('ArrowStyle15 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false;
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle15:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true; // Fixed typo: "dity" to "dirty"
            this.setCoords();
        }

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);

        // Base arrowhead size, scaled by the length of the arrow
        const baseArrowHeadSize = this.strokeWidth * 3;
        const arrowHeadSize = baseArrowHeadSize + (fullLineLength * 0.12); // Increase arrowhead size by 10% of the arrow length

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;

        // Define control points for a very smooth Bzier curve
        const controlPoint1 = {
            x: startPoint.x + dx * 0.25,
            y: startPoint.y + dy * 0.25 + (Math.abs(dx) * 0.5)
        };
        const controlPoint2 = {
            x: endPoint.x - dx * 0.25,
            y: endPoint.y - dy * 0.25 + (Math.abs(dx) * 0.5)
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // Adjust the curve length to account for the arrowhead and add a gap
        const adjustedPathLength = pathLength - arrowHeadSize - (this.strokeWidth * 1.0); // Added offset to create gap
        const adjustedPathLengthline = adjustedPathLength+50; // Added offset to create gap

        // Draw the curved line with consistent thickness
        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.lineWidth = this.strokeWidth;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const segmentLength = Math.sqrt((x - prevX) * (x - prevX) + (y - prevY) * (y - prevY));
            totalLengthDrawn += segmentLength;

            // if (totalLengthDrawn > adjustedPathLength) break;
            if (totalLengthDrawn > adjustedPathLengthline) break;

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the arrowhead position and orientation
        let arrowBaseX = 0;
        let arrowBaseY = 0;
        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const lengthEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd -60) || 1;
        const directionXEnd = dxEnd / lengthEnd;
        const directionYEnd = dyEnd / lengthEnd;

        const perpDirectionX = -directionYEnd;
        const perpDirectionY = directionXEnd;
        const arrowBaseWidth = this.strokeWidth * 2.0; // Increased to make arrowhead wider

        // Define thicknesses for the arrowhead lines
        const bottomArrowHeadThickness = this.strokeWidth* 1.0; // Bottom line same as main line
        const topArrowHeadThickness = this.strokeWidth * 0.8; // Top line 1.3 times thicker than main line

        // Determine which wing is the "top" based on orientation
        const topWingX = arrowBaseX + arrowBaseWidth * perpDirectionX;
        const topWingY = arrowBaseY + arrowBaseWidth * perpDirectionY;
        const bottomWingX = arrowBaseX - arrowBaseWidth * perpDirectionX;
        const bottomWingY = arrowBaseY - arrowBaseWidth * perpDirectionY;

        // Draw the top wing of the arrowhead
        ctx.beginPath();
        ctx.lineWidth = topArrowHeadThickness;
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(topWingX, topWingY);
        ctx.stroke();

        // Draw the bottom wing of the arrowhead
        ctx.beginPath();
        ctx.lineWidth = bottomArrowHeadThickness;
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(bottomWingX, bottomWingY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle15');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle15',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle15.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle15", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};


Ao.fabric.ArrowStyle16 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle16",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);
        console.log('ArrowStyle16 initialized with strokeWidth from local storage:', this.strokeWidth);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;
        this.callSuper('initialize', [this.points[0].x, this.points[0].y, this.points[1].x, this.points[1].y], options);
        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false,
            br: false,
            mb: false,
            ml: false,
            mr: false,
            mt: false,
            tl: false,
            tr: false,
            mtr: false
        });
        this.objectCaching = false;
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            console.log('Updated strokeWidth in local storage for ArrowStyle16:', value);
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        var points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);
        const directionX = dx / (fullLineLength || 1);
        const directionY = dy / (fullLineLength || 1);

        // Base arrowhead size, scaled by the length of the arrow
        const baseArrowHeadSize = this.strokeWidth * 3;
        const arrowHeadSize = baseArrowHeadSize + (fullLineLength * 0.12);

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;

        // Define control points for a very smooth Bzier curve
        const controlPoint1 = {
            x: startPoint.x + dx * 0.25,
            y: startPoint.y + dy * 0.25 + (Math.abs(dx) * 0.5)
        };
        const controlPoint2 = {
            x: endPoint.x - dx * 0.25,
            y: endPoint.y - dy * 0.25 + (Math.abs(dx) * 0.5)
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // Adjust the curve length to account for the arrowhead and add a gap
        const adjustedPathLength = pathLength - arrowHeadSize - (this.strokeWidth * 1.0);
        const adjustedPathLengthline = adjustedPathLength + 50;

        // Draw the main curved line with consistent thickness
        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.lineWidth = this.strokeWidth;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const segmentLength = Math.sqrt((x - prevX) * (x - prevX) + (y - prevY) * (y - prevY));
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLengthline) break;

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Draw the thin line above the curve, starting at 20% and ending at 80% of the adjusted path length
        const startPercentage = 0.2; // Start at 20% from the bottom
        const endPercentage = 0.8;   // End at 80% (20% before the top)
        const startLength = adjustedPathLength * startPercentage;
        const endLength = adjustedPathLength * endPercentage;

        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.lineWidth = this.strokeWidth * 0.4; // Thin line
        ctx.beginPath();
        let startedDrawing = false;

        // Determine the initial perpendicular direction at the start of the small line to ensure consistency
        let initialPerpDirectionX = 0;
        let initialPerpDirectionY = 0;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            let directionXAtPoint = 0;
            let directionYAtPoint = 0;
            if (i < numSegmentsForLength) {
                const tNext = (i + 1) / numSegmentsForLength;
                const mtNext = 1 - tNext;
                const xNext = mtNext * mtNext * mtNext * startPoint.x + 3 * mtNext * mtNext * tNext * controlPoint1.x + 3 * mtNext * tNext * tNext * controlPoint2.x + tNext * tNext * tNext * endPoint.x;
                const yNext = mtNext * mtNext * mtNext * startPoint.y + 3 * mtNext * mtNext * tNext * controlPoint1.y + 3 * mtNext * tNext * tNext * controlPoint2.y + tNext * tNext * tNext * endPoint.y;
                const dxDir = xNext - x;
                const dyDir = yNext - y;
                const lengthDir = Math.sqrt(dxDir * dxDir + dyDir * dyDir) || 1;
                directionXAtPoint = dxDir / lengthDir;
                directionYAtPoint = dyDir / lengthDir;
            } else {
                directionXAtPoint = directionX;
                directionYAtPoint = directionY;
            }

            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }

            if (totalLengthDrawn >= startLength && (initialPerpDirectionX === 0 && initialPerpDirectionY === 0)) {
                initialPerpDirectionX = -directionYAtPoint;
                initialPerpDirectionY = directionXAtPoint;
                // Use the overall curve direction to determine the "above" side at the start
                const crossProduct = directionXAtPoint * dy - directionYAtPoint * dx;
                // Adjust based on the direction of the arrow (left or right)
                if (dx > 0) {
                    // Arrow pointing right: ensure "above" means visually above
                    if (crossProduct > 0) {
                        initialPerpDirectionX = -initialPerpDirectionX;
                        initialPerpDirectionY = -initialPerpDirectionY;
                    }
                } else {
                    // Arrow pointing left: current logic is correct
                    if (crossProduct < 0) {
                        initialPerpDirectionX = -initialPerpDirectionX;
                        initialPerpDirectionY = -initialPerpDirectionY;
                    }
                }
            }

            if (totalLengthDrawn > endLength) break;

            prevX = x;
            prevY = y;
        }

        // Reset for drawing the small line
        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            let directionXAtPoint = 0;
            let directionYAtPoint = 0;
            if (i < numSegmentsForLength) {
                const tNext = (i + 1) / numSegmentsForLength;
                const mtNext = 1 - tNext;
                const xNext = mtNext * mtNext * mtNext * startPoint.x + 3 * mtNext * mtNext * tNext * controlPoint1.x + 3 * mtNext * tNext * tNext * controlPoint2.x + tNext * tNext * tNext * endPoint.x;
                const yNext = mtNext * mtNext * mtNext * startPoint.y + 3 * mtNext * mtNext * tNext * controlPoint1.y + 3 * mtNext * tNext * tNext * controlPoint2.y + tNext * tNext * tNext * endPoint.y;
                const dxDir = xNext - x;
                const dyDir = yNext - y;
                const lengthDir = Math.sqrt(dxDir * dxDir + dyDir * dyDir) || 1;
                directionXAtPoint = dxDir / lengthDir;
                directionYAtPoint = dyDir / lengthDir;
            } else {
                directionXAtPoint = directionX;
                directionYAtPoint = directionY;
            }

            // Calculate the perpendicular direction
            let perpDirectionX = -directionYAtPoint;
            let perpDirectionY = directionXAtPoint;
            // Ensure the perpendicular direction stays consistent with the initial direction
            const dotProduct = perpDirectionX * initialPerpDirectionX + perpDirectionY * initialPerpDirectionY;
            if (dotProduct < 0) {
                perpDirectionX = -perpDirectionX;
                perpDirectionY = -perpDirectionY;
            }

            const offsetAbove = this.strokeWidth * 1.2; // Reduced distance above the curve
            const offsetX = x + offsetAbove * perpDirectionX;
            const offsetY = y + offsetAbove * perpDirectionY;

            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }

            // Start drawing when we reach the startLength
            if (!startedDrawing && totalLengthDrawn >= startLength) {
                ctx.moveTo(offsetX, offsetY);
                startedDrawing = true;
            } else if (startedDrawing && totalLengthDrawn <= endLength) {
                ctx.lineTo(offsetX, offsetY);
            }

            // Stop drawing if we've exceeded the endLength
            if (totalLengthDrawn > endLength) break;

            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the main arrowhead position and orientation
        let arrowBaseX = 0;
        let arrowBaseY = 0;
        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the main arrowhead
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const lengthEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd - 60) || 1;
        const directionXEnd = dxEnd / lengthEnd;
        const directionYEnd = dyEnd / lengthEnd;

        const mainPerpDirectionX = -directionYEnd;
        const mainPerpDirectionY = directionXEnd;
        const arrowBaseWidth = this.strokeWidth * 2.0;

        // Define thicknesses for the main arrowhead lines
        const bottomArrowHeadThickness = this.strokeWidth * 1.0;
        const topArrowHeadThickness = this.strokeWidth * 0.8;

        // Determine which wing is the "top" for the main arrowhead
        const topWingX = arrowBaseX + arrowBaseWidth * mainPerpDirectionX;
        const topWingY = arrowBaseY + arrowBaseWidth * mainPerpDirectionY;
        const bottomWingX = arrowBaseX - arrowBaseWidth * mainPerpDirectionX;
        const bottomWingY = arrowBaseY - arrowBaseWidth * mainPerpDirectionY;

        // Draw the top wing of the main arrowhead
        ctx.beginPath();
        ctx.lineWidth = topArrowHeadThickness;
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(topWingX, topWingY);
        ctx.stroke();

        // Draw the bottom wing of the main arrowhead
        ctx.beginPath();
        ctx.lineWidth = bottomArrowHeadThickness;
        ctx.moveTo(endPoint.x, endPoint.y);
        ctx.lineTo(bottomWingX, bottomWingY);
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            console.log('Requesting canvas renderAll for ArrowStyle16');
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true,
            br: true,
            mb: true,
            ml: true,
            mr: true,
            mt: true,
            tl: true,
            tr: true,
            mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle16',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle16.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle16", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};


Ao.fabric.ArrowStyle17 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle17",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;

        this.callSuper('initialize', [options.x1, options.y1, options.x2, options.y2], options);

        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false, mtr: false
        });

        this.objectCaching = false;
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        // Arrowhead
        const headLength = this.strokeWidth * 4;
        const headWidth = this.strokeWidth * 3;

        const arrowBaseX = endPoint.x - headLength * Math.cos(angle);
        const arrowBaseY = endPoint.y - headLength * Math.sin(angle);

        // Line (shaft)
        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(arrowBaseX, arrowBaseY); // Only draw shaft until base of arrow
        ctx.stroke();

        // Arrowhead triangle
        const perpAngle = angle + Math.PI / 2;
        const x1 = arrowBaseX + (headWidth / 2) * Math.cos(perpAngle);
        const y1 = arrowBaseY + (headWidth / 2) * Math.sin(perpAngle);
        const x2 = arrowBaseX - (headWidth / 2) * Math.cos(perpAngle);
        const y2 = arrowBaseY - (headWidth / 2) * Math.sin(perpAngle);

        ctx.beginPath();
        ctx.moveTo(endPoint.x, endPoint.y); // arrow tip
        ctx.lineTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();

        ctx.restore();

        if (this.dirty && this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true, br: true, mb: true, ml: true,
            mr: true, mt: true, tl: true, tr: true, mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle17',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle17.fromObject = function(object, callback) {
    const cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle17", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



Ao.fabric.ArrowStyle18 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle18",

    initialize: function(points, options) {
        options = options || {};
        this.strokeWidth = options.strokeWidth || 8;
        this.stroke = options.stroke || 'black';
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];

        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;

        this.callSuper('initialize', [points[0], points[1], points[2], points[3]], options);

        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false, mtr: false
        });

        this.objectCaching = false;
        this._canvas = options.canvas || null;
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const arrowHeadSize = this.strokeWidth * 3;
        const arrowWidth = arrowHeadSize * 0.8;

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const directionX = dx / (length || 1);
        const directionY = dy / (length || 1);

        const shaftEndX = endPoint.x - arrowHeadSize * directionX;
        const shaftEndY = endPoint.y - arrowHeadSize * directionY;

        const perpX = -directionY;
        const perpY = directionX;
        const halfBase = arrowWidth / 2;

        const baseX1 = shaftEndX + halfBase * perpX;
        const baseY1 = shaftEndY + halfBase * perpY;
        const baseX2 = shaftEndX - halfBase * perpX;
        const baseY2 = shaftEndY - halfBase * perpY;

        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;

        // Draw shaft
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(shaftEndX, shaftEndY);
        ctx.stroke();

        // Draw arrowhead
        ctx.beginPath();
        ctx.moveTo(endPoint.x, endPoint.y);     // Tip
        ctx.lineTo(baseX1, baseY1);             // Base 1
        ctx.lineTo(baseX2, baseY2);             // Base 2
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true, br: true, mb: true, ml: true,
            mr: true, mt: true, tl: true, tr: true, mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle18',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle18.fromObject = function(object, callback) {
    var cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle18", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};




Ao.fabric.ArrowStyle19 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle19",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;

        this.callSuper('initialize', [options.x1, options.y1, options.x2, options.y2], options);

        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false, mtr: false
        });

        this.objectCaching = false;
        this._canvas = options.canvas || null;

        // Ensure smooth updates during drag
        this.on('moving', () => {
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        });
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);

        // ArrowStyle13 curve logic for control points
        const controlPoint1 = {
            x: startPoint.x + dx / 3,
            y: startPoint.y + dy / 3 + (Math.abs(dx) * 0.3)
        };
        const controlPoint2 = {
            x: endPoint.x - dx / 3,
            y: endPoint.y - dy / 3 + (Math.abs(dx) * 0.3)
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // ArrowStyle17 arrowhead logic
        const headLength = this.strokeWidth * 4;
        const headWidth = this.strokeWidth * 3;

        // Adjust the curve length to stop at the base of the arrowhead
        const adjustedPathLength = pathLength - headLength;

        // Draw the curved line with constant thickness (ArrowStyle17 logic)
        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth; // Constant thickness from ArrowStyle17
        ctx.lineCap = "round";

        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            const segmentLength = Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLength) {
                // Interpolate to find the exact point at adjustedPathLength
                const overshoot = totalLengthDrawn - adjustedPathLength;
                const fraction = (segmentLength - overshoot) / segmentLength;
                const adjustedX = prevX + fraction * (x - prevX);
                const adjustedY = prevY + fraction * (y - prevY);
                ctx.lineTo(adjustedX, adjustedY);
                break;
            }

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the arrowhead position and orientation
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        // Find the point on the curve at adjustedPathLength for the arrowhead base
        let arrowBaseX = arrowTipX;
        let arrowBaseY = arrowTipY;
        totalLengthDrawn = 0;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const angle = Math.atan2(dyEnd, dxEnd);

        // Arrowhead from ArrowStyle17
        const arrowBaseXForHead = arrowTipX - headLength * Math.cos(angle);
        const arrowBaseYForHead = arrowTipY - headLength * Math.sin(angle);

        const perpAngle = angle + Math.PI / 2;
        const x1 = arrowBaseXForHead + (headWidth / 2) * Math.cos(perpAngle);
        const y1 = arrowBaseYForHead + (headWidth / 2) * Math.sin(perpAngle);
        const x2 = arrowBaseXForHead - (headWidth / 2) * Math.cos(perpAngle);
        const y2 = arrowBaseYForHead - (headWidth / 2) * Math.sin(perpAngle);

        ctx.beginPath();
        ctx.moveTo(arrowTipX, arrowTipY);
        ctx.lineTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.fillStyle = this.fill || this.stroke;
        ctx.fill();

        ctx.restore();

        if (this.dirty && this.canvas) {
            this.canvas.requestRenderAll();
            this.dirty = false;
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true, br: true, mb: true, ml: true,
            mr: true, mt: true, tl: true, tr: true, mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle19',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle19.fromObject = function(object, callback) {
    const cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle19", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



Ao.fabric.ArrowStyle20 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle20",

    initialize: function(points, options) {
        options = options || {};
        this.strokeWidth = options.strokeWidth || 8;
        this.stroke = options.stroke || 'black';
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];

        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;

        this.callSuper('initialize', [points[0], points[1], points[2], points[3]], options);

        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false, mtr: false
        });

        this.objectCaching = false;
        this._canvas = options.canvas || null;

        // Ensure smooth updates during drag
        this.on('moving', () => {
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        });
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);

        // ArrowStyle13 curve logic for control points (from ArrowStyle19)
        const controlPoint1 = {
            x: startPoint.x + dx / 3,
            y: startPoint.y + dy / 3 + (Math.abs(dx) * 0.3)
        };
        const controlPoint2 = {
            x: endPoint.x - dx / 3,
            y: endPoint.y - dy / 3 + (Math.abs(dx) * 0.3)
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // ArrowStyle18 arrowhead logic
        const arrowHeadSize = this.strokeWidth * 3;
        const arrowWidth = arrowHeadSize * 0.8;

        // Adjust the curve length to stop at the base of the arrowhead
        const adjustedPathLength = pathLength - arrowHeadSize;

        // Draw the curved line with constant thickness (ArrowStyle18 logic)
        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth; // Constant thickness from ArrowStyle18

        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            const segmentLength = Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLength) {
                // Interpolate to find the exact point at adjustedPathLength
                const overshoot = totalLengthDrawn - adjustedPathLength;
                const fraction = (segmentLength - overshoot) / segmentLength;
                const adjustedX = prevX + fraction * (x - prevX);
                const adjustedY = prevY + fraction * (y - prevY);
                ctx.lineTo(adjustedX, adjustedY);
                break;
            }

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the arrowhead position and orientation
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        // Find the point on the curve at adjustedPathLength for the arrowhead base
        let shaftEndX = arrowTipX;
        let shaftEndY = arrowTipY;
        totalLengthDrawn = 0;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                shaftEndX = x;
                shaftEndY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead (ArrowStyle18 logic)
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const lengthEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd) || 1;
        const directionX = dxEnd / lengthEnd;
        const directionY = dyEnd / lengthEnd;

        // Arrowhead from ArrowStyle18
        const perpX = -directionY;
        const perpY = directionX;
        const halfBase = arrowWidth / 2;

        const baseX1 = shaftEndX + halfBase * perpX;
        const baseY1 = shaftEndY + halfBase * perpY;
        const baseX2 = shaftEndX - halfBase * perpX;
        const baseY2 = shaftEndY - halfBase * perpY;

        ctx.beginPath();
        ctx.moveTo(arrowTipX, arrowTipY); // Tip
        ctx.lineTo(baseX1, baseY1);       // Base 1
        ctx.lineTo(baseX2, baseY2);       // Base 2
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            this.canvas.requestRenderAll();
            this.dirty = false;
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true, br: true, mb: true, ml: true,
            mr: true, mt: true, tl: true, tr: true, mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle20',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle20.fromObject = function(object, callback) {
    const cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle20", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};



Ao.fabric.ArrowStyle21 = Ao.fabric.util.createClass(Ao.fabric.Line, {
    type: "arrowStyle21",

    initialize: function(points, options) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        this.strokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : (options.strokeWidth || 4);

        options = options || {};
        this.points = [
            { x: points[0], y: points[1] },
            { x: points[2], y: points[3] }
        ];
        options.x1 = this.points[0].x;
        options.y1 = this.points[0].y;
        options.x2 = this.points[1].x;
        options.y2 = this.points[1].y;

        this.callSuper('initialize', [options.x1, options.y1, options.x2, options.y2], options);

        this.set('selectable', true);
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false, mtr: false
        });

        this.objectCaching = false;
        this._canvas = options.canvas || null;

        // Ensure smooth updates during drag
        this.on('moving', () => {
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        });
    },

    set: function(key, value) {
        this.callSuper('set', key, value);
        if (key === 'strokeWidth') {
            localStorage.setItem("strokeWidth", value.toString());
            this.dirty = true;
            this.setCoords();
            this.canvas?.requestRenderAll();
        }
        return this;
    },

    render: function(ctx) {
        const storedStrokeWidth = localStorage.getItem("strokeWidth");
        const newStrokeWidth = storedStrokeWidth !== null ? Number(storedStrokeWidth) : this.strokeWidth;

        if (this.strokeWidth !== newStrokeWidth) {
            this.strokeWidth = newStrokeWidth;
            this.dirty = true;
            this.setCoords();
        }

        const points = this.calcLinePoints();
        const startPoint = { x: points.x1, y: points.y1 };
        const endPoint = { x: points.x2, y: points.y2 };

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const fullLineLength = Math.sqrt(dx * dx + dy * dy);

        // ArrowStyle13 curve logic for control points (from ArrowStyle19)
        const controlPoint1 = {
            x: startPoint.x + dx / 3,
            y: startPoint.y + dy / 3 + (Math.abs(dx) * 0.3)
        };
        const controlPoint2 = {
            x: endPoint.x - dx / 3,
            y: endPoint.y - dy / 3 + (Math.abs(dx) * 0.3)
        };

        // Calculate the length of the Bzier curve (approximate)
        let pathLength = 0;
        const numSegmentsForLength = 100;
        let prevX = startPoint.x;
        let prevY = startPoint.y;
        for (let i = 1; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            pathLength += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            prevX = x;
            prevY = y;
        }

        // ArrowStyle17 arrowhead logic (from ArrowStyle19)
        const headLength = this.strokeWidth * 4;
        const headWidth = this.strokeWidth * 3;

        // Adjust the curve length to stop at the base of the arrowhead
        const adjustedPathLength = pathLength - headLength;

        // Draw the curved line with a white center and colored border
        ctx.save();
        ctx.translate(this.left, this.top);
        ctx.lineCap = "round";

        // First pass: Draw the inner white line (thicker)
        ctx.strokeStyle = 'white';
        ctx.lineWidth = this.strokeWidth; // Thicker white center
        const numSegments = 200;
        let totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            const segmentLength = Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLength) {
                const overshoot = totalLengthDrawn - adjustedPathLength;
                const fraction = (segmentLength - overshoot) / segmentLength;
                const adjustedX = prevX + fraction * (x - prevX);
                const adjustedY = prevY + fraction * (y - prevY);
                ctx.lineTo(adjustedX, adjustedY);
                break;
            }

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Second pass: Draw the outer colored border (thinner)
        totalLengthDrawn = 0;
        prevX = startPoint.x;
        prevY = startPoint.y;
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth * 0.6; // Thinner border (adjust as needed)
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i <= numSegments; i++) {
            const t = i / numSegments;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;

            const dxSegment = x - prevX;
            const dySegment = y - prevY;
            const segmentLength = Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            totalLengthDrawn += segmentLength;

            if (totalLengthDrawn > adjustedPathLength) {
                const overshoot = totalLengthDrawn - adjustedPathLength;
                const fraction = (segmentLength - overshoot) / segmentLength;
                const adjustedX = prevX + fraction * (x - prevX);
                const adjustedY = prevY + fraction * (y - prevY);
                ctx.lineTo(adjustedX, adjustedY);
                break;
            }

            ctx.lineTo(x, y);
            prevX = x;
            prevY = y;
        }
        ctx.stroke();

        // Calculate the arrowhead position and orientation
        const arrowTipX = endPoint.x;
        const arrowTipY = endPoint.y;

        // Find the point on the curve at adjustedPathLength for the arrowhead base
        let arrowBaseX = arrowTipX;
        let arrowBaseY = arrowTipY;
        totalLengthDrawn = 0;
        for (let i = 0; i <= numSegmentsForLength; i++) {
            const t = i / numSegmentsForLength;
            const mt = 1 - t;
            const x = mt * mt * mt * startPoint.x + 3 * mt * mt * t * controlPoint1.x + 3 * mt * t * t * controlPoint2.x + t * t * t * endPoint.x;
            const y = mt * mt * mt * startPoint.y + 3 * mt * mt * t * controlPoint1.y + 3 * mt * t * t * controlPoint2.y + t * t * t * endPoint.y;
            if (i > 0) {
                const dxSegment = x - prevX;
                const dySegment = y - prevY;
                totalLengthDrawn += Math.sqrt(dxSegment * dxSegment + dySegment * dySegment);
            }
            if (totalLengthDrawn >= adjustedPathLength) {
                arrowBaseX = x;
                arrowBaseY = y;
                break;
            }
            prevX = x;
            prevY = y;
        }

        // Calculate direction at the end of the curve for the arrowhead
        const tEnd = 0.99;
        const mtEnd = 1 - tEnd;
        const xEnd = mtEnd * mtEnd * mtEnd * startPoint.x + 3 * mtEnd * mtEnd * tEnd * controlPoint1.x + 3 * mtEnd * tEnd * tEnd * controlPoint2.x + tEnd * tEnd * tEnd * endPoint.x;
        const yEnd = mtEnd * mtEnd * mtEnd * startPoint.y + 3 * mtEnd * mtEnd * tEnd * controlPoint1.y + 3 * mtEnd * tEnd * tEnd * controlPoint2.y + tEnd * tEnd * tEnd * endPoint.y;
        const dxEnd = endPoint.x - xEnd;
        const dyEnd = endPoint.y - yEnd;
        const angle = Math.atan2(dyEnd, dxEnd);

        // Arrowhead from ArrowStyle17 (modified for border fill)
        const arrowBaseXForHead = arrowTipX - headLength * Math.cos(angle);
        const arrowBaseYForHead = arrowTipY - headLength * Math.sin(angle);

        const perpAngle = angle + Math.PI / 2;
        const x1 = arrowBaseXForHead + (headWidth / 2) * Math.cos(perpAngle);
        const y1 = arrowBaseYForHead + (headWidth / 2) * Math.sin(perpAngle);
        const x2 = arrowBaseXForHead - (headWidth / 2) * Math.cos(perpAngle);
        const y2 = arrowBaseYForHead - (headWidth / 2) * Math.sin(perpAngle);

        // First pass: Draw the arrowhead with a white fill (center)
        ctx.beginPath();
        ctx.moveTo(arrowTipX, arrowTipY);
        ctx.lineTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();

        // Second pass: Draw the arrowhead border with the stroke color
        ctx.lineWidth = this.strokeWidth * 0.6; // Match the line border thickness
        ctx.strokeStyle = this.stroke;
        ctx.stroke();

        ctx.restore();

        if (this.dirty && this.canvas) {
            this.canvas.requestRenderAll();
            this.dirty = false;
        }
    },

    finishDrawing: function() {
        this.setControlsVisibility({
            bl: true, br: true, mb: true, ml: true,
            mr: true, mt: true, tl: true, tr: true, mtr: true
        });
        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },

    toObject: function() {
        return Ao.fabric.util.object.extend(this.callSuper('toObject'), {
            type: 'arrowStyle21',
            points: this.points,
            strokeWidth: this.strokeWidth
        });
    }
});

Ao.fabric.ArrowStyle21.fromObject = function(object, callback) {
    const cloned = Ao.fabric.util.object.clone(object, true);
    cloned.points = object.points || [
        { x: object.x1, y: object.y1 },
        { x: object.x2, y: object.y2 }
    ];
    Ao.fabric.Object._fromObject("ArrowStyle21", cloned, function(obj) {
        delete obj.points;
        callback && callback(obj);
    }, "points");
};






    // ArrowStyleMulti class definition  arrow

Ao.fabric.ArrowStyleMulti = fabric.util.createClass(fabric.Object, {

    type: "arrowStyleMulti",


    points: null,

 
    isDrawing: true,

    arrowHeadPoints: null,


    initialize: function(points, options) {
        options = options || {};
        this.callSuper('initialize', options);

        // Ensure this.points is an array of exactly 4 points for a cubic Bezier curve
        const inputPoints = points || [];
        this.points = [];
        for (let i = 0; i < 4; i++) {
            const p = inputPoints[i];
            this.points.push({
                x: (p && isFinite(p.x)) ? p.x : 0, // Default to 0 if point or coordinate is invalid/missing
                y: (p && isFinite(p.y)) ? p.y : 0
            });
        }

        this.isDrawing = true; // Initial state is drawing
        this.arrowHeadPoints = { tipX: 0, tipY: 0, wing1X: 0, wing1Y: 0, wing2X: 0, wing2Y: 0, neckX: 0, neckY: 0 };

        this.set('objectCaching', false); // Necessary for objects with custom rendering and controls
        this.set('fill', options.fill || null); // Bezier curve is typically not filled
        this.set('stroke', options.stroke || '#000000');
        this.set('strokeWidth', options.strokeWidth || 2); // Default stroke width
        this.set('strokeDashArray', options.strokeDashArray || (this.isDrawing ? [6, 6] : [])); // Dashed when drawing
        this.set('strokeUniform', options.strokeUniform || true); // Stroke width remains consistent on scaling
        this.set('originX', options.originX || 'center');
        this.set('originY', options.originY || 'center');
        this.set('cornerSize', options.cornerSize || 10); // Default size for Fabric's transform corners

        this._calcDimensions();
        this._calcArrowHead();

        // Hide default Fabric.js transformation controls initially
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false,
            mtr: false // Rotation control
        });
    },


    _calcDimensions: function() {
        if (!this.points || this.points.length !== 4) {
            this.width = 0;
            this.height = 0;
            this.left = 0;
            this.top = 0;
            return;
        }

        const allX = this.points.map(p => p.x);
        const allY = this.points.map(p => p.y);

        const minX = Math.min(...allX);
        const minY = Math.min(...allY);
        const maxX = Math.max(...allX);
        const maxY = Math.max(...allY);

        this.width = Math.max(1, maxX - minX); // Ensure width is at least 1
        this.height = Math.max(1, maxY - minY); // Ensure height is at least 1

        this.left = minX; // Position the object's top-left at the minX of its points
        this.top = minY;  // Position the object's top-left at the minY of its points
    },


    _rotateVector: function(dx, dy, angle, normalize, length) {
        let x = dx * Math.cos(angle) - dy * Math.sin(angle);
        let y = dx * Math.sin(angle) + dy * Math.cos(angle);
        if (normalize) {
            const magnitude = Math.sqrt(x * x + y * y);
            if (magnitude > 0) {
                x = (x / magnitude) * length;
                y = (y / magnitude) * length;
            } else { // Avoid division by zero for zero-length vectors
                x = 0;
                y = 0;
            }
        }
        return [x, y];
    },


    _calcArrowHead: function() {
        if (!this.points || this.points.length !== 4) {
            this.arrowHeadPoints = { tipX: 0, tipY: 0, wing1X: 0, wing1Y: 0, wing2X: 0, wing2Y: 0, neckX: 0, neckY: 0 };
            return;
        }

        const controlP2 = this.points[2]; // Second control point
        const endP = this.points[3];     // End point of the Bezier curve (tip of the arrow)

        // Use strokeWidth to determine arrow size, ensuring it's reasonably sized
        const headBaseSize = this.strokeWidth * 3; // Defines the length of the arrowhead "wings"
        const arrowHeadLength = Math.max(5, headBaseSize); // Length from tip to base of arrowhead
        const arrowWingSpanFactor = 0.6; // Determines how wide the arrowhead is relative to its length
        const arrowWingWidth = arrowHeadLength * arrowWingSpanFactor; // Half-width of the arrowhead base

        // Vector from controlP2 to endP (direction of the curve at the end)
        const dirX = endP.x - controlP2.x;
        const dirY = endP.y - controlP2.y;

        const dirMagnitude = Math.sqrt(dirX * dirX + dirY * dirY);

        // Angle of the P2-P3 segment (tangent at the end of the curve)
        // This is the angle the arrowhead should align with.
        const tangentAngle = Math.atan2(dirY, dirX);

        // Angle for the arrowhead wings relative to the tangent
        // A common angle for barbs is around 20-30 degrees.
        // We use atan(wingWidth / headLength) for a proportional look.
        const wingAngleOffset = Math.atan2(arrowWingWidth, arrowHeadLength); // Angle of the wing relative to the shaft

        // Calculate wing points
        // Wing 1
        const wing1X = endP.x - arrowHeadLength * Math.cos(tangentAngle - wingAngleOffset);
        const wing1Y = endP.y - arrowHeadLength * Math.sin(tangentAngle - wingAngleOffset);

        // Wing 2
        const wing2X = endP.x - arrowHeadLength * Math.cos(tangentAngle + wingAngleOffset);
        const wing2Y = endP.y - arrowHeadLength * Math.sin(tangentAngle + wingAngleOffset);
        
        // Neck point (center of the arrowhead base, where the line visually connects)
        // This point is along the tangent, back from the tip by arrowHeadLength.
        let neckX = endP.x, neckY = endP.y;
        if (dirMagnitude > 0) { // Avoid issues if P2 and P3 are the same
             neckX = endP.x - (arrowHeadLength * (dirX / dirMagnitude));
             neckY = endP.y - (arrowHeadLength * (dirY / dirMagnitude));
        }


        this.arrowHeadPoints = {
            tipX: endP.x, tipY: endP.y,
            wing1X: wing1X, wing1Y: wing1Y,
            wing2X: wing2X, wing2Y: wing2Y,
            neckX: neckX, neckY: neckY // This point can be used if the Bezier should visually end before the arrowhead starts
        };
    },


    _render: function(ctx) {
        if (!this.points || this.points.length !== 4) {
            console.warn("ArrowStyleMulti: Not enough valid points to render.");
            return;
        }
        
        // Adjust points to be relative to the object's top-left (this.left, this.top)
        // This is crucial because _calcDimensions sets this.left and this.top
        const p0 = { x: this.points[0].x - this.left, y: this.points[0].y - this.top };
        const p1 = { x: this.points[1].x - this.left, y: this.points[1].y - this.top };
        const p2 = { x: this.points[2].x - this.left, y: this.points[2].y - this.top };
        const p3 = { x: this.points[3].x - this.left, y: this.points[3].y - this.top }; // End point of Bezier

        // Draw the Bezier curve
        ctx.beginPath();
        if (this.strokeDashArray && this.strokeDashArray.length > 0) {
            ctx.setLineDash(this.strokeDashArray);
        }
        ctx.moveTo(p0.x, p0.y);
        // The Bezier curve should visually lead into the arrowhead.
        // For a clean connection with a filled arrowhead, the curve could end at arrowHeadPoints.neck
        // However, drawing a Bezier to a precise intermediate point is complex.
        // A common method is to draw the full Bezier to P3, then draw the arrowhead.
        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);

        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash

        // Draw the arrowhead (filled triangle)
        if (!this.isDrawing) {
            const ahp = {
                tipX: this.arrowHeadPoints.tipX - this.left, tipY: this.arrowHeadPoints.tipY - this.top,
                wing1X: this.arrowHeadPoints.wing1X - this.left, wing1Y: this.arrowHeadPoints.wing1Y - this.top,
                wing2X: this.arrowHeadPoints.wing2X - this.left, wing2Y: this.arrowHeadPoints.wing2Y - this.top,
            };

            ctx.beginPath();
            ctx.moveTo(ahp.tipX, ahp.tipY);     // Tip of the arrow
            ctx.lineTo(ahp.wing1X, ahp.wing1Y); // One wing
            ctx.lineTo(ahp.wing2X, ahp.wing2Y); // Other wing
            ctx.closePath();                    // Close path to form a triangle

            ctx.fillStyle = this.stroke; // Fill arrowhead with stroke color
            ctx.fill();
            // Optionally, stroke the arrowhead if a border is desired (often not needed if filled)
            // ctx.strokeStyle = this.stroke;
            // ctx.lineWidth = 1; // Or this.strokeWidth / 2 for a thinner border
            // ctx.stroke();
        }

        // During initial drawing, render control point hints
        if (this.isDrawing) {
            const controlPointRadius = Math.max(3, this.strokeWidth * 1.5); // Smaller radius for drawing hints
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // Semi-transparent red
            
            // Draw circles at original point locations (P0, P1, P2, P3) relative to object's top-left
            [p0, p1, p2, p3].forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, controlPointRadius, 0, Math.PI * 2, false);
                ctx.fill();
            });
        }
    },

    finishDrawing: function() {
        this.isDrawing = false;
        this.set('strokeDashArray', []); // Solid line after drawing
        this.controls = {}; // Clear default controls, add custom ones

        // Add custom controls for each of the 4 Bezier points
        this.points.forEach((point, index) => {
            this.controls[`p${index}`] = new fabric.Control({
                // Position handler returns the absolute canvas coordinates of the control point
                positionHandler: (dimX, dimY, fabricObject) => {
                    // Transform local point to canvas coordinates
                    const currentPoint = fabricObject.points[index];
                    return fabric.util.transformPoint(
                        new fabric.Point(currentPoint.x, currentPoint.y),
                        fabricObject.calcTransformMatrix()
                    );
                },
                // Action handler updates the point's local coordinates
                actionHandler: (eventData, transform, x, y) => {
                    const fabricObject = transform.target;
                    // Transform canvas coordinates (x,y) back to object's local coordinates
                    const localPoint = fabric.util.transformPoint(
                        new fabric.Point(x, y),
                        fabric.util.invertTransform(fabricObject.calcTransformMatrix())
                    );

                    fabricObject.points[index] = { x: localPoint.x, y: localPoint.y };
                    fabricObject._calcDimensions(); // Recalculate bounds
                    fabricObject._calcArrowHead();  // Recalculate arrowhead
                    fabricObject.dirty = true;      // Mark object as needing redraw
                    if (fabricObject.canvas) {
                        fabricObject.canvas.requestRenderAll();
                    }
                    return true; // Indicate action was handled
                },
                // Renders the control point handle
                render: (ctx, left, top, styleOverride, fabricObject) => {
                    ctx.save();
                    ctx.translate(left, top); // `left`, `top` are canvas coords of the control point
                    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor || 'rgba(220,53,69,0.8)'; // Reddish, semi-transparent
                    ctx.strokeStyle = styleOverride.cornerStrokeColor || 'rgba(0,0,0,0.5)';
                    ctx.lineWidth = 1;
                    const cornerSize = styleOverride.cornerSize || fabricObject.cornerSize || 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, cornerSize / 2, 0, Math.PI * 2, false);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                },
                cursorStyle: 'grab', // Cursor style for the control
                sizeX: this.cornerSize, // Hit area size
                sizeY: this.cornerSize,
            });
        });

        this.hasControls = true; // Enable custom controls
        // Ensure default transform controls remain hidden
        this.setControlsVisibility({
            bl: false, br: false, mb: false, ml: false,
            mr: false, mt: false, tl: false, tr: false,
            mtr: false
        });

        if (this.canvas) {
            this.canvas.requestRenderAll();
        }
    },


    toObject: function(propertiesToInclude) {
        return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
            points: this.points.map(p => ({ x: p.x, y: p.y })), // Ensure points are cloned
            arrowHeadPoints: { ...this.arrowHeadPoints } // Clone arrowhead points
        });
    }
});

Ao.fabric.ArrowStyleMulti.fromObject = function(object, callback) {
    // Create an instance with points and general options
    const instance = new Ao.fabric.ArrowStyleMulti(object.points, object);
    // Restore specific calculated properties if needed, though they are recalculated on init
    instance.arrowHeadPoints = object.arrowHeadPoints || instance.arrowHeadPoints; // Restore if saved
    
    // If the object was saved after drawing was finished, reflect that state
    if (object.isDrawing === false) {
        instance.finishDrawing(); 
    }
    callback(instance);
};


 
 

// here new code ends 




		
		
		
		var np = function(t, e) {
			return Object.assign(Ao.fabric.Rect.prototype.controls[t], {
				render: function() {
					for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
					return e.bind(this)(r[4].strokeWidth), (t = this.__proto__).render.apply(t, r)
				}
			})
		};

		function rp(t, e) {
			for (var n = 0; n < e.length; n++) {
				var r = e[n];
				r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, wo(r.key), r)
			}
		}
		Ao.fabric.util.object.extend(Ao.fabric.Rect.prototype, {
			controls: {
				bl: np("bl", (function(t) {
					this.offsetX = t / 2, this.offsetY = -t / 2
				})),
				tr: np("tr", (function(t) {
					this.offsetX = -t / 2, this.offsetY = t / 2
				})),
				br: np("br", (function(t) {
					this.offsetX = -t / 2, this.offsetY = -t / 2
				})),
				tl: np("tl", (function(t) {
					this.offsetX = t / 2, this.offsetY = t / 2
				})),
				mb: np("mb", (function(t) {
					this.offsetY = -t / 2
				})),
				ml: np("ml", (function(t) {
					this.offsetX = t / 2
				})),
				mr: np("mr", (function(t) {
					this.offsetX = -t / 2
				})),
				mt: np("mt", (function(t) {
					this.offsetY = t / 2
				})),
				mtr: Ao.fabric.Object.prototype.controls.mtr
			}
		}), Ao.fabric.Ellipse.prototype._controlsVisibility = {
			bl: !1,
			tr: !1,
			br: !1,
			tl: !1,
			mb: !0,
			ml: !0,
			mr: !0,
			mt: !0,
			mtr: !0
		}, Ao.fabric.Textbox.prototype._controlsVisibility = {
			bl: !0,
			tr: !0,
			br: !0,
			tl: !0,
			mb: !1,
			ml: !0,
			mr: !0,
			mt: !1,
			mtr: !0
		}, Ao.fabric.util.object.extend(Ao.fabric.Textbox.prototype, {
			_wordJoiners: /[\t\r]/
		}), Ao.fabric.Image.prototype._controlsVisibility = {
			bl: !0,
			tr: !0,
			br: !0,
			tl: !0,
			mb: !1,
			ml: !1,
			mr: !1,
			mt: !1,
			mtr: !0
		}, Ao.fabric.Group.prototype._controlsVisibility = {
			bl: !0,
			tr: !0,
			br: !0,
			tl: !0,
			mb: !1,
			ml: !1,
			mr: !1,
			mt: !1,
			mtr: !0
		};
		var ip = function() {
			function t() {
				! function(t, e) {
					if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
				}(this, t)
			}
			var e, n;
			return e = t, n = [{
				key: "getStorage",
				value: function(t) {
					return t ? new Promise((function(e, n) {
						chrome.storage.sync.get([t], (function(r) {
							if (chrome.runtime.lastError) return n(chrome.runtime.lastError);
							e(r[t])
						}))
					})) : null
				}
			}, {
				key: "getAllStorage",
				value: function() {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
					return t.length ? new Promise((function(e, n) {
						chrome.storage.sync.get(t, (function(t) {
							if (chrome.runtime.lastError) return n(chrome.runtime.lastError);
							e(t)
						}))
					})) : Promise.resolve({})
				}
			}, {
				key: "setStorage",
				value: function(t, e) {
					return new Promise((function(n, r) {
						var i = {};
						i[t] = e, chrome.storage.sync.set(i, (function() {
							if (chrome.runtime.lastError) return r(chrome.runtime.lastError);
							n(e)
						}))
					}))
				}
			}, {
				key: "setAllStorage",
				value: function() {
					var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
					return new Promise((function(e, n) {
						chrome.storage.sync.set(t, (function() {
							if (chrome.runtime.lastError) return n(chrome.runtime.lastError);
							e(!0)
						}))
					}))
				}
			}], null && rp(e.prototype, null), n && rp(e, n), Object.defineProperty(e, "prototype", {
				writable: !1
			}), t
		}();

		function op(t) {
			if (/^#/.test(t)) return t;
			var e = t.match(/(\d|\.)+/g),
				n = e.slice(0, 3).reduce((function(t, e) {
					var n = parseInt(e).toString(16);
					return t + (n.length < 2 ? "0" + n : n)
				}), "#"),
				r = e[3] ? parseInt(255 * e[3]).toString(16) : "";
			return n + (r.length < 2 ? "0" + r : r)
		}
		var ap = n(563);

		function sp(t, e) {
			var n = Object.keys(t);
			if (Object.getOwnPropertySymbols) {
				var r = Object.getOwnPropertySymbols(t);
				e && (r = r.filter((function(e) {
					return Object.getOwnPropertyDescriptor(t, e).enumerable
				}))), n.push.apply(n, r)
			}
			return n
		}

		function lp(t) {
			for (var e = 1; e < arguments.length; e++) {
				var n = null != arguments[e] ? arguments[e] : {};
				e % 2 ? sp(Object(n), !0).forEach((function(e) {
					Co(t, e, n[e])
				})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sp(Object(n)).forEach((function(e) {
					Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
				}))
			}
			return t
		}
		var cp = !1,
			up = !1,
			hp = "#FF0000",
			fp = 10,
			dp = "fillRect",
			pp = "Roboto",
			gp = "",
			vp = null;
		window.rate = 1;
		var mp, yp, bp, xp, wp, Cp, Sp, Op, Tp, kp, Fp, Pp, jp = null,
			Ap = null,
			_p = {
				x: 0,
				y: 0
			},
			Ep = {
				hasControls: !0
			};

 
     // Dp_multi function to initialize the canvas and handle drawing
    function Dp_multi(t, e, n) {
        let jp = t;
        let Ap = new fabric.Canvas(t, {
            containerClass: "c-pointer-container",
            height: e / devicePixelRatio,
            width: n / devicePixelRatio,
            selectionBorderColor: "#F00",
            selection: false,
            controlsAboveOverlay: true
        });
        fabric.Object.prototype.canvas = Ap;

        let isAddingPoints = false;
        let isDraggingControlPoint = false;
        let isMovingObject = false;
        let lastPos = null;
        let kp = null;
        let tempLine = null;
        let tempPoints = [];
        let pointToMove = null;
        let cp = true;
        let dp = null; // Equivalent to squareType
        let hp = null; // Color
        let fp = null; // Stroke width

        function resetDrawingState() {
            isAddingPoints = false;
            isDraggingControlPoint = false;
            isMovingObject = false;
            lastPos = null;
            pointToMove = null;
            if (tempLine) {
                Ap.remove(tempLine);
                tempLine = null;
            }
            tempPoints.forEach(point => Ap.remove(point));
            tempPoints = [];
            kp = null;
            Ap.renderAll();
        }

        function isMouseOverPoint(point, pointer) {
            const posRadius = 10;
            const dx = pointer.x - point.x;
            const dy = pointer.y - point.y;
            return (dx * dx + dy * dy < posRadius * posRadius);
        }

        function Ip(t) {
            let _p = Ap.getPointer(t.e);
            cp = true;

            // Check if we're interacting with an existing object (e.g., dragging control points)
            const activeObject = Ap.getActiveObject();
            if (activeObject && activeObject.type === "arrowStyleMulti") {
                let controlPointClicked = false;
                for (let controlName in activeObject.controls) {
                    const control = activeObject.controls[controlName];
                    const controlPos = control.positionHandler({}, null, activeObject);
                    const controlSize = control.size || 16;
                    if (
                        Math.abs(controlPos.x - _p.x) < controlSize / 2 &&
                        Math.abs(controlPos.y - _p.y) < controlSize / 2
                    ) {
                        controlPointClicked = true;
                        isDraggingControlPoint = true;
                        break;
                    }
                }
                if (!controlPointClicked && !isAddingPoints) {
                    isMovingObject = true;
                    lastPos = { x: _p.x, y: _p.y };
                    return;
                }
            }

            // If we're in drawing mode, check if we're dragging an existing point
            if (isAddingPoints && kp && kp.type === "arrowStyleMulti") {
                pointToMove = null;
                kp.points.forEach((point, index) => {
                    if (isMouseOverPoint(point, _p)) {
                        pointToMove = index;
                    }
                });
                if (pointToMove !== null) {
                    return; // Allow dragging the point
                }
                // If not clicking on a point, finalize the drawing
                kp.finishDrawing();
                Ap.setActiveObject(kp);
                Ap.renderAll();
                resetDrawingState();
                return;
            }

            // Start a new arrow only if we're not already drawing
            if (!isAddingPoints && !isDraggingControlPoint && !isMovingObject) {
                if (dp === "arrow_style_multi") {
                    isAddingPoints = true;
                    const baseX = _p.x;
                    const baseY = _p.y;
                    kp = new fabric.ArrowStyleMulti([
                        { x: baseX, y: baseY }, // Point 0: Start of the arrow
                        { x: baseX + 40, y: baseY + 170 }, // Point 1: Control point
                        { x: baseX + 95, y: baseY + 265 }, // Point 2: Control point
                        { x: baseX + 320, y: baseY + 320 } // Point 3: End of the arrow
                    ], {
                        type: "arrowStyleMulti",
                        fill: hp || null,
                        strokeWidth: fp || 3,
                        stroke: hp || "#000000",
                        strokeUniform: true,
                        originX: "center",
                        originY: "center",
                        cornerSize: fp || 3,
                        selectable: true
                    });
                    Ap.add(kp);
                    kp.canvas = Ap;
                    Ap.setActiveObject(kp);
                    Ap.renderAll();

                    // Initialize tempLine and tempPoints immediately
                    if (tempLine) Ap.remove(tempLine);
                    tempPoints.forEach(point => Ap.remove(point));
                    tempPoints = [];

                    const pathString = `M ${kp.points[0].x} ${kp.points[0].y} C ${kp.points[1].x} ${kp.points[1].y}, ${kp.points[2].x} ${kp.points[2].y}, ${kp.points[3].x} ${kp.points[3].y}`;
                    tempLine = new fabric.Path(pathString, {
                        stroke: hp || "#000000",
                        strokeWidth: fp || 3,
                        fill: '',
                        selectable: false,
                        strokeDashArray: [8, 15],
                        left: 0,
                        top: 0
                    });
                    Ap.add(tempLine);

                    kp.points.forEach(point => {
                        const circle = new fabric.Circle({
                            left: point.x,
                            top: point.y,
                            radius: 7,
                            fill: 'red',
                            selectable: false,
                            originX: 'center',
                            originY: 'center'
                        });
                        tempPoints.push(circle);
                        Ap.add(circle);
                    });

                    Ap.renderAll();
                }
            }
        }

        function Rp(t) {
            if (!cp) return;
            let _p = Ap.getPointer(t.e);

            const activeObject = Ap.getActiveObject();
            if (isMovingObject && activeObject) {
                const deltaX = _p.x - lastPos.x;
                const deltaY = _p.y - lastPos.y;
                activeObject.points.forEach(point => {
                    point.x += deltaX;
                    point.y += deltaY;
                });
                activeObject._calcDimensions();
                activeObject._calcArrow();
                lastPos = { x: _p.x, y: _p.y };
                activeObject.setCoords();
                Ap.renderAll();
                return;
            }

            if (isAddingPoints && kp && kp.type === "arrowStyleMulti" && pointToMove !== null) {
                // Validate points array
                if (!kp.points || kp.points.length !== 4) {
                    kp.points = [
                        { x: kp.points[0]?.x || 0, y: kp.points[0]?.y || 0 },
                        { x: kp.points[1]?.x || 0, y: kp.points[1]?.y || 0 },
                        { x: kp.points[2]?.x || 0, y: kp.points[2]?.y || 0 },
                        { x: kp.points[3]?.x || 0, y: kp.points[3]?.y || 0 }
                    ];
                }

                // Handle dragging based on which point is being moved
                if (pointToMove === 0 || pointToMove === 3) {
                    // Dragging start (point 0) or end (point 3): Resize the arrow
                    const anchorPoint = pointToMove === 0 ? 3 : 0; // Anchor is the opposite point
                    const anchorX = kp.points[anchorPoint].x;
                    const anchorY = kp.points[anchorPoint].y;

                    // Update the dragged point
                    kp.points[pointToMove] = { x: _p.x, y: _p.y };

                    // Calculate scaling factor based on the distance between anchor and dragged point
                    const originalDistance = Math.sqrt(
                        Math.pow(anchorX - kp.points[pointToMove].x, 2) +
                        Math.pow(anchorY - kp.points[pointToMove].y, 2)
                    );
                    const newDistance = Math.sqrt(
                        Math.pow(anchorX - _p.x, 2) +
                        Math.pow(anchorY - _p.y, 2)
                    );
                    const scale = newDistance / (originalDistance || 1);

                    // Scale the control points relative to the anchor point
                    for (let i = 1; i < 3; i++) {
                        const dx = (kp.points[i]?.x || 0) - anchorX;
                        const dy = (kp.points[i]?.y || 0) - anchorY;
                        kp.points[i] = {
                            x: anchorX + dx * scale,
                            y: anchorY + dy * scale
                        };
                    }
                } else {
                    // Dragging control points (1 or 2): Adjust the curve shape
                    kp.points[pointToMove] = { x: _p.x, y: _p.y };
                }

                // Validate points after modification
                kp.points = kp.points.map(point => ({
                    x: isFinite(point.x) ? point.x : 0,
                    y: isFinite(point.y) ? point.y : 0
                }));

                kp._calcDimensions();
                kp._calcArrow();
                kp.dirty = true;

                // Update tempLine and tempPoints
                if (tempLine) {
                    Ap.remove(tempLine);
                }
                tempPoints.forEach(point => Ap.remove(point));
                tempPoints = [];

                const pathString = `M ${kp.points[0].x} ${kp.points[0].y} C ${kp.points[1].x} ${kp.points[1].y}, ${kp.points[2].x} ${kp.points[2].y}, ${kp.points[3].x} ${kp.points[3].y}`;

                tempLine = new fabric.Path(pathString, {
                    stroke: hp || "#000000",
                    strokeWidth: fp || 3,
                    fill: '',
                    selectable: false,
                    strokeDashArray: [8, 15],
                    left: 0,
                    top: 0
                });
                Ap.add(tempLine);

                kp.points.forEach(point => {
                    const circle = new fabric.Circle({
                        left: point.x,
                        top: point.y,
                        radius: 7,
                        fill: 'red',
                        selectable: false,
                        originX: 'center',
                        originY: 'center'
                    });
                    tempPoints.push(circle);
                    Ap.add(circle);
                });

                Ap.renderAll();
                return;
            }
        }

        function Bp(t) {
            cp = false;
            isDraggingControlPoint = false;
            isMovingObject = false;
            lastPos = null;
            pointToMove = null;
        }

        function Np(t) {
            if (isAddingPoints && kp && kp.type === "arrowStyleMulti") {
                kp.finishDrawing();
                Ap.setActiveObject(kp);
                Ap.renderAll();
                resetDrawingState();
            }
        }

        Ap.on("mouse:down", Ip);
        Ap.on("mouse:move", Rp);
        Ap.on("mouse:up", Bp);
        Ap.on("mouse:dblclick", Np);

        return function(t) {
            let e = t.color,
                n = t.strokeWidth,
                r = t.squareType;

            fp = n;
            hp = e;
            dp = r;
            Ap.squareType = r;
            resetDrawingState();
        };
    }
 
 
 

function Dp(t, e, n) {
    jp = t;
    Ap = new Ao.fabric.Canvas(t, {
        containerClass: "c-pointer-container",
        height: e / devicePixelRatio,
        width: n / devicePixelRatio,
        selectionBorderColor: "#F00",
        selection: !1,
        controlsAboveOverlay: !0
    });
    Ao.fabric.Object.prototype.canvas = Ap;

    // Existing event listeners for mouse and canvas interactions
    Ap.on("mouse:down", Ip);
    Ap.on("mouse:move", Rp);
    Ap.on("mouse:up", Bp);
    Ap.on("mouse:dblclick", Np);
    Ap.on("selection:created", Up);
    Ap.on("selection:updated", Hp);
    Ap.on("selection:cleared", qp);
    Ap.on("history:append", Lp);
    Ap.on("history:undo", zp);
    Ap.on("history:redo", Wp);
    Ap.on("history:clear", Vp);

    // Add keyboard event listener for Delete and Backspace
    document.addEventListener('keydown', handleDeleteKey);

    // Define the keyboard event handler
    function handleDeleteKey(event) {
        if (event.key === 'Delete' || event.key === 'Backspace') {
            event.preventDefault(); // Prevent default behavior (e.g., browser navigation)
            const activeSelection = Ap.getActiveObject();
            if (activeSelection) {
                if (activeSelection.type === 'activeSelection') {
                    // Handle group selection: remove all objects in the group
                    activeSelection.getObjects().forEach(obj => Ap.remove(obj));
                    Ap.discardActiveObject();
                } else {
                    // Single object: remove the active object
                    Ap.remove(activeSelection);
                    Ap.discardActiveObject();
                }
                Ap.renderAll(); // Re-render the canvas
            }
        }
    }

    // Existing function for updating object properties   strokeWidth
    return function(t) {
        var e = t.color,
            n = t.strokeWidth,
            r = t.squareType,
            i = t.fontFamily,
            o = t.textbgColor,
            a = t.isTrusted;
        vp && !a ? (function(t, e, n) {
            hp = e;
            ["text"].some((function(e) {
                return e === t
            })) ? vp.set("fill", e) : "fillRect" === t ? (vp.set("fill", e), vp.set("stroke", e)) : "step" === t ? "#FFFFFF" === e ? (vp._objects[0].set("fill", e), vp._objects[0].set("stroke", "#000000")) : vp._objects[0].set("fill", e) : ["spray", "circle"].some((function(e) {
                return e === t
            })) ? vp._objects.forEach((function(t) {
                t.set("fill", e + op(t.fill).slice(-2))
            })) : "mosaic" === t ? (Kp(t), vp.stroke.source = Ap.freeDrawingBrush.getPatternSrc(), vp.set("strokeWidth", n - 1), vp.set("strokeWidth", n + 1)) : "mark" === t ? (Kp(t), vp.set("stroke", e + 44)) : (Kp(t), vp.set("stroke", e))
        }(r, e, n), function(t, e) {
            ["circle", "spray"].some((function(e) {
                return e === t
            })) || ("text" === t ? vp.set("fontSize", e) : vp.set("strokeWidth", e))
        }(r, n), "text" === r && (vp.set("textBackgroundColor", o), vp.set("backgroundColor", o), vp.set("fontFamily", i)), fp = n, hp = e, dp = r, pp = i, gp = o, Ap.squareType = r, vp.dirty && vp.canvas.fire("object:modified", {
            target: vp
        }), Ap.renderAll()) : (fp = n, hp = e, dp = r, pp = i, gp = o, Ap.squareType = r, Xp())
    };
}




     // Dp_multi function to initialize the canvas and handle drawing
     // Dp_multi function to initialize the canvas and handle drawing
    function Dp_multi(t, e, n) {
        let jp = t;
        let Ap = new fabric.Canvas(t, {
            containerClass: "c-pointer-container",
            height: e / devicePixelRatio,
            width: n / devicePixelRatio,
            selectionBorderColor: "#F00",
            selection: false,
            controlsAboveOverlay: true
        });
        fabric.Object.prototype.canvas = Ap;

        let isAddingPoints = false;
        let isDraggingControlPoint = false;
        let isMovingObject = false;
        let lastPos = null;
        let kp = null;
        let tempLine = null;
        let tempPoints = [];
        let pointToMove = null;

        function resetDrawingState() {
            isAddingPoints = false;
            isDraggingControlPoint = false;
            isMovingObject = false;
            lastPos = null;
            pointToMove = null;
            if (tempLine) {
                Ap.remove(tempLine);
                tempLine = null;
            }
            tempPoints.forEach(point => Ap.remove(point));
            tempPoints = [];
            kp = null;
            Ap.renderAll();
        }

        function isMouseOverPoint(point, pointer) {
            const posRadius = 10; // Increased radius for better click detection
            const dx = pointer.x - point.x;
            const dy = pointer.y - point.y;
            return (dx * dx + dy * dy < posRadius * posRadius);
        }

        function Ip(t) {
            let _p = Ap.getPointer(t.e);
            let cp = true;

            // Check if we're interacting with an existing object (e.g., dragging control points)
            const activeObject = Ap.getActiveObject();
            if (activeObject && activeObject.type === "arrowStyleMulti") {
                let controlPointClicked = false;
                for (let controlName in activeObject.controls) {
                    const control = activeObject.controls[controlName];
                    const controlPos = control.positionHandler({}, null, activeObject);
                    const controlSize = control.size || 16;
                    if (
                        Math.abs(controlPos.x - _p.x) < controlSize / 2 &&
                        Math.abs(controlPos.y - _p.y) < controlSize / 2
                    ) {
                        controlPointClicked = true;
                        isDraggingControlPoint = true;
                        break;
                    }
                }
                if (!controlPointClicked && !isAddingPoints) {
                    isMovingObject = true;
                    lastPos = { x: _p.x, y: _p.y };
                    return;
                }
            }

            // If we're in drawing mode, check if we're dragging an existing point
            if (isAddingPoints && kp && kp.type === "arrowStyleMulti") {
                pointToMove = null;
                kp.points.forEach((point, index) => {
                    if (isMouseOverPoint(point, _p)) {
                        pointToMove = index;
                    }
                });
                if (pointToMove !== null) {
                    return; // Allow dragging the point
                }
                // If not clicking on a point, finalize the drawing
                kp.finishDrawing();
                Ap.setActiveObject(kp);
                Ap.renderAll();
                resetDrawingState();
                return;
            }

            // Start a new arrow only if we're not already drawing
            if (!isAddingPoints && !isDraggingControlPoint && !isMovingObject) {
                if (dp === "arrow_style_multi") {
                    isAddingPoints = true;
                    const baseX = _p.x;
                    const baseY = _p.y;
                    kp = new fabric.ArrowStyleMulti([
                        { x: baseX, y: baseY }, // Point 0: Start of the arrow
                        { x: baseX + 40, y: baseY + 170 }, // Point 1: Control point
                        { x: baseX + 95, y: baseY + 265 }, // Point 2: Control point
                        { x: baseX + 320, y: baseY + 320 } // Point 3: End of the arrow
                    ], {
                        stroke: hp || "#000000",
                        strokeWidth: fp || 3,
                        selectable: true
                    });
                    Ap.add(kp);
                    kp.canvas = Ap;
                    Ap.setActiveObject(kp);
                    Ap.renderAll();

                    // Initialize tempLine and tempPoints immediately
                    if (tempLine) Ap.remove(tempLine);
                    tempPoints.forEach(point => Ap.remove(point));
                    tempPoints = [];

                    const pathString = `M ${kp.points[0].x} ${kp.points[0].y} C ${kp.points[1].x} ${kp.points[1].y}, ${kp.points[2].x} ${kp.points[2].y}, ${kp.points[3].x} ${kp.points[3].y}`;
                    tempLine = new fabric.Path(pathString, {
                        stroke: hp || "#000000",
                        strokeWidth: fp || 3,
                        fill: '',
                        selectable: false,
                        strokeDashArray: [8, 15],
                        left: 0,
                        top: 0
                    });
                    Ap.add(tempLine);

                    kp.points.forEach(point => {
                        const circle = new fabric.Circle({
                            left: point.x,
                            top: point.y,
                            radius: 7,
                            fill: 'red',
                            selectable: false,
                            originX: 'center',
                            originY: 'center'
                        });
                        tempPoints.push(circle);
                        Ap.add(circle);
                    });

                    Ap.renderAll();
                }
            }
        }

        function Rp(t) {
            if (!cp) return;
            let _p = Ap.getPointer(t.e);

            const activeObject = Ap.getActiveObject();
            if (isMovingObject && activeObject) {
                const deltaX = _p.x - lastPos.x;
                const deltaY = _p.y - lastPos.y;
                activeObject.points.forEach(point => {
                    point.x += deltaX;
                    point.y += deltaY;
                });
                activeObject._calcDimensions();
                activeObject._calcArrow();
                lastPos = { x: _p.x, y: _p.y };
                activeObject.setCoords();
                Ap.renderAll();
                return;
            }

            if (isAddingPoints && kp && kp.type === "arrowStyleMulti" && pointToMove !== null) {
                // Validate points array
                if (!kp.points || kp.points.length !== 4) {
                    kp.points = [
                        { x: kp.points[0]?.x || 0, y: kp.points[0]?.y || 0 },
                        { x: kp.points[1]?.x || 0, y: kp.points[1]?.y || 0 },
                        { x: kp.points[2]?.x || 0, y: kp.points[2]?.y || 0 },
                        { x: kp.points[3]?.x || 0, y: kp.points[3]?.y || 0 }
                    ];
                }

                // Handle dragging based on which point is being moved
                if (pointToMove === 0 || pointToMove === 3) {
                    // Dragging start (point 0) or end (point 3): Resize the arrow
                    const anchorPoint = pointToMove === 0 ? 3 : 0; // Anchor is the opposite point
                    const anchorX = kp.points[anchorPoint].x;
                    const anchorY = kp.points[anchorPoint].y;

                    // Update the dragged point
                    kp.points[pointToMove] = { x: _p.x, y: _p.y };

                    // Calculate scaling factor based on the distance between anchor and dragged point
                    const originalDistance = Math.sqrt(
                        Math.pow(anchorX - kp.points[pointToMove].x, 2) +
                        Math.pow(anchorY - kp.points[pointToMove].y, 2)
                    );
                    const newDistance = Math.sqrt(
                        Math.pow(anchorX - _p.x, 2) +
                        Math.pow(anchorY - _p.y, 2)
                    );
                    const scale = newDistance / (originalDistance || 1);

                    // Scale the control points relative to the anchor point
                    for (let i = 1; i < 3; i++) {
                        const dx = (kp.points[i]?.x || 0) - anchorX;
                        const dy = (kp.points[i]?.y || 0) - anchorY;
                        kp.points[i] = {
                            x: anchorX + dx * scale,
                            y: anchorY + dy * scale
                        };
                    }
                } else {
                    // Dragging control points (1 or 2): Adjust the curve shape
                    kp.points[pointToMove] = { x: _p.x, y: _p.y };
                }

                // Validate points after modification
                kp.points = kp.points.map(point => ({
                    x: isFinite(point.x) ? point.x : 0,
                    y: isFinite(point.y) ? point.y : 0
                }));

                kp._calcDimensions();
                kp._calcArrow();
                kp.dirty = true;

                // Update tempLine and tempPoints
                if (tempLine) {
                    Ap.remove(tempLine);
                }
                tempPoints.forEach(point => Ap.remove(point));
                tempPoints = [];

                const pathString = `M ${kp.points[0].x} ${kp.points[0].y} C ${kp.points[1].x} ${kp.points[1].y}, ${kp.points[2].x} ${kp.points[2].y}, ${kp.points[3].x} ${kp.points[3].y}`;

                tempLine = new fabric.Path(pathString, {
                    stroke: hp || "#000000",
                    strokeWidth: fp || 3,
                    fill: '',
                    selectable: false,
                    strokeDashArray: [8, 15],
                    left: 0,
                    top: 0
                });
                Ap.add(tempLine);

                kp.points.forEach(point => {
                    const circle = new fabric.Circle({
                        left: point.x,
                        top: point.y,
                        radius: 7,
                        fill: 'red',
                        selectable: false,
                        originX: 'center',
                        originY: 'center'
                    });
                    tempPoints.push(circle);
                    Ap.add(circle);
                });

                Ap.renderAll();
                return;
            }
        }

        function Bp(t) {
            cp = false;
            isDraggingControlPoint = false;
            isMovingObject = false;
            lastPos = null;
            pointToMove = null;
        }

        function Np(t) {
            if (isAddingPoints && kp && kp.type === "arrowStyleMulti") {
                kp.finishDrawing();
                Ap.setActiveObject(kp);
                Ap.renderAll();
                resetDrawingState();
            }
        }

        Ap.on("mouse:down", Ip);
        Ap.on("mouse:move", Rp);
        Ap.on("mouse:up", Bp);
        Ap.on("mouse:dblclick", Np);

        return function(t) {
            let e = t.color,
                n = t.strokeWidth,
                r = t.squareType;

            fp = n;
            hp = e;
            dp = r;
            Ap.squareType = r;
            resetDrawingState();
        };
    }












		function Mp(t) {
			up = t, t ? Xp() : (Ap.defaultCursor = "default", Ap.isDrawingMode = !1)
		}

		function Ip(t) {
			if (up && !t.target) {
				var e = Ap.getPointer(t.e);
				Ap.discardActiveObject(), cp = !0, _p.x = e.x, _p.y = e.y,
					function() {
						switch (dp) {
							case "text":
								! function() {
									if (Pp) return "" == Pp.text && Ap.remove(Pp), Ap.renderAll(), void(Pp = null);
									Pp = new Ao.fabric.Textbox("", {
										fill: hp,
										left: _p.x,
										top: _p.y,
										caching: !1,
										strokeUniform: !0,
										editable: !0,
										selectable: !0,
										textBackgroundColor: gp,
										backgroundColor: gp,
										hasControls: !0,
										borderDashArray: [3, 3],
										borderColor: "#CCCCCC",
										padding: 5,
										fontSize: fp,
										fontFamily: pp
									}), Ap.add(Pp), Ap.setActiveObject(Pp), Pp.enterEditing(), Pp.hiddenTextarea.focus(), Pp.on("changed", Zp)
								}();
								break;
							case "step":
								! function() {
									Jp > 1e3 && (Jp = 1);
									var t = new Ao.fabric.Textbox(String(Jp++), {
											fill: "#ffffff" === hp.toLocaleLowerCase() ? "black" : "white",
											left: _p.x,
											top: _p.y + 1,
											hasControls: !1,
											fontSize: 40 * Math.pow(.82, Math.floor(Math.log10(Jp)) + 1),
											fontFamily: "Roboto",
											strokeUniform: !1,
											originX: "center",
											originY: "center",
											editable: !1,
											selectable: !1
										}),
										e = new Ao.fabric.Circle({
											left: _p.x,
											top: _p.y,
											radius: 22,
											fill: hp,
											stroke: "white",
											originX: "center",
											originY: "center",
											shadow: new Ao.fabric.Shadow({
												color: "#333333",
												blur: 4,
												offsetY: 1
											}),
											strokeWidth: 4,
											strokeUniform: !1
										}),
										n = new Ao.fabric.Group([e, t], {
											hasControls: !0
										});
									Ap.add(n), Ap.setActiveObject(n)
								}()
						}
					}()
			}
		}

		function Rp(t) {
			if (cp && up) {
				var e = Ap.getPointer(t.e);
				(Math.abs(_p.x - e.x) > 3 || Math.abs(_p.y - e.y) > 3) && function() {
					switch ((0, _o.publish)("activeObjectChange", dp), Ap.defaultCursor = "default", dp) {
						case "fillRect":
							Op || (Op = new Ao.fabric.Rect(lp({
								width: 1,
								height: 1,
								left: _p.x,
								top: _p.y,
								stroke: hp,
								strokeWidth: fp,
								fill: hp,
								strokeUniform: !0,
								cornerSize: fp
							}, Ep)), Ap.add(Op), Ap.setActiveObject(Op));
							break;
						case "strokeRect":
							Cp || (Cp = new Ao.fabric.Rect(lp({
								width: 1,
								height: 1,
								left: _p.x,
								top: _p.y,
								stroke: hp,
								strokeWidth: fp,
								strokeUniform: !0,
								fill: "transparent",
								cornerSize: fp
							}, Ep)), Ap.add(Cp), Ap.setActiveObject(Cp));
							break;
						case "strokeEllipse":
							Sp || (Sp = new Ao.fabric.Ellipse(lp({
								rx: 1,
								ry: 1,
								left: _p.x,
								top: _p.y,
								stroke: hp,
								strokeWidth: fp,
								strokeUniform: !0,
								fill: "transparent",
								cornerSize: fp
							}, Ep)), Ap.add(Sp), Ap.setActiveObject(Sp));
							break;
						case "line":
							! function() {
								if (!Tp) {
									var t = Ao.fabric.Line.prototype.controls;
									t.bl.touchSizeX = t.bl.touchSizeY = fp / 2, t.tr.touchSizeX = t.tr.touchSizeY = fp / 2, (Tp = new Ao.fabric.Line([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
										fill: hp,
										strokeWidth: fp,
										stroke: hp,
										strokeUniform: !0,
										originX: "center",
										originY: "center",
										cornerSize: fp
									}, Ep))).dirty = !1, Ap.add(Tp), Ap.setActiveObject(Tp)
								}
							}();
							break;
						case "arrow":
							kp || (kp = new Ao.fabric.Arrow([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
								type: "arrow",
								fill: hp,
								strokeWidth: fp,
								stroke: hp,
								strokeUniform: !0,
								originX: "center",
								originY: "center",
								cornerSize: fp
							}, Ep)), Ap.add(kp), Ap.setActiveObject(kp))
					
						break;
case "arrow_style2":
    kp || (kp = new Ao.fabric.ArrowStyle2([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle2",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;
case "arrow_style3":
    kp || (kp = new Ao.fabric.ArrowStyle3([{
        x: _p.x,
        y: _p.y
    }, {
        x: _p.x + 1,
        y: _p.y + 1
    }], lp({
        type: "arrowStyle3",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;
case "arrow_style4":
    kp || (kp = new Ao.fabric.ArrowStyle4([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle4",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;
 
 case "arrow_style5":
    kp || (kp = new Ao.fabric.ArrowStyle5([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle5",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;
 
 
  case "arrow_style6":
    kp || (kp = new Ao.fabric.ArrowStyle6([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle6",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;
 
  case "arrow_style7":
    kp || (kp = new Ao.fabric.ArrowStyle7([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle7",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
  case "arrow_style8":
    kp || (kp = new Ao.fabric.ArrowStyle8([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle8",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
	
  case "arrow_style9":
    kp || (kp = new Ao.fabric.ArrowStyle9([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle9",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
	
	  case "arrow_style10":
    kp || (kp = new Ao.fabric.ArrowStyle10([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle10",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
	
	  case "arrow_style11":
    kp || (kp = new Ao.fabric.ArrowStyle11([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle11",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
		  case "arrow_style12":
    kp || (kp = new Ao.fabric.ArrowStyle12([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle12",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
	
	  case "arrow_style13":
    kp || (kp = new Ao.fabric.ArrowStyle13([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle13",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
	
	
	  case "arrow_style14":
    kp || (kp = new Ao.fabric.ArrowStyle14([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle14",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;			
	
	  case "arrow_style15":
    kp || (kp = new Ao.fabric.ArrowStyle15([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle15",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
	
	
  case "arrow_style16":
    kp || (kp = new Ao.fabric.ArrowStyle16([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle16",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	

  case "arrow_style17":
    kp || (kp = new Ao.fabric.ArrowStyle17([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle17",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
	
	
  case "arrow_style18":
    kp || (kp = new Ao.fabric.ArrowStyle18([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle18",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
	
  case "arrow_style19":
    kp || (kp = new Ao.fabric.ArrowStyle19([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle19",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;		
	
	
  case "arrow_style20":
    kp || (kp = new Ao.fabric.ArrowStyle20([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle20",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
	
  case "arrow_style21":
    kp || (kp = new Ao.fabric.ArrowStyle21([_p.x, _p.y, _p.x + 1, _p.y + 1], lp({
        type: "arrowStyle21",
        fill: hp,
        strokeWidth: fp,
        stroke: hp,
        strokeUniform: !0,
        originX: "center",
        originY: "center",
        cornerSize: fp
    }, Ep)), Ap.add(kp), Ap.setActiveObject(kp));
    break;	
		
	
	
	
	case "arrow_style_multi":
    if (!kp) {
        kp = new Ao.fabric.ArrowStyleMulti([{
            x: _p.x,
            y: _p.y
        }, {
            x: _p.x + 1,
            y: _p.y + 1
        }], lp({
            type: "arrowStyleMulti",
            fill: hp,
            strokeWidth: fp,
            stroke: hp,
            strokeUniform: !0,
            originX: "center",
            originY: "center",
            cornerSize: fp
        }, Ep));
        Ap.add(kp);
        Ap.setActiveObject(kp);
     //   isAddingPoints = true; // Set the flag
    }
    break;					
							
							
					}
				}();
				
				var n = Ap.getActiveObject();
				if (n && "textbox" !== n.type) {
					switch (_p.x > e.x && n.set({
							left: e.x
						}), _p.y > e.y && n.set({
							top: e.y
						}), n.type) {
						case "rect":
							n.set({
								width: Math.abs(_p.x - e.x)
							}), n.set({
								height: Math.abs(_p.y - e.y)
							});
							break;
						case "ellipse":
							n.set({
								rx: Math.abs(_p.x - e.x) / 2
							}), n.set({
								ry: Math.abs(_p.y - e.y) / 2
							});
							break;
						case "line":
						case "arrow":
							n.set({
								x2: e.x,
								y2: e.y
							}), n.dirty = !1
							case "arrowStyle2":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
 		case "arrowStyle3":
    if (n.points && n.points.length >= 2) {
        n.points[n.points.length - 1] = {
            x: e.x,
            y: e.y
        };
        n.set({
            x2: e.x,
            y2: e.y
        });
        n.dirty = !1;
    }
    break;
	case "arrowStyle4":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle5":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle6":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle7":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle8":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle9":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;
	case "arrowStyle10":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle11":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle12":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle13":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle14":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle15":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle16":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle17":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;


	case "arrowStyle18":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;

	case "arrowStyle19":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;
	case "arrowStyle20":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;


	case "arrowStyle21":
							n.set({
							x2: e.x,
							y2: e.y
							});
							n.dirty = !1;
	
	    break;


case "arrowStyleMulti":
    if (n.points && n.points.length >= 2) {
        n.points[n.points.length - 1] = {
            x: e.x,
            y: e.y
        };
        n.set({
            x2: e.x,
            y2: e.y
        });
        n.dirty = !1;
    }
    break;					
							
							
					}
					Ap.renderAll()
				}
			}
		}

		function Bp(t) {
			up && (t.transform || Ap.fire("object:added", {
				target: vp,
				h: 1
			}), mp = yp = bp = xp = wp = null, Cp = Sp = Op = Tp = kp = null, _p = {
				x: 0,
				y: 0
			}, cp = !1)
		}

		function Np(t) {
			up && t.target && "textbox" === t.target.type && (Pp = t.target)
		}

		function Lp(t) {
			(0, _o.publish)("abledClear", !1)
		}

		function zp(t) {
			"clipper" === t.type && (ap(".clipper").css({
				height: t.clipper.height,
				width: t.clipper.width
			}), ap("#image_canvas").css({
				left: t.canvas.left,
				top: t.canvas.top
			}), ap(".c-pointer-container").css({
				left: t.canvas.left,
				top: t.canvas.top
			}))
		}

		function Wp(t) {
			"clipper" === t.type && (ap(".clipper").css({
				height: t.clipper.rheight,
				width: t.clipper.rwidth
			}), ap("#image_canvas").css({
				left: t.canvas.rleft,
				top: t.canvas.rtop
			}), ap(".c-pointer-container").css({
				left: t.canvas.rleft,
				top: t.canvas.rtop
			}))
		}

		function Vp(t) {
			(0, _o.publish)("abledClear", !0), (0, _o.publish)("abledDelSel", !0), (0, _o.publish)("abledUndo", !0), (0, _o.publish)("abledRedo", !0)
		}

		function Up(t) {
			t.selected.forEach((function(t) {
				return t.shadow = new Ao.fabric.Shadow({
					color: "#333333",
					blur: 5,
					offsetY: 1
				}), vp = t, (0, _o.publish)("activeObjectChange", Qp(t)), (0, _o.publish)("abledDelSel", !1)
			})), Ap.renderAll()
		}

		function Hp(t) {
			t.selected.forEach((function(t) {
				return t.shadow = new Ao.fabric.Shadow({
					color: "#333333",
					blur: 5,
					offsetY: 1
				}), vp = t, (0, _o.publish)("activeObjectChange", Qp(t)), (0, _o.publish)("abledDelSel", !1)
			})), t.deselected.forEach((function(t) {
				return t.shadow = null
			})), Ap.renderAll()
		}

		function qp(t) {
			t.deselected && t.deselected.forEach((function(t) {
				return t.shadow = null, vp = null
			})), Ap.renderAll()
		}

		function Xp() {
			switch ((0, _o.publish)("activeObjectChange", dp), Pp && (Pp.exitEditing(), Pp = null), Ap.defaultCursor = "default", dp) {
				case "paint":
					! function() {
						if (!mp || mp.width !== fp) {
							Ap.isDrawingMode = !0, Ap.freeDrawingBrush = new Ao.fabric.PencilBrush(Ap);
							var t = Ap.freeDrawingBrush;
							t.color = hp, t.width = fp, mp = t
						}
					}();
					break;
				case "mark":
					! function() {
						if (!yp || yp.width !== fp) {
							Ap.isDrawingMode = !0, Ap.freeDrawingBrush = new Ao.fabric.PencilBrush(Ap);
							var t = Ap.freeDrawingBrush;
							t.color = hp + "44", t.width = fp, yp = t
						}
					}();
					break;
				case "mosaic":
					! function() {
						if (!bp || bp.width !== fp) {
							Ap.isDrawingMode = !0;
							var t = Gp();
							Ap.freeDrawingBrush = t, Ap.freeDrawingBrush.color = hp, Ap.freeDrawingBrush.width = fp, Ap.freeDrawingBrush.source = Ap.freeDrawingBrush.getPatternSrc(), bp = t
						}
					}();
					break;
				case "spray":
					! function() {
						if (!xp) {
							Ap.isDrawingMode = !0;
							var t = new Ao.fabric.SprayBrush(Ap);
							Ap.freeDrawingBrush = t, Ap.freeDrawingBrush.color = hp, Ap.freeDrawingBrush.width = fp, xp = t
						}
					}();
					break;
				case "circle":
					! function() {
						if (!wp || wp.width !== fp) {
							Ap.isDrawingMode = !0;
							var t = new Ao.fabric.CircleBrush(Ap);
							Ap.freeDrawingBrush = t, Ap.freeDrawingBrush.color = hp, Ap.freeDrawingBrush.width = fp, wp = t
						}
					}();
					break;
				case "text":
					Ap.isDrawingMode = !1, Ap.defaultCursor = "text";
					break;
				default:
					Ap.isDrawingMode = !1
			}
		}

		function Gp() {
			var t = new Ao.fabric.PatternBrush(Ap);
			return t.getPatternSrc = function() {
				var t = Ao.fabric.document.createElement("canvas");
				t.width = t.height = fp;
				var e = t.getContext("2d"),
					n = fp / 2;
				return e.fillStyle = hp, e.beginPath(), e.rect(0, 0, n, n), e.rect(n, n, n, n), e.closePath(), e.fill(), e.beginPath(), e.fillStyle = "#fff", e.rect(0, n, n, n), e.rect(n, 0, n, n), e.closePath(), e.fill(), t
			}, t
		}

		function Kp(t) {
			if ("circle" === t) {
				var e = new Ao.fabric.CircleBrush(Ap);
				Ap.freeDrawingBrush = e, Ap.freeDrawingBrush.color = hp, Ap.freeDrawingBrush.width = fp, wp = e
			} else if ("mosaic" === t) {
				var n = Gp();
				Ap.freeDrawingBrush = n, Ap.freeDrawingBrush.color = hp, Ap.freeDrawingBrush.width = fp, Ap.freeDrawingBrush.source = Ap.freeDrawingBrush.getPatternSrc(), bp = n
			} else {
				Ap.freeDrawingBrush = new Ao.fabric.PencilBrush(Ap);
				var r = Ap.freeDrawingBrush;
				r.color = "mark" === t ? hp + "44" : hp, r.width = fp, mp = r
			}
		}
		Ao.fabric.Canvas.prototype._checkTarget = function(t, e, n) {
			var r = this;
			if (e && e.visible && e.evented && !cp && e.containsPoint(t)) {
				if (this._activeObject && "textbox" === this._activeObject.type) return !0;
				try {
					var i = this.isTargetTransparent(e, n.x, n.y);
					return i && ["paint", "mark", "mosaic", "spray", "circle"].some((function(t) {
						return t === r.squareType
					})) ? this.isDrawingMode = !0 : this.isDrawingMode = !1, !i
				} catch (t) {}
			} else ["paint", "mark", "mosaic", "spray", "circle"].some((function(t) {
				return t === r.squareType
			})) && (this.isDrawingMode = !0)
		};
		var Yp, Zp = function() {
				this.__allLineWidths = [].slice.call(lp(lp(lp({}, this.__allLineWidths || []), this.__lineWidths), {}, {
					length: this.__lineWidths.length
				}));
				var t, e = this.scaleX * this.width,
					n = (Math.max.apply(Math, function(t) {
						if (Array.isArray(t)) return Po(t)
					}(t = this.__allLineWidths) || function(t) {
						if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
					}(t) || jo(t) || function() {
						throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
					}()) + 15) * this.scaleX;
				this.set("width", n), this.left + e >= this.width - 10 && this.set("width", this.width - this.left - 10), Ap.renderAll()
			},
			Jp = 1;

		function Qp(t) {
			if (t) {
				var e = t.type,
					n = "#ff0000",
					r = 8,
					i = void 0,
					o = void 0;
				switch (t.type) {
					case "group":
						e = "rect" === t._objects[0].type ? "spray" : "circle" === t._objects[1].type ? "circle" : "step", n = op(t._objects[0].fill).slice(0, 7), r = 8, "circle" === e && (hp = n || "#FF0000", fp = r, dp = e, Kp(e));
						break;
					case "path":
						n = "mosaic" == (e = "string" == typeof t.stroke ? 7 === t.stroke.length ? "paint" : "mark" : "mosaic") ? null : "paint" === e ? t.stroke : t.stroke.slice(0, 7), r = t.strokeWidth, hp = n || "#FF0000", fp = r, dp = e, Kp(e);
						break;
					case "textbox":
						e = "text", n = t.fill, r = t.fontSize, i = op(t.backgroundColor), o = t.fontFamily;
						break;
					case "rect":
						e = "transparent" === t.fill ? "strokeRect" : "fillRect", n = t.stroke, r = t.strokeWidth;
						break;
					case "ellipse":
						e = "strokeEllipse", n = t.stroke, r = t.strokeWidth;
						break;
					default:
						n = "step" === (e = t.type) ? t._objects[0].fill : t.stroke, r = "step" === e ? 40 : t.strokeWidth
				}
				return [e, n, r, i, o]
			}
		}

		function $p(t, e) {
			var n = document.createElement("canvas"),
				r = ap("#image_canvas"),
				i = ap(".clipper"),
				o = Math.abs(parseInt(r.css("left"))) * devicePixelRatio / rate,
				a = Math.abs(parseInt(r.css("top"))) * devicePixelRatio / rate,
				s = parseInt(i.css("height")) * devicePixelRatio / rate,
				l = parseInt(i.css("width")) * devicePixelRatio / rate;
			n.height = s, n.width = l;
			var c = n.getContext("2d");
			return c.drawImage(t, o, a, l, s, 0, 0, l, s), c.drawImage(e, o, a, l, s, 0, 0, l, s), n
		}(0, _o.subscribe)("addemojObject", (function(t, e) {
			var n = ap(".c-pointer-container");
			Fp = new Ao.fabric.Image(e, {
				left: 20 - parseInt(n.css("left")) / rate,
				top: 20 - parseInt(n.css("top")) / rate,
				originX: "left",
				originY: "top",
				hasControls: !0
			}), Ap.add(Fp), Ap.setActiveObject(Fp)
		})), (0, _o.subscribe)("discardActiveObject", (function() {
			(0, _o.publish)("abledDelSel", !0), Ap.discardActiveObject().renderAll()
		})), (0, _o.subscribe)("forward", (function(t) {
			Ap.redo()
		})), (0, _o.subscribe)("back", (function(t) {
			vp && "textbox" === vp.type && vp.exitEditing(), Ap.undo()
		})), (0, _o.subscribe)("clear-all", (function(t) {
			Ap.clear(), Ap.clearHistory(), Jp = 1
		})), (0, _o.subscribe)("delete-selected", (function(t) {
			(0, _o.publish)("abledDelSel", !0), Ap.remove(Ap.getActiveObject()), vp = null
		})), (0, _o.subscribe)("cropper", (function(t, e) {
			var n = e.lt,
				r = e.rb,
				i = ap("#image_canvas"),
				o = ap(".clipper"),
				a = parseInt(i.css("left")),
				s = parseInt(i.css("top")),
				l = n.x,
				c = n.y,
				u = r.y - n.y,
				h = r.x - n.x,
				f = {
					target: {
						type: "clipper",
						clipper: {
							height: o.height() / rate,
							width: o.width() / rate,
							rheight: u / rate,
							rwidth: h / rate
						},
						canvas: {
							left: a,
							top: s,
							rleft: a - l,
							rtop: s - c
						},
						state: JSON.parse(Ap.historyNextState || "[]")
					}
				};
			Ap.fire("object:added", f), o.css({
				height: u,
				width: h
			}), o.data("height", u / rate).data("width", h / rate), ap("#image_canvas").data("left", (a - l) / rate).data("top", (s - c) / rate), ap("#image_canvas").css({
				left: a - l,
				top: s - c
			}), ap(".c-pointer-container").css({
				left: a - l,
				top: s - c
			})
		})), (0, _o.subscribe)("download", (function(t, e) {
			ip.getStorage("saveImageType").then((function(t) {
				(0, _o.publish)("abledDelSel", !0), Ap.discardActiveObject().renderAll(), chrome.runtime.sendMessage({
					type: "screen_download",
					data: $p(e, jp).toDataURL(t),
					suffix: "image/png" === t ? "png" : "jpg"
				})
			}))
		})), (0, _o.subscribe)("copy", (function(t, e) {
			var n = e.imgCanvas,
				r = e.callback;
			(0, _o.publish)("abledDelSel", !0), Ap.discardActiveObject().renderAll(), $p(n, jp).toBlob(function() {
				var t = bo(Oo().mark((function t(e) {
					var n;
					return Oo().wrap((function(t) {
						for (;;) switch (t.prev = t.next) {
							case 0:
								return n = [new ClipboardItem(Co({}, e.type, e))], t.next = 3, navigator.clipboard.write(n).then((function() {
									console.log("Copied to clipboard successfully!"), r()
								}), (function() {
									console.error("Unable to write to clipboard.")
								}));
							case 3:
							case "end":
								return t.stop()
						}
					}), t)
				})));
				return function(e) {
					return t.apply(this, arguments)
				}
			}())
		})),


		(0, _o.subscribe)("savePDF", (function(t, e) {
			(0, _o.publish)("abledDelSel", !0), Ap.discardActiveObject().renderAll();
			var n = $p(e, jp).toDataURL("image/png", 1),
				r = new Image;
			r.onload = bo(Oo().mark((function t() {
				var e, r, i, o, a, s, l, c, u, h;
				return Oo().wrap((function(t) {
					for (;;) switch (t.prev = t.next) {
						case 0:
							return t.next = 2, zd.create();
						case 2:
							for (e = t.sent, r = e.addPage([this.width / devicePixelRatio, this.height / devicePixelRatio]), i = atob(n.split(",")[1]), o = new Uint8Array(i.length), a = 0; a < i.length; a++) o[a] = i.charCodeAt(a);
							return t.next = 9, e.embedPng(o);
						case 9:
							return s = t.sent, r.drawImage(s, {
								x: 0,
								y: 0,
								width: this.width / devicePixelRatio,
								height: this.height / devicePixelRatio
							}), t.next = 13, e.save();
						case 13:
							l = t.sent, c = new Blob([l], {
								type: "application/pdf"
							}), u = URL.createObjectURL(c), (h = document.createElement("a")).href = u, h.download = "".concat(Date.now(), ".pdf"), h.click();
						case 20:
						case "end":
							return t.stop()
					}
				}), t, this)
			}))), r.src = n
		})),

		(0, _o.subscribe)("uploadImage", function(t, e) {
			// Safely get the upload button element with null checks
			const uploadButton = document.querySelector('.el-button.el-button--warningyyy .el-button__content') ||
				document.querySelector('.el-button--warningyyy span');

			if (!uploadButton) {
				console.error("Upload button not found");
				return;
			}

			// Store original button state
			const originalHTML = uploadButton.innerHTML;
			const originalClass = uploadButton.className;
			const originalStyle = uploadButton.style.cssText;

			// Update button appearance
			uploadButton.style.backgroundColor = '#000';
			uploadButton.style.color = '#fff';
			uploadButton.style.padding = '0 10px';
			uploadButton.textContent = 'Preparing image...';

			// Enable delete/selection (if needed)
			(0, _o.publish)("abledDelSel", true);

			// Discard active objects and render canvas
			Ap.discardActiveObject().renderAll();

			// Get canvas data URL (PNG format)
			const imageDataUrl = $p(e, jp).toDataURL("image/png", 1);

			// Resize image
			resizeImage(imageDataUrl, 0.99, (resizedDataUrl) => {
				// Convert to Blob for FormData upload
				const blob = dataURLToBlob(resizedDataUrl);
				const formData = new FormData();
				formData.append("image", blob, "uploaded_image.png");

				// XMLHttpRequest for upload progress
				const xhr = new XMLHttpRequest();
				xhr.open("POST", "https://scrsht.com/touch/chrome_extn/screenshot/upload_s.php", true);

				// Progress tracking
				xhr.upload.onprogress = function(event) {
					if (event.lengthComputable && uploadButton) {
						const percent = Math.round((event.loaded / event.total) * 100);
						uploadButton.textContent = `Uploading ${percent}%`;
						if (percent > 75) {
							uploadButton.style.backgroundColor = '#4CAF50';
						}
					}
				};

				// Handle response
				xhr.onload = function() {
					if (!uploadButton) return;

					if (xhr.status === 200) {
						uploadButton.textContent = " Upload Complete";
						setTimeout(resetButton, 2000);

						const url = new DOMParser()
							.parseFromString(xhr.responseText, "text/html")
							.querySelector("share").innerHTML;
						const scrshtId = url.split("/")[url.split("/").length - 1];

						fetch(`https://scrsht.com/api/updateScreenshot/?${scrshtId}`, {
							method: "POST",
							body: JSON.stringify({
								"markers": annotations
							}),
						}).then(() => {
							chrome.tabs.create({
								url: url
							});
						});
					} else {
						uploadButton.textContent = " Upload Failed";
						setTimeout(resetButton, 3000);
					}
				};

				xhr.onerror = function() {
					if (!uploadButton) return;
					uploadButton.textContent = " Upload Error";
					setTimeout(resetButton, 3000);
				};

				uploadButton.textContent = "Starting upload...";
				xhr.send(formData);
			});

			function resetButton() {
				if (!uploadButton) return;
				uploadButton.innerHTML = originalHTML;
				uploadButton.className = originalClass;
				uploadButton.style.cssText = originalStyle;
			}
		}),

(0, _o.subscribe)("Ideastowork", function(t, e) {
    // Open the Google Forms link in a new tab
   // window.open("https://forms.gle/2iuddYHhs3UmvUkA9", "_blank");
       window.open("https://way2enjoy.com/chrome/paypalpayment.html", "_blank");

   
}),

		(0, _o.subscribe)("scaleChange", (function(t, e) {
			return rate = e
		})), Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
		const tg = "undefined" != typeof window,
			eg = (Object.prototype.toString, t => "string" == typeof t),
			ng = () => {},
			rg = tg && (null == (Yp = null == window ? void 0 : window.navigator) ? void 0 : Yp.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

		function ig(t) {
			return "function" == typeof t ? t() : we(t)
		}

		function og(t) {
			return !!G && (function(t) {
				G && G.cleanups.push(t)
			}(t), !0)
		}

		function ag(t) {
			var e;
			const n = ig(t);
			return null != (e = null == n ? void 0 : n.$el) ? e : n
		}
		Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
		const sg = tg ? window : void 0;

		function lg(...t) {
			let e, n, r, i;
			if (eg(t[0]) || Array.isArray(t[0]) ? ([n, r, i] = t, e = sg) : [e, n, r, i] = t, !e) return ng;
			Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
			const o = [],
				a = () => {
					o.forEach((t => t())), o.length = 0
				},
				s = vi((() => [ag(e), ig(i)]), (([t, e]) => {
					a(), t && o.push(...n.flatMap((n => r.map((r => ((t, e, n, r) => (t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r)))(t, n, r, e))))))
				}), {
					immediate: !0,
					flush: "post"
				}),
				l = () => {
					s(), a()
				};
			return og(l), l
		}
		tg && window.document, tg && window.navigator, tg && window.location;
		let cg = !1;
		Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
		const ug = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
			hg = "__vueuse_ssr_handlers__";
		ug[hg] = ug[hg] || {}, ug[hg], Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
		var fg, dg, pg = Object.getOwnPropertySymbols,
			gg = Object.prototype.hasOwnProperty,
			vg = Object.prototype.propertyIsEnumerable;

		function mg(t, e, n = {}) {
			const r = n,
				{
					window: i = sg
				} = r,
				o = ((t, e) => {
					var n = {};
					for (var r in t) gg.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
					if (null != t && pg)
						for (var r of pg(t)) e.indexOf(r) < 0 && vg.call(t, r) && (n[r] = t[r]);
					return n
				})(r, ["window"]);
			let a;
			const s = function(t, e = !1) {
					const n = ve(),
						r = () => n.value = Boolean(t());
					return r(),
						function(t, e = !0) {
							Fr() ? on(t) : e ? t() : si(t)
						}(r, e), n
				}((() => i && "ResizeObserver" in i)),
				l = () => {
					a && (a.disconnect(), a = void 0)
				},
				c = vi((() => ag(t)), (t => {
					l(), s.value && i && t && (a = new ResizeObserver(e), a.observe(t, o))
				}), {
					immediate: !0,
					flush: "post"
				}),
				u = () => {
					l(), c()
				};
			return og(u), {
				isSupported: s,
				stop: u
			}
		}
		Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, new Map, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, (dg = fg || (fg = {})).UP = "UP", dg.RIGHT = "RIGHT", dg.DOWN = "DOWN", dg.LEFT = "LEFT", dg.NONE = "NONE", Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.defineProperties, Object.getOwnPropertyDescriptors, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, Object.defineProperty, Object.getOwnPropertySymbols, Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
		var yg = Object.defineProperty,
			bg = Object.getOwnPropertySymbols,
			xg = Object.prototype.hasOwnProperty,
			wg = Object.prototype.propertyIsEnumerable,
			Cg = (t, e, n) => e in t ? yg(t, e, {
				enumerable: !0,
				configurable: !0,
				writable: !0,
				value: n
			}) : t[e] = n;
		((t, e) => {
			for (var n in e || (e = {})) xg.call(e, n) && Cg(t, n, e[n]);
			if (bg)
				for (var n of bg(e)) wg.call(e, n) && Cg(t, n, e[n])
		})({
			linear: function(t) {
				return t
			}
		}, {
			easeInSine: [.12, 0, .39, 0],
			easeOutSine: [.61, 1, .88, 1],
			easeInOutSine: [.37, 0, .63, 1],
			easeInQuad: [.11, 0, .5, 0],
			easeOutQuad: [.5, 1, .89, 1],
			easeInOutQuad: [.45, 0, .55, 1],
			easeInCubic: [.32, 0, .67, 0],
			easeOutCubic: [.33, 1, .68, 1],
			easeInOutCubic: [.65, 0, .35, 1],
			easeInQuart: [.5, 0, .75, 0],
			easeOutQuart: [.25, 1, .5, 1],
			easeInOutQuart: [.76, 0, .24, 1],
			easeInQuint: [.64, 0, .78, 0],
			easeOutQuint: [.22, 1, .36, 1],
			easeInOutQuint: [.83, 0, .17, 1],
			easeInExpo: [.7, 0, .84, 0],
			easeOutExpo: [.16, 1, .3, 1],
			easeInOutExpo: [.87, 0, .13, 1],
			easeInCirc: [.55, 0, 1, .45],
			easeOutCirc: [0, .55, .45, 1],
			easeInOutCirc: [.85, 0, .15, 1],
			easeInBack: [.36, 0, .66, -.56],
			easeOutBack: [.34, 1.56, .64, 1],
			easeInOutBack: [.68, -.6, .32, 1.6]
		});
		const Sg = function(t) {
				for (var e = -1, n = null == t ? 0 : t.length, r = {}; ++e < n;) {
					var i = t[e];
					r[i[0]] = i[1]
				}
				return r
			},
			Og = "__epPropKey",
			Tg = (t, e) => {
				if (!P(t) || P(n = t) && n[Og]) return t;
				var n;
				const {
					values: r,
					required: i,
					default: o,
					type: a,
					validator: s
				} = t, l = r || s ? n => {
					let i = !1,
						a = [];
					if (r && (a = Array.from(r), w(t, "default") && a.push(o), i || (i = a.includes(n))), s && (i || (i = s(n))), !i && a.length > 0) {
						const t = [...new Set(a)].map((t => JSON.stringify(t))).join(", ");
						! function(t, ...e) {
							ht();
							const n = Vr.length ? Vr[Vr.length - 1].component : null,
								r = n && n.appContext.config.warnHandler,
								i = function() {
									let t = Vr[Vr.length - 1];
									if (!t) return [];
									const e = [];
									for (; t;) {
										const n = e[0];
										n && n.vnode === t ? n.recurseCount++ : e.push({
											vnode: t,
											recurseCount: 0
										});
										const r = t.component && t.component.parent;
										t = r && r.vnode
									}
									return e
								}();
							if (r) qr(r, n, 11, [t + e.join(""), n && n.proxy, i.map((({
								vnode: t
							}) => `at <${Wr(n,t.type)}>`)).join("\n"), i]);
							else {
								const n = [`[Vue warn]: ${t}`, ...e];
								i.length && n.push("\n", ... function(t) {
									const e = [];
									return t.forEach(((t, n) => {
										e.push(...0 === n ? [] : ["\n"], ... function({
											vnode: t,
											recurseCount: e
										}) {
											const n = e > 0 ? `... (${e} recursive calls)` : "",
												r = !!t.component && null == t.component.parent,
												i = ` at <${Wr(t.component,t.type,r)}`,
												o = ">" + n;
											return t.props ? [i, ...Ur(t.props), o] : [i + o]
										}(t))
									})), e
								}(i)), console.warn(...n)
							}
							ft()
						}(`Invalid prop: validation failed${e?` for prop "${e}"`:""}. Expected one of [${t}], got value ${JSON.stringify(n)}.`)
					}
					return i
				} : void 0, c = {
					type: a,
					required: !!i,
					validator: l,
					[Og]: !0
				};
				return w(t, "default") && (c.default = o), c
			},
			kg = t => Sg(Object.entries(t).map((([t, e]) => [t, Tg(e, t)]))),
			Fg = kg({
				value: {
					type: [String, Number],
					default: ""
				},
				max: {
					type: Number,
					default: 99
				},
				isDot: Boolean,
				hidden: Boolean,
				type: {
					type: String,
					values: ["primary", "success", "warning", "info", "danger"],
					default: "danger"
				}
			});
		var Pg = (t, e) => {
			const n = t.__vccOpts || t;
			for (const [t, r] of e) n[t] = r;
			return n
		};
		const jg = "el",
			Ag = (t, e, n, r, i) => {
				let o = `${t}-${e}`;
				return n && (o += `-${n}`), r && (o += `__${r}`), i && (o += `--${i}`), o
			},
			_g = Symbol("namespaceContextKey"),
			Eg = t => {
				const e = t || (Fr() ? We(_g, ve(jg)) : ve(jg));
				return Pe((() => we(e) || jg))
			},
			Dg = (t, e) => {
				const n = Eg(e);
				return {
					namespace: n,
					b: (e = "") => Ag(n.value, t, e, "", ""),
					e: e => e ? Ag(n.value, t, "", e, "") : "",
					m: e => e ? Ag(n.value, t, "", "", e) : "",
					be: (e, r) => e && r ? Ag(n.value, t, e, r, "") : "",
					em: (e, r) => e && r ? Ag(n.value, t, "", e, r) : "",
					bm: (e, r) => e && r ? Ag(n.value, t, e, "", r) : "",
					bem: (e, r, i) => e && r && i ? Ag(n.value, t, e, r, i) : "",
					is: (t, ...e) => {
						const n = !(e.length >= 1) || e[0];
						return t && n ? `is-${t}` : ""
					},
					cssVar: t => {
						const e = {};
						for (const r in t) t[r] && (e[`--${n.value}-${r}`] = t[r]);
						return e
					},
					cssVarName: t => `--${n.value}-${t}`,
					cssVarBlock: e => {
						const r = {};
						for (const i in e) e[i] && (r[`--${n.value}-${t}-${i}`] = e[i]);
						return r
					},
					cssVarBlockName: e => `--${n.value}-${t}-${e}`
				}
			},
			Mg = t => void 0 === t,
			Ig = t => "boolean" == typeof t,
			Rg = t => "number" == typeof t,
			Bg = t => "undefined" != typeof Element && t instanceof Element,
			Ng = ["textContent"],
			Lg = Ze({
				name: "ElBadge"
			}),
			zg = (t, e) => {
				if (t.install = n => {
						for (const r of [t, ...Object.values(null != e ? e : {})]) n.component(r.name, r)
					}, e)
					for (const [n, r] of Object.entries(e)) t[n] = r;
				return t
			},
			Wg = t => (t.install = d, t),
			Vg = zg(Pg(Ze({
				...Lg,
				props: Fg,
				setup(t, {
					expose: e
				}) {
					const n = t,
						r = Dg("badge"),
						i = Pe((() => n.isDot ? "" : Rg(n.value) && Rg(n.max) && n.max < n.value ? `${n.max}+` : `${n.value}`));
					return e({
						content: i
					}), (t, e) => (Jn(), er("div", {
						class: l(we(r).b())
					}, [br(t.$slots, "default"), cr(Hi, {
						name: `${we(r).namespace.value}-zoom-in-center`,
						persisted: ""
					}, {
						default: Ie((() => [Sn(lr("sup", {
							class: l([we(r).e("content"), we(r).em("content", t.type), we(r).is("fixed", !!t.$slots.default), we(r).is("dot", t.isDot)]),
							textContent: c(we(i))
						}, null, 10, Ng), [
							[ho, !t.hidden && (we(i) || t.isDot)]
						])])),
						_: 1
					}, 8, ["name"])], 2))
				}
			}), [
				["__file", "badge.vue"]
			])),
			Ug = kg({
				size: {
					type: [Number, String]
				},
				color: {
					type: String
				}
			});
		class Hg extends Error {
			constructor(t) {
				super(t), this.name = "ElementPlusError"
			}
		}

		function qg(t, e) {
			throw new Hg(`[${t}] ${e}`)
		}

		function Xg(t, e = "px") {
			return t ? Rg(t) || k(n = t) && !Number.isNaN(Number(n)) ? `${t}${e}` : k(t) ? t : void 0 : "";
			var n
		}
		const Gg = Ze({
				name: "ElIcon",
				inheritAttrs: !1
			}),
			Kg = Ze({
				...Gg,
				props: Ug,
				setup(t) {
					const e = t,
						n = Dg("icon"),
						r = Pe((() => {
							const {
								size: t,
								color: n
							} = e;
							return t || n ? {
								fontSize: Mg(t) ? void 0 : Xg(t),
								"--color": n
							} : {}
						}));
					return (t, e) => (Jn(), er("i", vr({
						class: we(n).b(),
						style: we(r)
					}, t.$attrs), [br(t.$slots, "default")], 16))
				}
			}),
			Yg = zg(Pg(Kg, [
				["__file", "icon.vue"]
			]));
		var Zg = Ze({
				name: "ArrowDown",
				__name: "arrow-down",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
				})]))
			}),
			Jg = Ze({
				name: "ArrowUp",
				__name: "arrow-up",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
				})]))
			}),
			Qg = Ze({
				name: "CircleCheck",
				__name: "circle-check",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
				}), lr("path", {
					fill: "currentColor",
					d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
				})]))
			}),
			$g = Ze({
				name: "CircleCloseFilled",
				__name: "circle-close-filled",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
				})]))
			}),
			tv = Ze({
				name: "CircleClose",
				__name: "circle-close",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
				}), lr("path", {
					fill: "currentColor",
					d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
				})]))
			}),
			ev = Ze({
				name: "Close",
				__name: "close",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
				})]))
			}),
			nv = Ze({
				name: "Hide",
				__name: "hide",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
				}), lr("path", {
					fill: "currentColor",
					d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
				})]))
			}),
			rv = Ze({
				name: "InfoFilled",
				__name: "info-filled",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
				})]))
			}),
			iv = Ze({
				name: "Loading",
				__name: "loading",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
				})]))
			}),
			ov = Ze({
				name: "Minus",
				__name: "minus",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
				})]))
			}),
			av = Ze({
				name: "Plus",
				__name: "plus",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
				})]))
			}),
			sv = Ze({
				name: "SuccessFilled",
				__name: "success-filled",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
				})]))
			}),
			lv = Ze({
				name: "View",
				__name: "view",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
				})]))
			}),
			cv = Ze({
				name: "WarningFilled",
				__name: "warning-filled",
				setup: t => (t, e) => (Jn(), er("svg", {
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 0 1024 1024"
				}, [lr("path", {
					fill: "currentColor",
					d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
				})]))
			});
		const uv = [String, Object, Function],
			hv = {
				Close: ev,
				SuccessFilled: sv,
				InfoFilled: rv,
				WarningFilled: cv,
				CircleCloseFilled: $g
			},
			fv = {
				success: sv,
				warning: cv,
				error: $g,
				info: rv
			},
			dv = {
				validating: iv,
				success: Qg,
				error: tv
			},
			pv = ["success", "info", "warning", "error"],
			gv = {
				customClass: "",
				center: !1,
				dangerouslyUseHTMLString: !1,
				duration: 3e3,
				icon: void 0,
				id: "",
				message: "",
				onClose: void 0,
				showClose: !1,
				type: "info",
				offset: 16,
				zIndex: 0,
				grouping: !1,
				repeatNum: 1,
				appendTo: tg ? document.body : void 0
			},
			vv = kg({
				customClass: {
					type: String,
					default: gv.customClass
				},
				center: {
					type: Boolean,
					default: gv.center
				},
				dangerouslyUseHTMLString: {
					type: Boolean,
					default: gv.dangerouslyUseHTMLString
				},
				duration: {
					type: Number,
					default: gv.duration
				},
				icon: {
					type: uv,
					default: gv.icon
				},
				id: {
					type: String,
					default: gv.id
				},
				message: {
					type: [String, Object, Function],
					default: gv.message
				},
				onClose: {
					type: Function,
					required: !1
				},
				showClose: {
					type: Boolean,
					default: gv.showClose
				},
				type: {
					type: String,
					values: pv,
					default: gv.type
				},
				offset: {
					type: Number,
					default: gv.offset
				},
				zIndex: {
					type: Number,
					default: gv.zIndex
				},
				grouping: {
					type: Boolean,
					default: gv.grouping
				},
				repeatNum: {
					type: Number,
					default: gv.repeatNum
				}
			}),
			mv = ie([]),
			yv = Symbol(),
			bv = Array.isArray,
			xv = "object" == typeof global && global && global.Object === Object && global;
		var wv = "object" == typeof self && self && self.Object === Object && self;
		const Cv = xv || wv || Function("return this")(),
			Sv = Cv.Symbol;
		var Ov = Object.prototype,
			Tv = Ov.hasOwnProperty,
			kv = Ov.toString,
			Fv = Sv ? Sv.toStringTag : void 0;
		var Pv = Object.prototype.toString;
		var jv = Sv ? Sv.toStringTag : void 0;
		const Av = function(t) {
				return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : jv && jv in Object(t) ? function(t) {
					var e = Tv.call(t, Fv),
						n = t[Fv];
					try {
						t[Fv] = void 0;
						var r = !0
					} catch (t) {}
					var i = kv.call(t);
					return r && (e ? t[Fv] = n : delete t[Fv]), i
				}(t) : function(t) {
					return Pv.call(t)
				}(t)
			},
			_v = function(t) {
				return null != t && "object" == typeof t
			},
			Ev = function(t) {
				return "symbol" == typeof t || _v(t) && "[object Symbol]" == Av(t)
			};
		var Dv = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
			Mv = /^\w*$/;
		const Iv = function(t, e) {
				if (bv(t)) return !1;
				var n = typeof t;
				return !("number" != n && "symbol" != n && "boolean" != n && null != t && !Ev(t)) || Mv.test(t) || !Dv.test(t) || null != e && t in Object(e)
			},
			Rv = function(t) {
				var e = typeof t;
				return null != t && ("object" == e || "function" == e)
			},
			Bv = function(t) {
				if (!Rv(t)) return !1;
				var e = Av(t);
				return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
			},
			Nv = Cv["__core-js_shared__"];
		var Lv = function() {
			var t = /[^.]+$/.exec(Nv && Nv.keys && Nv.keys.IE_PROTO || "");
			return t ? "Symbol(src)_1." + t : ""
		}();
		var zv = Function.prototype.toString;
		const Wv = function(t) {
			if (null != t) {
				try {
					return zv.call(t)
				} catch (t) {}
				try {
					return t + ""
				} catch (t) {}
			}
			return ""
		};
		var Vv = /^\[object .+?Constructor\]$/,
			Uv = Function.prototype,
			Hv = Object.prototype,
			qv = Uv.toString,
			Xv = Hv.hasOwnProperty,
			Gv = RegExp("^" + qv.call(Xv).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
		const Kv = function(t) {
				return !(!Rv(t) || (e = t, Lv && Lv in e)) && (Bv(t) ? Gv : Vv).test(Wv(t));
				var e
			},
			Yv = function(t, e) {
				var n = function(t, e) {
					return null == t ? void 0 : t[e]
				}(t, e);
				return Kv(n) ? n : void 0
			},
			Zv = Yv(Object, "create");
		var Jv = Object.prototype.hasOwnProperty;
		var Qv = Object.prototype.hasOwnProperty;

		function $v(t) {
			var e = -1,
				n = null == t ? 0 : t.length;
			for (this.clear(); ++e < n;) {
				var r = t[e];
				this.set(r[0], r[1])
			}
		}
		$v.prototype.clear = function() {
			this.__data__ = Zv ? Zv(null) : {}, this.size = 0
		}, $v.prototype.delete = function(t) {
			var e = this.has(t) && delete this.__data__[t];
			return this.size -= e ? 1 : 0, e
		}, $v.prototype.get = function(t) {
			var e = this.__data__;
			if (Zv) {
				var n = e[t];
				return "__lodash_hash_undefined__" === n ? void 0 : n
			}
			return Jv.call(e, t) ? e[t] : void 0
		}, $v.prototype.has = function(t) {
			var e = this.__data__;
			return Zv ? void 0 !== e[t] : Qv.call(e, t)
		}, $v.prototype.set = function(t, e) {
			var n = this.__data__;
			return this.size += this.has(t) ? 0 : 1, n[t] = Zv && void 0 === e ? "__lodash_hash_undefined__" : e, this
		};
		const tm = $v,
			em = function(t, e) {
				return t === e || t != t && e != e
			},
			nm = function(t, e) {
				for (var n = t.length; n--;)
					if (em(t[n][0], e)) return n;
				return -1
			};
		var rm = Array.prototype.splice;

		function im(t) {
			var e = -1,
				n = null == t ? 0 : t.length;
			for (this.clear(); ++e < n;) {
				var r = t[e];
				this.set(r[0], r[1])
			}
		}
		im.prototype.clear = function() {
			this.__data__ = [], this.size = 0
		}, im.prototype.delete = function(t) {
			var e = this.__data__,
				n = nm(e, t);
			return !(n < 0 || (n == e.length - 1 ? e.pop() : rm.call(e, n, 1), --this.size, 0))
		}, im.prototype.get = function(t) {
			var e = this.__data__,
				n = nm(e, t);
			return n < 0 ? void 0 : e[n][1]
		}, im.prototype.has = function(t) {
			return nm(this.__data__, t) > -1
		}, im.prototype.set = function(t, e) {
			var n = this.__data__,
				r = nm(n, t);
			return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
		};
		const om = im,
			am = Yv(Cv, "Map"),
			sm = function(t, e) {
				var n, r, i = t.__data__;
				return ("string" == (r = typeof(n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map
			};

		function lm(t) {
			var e = -1,
				n = null == t ? 0 : t.length;
			for (this.clear(); ++e < n;) {
				var r = t[e];
				this.set(r[0], r[1])
			}
		}
		lm.prototype.clear = function() {
			this.size = 0, this.__data__ = {
				hash: new tm,
				map: new(am || om),
				string: new tm
			}
		}, lm.prototype.delete = function(t) {
			var e = sm(this, t).delete(t);
			return this.size -= e ? 1 : 0, e
		}, lm.prototype.get = function(t) {
			return sm(this, t).get(t)
		}, lm.prototype.has = function(t) {
			return sm(this, t).has(t)
		}, lm.prototype.set = function(t, e) {
			var n = sm(this, t),
				r = n.size;
			return n.set(t, e), this.size += n.size == r ? 0 : 1, this
		};
		const cm = lm;

		function um(t, e) {
			if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError("Expected a function");
			var n = function() {
				var r = arguments,
					i = e ? e.apply(this, r) : r[0],
					o = n.cache;
				if (o.has(i)) return o.get(i);
				var a = t.apply(this, r);
				return n.cache = o.set(i, a) || o, a
			};
			return n.cache = new(um.Cache || cm), n
		}
		um.Cache = cm;
		var hm = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
			fm = /\\(\\)?/g;
		const dm = (pm = um((function(t) {
			var e = [];
			return 46 === t.charCodeAt(0) && e.push(""), t.replace(hm, (function(t, n, r, i) {
				e.push(r ? i.replace(fm, "$1") : n || t)
			})), e
		}), (function(t) {
			return 500 === gm.size && gm.clear(), t
		})), gm = pm.cache, pm);
		var pm, gm;
		var vm = Sv ? Sv.prototype : void 0,
			mm = vm ? vm.toString : void 0;
		const ym = function t(e) {
				if ("string" == typeof e) return e;
				if (bv(e)) return function(t, e) {
					for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
					return i
				}(e, t) + "";
				if (Ev(e)) return mm ? mm.call(e) : "";
				var n = e + "";
				return "0" == n && 1 / e == -1 / 0 ? "-0" : n
			},
			bm = function(t, e) {
				return bv(t) ? t : Iv(t, e) ? [t] : dm(function(t) {
					return null == t ? "" : ym(t)
				}(t))
			},
			xm = function(t) {
				if ("string" == typeof t || Ev(t)) return t;
				var e = t + "";
				return "0" == e && 1 / t == -1 / 0 ? "-0" : e
			},
			wm = function(t, e) {
				for (var n = 0, r = (e = bm(e, t)).length; null != t && n < r;) t = t[xm(e[n++])];
				return n && n == r ? t : void 0
			},
			Cm = function(t, e, n) {
				var r = null == t ? void 0 : wm(t, e);
				return void 0 === r ? n : r
			};
		var Sm = {
			name: "en",
			el: {
				colorpicker: {
					confirm: "OK",
					clear: "Clear",
					defaultLabel: "color picker",
					description: "current color is {color}. press enter to select a new color."
				},
				datepicker: {
					now: "Now",
					today: "Today",
					cancel: "Cancel",
					clear: "Clear",
					confirm: "OK",
					dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
					monthTablePrompt: "Use the arrow keys and enter to select the month",
					yearTablePrompt: "Use the arrow keys and enter to select the year",
					selectedDate: "Selected date",
					selectDate: "Select date",
					selectTime: "Select time",
					startDate: "Start Date",
					startTime: "Start Time",
					endDate: "End Date",
					endTime: "End Time",
					prevYear: "Previous Year",
					nextYear: "Next Year",
					prevMonth: "Previous Month",
					nextMonth: "Next Month",
					year: "",
					month1: "January",
					month2: "February",
					month3: "March",
					month4: "April",
					month5: "May",
					month6: "June",
					month7: "July",
					month8: "August",
					month9: "September",
					month10: "October",
					month11: "November",
					month12: "December",
					week: "week",
					weeks: {
						sun: "Sun",
						mon: "Mon",
						tue: "Tue",
						wed: "Wed",
						thu: "Thu",
						fri: "Fri",
						sat: "Sat"
					},
					weeksFull: {
						sun: "Sunday",
						mon: "Monday",
						tue: "Tuesday",
						wed: "Wednesday",
						thu: "Thursday",
						fri: "Friday",
						sat: "Saturday"
					},
					months: {
						jan: "Jan",
						feb: "Feb",
						mar: "Mar",
						apr: "Apr",
						may: "May",
						jun: "Jun",
						jul: "Jul",
						aug: "Aug",
						sep: "Sep",
						oct: "Oct",
						nov: "Nov",
						dec: "Dec"
					}
				},
				inputNumber: {
					decrease: "decrease number",
					increase: "increase number"
				},
				select: {
					loading: "Loading",
					noMatch: "No matching data",
					noData: "No data",
					placeholder: "Select"
				},
				dropdown: {
					toggleDropdown: "Toggle Dropdown"
				},
				cascader: {
					noMatch: "No matching data",
					loading: "Loading",
					placeholder: "Select",
					noData: "No data"
				},
				pagination: {
					goto: "Go to",
					pagesize: "/page",
					total: "Total {total}",
					pageClassifier: "",
					page: "Page",
					prev: "Go to previous page",
					next: "Go to next page",
					currentPage: "page {pager}",
					prevPages: "Previous {pager} pages",
					nextPages: "Next {pager} pages",
					deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
				},
				dialog: {
					close: "Close this dialog"
				},
				drawer: {
					close: "Close this dialog"
				},
				messagebox: {
					title: "Message",
					confirm: "OK",
					cancel: "Cancel",
					error: "Illegal input",
					close: "Close this dialog"
				},
				upload: {
					deleteTip: "press delete to remove",
					delete: "Delete",
					preview: "Preview",
					continue: "Continue"
				},
				slider: {
					defaultLabel: "slider between {min} and {max}",
					defaultRangeStartLabel: "pick start value",
					defaultRangeEndLabel: "pick end value"
				},
				table: {
					emptyText: "No Data",
					confirmFilter: "Confirm",
					resetFilter: "Reset",
					clearFilter: "All",
					sumText: "Sum"
				},
				tree: {
					emptyText: "No Data"
				},
				transfer: {
					noMatch: "No matching data",
					noData: "No data",
					titles: ["List 1", "List 2"],
					filterPlaceholder: "Enter keyword",
					noCheckedFormat: "{total} items",
					hasCheckedFormat: "{checked}/{total} checked"
				},
				image: {
					error: "FAILED"
				},
				pageHeader: {
					title: "Back"
				},
				popconfirm: {
					confirmButtonText: "Yes",
					cancelButtonText: "No"
				}
			}
		};
		const Om = t => (e, n) => Tm(e, n, we(t)),
			Tm = (t, e, n) => Cm(n, t, t).replace(/\{(\w+)\}/g, ((t, n) => {
				var r;
				return `${null!=(r=null==e?void 0:e[n])?r:`{${n}}`}`
			})),
			km = Symbol("localeContextKey"),
			Fm = t => {
				const e = t || We(km, ve());
				return (t => ({
					lang: Pe((() => we(t).name)),
					locale: ge(t) ? t : ve(t),
					t: Om(t)
				}))(Pe((() => e.value || Sm)))
			},
			Pm = ve(0),
			jm = Symbol("zIndexContextKey"),
			Am = t => {
				const e = t || (Fr() ? We(jm, void 0) : void 0),
					n = Pe((() => {
						const t = we(e);
						return Rg(t) ? t : 2e3
					})),
					r = Pe((() => n.value + Pm.value));
				return {
					initialZIndex: n,
					currentZIndex: r,
					nextZIndex: () => (Pm.value++, r.value)
				}
			},
			_m = ["", "default", "small", "large"],
			Em = {
				large: 40,
				default: 32,
				small: 24
			},
			Dm = Tg({
				type: String,
				values: _m,
				required: !1
			}),
			Mm = Symbol("size"),
			Im = t => Object.keys(t),
			Rm = ve();

		function Bm(t, e = void 0) {
			const n = Fr() ? We(yv, Rm) : Rm;
			return t ? Pe((() => {
				var r, i;
				return null != (i = null == (r = n.value) ? void 0 : r[t]) ? i : e
			})) : n
		}
		const Nm = (t, e, n = !1) => {
				var r;
				const i = !!Fr(),
					o = i ? Bm() : void 0,
					a = null != (r = null == e ? void 0 : e.provide) ? r : i ? ze : void 0;
				if (!a) return;
				const s = Pe((() => {
					const e = we(t);
					return (null == o ? void 0 : o.value) ? Lm(o.value, e) : e
				}));
				return a(yv, s), a(km, Pe((() => s.value.locale))), a(_g, Pe((() => s.value.namespace))), a(jm, Pe((() => s.value.zIndex))), a(Mm, {
					size: Pe((() => s.value.size || ""))
				}), !n && Rm.value || (Rm.value = s.value), s
			},
			Lm = (t, e) => {
				var n;
				const r = [...new Set([...Im(t), ...Im(e)])],
					i = {};
				for (const o of r) i[o] = null != (n = e[o]) ? n : t[o];
				return i
			},
			zm = "Enter",
			Wm = "Space",
			Vm = "Escape",
			Um = ["id"],
			Hm = ["innerHTML"],
			qm = Ze({
				name: "ElMessage"
			}),
			Xm = Ze({
				...qm,
				props: vv,
				emits: {
					destroy: () => !0
				},
				setup(t, {
					expose: e
				}) {
					const n = t,
						{
							Close: r
						} = hv,
						{
							ns: o,
							zIndex: a
						} = function(t, e) {
							const n = Bm(),
								r = Dg("message", Pe((() => {
									var t;
									return (null == (t = n.value) ? void 0 : t.namespace) || jg
								}))),
								i = Fm(Pe((() => {
									var t;
									return null == (t = n.value) ? void 0 : t.locale
								}))),
								o = Am(Pe((() => {
									var t;
									return (null == (t = n.value) ? void 0 : t.zIndex) || 2e3
								}))),
								a = Pe((() => {
									var t;
									return we(undefined) || (null == (t = n.value) ? void 0 : t.size) || ""
								}));
							return Nm(Pe((() => we(n) || {}))), {
								ns: r,
								locale: i,
								zIndex: o,
								size: a
							}
						}(),
						{
							currentZIndex: s,
							nextZIndex: u
						} = a,
						h = ve(),
						f = ve(!1),
						d = ve(0);
					let p;
					const g = Pe((() => n.type ? "error" === n.type ? "danger" : n.type : "info")),
						v = Pe((() => {
							const t = n.type;
							return {
								[o.bm("icon", t)]: t && fv[t]
							}
						})),
						m = Pe((() => n.icon || fv[n.type] || "")),
						y = Pe((() => (t => {
							const {
								prev: e
							} = (t => {
								const e = mv.findIndex((e => e.id === t)),
									n = mv[e];
								let r;
								return e > 0 && (r = mv[e - 1]), {
									current: n,
									prev: r
								}
							})(t);
							return e ? e.vm.exposed.bottom.value : 0
						})(n.id))),
						b = Pe((() => ((t, e) => mv.findIndex((e => e.id === t)) > 0 ? 20 : e)(n.id, n.offset) + y.value)),
						x = Pe((() => d.value + b.value)),
						w = Pe((() => ({
							top: `${b.value}px`,
							zIndex: s.value
						})));

					function C() {
						0 !== n.duration && ({
							stop: p
						} = function(t, e, n = {}) {
							const {
								immediate: r = !0
							} = n, i = ve(!1);
							let o = null;

							function a() {
								o && (clearTimeout(o), o = null)
							}

							function s() {
								i.value = !1, a()
							}

							function l(...n) {
								a(), i.value = !0, o = setTimeout((() => {
									i.value = !1, o = null, t(...n)
								}), ig(e))
							}
							return r && (i.value = !0, tg && l()), og(s), {
								isPending: oe(i),
								start: l,
								stop: s
							}
						}((() => {
							O()
						}), n.duration))
					}

					function S() {
						null == p || p()
					}

					function O() {
						f.value = !1
					}
					return on((() => {
						C(), u(), f.value = !0
					})), vi((() => n.repeatNum), (() => {
						S(), C()
					})), lg(document, "keydown", (function({
						code: t
					}) {
						t === Vm && O()
					})), mg(h, (() => {
						d.value = h.value.getBoundingClientRect().height
					})), e({
						visible: f,
						bottom: x,
						close: O
					}), (t, e) => (Jn(), nr(Hi, {
						name: we(o).b("fade"),
						onBeforeLeave: t.onClose,
						onAfterLeave: e[0] || (e[0] = e => t.$emit("destroy")),
						persisted: ""
					}, {
						default: Ie((() => [Sn(lr("div", {
							id: t.id,
							ref_key: "messageRef",
							ref: h,
							class: l([we(o).b(), {
								[we(o).m(t.type)]: t.type && !t.icon
							}, we(o).is("center", t.center), we(o).is("closable", t.showClose), t.customClass]),
							style: i(we(w)),
							role: "alert",
							onMouseenter: S,
							onMouseleave: C
						}, [t.repeatNum > 1 ? (Jn(), nr(we(Vg), {
							key: 0,
							value: t.repeatNum,
							type: we(g),
							class: l(we(o).e("badge"))
						}, null, 8, ["value", "type", "class"])) : fr("v-if", !0), we(m) ? (Jn(), nr(we(Yg), {
							key: 1,
							class: l([we(o).e("icon"), we(v)])
						}, {
							default: Ie((() => [(Jn(), nr(Vn(we(m))))])),
							_: 1
						}, 8, ["class"])) : fr("v-if", !0), br(t.$slots, "default", {}, (() => [t.dangerouslyUseHTMLString ? (Jn(), er(qn, {
							key: 1
						}, [fr(" Caution here, message could've been compromised, never use user's input as message "), lr("p", {
							class: l(we(o).e("content")),
							innerHTML: t.message
						}, null, 10, Hm)], 2112)) : (Jn(), er("p", {
							key: 0,
							class: l(we(o).e("content"))
						}, c(t.message), 3))])), t.showClose ? (Jn(), nr(we(Yg), {
							key: 2,
							class: l(we(o).e("closeBtn")),
							onClick: lo(O, ["stop"])
						}, {
							default: Ie((() => [cr(we(r))])),
							_: 1
						}, 8, ["class", "onClick"])) : fr("v-if", !0)], 46, Um), [
							[ho, f.value]
						])])),
						_: 3
					}, 8, ["name", "onBeforeLeave"]))
				}
			});
		var Gm = Pg(Xm, [
			["__file", "message.vue"]
		]);
		const Km = kg({
				a11y: {
					type: Boolean,
					default: !0
				},
				locale: {
					type: Object
				},
				size: Dm,
				button: {
					type: Object
				},
				experimentalFeatures: {
					type: Object
				},
				keyboardNavigation: {
					type: Boolean,
					default: !0
				},
				message: {
					type: Object
				},
				zIndex: Number,
				namespace: {
					type: String,
					default: "el"
				}
			}),
			Ym = {};
		Ze({
			name: "ElConfigProvider",
			props: Km,
			setup(t, {
				slots: e
			}) {
				vi((() => t.message), (t => {
					Object.assign(Ym, null != t ? t : {})
				}), {
					immediate: !0,
					deep: !0
				});
				const n = Nm(t);
				return () => br(e, "default", {
					config: null == n ? void 0 : n.value
				})
			}
		});
		let Zm = 1;
		const Jm = t => {
				const e = !t || k(t) || rr(t) || T(t) ? {
						message: t
					} : t,
					n = {
						...gv,
						...e
					};
				if (n.appendTo) {
					if (k(n.appendTo)) {
						let t = document.querySelector(n.appendTo);
						Bg(t) || (t = document.body), n.appendTo = t
					}
				} else n.appendTo = document.body;
				return n
			},
			Qm = (t = {}, e) => {
				if (!tg) return {
					close: () => {}
				};
				if (Rg(Ym.max) && mv.length >= Ym.max) return {
					close: () => {}
				};
				const n = Jm(t);
				if (n.grouping && mv.length) {
					const t = mv.find((({
						vnode: t
					}) => {
						var e;
						return (null == (e = t.props) ? void 0 : e.message) === n.message
					}));
					if (t) return t.props.repeatNum += 1, t.props.type = n.type, t.handler
				}
				const r = (({
					appendTo: t,
					...e
				}, n) => {
					const r = "message_" + Zm++,
						i = e.onClose,
						o = document.createElement("div"),
						a = {
							...e,
							id: r,
							onClose: () => {
								null == i || i(), (t => {
									const e = mv.indexOf(t);
									if (-1 === e) return;
									mv.splice(e, 1);
									const {
										handler: n
									} = t;
									n.close()
								})(u)
							},
							onDestroy: () => {
								mo(null, o)
							}
						},
						s = cr(Gm, a, T(a.message) || rr(a.message) ? {
							default: T(a.message) ? a.message : () => a.message
						} : null);
					s.appContext = n || Qm._context, mo(s, o), t.appendChild(o.firstElementChild);
					const l = s.component,
						c = {
							close: () => {
								l.exposed.visible.value = !1
							}
						},
						u = {
							id: r,
							vnode: s,
							vm: l,
							handler: c,
							props: s.component.props
						};
					return u
				})(n, e);
				return mv.push(r), r.handler
			};
		pv.forEach((t => {
			Qm[t] = (e = {}, n) => {
				const r = Jm(e);
				return Qm({
					...r,
					type: t
				}, n)
			}
		})), Qm.closeAll = function(t) {
			for (const e of mv) t && t !== e.props.type || e.handler.close()
		}, Qm._context = null;
		const $m = ((iy = Qm).install = t => {
				iy._context = t._context, t.config.globalProperties.$message = iy
			}, iy),
			ty = Symbol("popper"),
			ey = Symbol("popperContent"),
			ny = kg({
				role: {
					type: String,
					values: ["dialog", "grid", "group", "listbox", "menu", "navigation", "tooltip", "tree"],
					default: "tooltip"
				}
			}),
			ry = Ze({
				name: "ElPopper",
				inheritAttrs: !1
			});
		var iy;
		const oy = zg(Pg(Ze({
				...ry,
				props: ny,
				setup(t, {
					expose: e
				}) {
					const n = t,
						r = {
							triggerRef: ve(),
							popperInstanceRef: ve(),
							contentRef: ve(),
							referenceRef: ve(),
							role: Pe((() => n.role))
						};
					return e(r), ze(ty, r), (t, e) => br(t.$slots, "default")
				}
			}), [
				["__file", "popper.vue"]
			])),
			ay = Symbol("elTooltip");

		function sy() {
			let t;
			const e = () => window.clearTimeout(t);
			return og((() => e())), {
				registerTimeout: (n, r) => {
					e(), t = window.setTimeout(n, r)
				},
				cancelTimeout: e
			}
		}
		const ly = kg({
			showAfter: {
				type: Number,
				default: 0
			},
			hideAfter: {
				type: Number,
				default: 200
			},
			autoClose: {
				type: Number,
				default: 0
			}
		});
		var cy = "top",
			uy = "bottom",
			hy = "right",
			fy = "left",
			dy = "auto",
			py = [cy, uy, hy, fy],
			gy = "start",
			vy = "end",
			my = "viewport",
			yy = "popper",
			by = py.reduce((function(t, e) {
				return t.concat([e + "-" + gy, e + "-" + vy])
			}), []),
			xy = [].concat(py, [dy]).reduce((function(t, e) {
				return t.concat([e, e + "-" + gy, e + "-" + vy])
			}), []),
			wy = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

		function Cy(t) {
			return t ? (t.nodeName || "").toLowerCase() : null
		}

		function Sy(t) {
			if (null == t) return window;
			if ("[object Window]" !== t.toString()) {
				var e = t.ownerDocument;
				return e && e.defaultView || window
			}
			return t
		}

		function Oy(t) {
			return t instanceof Sy(t).Element || t instanceof Element
		}

		function Ty(t) {
			return t instanceof Sy(t).HTMLElement || t instanceof HTMLElement
		}

		function ky(t) {
			return "undefined" != typeof ShadowRoot && (t instanceof Sy(t).ShadowRoot || t instanceof ShadowRoot)
		}
		var Fy = {
			name: "applyStyles",
			enabled: !0,
			phase: "write",
			fn: function(t) {
				var e = t.state;
				Object.keys(e.elements).forEach((function(t) {
					var n = e.styles[t] || {},
						r = e.attributes[t] || {},
						i = e.elements[t];
					!Ty(i) || !Cy(i) || (Object.assign(i.style, n), Object.keys(r).forEach((function(t) {
						var e = r[t];
						!1 === e ? i.removeAttribute(t) : i.setAttribute(t, !0 === e ? "" : e)
					})))
				}))
			},
			effect: function(t) {
				var e = t.state,
					n = {
						popper: {
							position: e.options.strategy,
							left: "0",
							top: "0",
							margin: "0"
						},
						arrow: {
							position: "absolute"
						},
						reference: {}
					};
				return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
					function() {
						Object.keys(e.elements).forEach((function(t) {
							var r = e.elements[t],
								i = e.attributes[t] || {},
								o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce((function(t, e) {
									return t[e] = "", t
								}), {});
							!Ty(r) || !Cy(r) || (Object.assign(r.style, o), Object.keys(i).forEach((function(t) {
								r.removeAttribute(t)
							})))
						}))
					}
			},
			requires: ["computeStyles"]
		};

		function Py(t) {
			return t.split("-")[0]
		}
		var jy = Math.max,
			Ay = Math.min,
			_y = Math.round;

		function Ey(t, e) {
			void 0 === e && (e = !1);
			var n = t.getBoundingClientRect(),
				r = 1,
				i = 1;
			if (Ty(t) && e) {
				var o = t.offsetHeight,
					a = t.offsetWidth;
				a > 0 && (r = _y(n.width) / a || 1), o > 0 && (i = _y(n.height) / o || 1)
			}
			return {
				width: n.width / r,
				height: n.height / i,
				top: n.top / i,
				right: n.right / r,
				bottom: n.bottom / i,
				left: n.left / r,
				x: n.left / r,
				y: n.top / i
			}
		}

		function Dy(t) {
			var e = Ey(t),
				n = t.offsetWidth,
				r = t.offsetHeight;
			return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
				x: t.offsetLeft,
				y: t.offsetTop,
				width: n,
				height: r
			}
		}

		function My(t, e) {
			var n = e.getRootNode && e.getRootNode();
			if (t.contains(e)) return !0;
			if (n && ky(n)) {
				var r = e;
				do {
					if (r && t.isSameNode(r)) return !0;
					r = r.parentNode || r.host
				} while (r)
			}
			return !1
		}

		function Iy(t) {
			return Sy(t).getComputedStyle(t)
		}

		function Ry(t) {
			return ["table", "td", "th"].indexOf(Cy(t)) >= 0
		}

		function By(t) {
			return ((Oy(t) ? t.ownerDocument : t.document) || window.document).documentElement
		}

		function Ny(t) {
			return "html" === Cy(t) ? t : t.assignedSlot || t.parentNode || (ky(t) ? t.host : null) || By(t)
		}

		function Ly(t) {
			return Ty(t) && "fixed" !== Iy(t).position ? t.offsetParent : null
		}

		function zy(t) {
			for (var e = Sy(t), n = Ly(t); n && Ry(n) && "static" === Iy(n).position;) n = Ly(n);
			return n && ("html" === Cy(n) || "body" === Cy(n) && "static" === Iy(n).position) ? e : n || function(t) {
				var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
				if (-1 !== navigator.userAgent.indexOf("Trident") && Ty(t) && "fixed" === Iy(t).position) return null;
				var n = Ny(t);
				for (ky(n) && (n = n.host); Ty(n) && ["html", "body"].indexOf(Cy(n)) < 0;) {
					var r = Iy(n);
					if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || e && "filter" === r.willChange || e && r.filter && "none" !== r.filter) return n;
					n = n.parentNode
				}
				return null
			}(t) || e
		}

		function Wy(t) {
			return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
		}

		function Vy(t, e, n) {
			return jy(t, Ay(e, n))
		}

		function Uy(t) {
			return Object.assign({}, {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}, t)
		}

		function Hy(t, e) {
			return e.reduce((function(e, n) {
				return e[n] = t, e
			}), {})
		}
		var qy = {
			name: "arrow",
			enabled: !0,
			phase: "main",
			fn: function(t) {
				var e, n = t.state,
					r = t.name,
					i = t.options,
					o = n.elements.arrow,
					a = n.modifiersData.popperOffsets,
					s = Py(n.placement),
					l = Wy(s),
					c = [fy, hy].indexOf(s) >= 0 ? "height" : "width";
				if (o && a) {
					var u = function(t, e) {
							return Uy("number" != typeof(t = "function" == typeof t ? t(Object.assign({}, e.rects, {
								placement: e.placement
							})) : t) ? t : Hy(t, py))
						}(i.padding, n),
						h = Dy(o),
						f = "y" === l ? cy : fy,
						d = "y" === l ? uy : hy,
						p = n.rects.reference[c] + n.rects.reference[l] - a[l] - n.rects.popper[c],
						g = a[l] - n.rects.reference[l],
						v = zy(o),
						m = v ? "y" === l ? v.clientHeight || 0 : v.clientWidth || 0 : 0,
						y = p / 2 - g / 2,
						b = u[f],
						x = m - h[c] - u[d],
						w = m / 2 - h[c] / 2 + y,
						C = Vy(b, w, x),
						S = l;
					n.modifiersData[r] = ((e = {})[S] = C, e.centerOffset = C - w, e)
				}
			},
			effect: function(t) {
				var e = t.state,
					n = t.options.element,
					r = void 0 === n ? "[data-popper-arrow]" : n;
				null != r && ("string" == typeof r && !(r = e.elements.popper.querySelector(r)) || !My(e.elements.popper, r) || (e.elements.arrow = r))
			},
			requires: ["popperOffsets"],
			requiresIfExists: ["preventOverflow"]
		};

		function Xy(t) {
			return t.split("-")[1]
		}
		var Gy = {
			top: "auto",
			right: "auto",
			bottom: "auto",
			left: "auto"
		};

		function Ky(t) {
			var e, n = t.popper,
				r = t.popperRect,
				i = t.placement,
				o = t.variation,
				a = t.offsets,
				s = t.position,
				l = t.gpuAcceleration,
				c = t.adaptive,
				u = t.roundOffsets,
				h = t.isFixed,
				f = a.x,
				d = void 0 === f ? 0 : f,
				p = a.y,
				g = void 0 === p ? 0 : p,
				v = "function" == typeof u ? u({
					x: d,
					y: g
				}) : {
					x: d,
					y: g
				};
			d = v.x, g = v.y;
			var m = a.hasOwnProperty("x"),
				y = a.hasOwnProperty("y"),
				b = fy,
				x = cy,
				w = window;
			if (c) {
				var C = zy(n),
					S = "clientHeight",
					O = "clientWidth";
				C === Sy(n) && "static" !== Iy(C = By(n)).position && "absolute" === s && (S = "scrollHeight", O = "scrollWidth"), (i === cy || (i === fy || i === hy) && o === vy) && (x = uy, g -= (h && C === w && w.visualViewport ? w.visualViewport.height : C[S]) - r.height, g *= l ? 1 : -1), i !== fy && (i !== cy && i !== uy || o !== vy) || (b = hy, d -= (h && C === w && w.visualViewport ? w.visualViewport.width : C[O]) - r.width, d *= l ? 1 : -1)
			}
			var T, k = Object.assign({
					position: s
				}, c && Gy),
				F = !0 === u ? function(t) {
					var e = t.x,
						n = t.y,
						r = window.devicePixelRatio || 1;
					return {
						x: _y(e * r) / r || 0,
						y: _y(n * r) / r || 0
					}
				}({
					x: d,
					y: g
				}) : {
					x: d,
					y: g
				};
			return d = F.x, g = F.y, l ? Object.assign({}, k, ((T = {})[x] = y ? "0" : "", T[b] = m ? "0" : "", T.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + g + "px)" : "translate3d(" + d + "px, " + g + "px, 0)", T)) : Object.assign({}, k, ((e = {})[x] = y ? g + "px" : "", e[b] = m ? d + "px" : "", e.transform = "", e))
		}
		var Yy = {
				name: "computeStyles",
				enabled: !0,
				phase: "beforeWrite",
				fn: function(t) {
					var e = t.state,
						n = t.options,
						r = n.gpuAcceleration,
						i = void 0 === r || r,
						o = n.adaptive,
						a = void 0 === o || o,
						s = n.roundOffsets,
						l = void 0 === s || s,
						c = {
							placement: Py(e.placement),
							variation: Xy(e.placement),
							popper: e.elements.popper,
							popperRect: e.rects.popper,
							gpuAcceleration: i,
							isFixed: "fixed" === e.options.strategy
						};
					null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, Ky(Object.assign({}, c, {
						offsets: e.modifiersData.popperOffsets,
						position: e.options.strategy,
						adaptive: a,
						roundOffsets: l
					})))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, Ky(Object.assign({}, c, {
						offsets: e.modifiersData.arrow,
						position: "absolute",
						adaptive: !1,
						roundOffsets: l
					})))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
						"data-popper-placement": e.placement
					})
				},
				data: {}
			},
			Zy = {
				passive: !0
			},
			Jy = {
				name: "eventListeners",
				enabled: !0,
				phase: "write",
				fn: function() {},
				effect: function(t) {
					var e = t.state,
						n = t.instance,
						r = t.options,
						i = r.scroll,
						o = void 0 === i || i,
						a = r.resize,
						s = void 0 === a || a,
						l = Sy(e.elements.popper),
						c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
					return o && c.forEach((function(t) {
							t.addEventListener("scroll", n.update, Zy)
						})), s && l.addEventListener("resize", n.update, Zy),
						function() {
							o && c.forEach((function(t) {
								t.removeEventListener("scroll", n.update, Zy)
							})), s && l.removeEventListener("resize", n.update, Zy)
						}
				},
				data: {}
			},
			Qy = {
				left: "right",
				right: "left",
				bottom: "top",
				top: "bottom"
			};

		function $y(t) {
			return t.replace(/left|right|bottom|top/g, (function(t) {
				return Qy[t]
			}))
		}
		var tb = {
			start: "end",
			end: "start"
		};

		function eb(t) {
			return t.replace(/start|end/g, (function(t) {
				return tb[t]
			}))
		}

		function nb(t) {
			var e = Sy(t);
			return {
				scrollLeft: e.pageXOffset,
				scrollTop: e.pageYOffset
			}
		}

		function rb(t) {
			return Ey(By(t)).left + nb(t).scrollLeft
		}

		function ib(t) {
			var e = Iy(t),
				n = e.overflow,
				r = e.overflowX,
				i = e.overflowY;
			return /auto|scroll|overlay|hidden/.test(n + i + r)
		}

		function ob(t) {
			return ["html", "body", "#document"].indexOf(Cy(t)) >= 0 ? t.ownerDocument.body : Ty(t) && ib(t) ? t : ob(Ny(t))
		}

		function ab(t, e) {
			var n;
			void 0 === e && (e = []);
			var r = ob(t),
				i = r === (null == (n = t.ownerDocument) ? void 0 : n.body),
				o = Sy(r),
				a = i ? [o].concat(o.visualViewport || [], ib(r) ? r : []) : r,
				s = e.concat(a);
			return i ? s : s.concat(ab(Ny(a)))
		}

		function sb(t) {
			return Object.assign({}, t, {
				left: t.x,
				top: t.y,
				right: t.x + t.width,
				bottom: t.y + t.height
			})
		}

		function lb(t, e) {
			return e === my ? sb(function(t) {
				var e = Sy(t),
					n = By(t),
					r = e.visualViewport,
					i = n.clientWidth,
					o = n.clientHeight,
					a = 0,
					s = 0;
				return r && (i = r.width, o = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), {
					width: i,
					height: o,
					x: a + rb(t),
					y: s
				}
			}(t)) : Oy(e) ? function(t) {
				var e = Ey(t);
				return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e
			}(e) : sb(function(t) {
				var e, n = By(t),
					r = nb(t),
					i = null == (e = t.ownerDocument) ? void 0 : e.body,
					o = jy(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
					a = jy(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
					s = -r.scrollLeft + rb(t),
					l = -r.scrollTop;
				return "rtl" === Iy(i || n).direction && (s += jy(n.clientWidth, i ? i.clientWidth : 0) - o), {
					width: o,
					height: a,
					x: s,
					y: l
				}
			}(By(t)))
		}

		function cb(t) {
			var e, n = t.reference,
				r = t.element,
				i = t.placement,
				o = i ? Py(i) : null,
				a = i ? Xy(i) : null,
				s = n.x + n.width / 2 - r.width / 2,
				l = n.y + n.height / 2 - r.height / 2;
			switch (o) {
				case cy:
					e = {
						x: s,
						y: n.y - r.height
					};
					break;
				case uy:
					e = {
						x: s,
						y: n.y + n.height
					};
					break;
				case hy:
					e = {
						x: n.x + n.width,
						y: l
					};
					break;
				case fy:
					e = {
						x: n.x - r.width,
						y: l
					};
					break;
				default:
					e = {
						x: n.x,
						y: n.y
					}
			}
			var c = o ? Wy(o) : null;
			if (null != c) {
				var u = "y" === c ? "height" : "width";
				switch (a) {
					case gy:
						e[c] = e[c] - (n[u] / 2 - r[u] / 2);
						break;
					case vy:
						e[c] = e[c] + (n[u] / 2 - r[u] / 2)
				}
			}
			return e
		}

		function ub(t, e) {
			void 0 === e && (e = {});
			var n = e,
				r = n.placement,
				i = void 0 === r ? t.placement : r,
				o = n.boundary,
				a = void 0 === o ? "clippingParents" : o,
				s = n.rootBoundary,
				l = void 0 === s ? my : s,
				c = n.elementContext,
				u = void 0 === c ? yy : c,
				h = n.altBoundary,
				f = void 0 !== h && h,
				d = n.padding,
				p = void 0 === d ? 0 : d,
				g = Uy("number" != typeof p ? p : Hy(p, py)),
				v = u === yy ? "reference" : yy,
				m = t.rects.popper,
				y = t.elements[f ? v : u],
				b = function(t, e, n) {
					var r = "clippingParents" === e ? function(t) {
							var e = ab(Ny(t)),
								n = ["absolute", "fixed"].indexOf(Iy(t).position) >= 0 && Ty(t) ? zy(t) : t;
							return Oy(n) ? e.filter((function(t) {
								return Oy(t) && My(t, n) && "body" !== Cy(t)
							})) : []
						}(t) : [].concat(e),
						i = [].concat(r, [n]),
						o = i[0],
						a = i.reduce((function(e, n) {
							var r = lb(t, n);
							return e.top = jy(r.top, e.top), e.right = Ay(r.right, e.right), e.bottom = Ay(r.bottom, e.bottom), e.left = jy(r.left, e.left), e
						}), lb(t, o));
					return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
				}(Oy(y) ? y : y.contextElement || By(t.elements.popper), a, l),
				x = Ey(t.elements.reference),
				w = cb({
					reference: x,
					element: m,
					strategy: "absolute",
					placement: i
				}),
				C = sb(Object.assign({}, m, w)),
				S = u === yy ? C : x,
				O = {
					top: b.top - S.top + g.top,
					bottom: S.bottom - b.bottom + g.bottom,
					left: b.left - S.left + g.left,
					right: S.right - b.right + g.right
				},
				T = t.modifiersData.offset;
			if (u === yy && T) {
				var k = T[i];
				Object.keys(O).forEach((function(t) {
					var e = [hy, uy].indexOf(t) >= 0 ? 1 : -1,
						n = [cy, uy].indexOf(t) >= 0 ? "y" : "x";
					O[t] += k[n] * e
				}))
			}
			return O
		}
		var hb = {
			name: "flip",
			enabled: !0,
			phase: "main",
			fn: function(t) {
				var e = t.state,
					n = t.options,
					r = t.name;
				if (!e.modifiersData[r]._skip) {
					for (var i = n.mainAxis, o = void 0 === i || i, a = n.altAxis, s = void 0 === a || a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, h = n.rootBoundary, f = n.altBoundary, d = n.flipVariations, p = void 0 === d || d, g = n.allowedAutoPlacements, v = e.options.placement, m = Py(v), y = l || (m !== v && p ? function(t) {
							if (Py(t) === dy) return [];
							var e = $y(t);
							return [eb(t), e, eb(e)]
						}(v) : [$y(v)]), b = [v].concat(y).reduce((function(t, n) {
							return t.concat(Py(n) === dy ? function(t, e) {
								void 0 === e && (e = {});
								var n = e,
									r = n.placement,
									i = n.boundary,
									o = n.rootBoundary,
									a = n.padding,
									s = n.flipVariations,
									l = n.allowedAutoPlacements,
									c = void 0 === l ? xy : l,
									u = Xy(r),
									h = u ? s ? by : by.filter((function(t) {
										return Xy(t) === u
									})) : py,
									f = h.filter((function(t) {
										return c.indexOf(t) >= 0
									}));
								0 === f.length && (f = h);
								var d = f.reduce((function(e, n) {
									return e[n] = ub(t, {
										placement: n,
										boundary: i,
										rootBoundary: o,
										padding: a
									})[Py(n)], e
								}), {});
								return Object.keys(d).sort((function(t, e) {
									return d[t] - d[e]
								}))
							}(e, {
								placement: n,
								boundary: u,
								rootBoundary: h,
								padding: c,
								flipVariations: p,
								allowedAutoPlacements: g
							}) : n)
						}), []), x = e.rects.reference, w = e.rects.popper, C = new Map, S = !0, O = b[0], T = 0; T < b.length; T++) {
						var k = b[T],
							F = Py(k),
							P = Xy(k) === gy,
							j = [cy, uy].indexOf(F) >= 0,
							A = j ? "width" : "height",
							_ = ub(e, {
								placement: k,
								boundary: u,
								rootBoundary: h,
								altBoundary: f,
								padding: c
							}),
							E = j ? P ? hy : fy : P ? uy : cy;
						x[A] > w[A] && (E = $y(E));
						var D = $y(E),
							M = [];
						if (o && M.push(_[F] <= 0), s && M.push(_[E] <= 0, _[D] <= 0), M.every((function(t) {
								return t
							}))) {
							O = k, S = !1;
							break
						}
						C.set(k, M)
					}
					if (S)
						for (var I = function(t) {
								var e = b.find((function(e) {
									var n = C.get(e);
									if (n) return n.slice(0, t).every((function(t) {
										return t
									}))
								}));
								if (e) return O = e, "break"
							}, R = p ? 3 : 1; R > 0 && "break" !== I(R); R--);
					e.placement !== O && (e.modifiersData[r]._skip = !0, e.placement = O, e.reset = !0)
				}
			},
			requiresIfExists: ["offset"],
			data: {
				_skip: !1
			}
		};

		function fb(t, e, n) {
			return void 0 === n && (n = {
				x: 0,
				y: 0
			}), {
				top: t.top - e.height - n.y,
				right: t.right - e.width + n.x,
				bottom: t.bottom - e.height + n.y,
				left: t.left - e.width - n.x
			}
		}

		function db(t) {
			return [cy, hy, uy, fy].some((function(e) {
				return t[e] >= 0
			}))
		}
		var pb = {
				name: "hide",
				enabled: !0,
				phase: "main",
				requiresIfExists: ["preventOverflow"],
				fn: function(t) {
					var e = t.state,
						n = t.name,
						r = e.rects.reference,
						i = e.rects.popper,
						o = e.modifiersData.preventOverflow,
						a = ub(e, {
							elementContext: "reference"
						}),
						s = ub(e, {
							altBoundary: !0
						}),
						l = fb(a, r),
						c = fb(s, i, o),
						u = db(l),
						h = db(c);
					e.modifiersData[n] = {
						referenceClippingOffsets: l,
						popperEscapeOffsets: c,
						isReferenceHidden: u,
						hasPopperEscaped: h
					}, e.attributes.popper = Object.assign({}, e.attributes.popper, {
						"data-popper-reference-hidden": u,
						"data-popper-escaped": h
					})
				}
			},
			gb = {
				name: "offset",
				enabled: !0,
				phase: "main",
				requires: ["popperOffsets"],
				fn: function(t) {
					var e = t.state,
						n = t.options,
						r = t.name,
						i = n.offset,
						o = void 0 === i ? [0, 0] : i,
						a = xy.reduce((function(t, n) {
							return t[n] = function(t, e, n) {
								var r = Py(t),
									i = [fy, cy].indexOf(r) >= 0 ? -1 : 1,
									o = "function" == typeof n ? n(Object.assign({}, e, {
										placement: t
									})) : n,
									a = o[0],
									s = o[1];
								return a = a || 0, s = (s || 0) * i, [fy, hy].indexOf(r) >= 0 ? {
									x: s,
									y: a
								} : {
									x: a,
									y: s
								}
							}(n, e.rects, o), t
						}), {}),
						s = a[e.placement],
						l = s.x,
						c = s.y;
					null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a
				}
			},
			vb = {
				name: "popperOffsets",
				enabled: !0,
				phase: "read",
				fn: function(t) {
					var e = t.state,
						n = t.name;
					e.modifiersData[n] = cb({
						reference: e.rects.reference,
						element: e.rects.popper,
						strategy: "absolute",
						placement: e.placement
					})
				},
				data: {}
			},
			mb = {
				name: "preventOverflow",
				enabled: !0,
				phase: "main",
				fn: function(t) {
					var e = t.state,
						n = t.options,
						r = t.name,
						i = n.mainAxis,
						o = void 0 === i || i,
						a = n.altAxis,
						s = void 0 !== a && a,
						l = n.boundary,
						c = n.rootBoundary,
						u = n.altBoundary,
						h = n.padding,
						f = n.tether,
						d = void 0 === f || f,
						p = n.tetherOffset,
						g = void 0 === p ? 0 : p,
						v = ub(e, {
							boundary: l,
							rootBoundary: c,
							padding: h,
							altBoundary: u
						}),
						m = Py(e.placement),
						y = Xy(e.placement),
						b = !y,
						x = Wy(m),
						w = function(t) {
							return "x" === t ? "y" : "x"
						}(x),
						C = e.modifiersData.popperOffsets,
						S = e.rects.reference,
						O = e.rects.popper,
						T = "function" == typeof g ? g(Object.assign({}, e.rects, {
							placement: e.placement
						})) : g,
						k = "number" == typeof T ? {
							mainAxis: T,
							altAxis: T
						} : Object.assign({
							mainAxis: 0,
							altAxis: 0
						}, T),
						F = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
						P = {
							x: 0,
							y: 0
						};
					if (C) {
						if (o) {
							var j, A = "y" === x ? cy : fy,
								_ = "y" === x ? uy : hy,
								E = "y" === x ? "height" : "width",
								D = C[x],
								M = D + v[A],
								I = D - v[_],
								R = d ? -O[E] / 2 : 0,
								B = y === gy ? S[E] : O[E],
								N = y === gy ? -O[E] : -S[E],
								L = e.elements.arrow,
								z = d && L ? Dy(L) : {
									width: 0,
									height: 0
								},
								W = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
									top: 0,
									right: 0,
									bottom: 0,
									left: 0
								},
								V = W[A],
								U = W[_],
								H = Vy(0, S[E], z[E]),
								q = b ? S[E] / 2 - R - H - V - k.mainAxis : B - H - V - k.mainAxis,
								X = b ? -S[E] / 2 + R + H + U + k.mainAxis : N + H + U + k.mainAxis,
								G = e.elements.arrow && zy(e.elements.arrow),
								K = G ? "y" === x ? G.clientTop || 0 : G.clientLeft || 0 : 0,
								Y = null != (j = null == F ? void 0 : F[x]) ? j : 0,
								Z = D + X - Y,
								J = Vy(d ? Ay(M, D + q - Y - K) : M, D, d ? jy(I, Z) : I);
							C[x] = J, P[x] = J - D
						}
						if (s) {
							var Q, $ = "x" === x ? cy : fy,
								tt = "x" === x ? uy : hy,
								et = C[w],
								nt = "y" === w ? "height" : "width",
								rt = et + v[$],
								it = et - v[tt],
								ot = -1 !== [cy, fy].indexOf(m),
								at = null != (Q = null == F ? void 0 : F[w]) ? Q : 0,
								st = ot ? rt : et - S[nt] - O[nt] - at + k.altAxis,
								lt = ot ? et + S[nt] + O[nt] - at - k.altAxis : it,
								ct = d && ot ? function(t, e, n) {
									var r = Vy(t, e, n);
									return r > n ? n : r
								}(st, et, lt) : Vy(d ? st : rt, et, d ? lt : it);
							C[w] = ct, P[w] = ct - et
						}
						e.modifiersData[r] = P
					}
				},
				requiresIfExists: ["offset"]
			};

		function yb(t, e, n) {
			void 0 === n && (n = !1);
			var r = Ty(e),
				i = Ty(e) && function(t) {
					var e = t.getBoundingClientRect(),
						n = _y(e.width) / t.offsetWidth || 1,
						r = _y(e.height) / t.offsetHeight || 1;
					return 1 !== n || 1 !== r
				}(e),
				o = By(e),
				a = Ey(t, i),
				s = {
					scrollLeft: 0,
					scrollTop: 0
				},
				l = {
					x: 0,
					y: 0
				};
			return (r || !r && !n) && (("body" !== Cy(e) || ib(o)) && (s = function(t) {
				return t !== Sy(t) && Ty(t) ? function(t) {
					return {
						scrollLeft: t.scrollLeft,
						scrollTop: t.scrollTop
					}
				}(t) : nb(t)
			}(e)), Ty(e) ? ((l = Ey(e, !0)).x += e.clientLeft, l.y += e.clientTop) : o && (l.x = rb(o))), {
				x: a.left + s.scrollLeft - l.x,
				y: a.top + s.scrollTop - l.y,
				width: a.width,
				height: a.height
			}
		}

		function bb(t) {
			var e = new Map,
				n = new Set,
				r = [];

			function i(t) {
				n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function(t) {
					if (!n.has(t)) {
						var r = e.get(t);
						r && i(r)
					}
				})), r.push(t)
			}
			return t.forEach((function(t) {
				e.set(t.name, t)
			})), t.forEach((function(t) {
				n.has(t.name) || i(t)
			})), r
		}

		function xb(t) {
			var e;
			return function() {
				return e || (e = new Promise((function(n) {
					Promise.resolve().then((function() {
						e = void 0, n(t())
					}))
				}))), e
			}
		}
		var wb = {
			placement: "bottom",
			modifiers: [],
			strategy: "absolute"
		};

		function Cb() {
			for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
			return !e.some((function(t) {
				return !(t && "function" == typeof t.getBoundingClientRect)
			}))
		}

		function Sb(t) {
			void 0 === t && (t = {});
			var e = t,
				n = e.defaultModifiers,
				r = void 0 === n ? [] : n,
				i = e.defaultOptions,
				o = void 0 === i ? wb : i;
			return function(t, e, n) {
				void 0 === n && (n = o);
				var i = {
						placement: "bottom",
						orderedModifiers: [],
						options: Object.assign({}, wb, o),
						modifiersData: {},
						elements: {
							reference: t,
							popper: e
						},
						attributes: {},
						styles: {}
					},
					a = [],
					s = !1,
					l = {
						state: i,
						setOptions: function(n) {
							var s = "function" == typeof n ? n(i.options) : n;
							c(), i.options = Object.assign({}, o, i.options, s), i.scrollParents = {
								reference: Oy(t) ? ab(t) : t.contextElement ? ab(t.contextElement) : [],
								popper: ab(e)
							};
							var u = function(t) {
								var e = bb(t);
								return wy.reduce((function(t, n) {
									return t.concat(e.filter((function(t) {
										return t.phase === n
									})))
								}), [])
							}(function(t) {
								var e = t.reduce((function(t, e) {
									var n = t[e.name];
									return t[e.name] = n ? Object.assign({}, n, e, {
										options: Object.assign({}, n.options, e.options),
										data: Object.assign({}, n.data, e.data)
									}) : e, t
								}), {});
								return Object.keys(e).map((function(t) {
									return e[t]
								}))
							}([].concat(r, i.options.modifiers)));
							return i.orderedModifiers = u.filter((function(t) {
								return t.enabled
							})), i.orderedModifiers.forEach((function(t) {
								var e = t.name,
									n = t.options,
									r = void 0 === n ? {} : n,
									o = t.effect;
								if ("function" == typeof o) {
									var s = o({
										state: i,
										name: e,
										instance: l,
										options: r
									});
									a.push(s || function() {})
								}
							})), l.update()
						},
						forceUpdate: function() {
							if (!s) {
								var t = i.elements,
									e = t.reference,
									n = t.popper;
								if (Cb(e, n)) {
									i.rects = {
										reference: yb(e, zy(n), "fixed" === i.options.strategy),
										popper: Dy(n)
									}, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function(t) {
										return i.modifiersData[t.name] = Object.assign({}, t.data)
									}));
									for (var r = 0; r < i.orderedModifiers.length; r++)
										if (!0 !== i.reset) {
											var o = i.orderedModifiers[r],
												a = o.fn,
												c = o.options,
												u = void 0 === c ? {} : c,
												h = o.name;
											"function" == typeof a && (i = a({
												state: i,
												options: u,
												name: h,
												instance: l
											}) || i)
										} else i.reset = !1, r = -1
								}
							}
						},
						update: xb((function() {
							return new Promise((function(t) {
								l.forceUpdate(), t(i)
							}))
						})),
						destroy: function() {
							c(), s = !0
						}
					};
				if (!Cb(t, e)) return l;

				function c() {
					a.forEach((function(t) {
						return t()
					})), a = []
				}
				return l.setOptions(n).then((function(t) {
					!s && n.onFirstUpdate && n.onFirstUpdate(t)
				})), l
			}
		}
		Sb(), Sb({
			defaultModifiers: [Jy, vb, Yy, Fy]
		});
		var Ob = Sb({
			defaultModifiers: [Jy, vb, Yy, Fy, gb, hb, mb, qy, pb]
		});
		const Tb = kg({
				boundariesPadding: {
					type: Number,
					default: 0
				},
				fallbackPlacements: {
					type: Array,
					default: void 0
				},
				gpuAcceleration: {
					type: Boolean,
					default: !0
				},
				offset: {
					type: Number,
					default: 12
				},
				placement: {
					type: String,
					values: xy,
					default: "bottom"
				},
				popperOptions: {
					type: Object,
					default: () => ({})
				},
				strategy: {
					type: String,
					values: ["fixed", "absolute"],
					default: "absolute"
				}
			}),
			kb = kg({
				...Tb,
				id: String,
				style: {
					type: [String, Array, Object]
				},
				className: {
					type: [String, Array, Object]
				},
				effect: {
					type: String,
					default: "dark"
				},
				visible: Boolean,
				enterable: {
					type: Boolean,
					default: !0
				},
				pure: Boolean,
				focusOnShow: {
					type: Boolean,
					default: !1
				},
				trapping: {
					type: Boolean,
					default: !1
				},
				popperClass: {
					type: [String, Array, Object]
				},
				popperStyle: {
					type: [String, Array, Object]
				},
				referenceEl: {
					type: Object
				},
				triggerTargetEl: {
					type: Object
				},
				stopPopperMouseEvent: {
					type: Boolean,
					default: !0
				},
				ariaLabel: {
					type: String,
					default: void 0
				},
				virtualTriggering: Boolean,
				zIndex: Number
			}),
			Fb = {
				mouseenter: t => t instanceof MouseEvent,
				mouseleave: t => t instanceof MouseEvent,
				focus: () => !0,
				blur: () => !0,
				close: () => !0
			},
			Pb = kg({
				...ly,
				...kb,
				appendTo: {
					type: [String, Object]
				},
				content: {
					type: String,
					default: ""
				},
				rawContent: {
					type: Boolean,
					default: !1
				},
				persistent: Boolean,
				ariaLabel: String,
				visible: {
					type: Boolean,
					default: null
				},
				transition: String,
				teleported: {
					type: Boolean,
					default: !0
				},
				disabled: Boolean
			}),
			jb = kg({
				virtualRef: {
					type: Object
				},
				virtualTriggering: Boolean,
				onMouseenter: {
					type: Function
				},
				onMouseleave: {
					type: Function
				},
				onClick: {
					type: Function
				},
				onKeydown: {
					type: Function
				},
				onFocus: {
					type: Function
				},
				onBlur: {
					type: Function
				},
				onContextmenu: {
					type: Function
				},
				id: String,
				open: Boolean
			}),
			Ab = kg({
				...jb,
				disabled: Boolean,
				trigger: {
					type: [String, Array],
					default: "hover"
				},
				triggerKeys: {
					type: Array,
					default: () => [zm, Wm]
				}
			}),
			_b = Tg({
				type: Boolean,
				default: null
			}),
			Eb = Tg({
				type: Function
			}),
			Db = t => {
				const e = `update:${t}`,
					n = `onUpdate:${t}`;
				return {
					useModelToggle: ({
						indicator: r,
						toggleReason: i,
						shouldHideWhenRouteChanges: o,
						shouldProceed: a,
						onShow: s,
						onHide: l
					}) => {
						const c = Fr(),
							{
								emit: u
							} = c,
							h = c.props,
							f = Pe((() => T(h[n]))),
							d = Pe((() => null === h[t])),
							p = t => {
								!0 !== r.value && (r.value = !0, i && (i.value = t), T(s) && s(t))
							},
							g = t => {
								!1 !== r.value && (r.value = !1, i && (i.value = t), T(l) && l(t))
							},
							v = t => {
								if (!0 === h.disabled || T(a) && !a()) return;
								const n = f.value && tg;
								n && u(e, !0), !d.value && n || p(t)
							},
							m = t => {
								if (!0 === h.disabled || !tg) return;
								const n = f.value && tg;
								n && u(e, !1), !d.value && n || g(t)
							},
							y = t => {
								Ig(t) && (h.disabled && t ? f.value && u(e, !1) : r.value !== t && (t ? p() : g()))
							};
						return vi((() => h[t]), y), o && void 0 !== c.appContext.config.globalProperties.$route && vi((() => ({
							...c.proxy.$route
						})), (() => {
							o.value && r.value && m()
						})), on((() => {
							y(h[t])
						})), {
							hide: m,
							show: v,
							toggle: () => {
								r.value ? m() : v()
							},
							hasUpdateHandler: f
						}
					},
					useModelToggleProps: {
						[t]: _b,
						[n]: Eb
					},
					useModelToggleEmits: [e]
				}
			},
			{
				useModelToggle: Mb,
				useModelToggleProps: Ib,
				useModelToggleEmits: Rb
			} = Db("modelValue"),
			Bb = kg({
				arrowOffset: {
					type: Number,
					default: 5
				}
			}),
			{
				useModelToggleProps: Nb,
				useModelToggleEmits: Lb,
				useModelToggle: zb
			} = Db("visible"),
			Wb = kg({
				...ny,
				...Nb,
				...Pb,
				...Ab,
				...Bb,
				showArrow: {
					type: Boolean,
					default: !0
				}
			}),
			Vb = [...Lb, "before-show", "before-hide", "show", "hide", "open", "close"],
			Ub = (t, e, n) => r => {
				((t, e) => C(t) ? t.includes(e) : t === e)(we(t), e) && n(r)
			},
			Hb = (t, e, {
				checkForDefaultPrevented: n = !0
			} = {}) => r => {
				const i = null == t ? void 0 : t(r);
				if (!1 === n || !i) return null == e ? void 0 : e(r)
			},
			qb = function(t) {
				return null == t
			},
			Xb = Symbol("elForwardRef"),
			Gb = Ze({
				name: "ElOnlyChild",
				setup(t, {
					slots: e,
					attrs: n
				}) {
					var r;
					const i = We(Xb),
						o = (a = null != (r = null == i ? void 0 : i.setForwardRef) ? r : d, {
							mounted(t) {
								a(t)
							},
							updated(t) {
								a(t)
							},
							unmounted() {
								a(null)
							}
						});
					var a;
					return () => {
						var t;
						const r = null == (t = e.default) ? void 0 : t.call(e, n);
						if (!r) return null;
						if (r.length > 1) return null;
						const i = Kb(r);
						return i ? Sn(ur(i, n), [
							[o]
						]) : null
					}
				}
			});

		function Kb(t) {
			if (!t) return null;
			const e = t;
			for (const t of e) {
				if (P(t)) switch (t.type) {
					case Gn:
						continue;
					case Xn:
					case "svg":
						return Yb(t);
					case qn:
						return Kb(t.children);
					default:
						return t
				}
				return Yb(t)
			}
			return null
		}

		function Yb(t) {
			const e = Dg("only-child");
			return cr("span", {
				class: e.e("content")
			}, [t])
		}
		const Zb = Ze({
				name: "ElPopperTrigger",
				inheritAttrs: !1
			}),
			Jb = Ze({
				...Zb,
				props: jb,
				setup(t, {
					expose: e
				}) {
					const n = t,
						{
							role: r,
							triggerRef: i
						} = We(ty, void 0);
					var o;
					o = i, ze(Xb, {
						setForwardRef: t => {
							o.value = t
						}
					});
					const a = Pe((() => l.value ? n.id : void 0)),
						s = Pe((() => {
							if (r && "tooltip" === r.value) return n.open && n.id ? n.id : void 0
						})),
						l = Pe((() => {
							if (r && "tooltip" !== r.value) return r.value
						})),
						c = Pe((() => l.value ? `${n.open}` : void 0));
					let u;
					return on((() => {
						vi((() => n.virtualRef), (t => {
							t && (i.value = ag(t))
						}), {
							immediate: !0
						}), vi(i, ((t, e) => {
							null == u || u(), u = void 0, Bg(t) && (["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach((r => {
								var i;
								const o = n[r];
								o && (t.addEventListener(r.slice(2).toLowerCase(), o), null == (i = null == e ? void 0 : e.removeEventListener) || i.call(e, r.slice(2).toLowerCase(), o))
							})), u = vi([a, s, l, c], (e => {
								["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach(((n, r) => {
									qb(e[r]) ? t.removeAttribute(n) : t.setAttribute(n, e[r])
								}))
							}), {
								immediate: !0
							})), Bg(e) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((t => e.removeAttribute(t)))
						}), {
							immediate: !0
						})
					})), sn((() => {
						null == u || u(), u = void 0
					})), e({
						triggerRef: i
					}), (t, e) => t.virtualTriggering ? fr("v-if", !0) : (Jn(), nr(we(Gb), vr({
						key: 0
					}, t.$attrs, {
						"aria-controls": we(a),
						"aria-describedby": we(s),
						"aria-expanded": we(c),
						"aria-haspopup": we(l)
					}), {
						default: Ie((() => [br(t.$slots, "default")])),
						_: 3
					}, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]))
				}
			});
		var Qb = Pg(Jb, [
			["__file", "trigger.vue"]
		]);
		const $b = Ze({
				name: "ElTooltipTrigger"
			}),
			tx = Ze({
				...$b,
				props: Ab,
				setup(t, {
					expose: e
				}) {
					const n = t,
						r = Dg("tooltip"),
						{
							controlled: i,
							id: o,
							open: a,
							onOpen: s,
							onClose: c,
							onToggle: u
						} = We(ay, void 0),
						h = ve(null),
						f = () => {
							if (we(i) || n.disabled) return !0
						},
						d = ke(n, "trigger"),
						p = Hb(f, Ub(d, "hover", s)),
						g = Hb(f, Ub(d, "hover", c)),
						v = Hb(f, Ub(d, "click", (t => {
							0 === t.button && u(t)
						}))),
						m = Hb(f, Ub(d, "focus", s)),
						y = Hb(f, Ub(d, "focus", c)),
						b = Hb(f, Ub(d, "contextmenu", (t => {
							t.preventDefault(), u(t)
						}))),
						x = Hb(f, (t => {
							const {
								code: e
							} = t;
							n.triggerKeys.includes(e) && (t.preventDefault(), u(t))
						}));
					return e({
						triggerRef: h
					}), (t, e) => (Jn(), nr(we(Qb), {
						id: we(o),
						"virtual-ref": t.virtualRef,
						open: we(a),
						"virtual-triggering": t.virtualTriggering,
						class: l(we(r).e("trigger")),
						onBlur: we(y),
						onClick: we(v),
						onContextmenu: we(b),
						onFocus: we(m),
						onMouseenter: we(p),
						onMouseleave: we(g),
						onKeydown: we(x)
					}, {
						default: Ie((() => [br(t.$slots, "default")])),
						_: 3
					}, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]))
				}
			});
		var ex = Pg(tx, [
			["__file", "trigger.vue"]
		]);
		const nx = {
				prefix: Math.floor(1e4 * Math.random()),
				current: 0
			},
			rx = Symbol("elIdInjection"),
			ix = () => Fr() ? We(rx, nx) : nx,
			ox = t => {
				const e = ix(),
					n = Eg();
				return Pe((() => we(t) || `${n.value}-id-${e.prefix}-${e.current++}`))
			};
		let ax;
		const sx = () => {
				const t = Eg(),
					e = ix(),
					n = Pe((() => `${t.value}-popper-container-${e.prefix}`)),
					r = Pe((() => `#${n.value}`));
				return {
					id: n,
					selector: r
				}
			},
			lx = (t, e = []) => {
				const {
					placement: n,
					strategy: r,
					popperOptions: i
				} = t, o = {
					placement: n,
					strategy: r,
					...i,
					modifiers: [...cx(t), ...e]
				};
				return function(t, e) {
					e && (t.modifiers = [...t.modifiers, ...null != e ? e : []])
				}(o, null == i ? void 0 : i.modifiers), o
			};

		function cx(t) {
			const {
				offset: e,
				gpuAcceleration: n,
				fallbackPlacements: r
			} = t;
			return [{
				name: "offset",
				options: {
					offset: [0, null != e ? e : 12]
				}
			}, {
				name: "preventOverflow",
				options: {
					padding: {
						top: 2,
						bottom: 2,
						left: 5,
						right: 5
					}
				}
			}, {
				name: "flip",
				options: {
					padding: 5,
					fallbackPlacements: r
				}
			}, {
				name: "computeStyles",
				options: {
					gpuAcceleration: n
				}
			}]
		}
		const ux = t => {
				const {
					popperInstanceRef: e,
					contentRef: n,
					triggerRef: r,
					role: i
				} = We(ty, void 0), o = ve(), a = ve(), s = Pe((() => ({
					name: "eventListeners",
					enabled: !!t.visible
				}))), l = Pe((() => {
					var t;
					const e = we(o),
						n = null != (t = we(a)) ? t : 0;
					return {
						name: "arrow",
						enabled: (r = e, !(void 0 === r)),
						options: {
							element: e,
							padding: n
						}
					};
					var r
				})), c = Pe((() => ({
					onFirstUpdate: () => {
						p()
					},
					...lx(t, [we(l), we(s)])
				}))), u = Pe((() => (t => {
					if (tg) return ag(t)
				})(t.referenceEl) || we(r))), {
					attributes: h,
					state: f,
					styles: d,
					update: p,
					forceUpdate: g,
					instanceRef: v
				} = ((t, e, n = {}) => {
					const r = {
							name: "updateState",
							enabled: !0,
							phase: "write",
							fn: ({
								state: t
							}) => {
								const e = function(t) {
									const e = Object.keys(t.elements);
									return {
										styles: Sg(e.map((e => [e, t.styles[e] || {}]))),
										attributes: Sg(e.map((e => [e, t.attributes[e]])))
									}
								}(t);
								Object.assign(a.value, e)
							},
							requires: ["computeStyles"]
						},
						i = Pe((() => {
							const {
								onFirstUpdate: t,
								placement: e,
								strategy: i,
								modifiers: o
							} = we(n);
							return {
								onFirstUpdate: t,
								placement: e || "bottom",
								strategy: i || "absolute",
								modifiers: [...o || [], r, {
									name: "applyStyles",
									enabled: !1
								}]
							}
						})),
						o = me(),
						a = ve({
							styles: {
								popper: {
									position: we(i).strategy,
									left: "0",
									top: "0"
								},
								arrow: {
									position: "absolute"
								}
							},
							attributes: {}
						}),
						s = () => {
							o.value && (o.value.destroy(), o.value = void 0)
						};
					return vi(i, (t => {
						const e = we(o);
						e && e.setOptions(t)
					}), {
						deep: !0
					}), vi([t, e], (([t, e]) => {
						s(), t && e && (o.value = Ob(t, e, we(i)))
					})), sn((() => {
						s()
					})), {
						state: Pe((() => {
							var t;
							return {
								...(null == (t = we(o)) ? void 0 : t.state) || {}
							}
						})),
						styles: Pe((() => we(a).styles)),
						attributes: Pe((() => we(a).attributes)),
						update: () => {
							var t;
							return null == (t = we(o)) ? void 0 : t.update()
						},
						forceUpdate: () => {
							var t;
							return null == (t = we(o)) ? void 0 : t.forceUpdate()
						},
						instanceRef: Pe((() => we(o)))
					}
				})(u, n, c);
				return vi(v, (t => e.value = t)), on((() => {
					vi((() => {
						var t;
						return null == (t = we(u)) ? void 0 : t.getBoundingClientRect()
					}), (() => {
						p()
					}))
				})), {
					attributes: h,
					arrowRef: o,
					contentRef: n,
					instanceRef: v,
					state: f,
					styles: d,
					role: i,
					forceUpdate: g,
					update: p
				}
			},
			hx = Symbol("formContextKey"),
			fx = Symbol("formItemContextKey"),
			dx = "focus-trap.focus-after-trapped",
			px = "focus-trap.focus-after-released",
			gx = {
				cancelable: !0,
				bubbles: !1
			},
			vx = {
				cancelable: !0,
				bubbles: !1
			},
			mx = "focusAfterTrapped",
			yx = "focusAfterReleased",
			bx = Symbol("elFocusTrap"),
			xx = ve(),
			wx = ve(0),
			Cx = ve(0);
		let Sx = 0;
		const Ox = t => {
				const e = [],
					n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
						acceptNode: t => {
							const e = "INPUT" === t.tagName && "hidden" === t.type;
							return t.disabled || t.hidden || e ? NodeFilter.FILTER_SKIP : t.tabIndex >= 0 || t === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
						}
					});
				for (; n.nextNode();) e.push(n.currentNode);
				return e
			},
			Tx = (t, e) => {
				for (const n of t)
					if (!kx(n, e)) return n
			},
			kx = (t, e) => {
				if ("hidden" === getComputedStyle(t).visibility) return !0;
				for (; t;) {
					if (e && t === e) return !1;
					if ("none" === getComputedStyle(t).display) return !0;
					t = t.parentElement
				}
				return !1
			},
			Fx = (t, e) => {
				if (t && t.focus) {
					const n = document.activeElement;
					t.focus({
						preventScroll: !0
					}), Cx.value = window.performance.now(), t !== n && (t => t instanceof HTMLInputElement && "select" in t)(t) && e && t.select()
				}
			};

		function Px(t, e) {
			const n = [...t],
				r = t.indexOf(e);
			return -1 !== r && n.splice(r, 1), n
		}
		const jx = (() => {
				let t = [];
				return {
					push: e => {
						const n = t[0];
						n && e !== n && n.pause(), t = Px(t, e), t.unshift(e)
					},
					remove: e => {
						var n, r;
						t = Px(t, e), null == (r = null == (n = t[0]) ? void 0 : n.resume) || r.call(n)
					}
				}
			})(),
			Ax = () => {
				xx.value = "pointer", wx.value = window.performance.now()
			},
			_x = () => {
				xx.value = "keyboard", wx.value = window.performance.now()
			},
			Ex = () => (on((() => {
				0 === Sx && (document.addEventListener("mousedown", Ax), document.addEventListener("touchstart", Ax), document.addEventListener("keydown", _x)), Sx++
			})), sn((() => {
				Sx--, Sx <= 0 && (document.removeEventListener("mousedown", Ax), document.removeEventListener("touchstart", Ax), document.removeEventListener("keydown", _x))
			})), {
				focusReason: xx,
				lastUserFocusTimestamp: wx,
				lastAutomatedFocusTimestamp: Cx
			}),
			Dx = t => new CustomEvent("focus-trap.focusout-prevented", {
				...vx,
				detail: t
			});
		let Mx = [];
		const Ix = t => {
				const e = t;
				e.key === Vm && Mx.forEach((t => t(e)))
			},
			Rx = Ze({
				name: "ElFocusTrap",
				inheritAttrs: !1,
				props: {
					loop: Boolean,
					trapped: Boolean,
					focusTrapEl: Object,
					focusStartEl: {
						type: [Object, String],
						default: "first"
					}
				},
				emits: [mx, yx, "focusin", "focusout", "focusout-prevented", "release-requested"],
				setup(t, {
					emit: e
				}) {
					const n = ve();
					let r, i;
					const {
						focusReason: o
					} = Ex();
					var a;
					a = n => {
						t.trapped && !s.paused && e("release-requested", n)
					}, on((() => {
						0 === Mx.length && document.addEventListener("keydown", Ix), tg && Mx.push(a)
					})), sn((() => {
						Mx = Mx.filter((t => t !== a)), 0 === Mx.length && tg && document.removeEventListener("keydown", Ix)
					}));
					const s = {
							paused: !1,
							pause() {
								this.paused = !0
							},
							resume() {
								this.paused = !1
							}
						},
						l = n => {
							if (!t.loop && !t.trapped) return;
							if (s.paused) return;
							const {
								key: r,
								altKey: i,
								ctrlKey: a,
								metaKey: l,
								currentTarget: c,
								shiftKey: u
							} = n, {
								loop: h
							} = t, f = "Tab" === r && !i && !a && !l, d = document.activeElement;
							if (f && d) {
								const t = c,
									[r, i] = (t => {
										const e = Ox(t);
										return [Tx(e, t), Tx(e.reverse(), t)]
									})(t);
								if (r && i)
									if (u || d !== i) {
										if (u && [r, t].includes(d)) {
											const t = Dx({
												focusReason: o.value
											});
											e("focusout-prevented", t), t.defaultPrevented || (n.preventDefault(), h && Fx(i, !0))
										}
									} else {
										const t = Dx({
											focusReason: o.value
										});
										e("focusout-prevented", t), t.defaultPrevented || (n.preventDefault(), h && Fx(r, !0))
									}
								else if (d === t) {
									const t = Dx({
										focusReason: o.value
									});
									e("focusout-prevented", t), t.defaultPrevented || n.preventDefault()
								}
							}
						};
					ze(bx, {
						focusTrapRef: n,
						onKeydown: l
					}), vi((() => t.focusTrapEl), (t => {
						t && (n.value = t)
					}), {
						immediate: !0
					}), vi([n], (([t], [e]) => {
						t && (t.addEventListener("keydown", l), t.addEventListener("focusin", h), t.addEventListener("focusout", f)), e && (e.removeEventListener("keydown", l), e.removeEventListener("focusin", h), e.removeEventListener("focusout", f))
					}));
					const c = t => {
							e(mx, t)
						},
						u = t => e(yx, t),
						h = o => {
							const a = we(n);
							if (!a) return;
							const l = o.target,
								c = o.relatedTarget,
								u = l && a.contains(l);
							t.trapped || c && a.contains(c) || (r = c), u && e("focusin", o), s.paused || t.trapped && (u ? i = l : Fx(i, !0))
						},
						f = r => {
							const a = we(n);
							if (!s.paused && a)
								if (t.trapped) {
									const n = r.relatedTarget;
									qb(n) || a.contains(n) || setTimeout((() => {
										if (!s.paused && t.trapped) {
											const t = Dx({
												focusReason: o.value
											});
											e("focusout-prevented", t), t.defaultPrevented || Fx(i, !0)
										}
									}), 0)
								} else {
									const t = r.target;
									t && a.contains(t) || e("focusout", r)
								}
						};
					async function d() {
						await si();
						const e = we(n);
						if (e) {
							jx.push(s);
							const n = e.contains(document.activeElement) ? r : document.activeElement;
							if (r = n, !e.contains(n)) {
								const r = new Event(dx, gx);
								e.addEventListener(dx, c), e.dispatchEvent(r), r.defaultPrevented || si((() => {
									let r = t.focusStartEl;
									k(r) || (Fx(r), document.activeElement !== r && (r = "first")), "first" === r && ((t, e = !1) => {
										const n = document.activeElement;
										for (const r of t)
											if (Fx(r, e), document.activeElement !== n) return
									})(Ox(e), !0), document.activeElement !== n && "container" !== r || Fx(e)
								}))
							}
						}
					}

					function p() {
						const t = we(n);
						if (t) {
							t.removeEventListener(dx, c);
							const e = new CustomEvent(px, {
								...gx,
								detail: {
									focusReason: o.value
								}
							});
							t.addEventListener(px, u), t.dispatchEvent(e), e.defaultPrevented || "keyboard" != o.value && wx.value > Cx.value && !t.contains(document.activeElement) || Fx(null != r ? r : document.body), t.removeEventListener(px, u), jx.remove(s)
						}
					}
					return on((() => {
						t.trapped && d(), vi((() => t.trapped), (t => {
							t ? d() : p()
						}))
					})), sn((() => {
						t.trapped && p()
					})), {
						onKeydown: l
					}
				}
			});
		var Bx = Pg(Rx, [
			["render", function(t, e, n, r, i, o) {
				return br(t.$slots, "default", {
					handleKeydown: t.onKeydown
				})
			}],
			["__file", "focus-trap.vue"]
		]);
		const Nx = Ze({
				name: "ElPopperContent"
			}),
			Lx = Ze({
				...Nx,
				props: kb,
				emits: Fb,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t,
						{
							focusStartRef: i,
							trapped: o,
							onFocusAfterReleased: a,
							onFocusAfterTrapped: s,
							onFocusInTrap: l,
							onFocusoutPrevented: c,
							onReleaseRequested: u
						} = ((t, e) => {
							const n = ve(!1),
								r = ve();
							return {
								focusStartRef: r,
								trapped: n,
								onFocusAfterReleased: t => {
									var n;
									"pointer" !== (null == (n = t.detail) ? void 0 : n.focusReason) && (r.value = "first", e("blur"))
								},
								onFocusAfterTrapped: () => {
									e("focus")
								},
								onFocusInTrap: e => {
									t.visible && !n.value && (e.target && (r.value = e.target), n.value = !0)
								},
								onFocusoutPrevented: e => {
									t.trapping || ("pointer" === e.detail.focusReason && e.preventDefault(), n.value = !1)
								},
								onReleaseRequested: () => {
									n.value = !1, e("close")
								}
							}
						})(r, n),
						{
							attributes: h,
							arrowRef: f,
							contentRef: p,
							styles: g,
							instanceRef: v,
							role: m,
							update: y
						} = ux(r),
						{
							ariaModal: b,
							arrowStyle: x,
							contentAttrs: w,
							contentClass: C,
							contentStyle: S,
							updateZIndex: O
						} = ((t, {
							attributes: e,
							styles: n,
							role: r
						}) => {
							const {
								nextZIndex: i
							} = Am(), o = Dg("popper"), a = Pe((() => we(e).popper)), s = ve(Rg(t.zIndex) ? t.zIndex : i()), l = Pe((() => [o.b(), o.is("pure", t.pure), o.is(t.effect), t.popperClass])), c = Pe((() => [{
								zIndex: we(s)
							}, we(n).popper, t.popperStyle || {}]));
							return {
								ariaModal: Pe((() => "dialog" === r.value ? "false" : void 0)),
								arrowStyle: Pe((() => we(n).arrow || {})),
								contentAttrs: a,
								contentClass: l,
								contentStyle: c,
								contentZIndex: s,
								updateZIndex: () => {
									s.value = Rg(t.zIndex) ? t.zIndex : i()
								}
							}
						})(r, {
							styles: g,
							attributes: h,
							role: m
						}),
						T = We(fx, void 0),
						k = ve();
					let F;
					ze(ey, {
						arrowStyle: x,
						arrowRef: f,
						arrowOffset: k
					}), T && (T.addInputId || T.removeInputId) && ze(fx, {
						...T,
						addInputId: d,
						removeInputId: d
					});
					const P = (t = !0) => {
							y(), t && O()
						},
						j = () => {
							P(!1), r.visible && r.focusOnShow ? o.value = !0 : !1 === r.visible && (o.value = !1)
						};
					return on((() => {
						vi((() => r.triggerTargetEl), ((t, e) => {
							null == F || F(), F = void 0;
							const n = we(t || p.value),
								i = we(e || p.value);
							Bg(n) && (F = vi([m, () => r.ariaLabel, b, () => r.id], (t => {
								["role", "aria-label", "aria-modal", "id"].forEach(((e, r) => {
									qb(t[r]) ? n.removeAttribute(e) : n.setAttribute(e, t[r])
								}))
							}), {
								immediate: !0
							})), i !== n && Bg(i) && ["role", "aria-label", "aria-modal", "id"].forEach((t => {
								i.removeAttribute(t)
							}))
						}), {
							immediate: !0
						}), vi((() => r.visible), j, {
							immediate: !0
						})
					})), sn((() => {
						null == F || F(), F = void 0
					})), e({
						popperContentRef: p,
						popperInstanceRef: v,
						updatePopper: P,
						contentStyle: S
					}), (t, e) => (Jn(), er("div", vr({
						ref_key: "contentRef",
						ref: p
					}, we(w), {
						style: we(S),
						class: we(C),
						tabindex: "-1",
						onMouseenter: e[0] || (e[0] = e => t.$emit("mouseenter", e)),
						onMouseleave: e[1] || (e[1] = e => t.$emit("mouseleave", e))
					}), [cr(we(Bx), {
						trapped: we(o),
						"trap-on-focus-in": !0,
						"focus-trap-el": we(p),
						"focus-start-el": we(i),
						onFocusAfterTrapped: we(s),
						onFocusAfterReleased: we(a),
						onFocusin: we(l),
						onFocusoutPrevented: we(c),
						onReleaseRequested: we(u)
					}, {
						default: Ie((() => [br(t.$slots, "default")])),
						_: 3
					}, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])], 16))
				}
			});
		var zx = Pg(Lx, [
			["__file", "content.vue"]
		]);
		const Wx = Ze({
				name: "ElTooltipContent",
				inheritAttrs: !1
			}),
			Vx = Ze({
				...Wx,
				props: Pb,
				setup(t, {
					expose: e
				}) {
					const n = t,
						{
							selector: r
						} = sx(),
						i = Dg("tooltip"),
						o = ve(null),
						a = ve(!1),
						{
							controlled: s,
							id: l,
							open: c,
							trigger: u,
							onClose: h,
							onOpen: f,
							onShow: d,
							onHide: p,
							onBeforeShow: g,
							onBeforeHide: v
						} = We(ay, void 0),
						m = Pe((() => n.transition || `${i.namespace.value}-fade-in-linear`)),
						y = Pe((() => n.persistent));
					sn((() => {
						a.value = !0
					}));
					const b = Pe((() => !!we(y) || we(c))),
						x = Pe((() => !n.disabled && we(c))),
						w = Pe((() => n.appendTo || r.value)),
						C = Pe((() => {
							var t;
							return null != (t = n.style) ? t : {}
						})),
						S = Pe((() => !we(c))),
						O = () => {
							p()
						},
						T = () => {
							if (we(s)) return !0
						},
						k = Hb(T, (() => {
							n.enterable && "hover" === we(u) && f()
						})),
						F = Hb(T, (() => {
							"hover" === we(u) && h()
						})),
						P = () => {
							var t, e;
							null == (e = null == (t = o.value) ? void 0 : t.updatePopper) || e.call(t), null == g || g()
						},
						j = () => {
							null == v || v()
						},
						A = () => {
							d(), E = function(t, e, n = {}) {
								const {
									window: r = sg,
									ignore: i = [],
									capture: o = !0,
									detectIframe: a = !1
								} = n;
								if (!r) return;
								rg && !cg && (cg = !0, Array.from(r.document.body.children).forEach((t => t.addEventListener("click", ng))));
								let s = !0;
								const l = t => i.some((e => {
										if ("string" == typeof e) return Array.from(r.document.querySelectorAll(e)).some((e => e === t.target || t.composedPath().includes(e)));
										{
											const n = ag(e);
											return n && (t.target === n || t.composedPath().includes(n))
										}
									})),
									c = [lg(r, "click", (n => {
										const r = ag(t);
										r && r !== n.target && !n.composedPath().includes(r) && (0 === n.detail && (s = !l(n)), s ? e(n) : s = !0)
									}), {
										passive: !0,
										capture: o
									}), lg(r, "pointerdown", (e => {
										const n = ag(t);
										n && (s = !e.composedPath().includes(n) && !l(e))
									}), {
										passive: !0
									}), a && lg(r, "blur", (n => {
										var i;
										const o = ag(t);
										"IFRAME" !== (null == (i = r.document.activeElement) ? void 0 : i.tagName) || (null == o ? void 0 : o.contains(r.document.activeElement)) || e(n)
									}))].filter(Boolean);
								return () => c.forEach((t => t()))
							}(Pe((() => {
								var t;
								return null == (t = o.value) ? void 0 : t.popperContentRef
							})), (() => {
								we(s) || "hover" !== we(u) && h()
							}))
						},
						_ = () => {
							n.virtualTriggering || h()
						};
					let E;
					return vi((() => we(c)), (t => {
						t || null == E || E()
					}), {
						flush: "post"
					}), vi((() => n.content), (() => {
						var t, e;
						null == (e = null == (t = o.value) ? void 0 : t.updatePopper) || e.call(t)
					})), e({
						contentRef: o
					}), (t, e) => (Jn(), nr(Nn, {
						disabled: !t.teleported,
						to: we(w)
					}, [cr(Hi, {
						name: we(m),
						onAfterLeave: O,
						onBeforeEnter: P,
						onAfterEnter: A,
						onBeforeLeave: j
					}, {
						default: Ie((() => [we(b) ? Sn((Jn(), nr(we(zx), vr({
							key: 0,
							id: we(l),
							ref_key: "contentRef",
							ref: o
						}, t.$attrs, {
							"aria-label": t.ariaLabel,
							"aria-hidden": we(S),
							"boundaries-padding": t.boundariesPadding,
							"fallback-placements": t.fallbackPlacements,
							"gpu-acceleration": t.gpuAcceleration,
							offset: t.offset,
							placement: t.placement,
							"popper-options": t.popperOptions,
							strategy: t.strategy,
							effect: t.effect,
							enterable: t.enterable,
							pure: t.pure,
							"popper-class": t.popperClass,
							"popper-style": [t.popperStyle, we(C)],
							"reference-el": t.referenceEl,
							"trigger-target-el": t.triggerTargetEl,
							visible: we(x),
							"z-index": t.zIndex,
							onMouseenter: we(k),
							onMouseleave: we(F),
							onBlur: _,
							onClose: we(h)
						}), {
							default: Ie((() => [a.value ? fr("v-if", !0) : br(t.$slots, "default", {
								key: 0
							})])),
							_: 3
						}, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
							[ho, we(x)]
						]) : fr("v-if", !0)])),
						_: 3
					}, 8, ["name"])], 8, ["disabled", "to"]))
				}
			});
		var Ux = Pg(Vx, [
			["__file", "content.vue"]
		]);
		const Hx = Ze({
			name: "ElPopperArrow",
			inheritAttrs: !1
		});
		var qx = Pg(Ze({
			...Hx,
			props: Bb,
			setup(t, {
				expose: e
			}) {
				const n = t,
					r = Dg("popper"),
					{
						arrowOffset: o,
						arrowRef: a,
						arrowStyle: s
					} = We(ey, void 0);
				return vi((() => n.arrowOffset), (t => {
					o.value = t
				})), sn((() => {
					a.value = void 0
				})), e({
					arrowRef: a
				}), (t, e) => (Jn(), er("span", {
					ref_key: "arrowRef",
					ref: a,
					class: l(we(r).e("arrow")),
					style: i(we(s)),
					"data-popper-arrow": ""
				}, null, 6))
			}
		}), [
			["__file", "arrow.vue"]
		]);
		const Xx = ["innerHTML"],
			Gx = {
				key: 1
			},
			Kx = Ze({
				name: "ElTooltip"
			}),
			Yx = Ze({
				...Kx,
				props: Wb,
				emits: Vb,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t;
					(() => {
						const {
							id: t,
							selector: e
						} = sx();
						rn((() => {
							tg && (ax || document.body.querySelector(e.value) || (ax = (t => {
								const e = document.createElement("div");
								return e.id = t, document.body.appendChild(e), e
							})(t.value)))
						}))
					})();
					const i = ox(),
						o = ve(),
						a = ve(),
						s = () => {
							var t;
							const e = we(o);
							e && (null == (t = e.popperInstanceRef) || t.update())
						},
						l = ve(!1),
						u = ve(),
						{
							show: h,
							hide: f,
							hasUpdateHandler: d
						} = zb({
							indicator: l,
							toggleReason: u
						}),
						{
							onOpen: p,
							onClose: g
						} = (({
							showAfter: t,
							hideAfter: e,
							autoClose: n,
							open: r,
							close: i
						}) => {
							const {
								registerTimeout: o
							} = sy(), {
								registerTimeout: a,
								cancelTimeout: s
							} = sy();
							return {
								onOpen: e => {
									o((() => {
										r(e);
										const t = we(n);
										Rg(t) && t > 0 && a((() => {
											i(e)
										}), t)
									}), we(t))
								},
								onClose: t => {
									s(), o((() => {
										i(t)
									}), we(e))
								}
							}
						})({
							showAfter: ke(r, "showAfter"),
							hideAfter: ke(r, "hideAfter"),
							autoClose: ke(r, "autoClose"),
							open: h,
							close: f
						}),
						v = Pe((() => Ig(r.visible) && !d.value));
					return ze(ay, {
						controlled: v,
						id: i,
						open: oe(l),
						trigger: ke(r, "trigger"),
						onOpen: t => {
							p(t)
						},
						onClose: t => {
							g(t)
						},
						onToggle: t => {
							we(l) ? g(t) : p(t)
						},
						onShow: () => {
							n("show", u.value)
						},
						onHide: () => {
							n("hide", u.value)
						},
						onBeforeShow: () => {
							n("before-show", u.value)
						},
						onBeforeHide: () => {
							n("before-hide", u.value)
						},
						updatePopper: s
					}), vi((() => r.disabled), (t => {
						t && l.value && (l.value = !1)
					})), $e((() => l.value && f())), e({
						popperRef: o,
						contentRef: a,
						isFocusInsideContent: t => {
							var e, n;
							const r = null == (n = null == (e = a.value) ? void 0 : e.contentRef) ? void 0 : n.popperContentRef,
								i = (null == t ? void 0 : t.relatedTarget) || document.activeElement;
							return r && r.contains(i)
						},
						updatePopper: s,
						onOpen: p,
						onClose: g,
						hide: f
					}), (t, e) => (Jn(), nr(we(oy), {
						ref_key: "popperRef",
						ref: o,
						role: t.role
					}, {
						default: Ie((() => [cr(ex, {
							disabled: t.disabled,
							trigger: t.trigger,
							"trigger-keys": t.triggerKeys,
							"virtual-ref": t.virtualRef,
							"virtual-triggering": t.virtualTriggering
						}, {
							default: Ie((() => [t.$slots.default ? br(t.$slots, "default", {
								key: 0
							}) : fr("v-if", !0)])),
							_: 3
						}, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]), cr(Ux, {
							ref_key: "contentRef",
							ref: a,
							"aria-label": t.ariaLabel,
							"boundaries-padding": t.boundariesPadding,
							content: t.content,
							disabled: t.disabled,
							effect: t.effect,
							enterable: t.enterable,
							"fallback-placements": t.fallbackPlacements,
							"hide-after": t.hideAfter,
							"gpu-acceleration": t.gpuAcceleration,
							offset: t.offset,
							persistent: t.persistent,
							"popper-class": t.popperClass,
							"popper-style": t.popperStyle,
							placement: t.placement,
							"popper-options": t.popperOptions,
							pure: t.pure,
							"raw-content": t.rawContent,
							"reference-el": t.referenceEl,
							"trigger-target-el": t.triggerTargetEl,
							"show-after": t.showAfter,
							strategy: t.strategy,
							teleported: t.teleported,
							transition: t.transition,
							"virtual-triggering": t.virtualTriggering,
							"z-index": t.zIndex,
							"append-to": t.appendTo
						}, {
							default: Ie((() => [br(t.$slots, "content", {}, (() => [t.rawContent ? (Jn(), er("span", {
								key: 0,
								innerHTML: t.content
							}, null, 8, Xx)) : (Jn(), er("span", Gx, c(t.content), 1))])), t.showArrow ? (Jn(), nr(we(qx), {
								key: 0,
								"arrow-offset": t.arrowOffset
							}, null, 8, ["arrow-offset"])) : fr("v-if", !0)])),
							_: 3
						}, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])])),
						_: 3
					}, 8, ["role"]))
				}
			}),
			Zx = zg(Pg(Yx, [
				["__file", "tooltip.vue"]
			])),
			Jx = Symbol("buttonGroupContextKey"),
			Qx = ({
				from: t,
				replacement: e,
				scope: n,
				version: r,
				ref: i,
				type: o = "API"
			}, a) => {
				vi((() => we(a)), (t => {}), {
					immediate: !0
				})
			},
			$x = () => ({
				form: We(hx, void 0),
				formItem: We(fx, void 0)
			}),
			tw = (t, {
				formItemContext: e,
				disableIdGeneration: n,
				disableIdManagement: r
			}) => {
				n || (n = ve(!1)), r || (r = ve(!1));
				const i = ve();
				let o;
				const a = Pe((() => {
					var n;
					return !!(!t.label && e && e.inputIds && (null == (n = e.inputIds) ? void 0 : n.length) <= 1)
				}));
				return on((() => {
					o = vi([ke(t, "id"), n], (([t, n]) => {
						const o = null != t ? t : n ? void 0 : ox().value;
						o !== i.value && ((null == e ? void 0 : e.removeInputId) && (i.value && e.removeInputId(i.value), (null == r ? void 0 : r.value) || n || !o || e.addInputId(o)), i.value = o)
					}), {
						immediate: !0
					})
				})), ln((() => {
					o && o(), (null == e ? void 0 : e.removeInputId) && i.value && e.removeInputId(i.value)
				})), {
					isLabeledByFormItem: a,
					inputId: i
				}
			},
			ew = t => {
				const e = Fr();
				return Pe((() => {
					var n, r;
					return null == (r = null == (n = null == e ? void 0 : e.proxy) ? void 0 : n.$props) ? void 0 : r[t]
				}))
			},
			nw = (t, e = {}) => {
				const n = ve(void 0),
					r = e.prop ? n : ew("size"),
					i = e.global ? n : (() => {
						const t = We(Mm, {});
						return Pe((() => we(t.size) || ""))
					})(),
					o = e.form ? {
						size: void 0
					} : We(hx, void 0),
					a = e.formItem ? {
						size: void 0
					} : We(fx, void 0);
				return Pe((() => r.value || we(t) || (null == a ? void 0 : a.size) || (null == o ? void 0 : o.size) || i.value || ""))
			},
			rw = t => {
				const e = ew("disabled"),
					n = We(hx, void 0);
				return Pe((() => e.value || we(t) || (null == n ? void 0 : n.disabled) || !1))
			},
			iw = kg({
				size: Dm,
				disabled: Boolean,
				type: {
					type: String,
					values: ["default", "primary", "success", "warning", "info", "danger", "text", ""],
					default: ""
				},
				icon: {
					type: uv
				},
				nativeType: {
					type: String,
					values: ["button", "submit", "reset"],
					default: "button"
				},
				loading: Boolean,
				loadingIcon: {
					type: uv,
					default: () => iv
				},
				plain: Boolean,
				text: Boolean,
				link: Boolean,
				bg: Boolean,
				autofocus: Boolean,
				round: Boolean,
				circle: Boolean,
				color: String,
				dark: Boolean,
				autoInsertSpace: {
					type: Boolean,
					default: void 0
				},
				tag: {
					type: [String, Object],
					default: "button"
				}
			}),
			ow = {
				click: t => t instanceof MouseEvent
			};

		function aw(t, e) {
			(function(t) {
				return "string" == typeof t && -1 !== t.indexOf(".") && 1 === parseFloat(t)
			})(t) && (t = "100%");
			var n = function(t) {
				return "string" == typeof t && -1 !== t.indexOf("%")
			}(t);
			return t = 360 === e ? t : Math.min(e, Math.max(0, parseFloat(t))), n && (t = parseInt(String(t * e), 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t = 360 === e ? (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t % e / parseFloat(String(e))
		}

		function sw(t) {
			return Math.min(1, Math.max(0, t))
		}

		function lw(t) {
			return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
		}

		function cw(t) {
			return t <= 1 ? "".concat(100 * Number(t), "%") : t
		}

		function uw(t) {
			return 1 === t.length ? "0" + t : String(t)
		}

		function hw(t, e, n) {
			t = aw(t, 255), e = aw(e, 255), n = aw(n, 255);
			var r = Math.max(t, e, n),
				i = Math.min(t, e, n),
				o = 0,
				a = 0,
				s = (r + i) / 2;
			if (r === i) a = 0, o = 0;
			else {
				var l = r - i;
				switch (a = s > .5 ? l / (2 - r - i) : l / (r + i), r) {
					case t:
						o = (e - n) / l + (e < n ? 6 : 0);
						break;
					case e:
						o = (n - t) / l + 2;
						break;
					case n:
						o = (t - e) / l + 4
				}
				o /= 6
			}
			return {
				h: o,
				s: a,
				l: s
			}
		}

		function fw(t, e, n) {
			return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * n * (e - t) : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
		}

		function dw(t, e, n) {
			t = aw(t, 255), e = aw(e, 255), n = aw(n, 255);
			var r = Math.max(t, e, n),
				i = Math.min(t, e, n),
				o = 0,
				a = r,
				s = r - i,
				l = 0 === r ? 0 : s / r;
			if (r === i) o = 0;
			else {
				switch (r) {
					case t:
						o = (e - n) / s + (e < n ? 6 : 0);
						break;
					case e:
						o = (n - t) / s + 2;
						break;
					case n:
						o = (t - e) / s + 4
				}
				o /= 6
			}
			return {
				h: o,
				s: l,
				v: a
			}
		}

		function pw(t, e, n, r) {
			var i = [uw(Math.round(t).toString(16)), uw(Math.round(e).toString(16)), uw(Math.round(n).toString(16))];
			return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
		}

		function gw(t) {
			return vw(t) / 255
		}

		function vw(t) {
			return parseInt(t, 16)
		}
		var mw = {
			aliceblue: "#f0f8ff",
			antiquewhite: "#faebd7",
			aqua: "#00ffff",
			aquamarine: "#7fffd4",
			azure: "#f0ffff",
			beige: "#f5f5dc",
			bisque: "#ffe4c4",
			black: "#000000",
			blanchedalmond: "#ffebcd",
			blue: "#0000ff",
			blueviolet: "#8a2be2",
			brown: "#a52a2a",
			burlywood: "#deb887",
			cadetblue: "#5f9ea0",
			chartreuse: "#7fff00",
			chocolate: "#d2691e",
			coral: "#ff7f50",
			cornflowerblue: "#6495ed",
			cornsilk: "#fff8dc",
			crimson: "#dc143c",
			cyan: "#00ffff",
			darkblue: "#00008b",
			darkcyan: "#008b8b",
			darkgoldenrod: "#b8860b",
			darkgray: "#a9a9a9",
			darkgreen: "#006400",
			darkgrey: "#a9a9a9",
			darkkhaki: "#bdb76b",
			darkmagenta: "#8b008b",
			darkolivegreen: "#556b2f",
			darkorange: "#ff8c00",
			darkorchid: "#9932cc",
			darkred: "#8b0000",
			darksalmon: "#e9967a",
			darkseagreen: "#8fbc8f",
			darkslateblue: "#483d8b",
			darkslategray: "#2f4f4f",
			darkslategrey: "#2f4f4f",
			darkturquoise: "#00ced1",
			darkviolet: "#9400d3",
			deeppink: "#ff1493",
			deepskyblue: "#00bfff",
			dimgray: "#696969",
			dimgrey: "#696969",
			dodgerblue: "#1e90ff",
			firebrick: "#b22222",
			floralwhite: "#fffaf0",
			forestgreen: "#228b22",
			fuchsia: "#ff00ff",
			gainsboro: "#dcdcdc",
			ghostwhite: "#f8f8ff",
			goldenrod: "#daa520",
			gold: "#ffd700",
			gray: "#808080",
			green: "#008000",
			greenyellow: "#adff2f",
			grey: "#808080",
			honeydew: "#f0fff0",
			hotpink: "#ff69b4",
			indianred: "#cd5c5c",
			indigo: "#4b0082",
			ivory: "#fffff0",
			khaki: "#f0e68c",
			lavenderblush: "#fff0f5",
			lavender: "#e6e6fa",
			lawngreen: "#7cfc00",
			lemonchiffon: "#fffacd",
			lightblue: "#add8e6",
			lightcoral: "#f08080",
			lightcyan: "#e0ffff",
			lightgoldenrodyellow: "#fafad2",
			lightgray: "#d3d3d3",
			lightgreen: "#90ee90",
			lightgrey: "#d3d3d3",
			lightpink: "#ffb6c1",
			lightsalmon: "#ffa07a",
			lightseagreen: "#20b2aa",
			lightskyblue: "#87cefa",
			lightslategray: "#778899",
			lightslategrey: "#778899",
			lightsteelblue: "#b0c4de",
			lightyellow: "#ffffe0",
			lime: "#00ff00",
			limegreen: "#32cd32",
			linen: "#faf0e6",
			magenta: "#ff00ff",
			maroon: "#800000",
			mediumaquamarine: "#66cdaa",
			mediumblue: "#0000cd",
			mediumorchid: "#ba55d3",
			mediumpurple: "#9370db",
			mediumseagreen: "#3cb371",
			mediumslateblue: "#7b68ee",
			mediumspringgreen: "#00fa9a",
			mediumturquoise: "#48d1cc",
			mediumvioletred: "#c71585",
			midnightblue: "#191970",
			mintcream: "#f5fffa",
			mistyrose: "#ffe4e1",
			moccasin: "#ffe4b5",
			navajowhite: "#ffdead",
			navy: "#000080",
			oldlace: "#fdf5e6",
			olive: "#808000",
			olivedrab: "#6b8e23",
			orange: "#ffa500",
			orangered: "#ff4500",
			orchid: "#da70d6",
			palegoldenrod: "#eee8aa",
			palegreen: "#98fb98",
			paleturquoise: "#afeeee",
			palevioletred: "#db7093",
			papayawhip: "#ffefd5",
			peachpuff: "#ffdab9",
			peru: "#cd853f",
			pink: "#ffc0cb",
			plum: "#dda0dd",
			powderblue: "#b0e0e6",
			purple: "#800080",
			rebeccapurple: "#663399",
			red: "#ff0000",
			rosybrown: "#bc8f8f",
			royalblue: "#4169e1",
			saddlebrown: "#8b4513",
			salmon: "#fa8072",
			sandybrown: "#f4a460",
			seagreen: "#2e8b57",
			seashell: "#fff5ee",
			sienna: "#a0522d",
			silver: "#c0c0c0",
			skyblue: "#87ceeb",
			slateblue: "#6a5acd",
			slategray: "#708090",
			slategrey: "#708090",
			snow: "#fffafa",
			springgreen: "#00ff7f",
			steelblue: "#4682b4",
			tan: "#d2b48c",
			teal: "#008080",
			thistle: "#d8bfd8",
			tomato: "#ff6347",
			turquoise: "#40e0d0",
			violet: "#ee82ee",
			wheat: "#f5deb3",
			white: "#ffffff",
			whitesmoke: "#f5f5f5",
			yellow: "#ffff00",
			yellowgreen: "#9acd32"
		};
		var yw = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")"),
			bw = "[\\s|\\(]+(".concat(yw, ")[,|\\s]+(").concat(yw, ")[,|\\s]+(").concat(yw, ")\\s*\\)?"),
			xw = "[\\s|\\(]+(".concat(yw, ")[,|\\s]+(").concat(yw, ")[,|\\s]+(").concat(yw, ")[,|\\s]+(").concat(yw, ")\\s*\\)?"),
			ww = {
				CSS_UNIT: new RegExp(yw),
				rgb: new RegExp("rgb" + bw),
				rgba: new RegExp("rgba" + xw),
				hsl: new RegExp("hsl" + bw),
				hsla: new RegExp("hsla" + xw),
				hsv: new RegExp("hsv" + bw),
				hsva: new RegExp("hsva" + xw),
				hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
				hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
				hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
				hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
			};

		function Cw(t) {
			return Boolean(ww.CSS_UNIT.exec(String(t)))
		}
		var Sw = function() {
			function t(e, n) {
				var r;
				if (void 0 === e && (e = ""), void 0 === n && (n = {}), e instanceof t) return e;
				"number" == typeof e && (e = function(t) {
					return {
						r: t >> 16,
						g: (65280 & t) >> 8,
						b: 255 & t
					}
				}(e)), this.originalInput = e;
				var i = function(t) {
					var e, n, r, i = {
							r: 0,
							g: 0,
							b: 0
						},
						o = 1,
						a = null,
						s = null,
						l = null,
						c = !1,
						u = !1;
					return "string" == typeof t && (t = function(t) {
						if (0 === (t = t.trim().toLowerCase()).length) return !1;
						var e = !1;
						if (mw[t]) t = mw[t], e = !0;
						else if ("transparent" === t) return {
							r: 0,
							g: 0,
							b: 0,
							a: 0,
							format: "name"
						};
						var n = ww.rgb.exec(t);
						return n ? {
							r: n[1],
							g: n[2],
							b: n[3]
						} : (n = ww.rgba.exec(t)) ? {
							r: n[1],
							g: n[2],
							b: n[3],
							a: n[4]
						} : (n = ww.hsl.exec(t)) ? {
							h: n[1],
							s: n[2],
							l: n[3]
						} : (n = ww.hsla.exec(t)) ? {
							h: n[1],
							s: n[2],
							l: n[3],
							a: n[4]
						} : (n = ww.hsv.exec(t)) ? {
							h: n[1],
							s: n[2],
							v: n[3]
						} : (n = ww.hsva.exec(t)) ? {
							h: n[1],
							s: n[2],
							v: n[3],
							a: n[4]
						} : (n = ww.hex8.exec(t)) ? {
							r: vw(n[1]),
							g: vw(n[2]),
							b: vw(n[3]),
							a: gw(n[4]),
							format: e ? "name" : "hex8"
						} : (n = ww.hex6.exec(t)) ? {
							r: vw(n[1]),
							g: vw(n[2]),
							b: vw(n[3]),
							format: e ? "name" : "hex"
						} : (n = ww.hex4.exec(t)) ? {
							r: vw(n[1] + n[1]),
							g: vw(n[2] + n[2]),
							b: vw(n[3] + n[3]),
							a: gw(n[4] + n[4]),
							format: e ? "name" : "hex8"
						} : !!(n = ww.hex3.exec(t)) && {
							r: vw(n[1] + n[1]),
							g: vw(n[2] + n[2]),
							b: vw(n[3] + n[3]),
							format: e ? "name" : "hex"
						}
					}(t)), "object" == typeof t && (Cw(t.r) && Cw(t.g) && Cw(t.b) ? (e = t.r, n = t.g, r = t.b, i = {
						r: 255 * aw(e, 255),
						g: 255 * aw(n, 255),
						b: 255 * aw(r, 255)
					}, c = !0, u = "%" === String(t.r).substr(-1) ? "prgb" : "rgb") : Cw(t.h) && Cw(t.s) && Cw(t.v) ? (a = cw(t.s), s = cw(t.v), i = function(t, e, n) {
						t = 6 * aw(t, 360), e = aw(e, 100), n = aw(n, 100);
						var r = Math.floor(t),
							i = t - r,
							o = n * (1 - e),
							a = n * (1 - i * e),
							s = n * (1 - (1 - i) * e),
							l = r % 6;
						return {
							r: 255 * [n, a, o, o, s, n][l],
							g: 255 * [s, n, n, a, o, o][l],
							b: 255 * [o, o, s, n, n, a][l]
						}
					}(t.h, a, s), c = !0, u = "hsv") : Cw(t.h) && Cw(t.s) && Cw(t.l) && (a = cw(t.s), l = cw(t.l), i = function(t, e, n) {
						var r, i, o;
						if (t = aw(t, 360), e = aw(e, 100), n = aw(n, 100), 0 === e) i = n, o = n, r = n;
						else {
							var a = n < .5 ? n * (1 + e) : n + e - n * e,
								s = 2 * n - a;
							r = fw(s, a, t + 1 / 3), i = fw(s, a, t), o = fw(s, a, t - 1 / 3)
						}
						return {
							r: 255 * r,
							g: 255 * i,
							b: 255 * o
						}
					}(t.h, a, l), c = !0, u = "hsl"), Object.prototype.hasOwnProperty.call(t, "a") && (o = t.a)), o = lw(o), {
						ok: c,
						format: t.format || u,
						r: Math.min(255, Math.max(i.r, 0)),
						g: Math.min(255, Math.max(i.g, 0)),
						b: Math.min(255, Math.max(i.b, 0)),
						a: o
					}
				}(e);
				this.originalInput = e, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = null !== (r = n.format) && void 0 !== r ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok
			}
			return t.prototype.isDark = function() {
				return this.getBrightness() < 128
			}, t.prototype.isLight = function() {
				return !this.isDark()
			}, t.prototype.getBrightness = function() {
				var t = this.toRgb();
				return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3
			}, t.prototype.getLuminance = function() {
				var t = this.toRgb(),
					e = t.r / 255,
					n = t.g / 255,
					r = t.b / 255;
				return .2126 * (e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)) + .7152 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)) + .0722 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4))
			}, t.prototype.getAlpha = function() {
				return this.a
			}, t.prototype.setAlpha = function(t) {
				return this.a = lw(t), this.roundA = Math.round(100 * this.a) / 100, this
			}, t.prototype.isMonochrome = function() {
				return 0 === this.toHsl().s
			}, t.prototype.toHsv = function() {
				var t = dw(this.r, this.g, this.b);
				return {
					h: 360 * t.h,
					s: t.s,
					v: t.v,
					a: this.a
				}
			}, t.prototype.toHsvString = function() {
				var t = dw(this.r, this.g, this.b),
					e = Math.round(360 * t.h),
					n = Math.round(100 * t.s),
					r = Math.round(100 * t.v);
				return 1 === this.a ? "hsv(".concat(e, ", ").concat(n, "%, ").concat(r, "%)") : "hsva(".concat(e, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")")
			}, t.prototype.toHsl = function() {
				var t = hw(this.r, this.g, this.b);
				return {
					h: 360 * t.h,
					s: t.s,
					l: t.l,
					a: this.a
				}
			}, t.prototype.toHslString = function() {
				var t = hw(this.r, this.g, this.b),
					e = Math.round(360 * t.h),
					n = Math.round(100 * t.s),
					r = Math.round(100 * t.l);
				return 1 === this.a ? "hsl(".concat(e, ", ").concat(n, "%, ").concat(r, "%)") : "hsla(".concat(e, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")")
			}, t.prototype.toHex = function(t) {
				return void 0 === t && (t = !1), pw(this.r, this.g, this.b, t)
			}, t.prototype.toHexString = function(t) {
				return void 0 === t && (t = !1), "#" + this.toHex(t)
			}, t.prototype.toHex8 = function(t) {
				return void 0 === t && (t = !1),
					function(t, e, n, r, i) {
						var o, a = [uw(Math.round(t).toString(16)), uw(Math.round(e).toString(16)), uw(Math.round(n).toString(16)), uw((o = r, Math.round(255 * parseFloat(o)).toString(16)))];
						return i && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("")
					}(this.r, this.g, this.b, this.a, t)
			}, t.prototype.toHex8String = function(t) {
				return void 0 === t && (t = !1), "#" + this.toHex8(t)
			}, t.prototype.toHexShortString = function(t) {
				return void 0 === t && (t = !1), 1 === this.a ? this.toHexString(t) : this.toHex8String(t)
			}, t.prototype.toRgb = function() {
				return {
					r: Math.round(this.r),
					g: Math.round(this.g),
					b: Math.round(this.b),
					a: this.a
				}
			}, t.prototype.toRgbString = function() {
				var t = Math.round(this.r),
					e = Math.round(this.g),
					n = Math.round(this.b);
				return 1 === this.a ? "rgb(".concat(t, ", ").concat(e, ", ").concat(n, ")") : "rgba(".concat(t, ", ").concat(e, ", ").concat(n, ", ").concat(this.roundA, ")")
			}, t.prototype.toPercentageRgb = function() {
				var t = function(t) {
					return "".concat(Math.round(100 * aw(t, 255)), "%")
				};
				return {
					r: t(this.r),
					g: t(this.g),
					b: t(this.b),
					a: this.a
				}
			}, t.prototype.toPercentageRgbString = function() {
				var t = function(t) {
					return Math.round(100 * aw(t, 255))
				};
				return 1 === this.a ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")")
			}, t.prototype.toName = function() {
				if (0 === this.a) return "transparent";
				if (this.a < 1) return !1;
				for (var t = "#" + pw(this.r, this.g, this.b, !1), e = 0, n = Object.entries(mw); e < n.length; e++) {
					var r = n[e],
						i = r[0];
					if (t === r[1]) return i
				}
				return !1
			}, t.prototype.toString = function(t) {
				var e = Boolean(t);
				t = null != t ? t : this.format;
				var n = !1,
					r = this.a < 1 && this.a >= 0;
				return e || !r || !t.startsWith("hex") && "name" !== t ? ("rgb" === t && (n = this.toRgbString()), "prgb" === t && (n = this.toPercentageRgbString()), "hex" !== t && "hex6" !== t || (n = this.toHexString()), "hex3" === t && (n = this.toHexString(!0)), "hex4" === t && (n = this.toHex8String(!0)), "hex8" === t && (n = this.toHex8String()), "name" === t && (n = this.toName()), "hsl" === t && (n = this.toHslString()), "hsv" === t && (n = this.toHsvString()), n || this.toHexString()) : "name" === t && 0 === this.a ? this.toName() : this.toRgbString()
			}, t.prototype.toNumber = function() {
				return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
			}, t.prototype.clone = function() {
				return new t(this.toString())
			}, t.prototype.lighten = function(e) {
				void 0 === e && (e = 10);
				var n = this.toHsl();
				return n.l += e / 100, n.l = sw(n.l), new t(n)
			}, t.prototype.brighten = function(e) {
				void 0 === e && (e = 10);
				var n = this.toRgb();
				return n.r = Math.max(0, Math.min(255, n.r - Math.round(-e / 100 * 255))), n.g = Math.max(0, Math.min(255, n.g - Math.round(-e / 100 * 255))), n.b = Math.max(0, Math.min(255, n.b - Math.round(-e / 100 * 255))), new t(n)
			}, t.prototype.darken = function(e) {
				void 0 === e && (e = 10);
				var n = this.toHsl();
				return n.l -= e / 100, n.l = sw(n.l), new t(n)
			}, t.prototype.tint = function(t) {
				return void 0 === t && (t = 10), this.mix("white", t)
			}, t.prototype.shade = function(t) {
				return void 0 === t && (t = 10), this.mix("black", t)
			}, t.prototype.desaturate = function(e) {
				void 0 === e && (e = 10);
				var n = this.toHsl();
				return n.s -= e / 100, n.s = sw(n.s), new t(n)
			}, t.prototype.saturate = function(e) {
				void 0 === e && (e = 10);
				var n = this.toHsl();
				return n.s += e / 100, n.s = sw(n.s), new t(n)
			}, t.prototype.greyscale = function() {
				return this.desaturate(100)
			}, t.prototype.spin = function(e) {
				var n = this.toHsl(),
					r = (n.h + e) % 360;
				return n.h = r < 0 ? 360 + r : r, new t(n)
			}, t.prototype.mix = function(e, n) {
				void 0 === n && (n = 50);
				var r = this.toRgb(),
					i = new t(e).toRgb(),
					o = n / 100;
				return new t({
					r: (i.r - r.r) * o + r.r,
					g: (i.g - r.g) * o + r.g,
					b: (i.b - r.b) * o + r.b,
					a: (i.a - r.a) * o + r.a
				})
			}, t.prototype.analogous = function(e, n) {
				void 0 === e && (e = 6), void 0 === n && (n = 30);
				var r = this.toHsl(),
					i = 360 / n,
					o = [this];
				for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e;) r.h = (r.h + i) % 360, o.push(new t(r));
				return o
			}, t.prototype.complement = function() {
				var e = this.toHsl();
				return e.h = (e.h + 180) % 360, new t(e)
			}, t.prototype.monochromatic = function(e) {
				void 0 === e && (e = 6);
				for (var n = this.toHsv(), r = n.h, i = n.s, o = n.v, a = [], s = 1 / e; e--;) a.push(new t({
					h: r,
					s: i,
					v: o
				})), o = (o + s) % 1;
				return a
			}, t.prototype.splitcomplement = function() {
				var e = this.toHsl(),
					n = e.h;
				return [this, new t({
					h: (n + 72) % 360,
					s: e.s,
					l: e.l
				}), new t({
					h: (n + 216) % 360,
					s: e.s,
					l: e.l
				})]
			}, t.prototype.onBackground = function(e) {
				var n = this.toRgb(),
					r = new t(e).toRgb(),
					i = n.a + r.a * (1 - n.a);
				return new t({
					r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
					g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
					b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
					a: i
				})
			}, t.prototype.triad = function() {
				return this.polyad(3)
			}, t.prototype.tetrad = function() {
				return this.polyad(4)
			}, t.prototype.polyad = function(e) {
				for (var n = this.toHsl(), r = n.h, i = [this], o = 360 / e, a = 1; a < e; a++) i.push(new t({
					h: (r + a * o) % 360,
					s: n.s,
					l: n.l
				}));
				return i
			}, t.prototype.equals = function(e) {
				return this.toRgbString() === new t(e).toRgbString()
			}, t
		}();

		function Ow(t, e = 20) {
			return t.mix("#141414", e).toString()
		}
		const Tw = Ze({
				name: "ElButton"
			}),
			kw = Ze({
				...Tw,
				props: iw,
				emits: ow,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t,
						i = function(t) {
							const e = rw(),
								n = Dg("button");
							return Pe((() => {
								let r = {};
								const i = t.color;
								if (i) {
									const o = new Sw(i),
										a = t.dark ? o.tint(20).toString() : Ow(o, 20);
									if (t.plain) r = n.cssVarBlock({
										"bg-color": t.dark ? Ow(o, 90) : o.tint(90).toString(),
										"text-color": i,
										"border-color": t.dark ? Ow(o, 50) : o.tint(50).toString(),
										"hover-text-color": `var(${n.cssVarName("color-white")})`,
										"hover-bg-color": i,
										"hover-border-color": i,
										"active-bg-color": a,
										"active-text-color": `var(${n.cssVarName("color-white")})`,
										"active-border-color": a
									}), e.value && (r[n.cssVarBlockName("disabled-bg-color")] = t.dark ? Ow(o, 90) : o.tint(90).toString(), r[n.cssVarBlockName("disabled-text-color")] = t.dark ? Ow(o, 50) : o.tint(50).toString(), r[n.cssVarBlockName("disabled-border-color")] = t.dark ? Ow(o, 80) : o.tint(80).toString());
									else {
										const s = t.dark ? Ow(o, 30) : o.tint(30).toString(),
											l = o.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
										if (r = n.cssVarBlock({
												"bg-color": i,
												"text-color": l,
												"border-color": i,
												"hover-bg-color": s,
												"hover-text-color": l,
												"hover-border-color": s,
												"active-bg-color": a,
												"active-border-color": a
											}), e.value) {
											const e = t.dark ? Ow(o, 50) : o.tint(50).toString();
											r[n.cssVarBlockName("disabled-bg-color")] = e, r[n.cssVarBlockName("disabled-text-color")] = t.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, r[n.cssVarBlockName("disabled-border-color")] = e
										}
									}
								}
								return r
							}))
						}(r),
						o = Dg("button"),
						{
							_ref: a,
							_size: s,
							_type: c,
							_disabled: u,
							_props: h,
							shouldAddSpace: f,
							handleClick: d
						} = ((t, e) => {
							Qx({
								from: "type.text",
								replacement: "link",
								version: "3.0.0",
								scope: "props",
								ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
							}, Pe((() => "text" === t.type)));
							const n = We(Jx, void 0),
								r = Bm("button"),
								{
									form: i
								} = $x(),
								o = nw(Pe((() => null == n ? void 0 : n.size))),
								a = rw(),
								s = ve(),
								l = bi(),
								c = Pe((() => t.type || (null == n ? void 0 : n.type) || "")),
								u = Pe((() => {
									var e, n, i;
									return null != (i = null != (n = t.autoInsertSpace) ? n : null == (e = r.value) ? void 0 : e.autoInsertSpace) && i
								})),
								h = Pe((() => "button" === t.tag ? {
									ariaDisabled: a.value || t.loading,
									disabled: a.value || t.loading,
									autofocus: t.autofocus,
									type: t.nativeType
								} : {})),
								f = Pe((() => {
									var t;
									const e = null == (t = l.default) ? void 0 : t.call(l);
									if (u.value && 1 === (null == e ? void 0 : e.length)) {
										const t = e[0];
										if ((null == t ? void 0 : t.type) === Xn) {
											const e = t.children;
											return /^\p{Unified_Ideograph}{2}$/u.test(e.trim())
										}
									}
									return !1
								}));
							return {
								_disabled: a,
								_size: o,
								_type: c,
								_ref: s,
								_props: h,
								shouldAddSpace: f,
								handleClick: n => {
									"reset" === t.nativeType && (null == i || i.resetFields()), e("click", n)
								}
							}
						})(r, n);
					return e({
						ref: a,
						size: s,
						type: c,
						disabled: u,
						shouldAddSpace: f
					}), (t, e) => (Jn(), nr(Vn(t.tag), vr({
						ref_key: "_ref",
						ref: a
					}, we(h), {
						class: [we(o).b(), we(o).m(we(c)), we(o).m(we(s)), we(o).is("disabled", we(u)), we(o).is("loading", t.loading), we(o).is("plain", t.plain), we(o).is("round", t.round), we(o).is("circle", t.circle), we(o).is("text", t.text), we(o).is("link", t.link), we(o).is("has-bg", t.bg)],
						style: we(i),
						onClick: we(d)
					}), {
						default: Ie((() => [t.loading ? (Jn(), er(qn, {
							key: 0
						}, [t.$slots.loading ? br(t.$slots, "loading", {
							key: 0
						}) : (Jn(), nr(we(Yg), {
							key: 1,
							class: l(we(o).is("loading"))
						}, {
							default: Ie((() => [(Jn(), nr(Vn(t.loadingIcon)))])),
							_: 1
						}, 8, ["class"]))], 64)) : t.icon || t.$slots.icon ? (Jn(), nr(we(Yg), {
							key: 1
						}, {
							default: Ie((() => [t.icon ? (Jn(), nr(Vn(t.icon), {
								key: 0
							})) : br(t.$slots, "icon", {
								key: 1
							})])),
							_: 3
						})) : fr("v-if", !0), t.$slots.default ? (Jn(), er("span", {
							key: 2,
							class: l({
								[we(o).em("text", "expand")]: we(f)
							})
						}, [br(t.$slots, "default")], 2)) : fr("v-if", !0)])),
						_: 3
					}, 16, ["class", "style", "onClick"]))
				}
			});
		var Fw = Pg(kw, [
			["__file", "button.vue"]
		]);
		const Pw = {
				size: iw.size,
				type: iw.type
			},
			jw = Ze({
				name: "ElButtonGroup"
			});
		var Aw = Pg(Ze({
			...jw,
			props: Pw,
			setup(t) {
				const e = t;
				ze(Jx, re({
					size: ke(e, "size"),
					type: ke(e, "type")
				}));
				const n = Dg("button");
				return (t, e) => (Jn(), er("div", {
					class: l(`${we(n).b("group")}`)
				}, [br(t.$slots, "default")], 2))
			}
		}), [
			["__file", "button-group.vue"]
		]);
		const _w = zg(Fw, {
			ButtonGroup: Aw
		});
		Wg(Aw);
		var Ew, Dw, Mw, Iw, Rw, Bw, Nw, Lw, zw, Ww, Vw, Uw, Hw, qw, Xw, Gw, Kw, Yw = n(563),
			Zw = !1,
			Jw = {
				x: 0,
				y: 0
			},
			Qw = {
				x: 0,
				y: 0
			},
			$w = {
				x: 0,
				y: 0
			},
			tC = 0,
			eC = 0;

		function nC() {
			Jw.x = Jw.y = Qw.x = Qw.y = 0, Yw(".cropper-container").remove()
		}

		function rC() {
			return JSON.parse(JSON.stringify({
				lt: Jw,
				rb: Qw
			}))
		}

		function iC(t) {
			Zw = !0, zw = Yw(t.target), $w.x = t.pageX - Lw.offset().left, $w.y = t.pageY - Lw.offset().top
		}

		function oC(t) {
			Zw && (Nw.css({
				display: "block"
			}), lC()), Zw = !1
		}

		function aC(t) {
			var e, n, r, i;
			Zw && (zw.hasClass("c-pointer") ? function(t, e) {
				zw.hasClass("c-left") ? Jw.x = Math.max(0, t + 10 < Qw.x ? t : Qw.x - 10) : zw.hasClass("c-right") && (Qw.x = Math.min(Lw.width(), t - 10 > Jw.x ? t : Jw.x + 10)), zw.hasClass("c-top") ? Jw.y = Math.max(0, e + 10 < Qw.y ? e : Qw.y - 10) : zw.hasClass("c-bottom") && (Qw.y = Math.min(Lw.height(), e - 10 > Jw.y ? e : Jw.y + 10)), sC(), lC()
			}(t.pageX - Lw.offset().left, t.pageY - Lw.offset().top) : zw.hasClass("cropper-center") ? (e = t.pageX - Lw.offset().left, n = t.pageY - Lw.offset().top, r = e - $w.x, i = n - $w.y, $w.x = e, $w.y = n, Jw.x + r < 0 ? Jw.x = 0 : Qw.x + r > eC ? Qw.x = eC : (Jw.x += r, Qw.x += r), Jw.y + i < 0 ? Jw.y = 0 : Qw.y + i > tC ? Qw.y = tC : (Jw.y += i, Qw.y += i), sC(), lC()) : zw.hasClass("cropper-container") && function(t, e) {
				Nw.css({
					display: "none"
				}), t - $w.x > 0 ? (Jw.x = $w.x, Qw.x = t) : (Jw.x = t, Qw.x = $w.x), e - $w.y > 0 ? (Jw.y = $w.y, Qw.y = e) : (Jw.y = e, Qw.y = $w.y), Ew.css({
					backgroundColor: "rgba(0,0,0,0)"
				}), sC()
			}(t.pageX - Lw.offset().left, t.pageY - Lw.offset().top))
		}

		function sC() {
			var t = {
					top: Jw.y,
					left: Jw.x,
					height: Qw.y - Jw.y,
					width: Qw.x - Jw.x
				},
				e = {
					top: 0,
					left: 0,
					height: Jw.y,
					width: Qw.x
				},
				n = {
					top: Jw.y,
					left: 0,
					height: tC - Jw.y,
					width: Jw.x
				},
				r = {
					top: Qw.y,
					left: Jw.x,
					height: tC - Qw.y,
					width: eC - Jw.x
				},
				i = {
					top: 0,
					left: Qw.x,
					height: Qw.y,
					width: eC - Qw.x
				};
			Iw.css(Object.assign(t, {
				border: "2px dashed #ccc"
			})), Dw.css(n), Mw.css(e), Rw.css(i), Bw.css(r)
		}

		function lC() {
			Ww.css({
				top: Jw.y,
				left: Jw.x
			}), Vw.css({
				top: Jw.y,
				left: (Jw.x + Qw.x) / 2
			}), Uw.css({
				top: Jw.y,
				left: Qw.x
			}), Hw.css({
				top: (Jw.y + Qw.y) / 2,
				left: Qw.x
			}), qw.css({
				top: Qw.y,
				left: Qw.x
			}), Xw.css({
				top: Qw.y,
				left: (Jw.x + Qw.x) / 2
			}), Gw.css({
				top: Qw.y,
				left: Jw.x
			}), Kw.css({
				top: (Jw.y + Qw.y) / 2,
				left: Jw.x
			})
		}
		let cC;
		const uC = `\n  height:0 !important;\n  visibility:hidden !important;\n  ${tg&&/firefox/i.test(window.navigator.userAgent)?"":"overflow:hidden !important;"}\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n`,
			hC = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];

		function fC(t, e = 1, n) {
			var r;
			cC || (cC = document.createElement("textarea"), document.body.appendChild(cC));
			const {
				paddingSize: i,
				borderSize: o,
				boxSizing: a,
				contextStyle: s
			} = function(t) {
				const e = window.getComputedStyle(t),
					n = e.getPropertyValue("box-sizing"),
					r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top")),
					i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
				return {
					contextStyle: hC.map((t => `${t}:${e.getPropertyValue(t)}`)).join(";"),
					paddingSize: r,
					borderSize: i,
					boxSizing: n
				}
			}(t);
			cC.setAttribute("style", `${s};${uC}`), cC.value = t.value || t.placeholder || "";
			let l = cC.scrollHeight;
			const c = {};
			"border-box" === a ? l += o : "content-box" === a && (l -= i), cC.value = "";
			const u = cC.scrollHeight - i;
			if (Rg(e)) {
				let t = u * e;
				"border-box" === a && (t = t + i + o), l = Math.max(t, l), c.minHeight = `${t}px`
			}
			if (Rg(n)) {
				let t = u * n;
				"border-box" === a && (t = t + i + o), l = Math.min(t, l)
			}
			return c.height = `${l}px`, null == (r = cC.parentNode) || r.removeChild(cC), cC = void 0, c
		}
		const dC = "update:modelValue",
			pC = "change",
			gC = "input",
			vC = kg({
				id: {
					type: String,
					default: void 0
				},
				size: Dm,
				disabled: Boolean,
				modelValue: {
					type: [String, Number, Object],
					default: ""
				},
				type: {
					type: String,
					default: "text"
				},
				resize: {
					type: String,
					values: ["none", "both", "horizontal", "vertical"]
				},
				autosize: {
					type: [Boolean, Object],
					default: !1
				},
				autocomplete: {
					type: String,
					default: "off"
				},
				formatter: {
					type: Function
				},
				parser: {
					type: Function
				},
				placeholder: {
					type: String
				},
				form: {
					type: String
				},
				readonly: {
					type: Boolean,
					default: !1
				},
				clearable: {
					type: Boolean,
					default: !1
				},
				showPassword: {
					type: Boolean,
					default: !1
				},
				showWordLimit: {
					type: Boolean,
					default: !1
				},
				suffixIcon: {
					type: uv
				},
				prefixIcon: {
					type: uv
				},
				containerRole: {
					type: String,
					default: void 0
				},
				label: {
					type: String,
					default: void 0
				},
				tabindex: {
					type: [String, Number],
					default: 0
				},
				validateEvent: {
					type: Boolean,
					default: !0
				},
				inputStyle: {
					type: [Object, Array, String],
					default: () => ({})
				},
				autofocus: {
					type: Boolean,
					default: !1
				}
			}),
			mC = {
				[dC]: t => k(t),
				input: t => k(t),
				change: t => k(t),
				focus: t => t instanceof FocusEvent,
				blur: t => t instanceof FocusEvent,
				clear: () => !0,
				mouseleave: t => t instanceof MouseEvent,
				mouseenter: t => t instanceof MouseEvent,
				keydown: t => t instanceof Event,
				compositionstart: t => t instanceof CompositionEvent,
				compositionupdate: t => t instanceof CompositionEvent,
				compositionend: t => t instanceof CompositionEvent
			},
			yC = ["class", "style"],
			bC = /^on[A-Z]/;

		function xC(t, {
			afterFocus: e,
			beforeBlur: n,
			afterBlur: r
		} = {}) {
			const i = Fr(),
				{
					emit: o
				} = i,
				a = me(),
				s = ve(!1);
			return vi(a, (t => {
				t && t.setAttribute("tabindex", "-1")
			})), lg(a, "click", (() => {
				var e;

				null == (e = t.value) || e.focus()
			})), {
				wrapperRef: a,
				isFocused: s,
				handleFocus: t => {
					s.value || (s.value = !0, o("focus", t), null == e || e())
				},
				handleBlur: t => {
					var e;
					T(n) && n(t) || t.relatedTarget && (null == (e = a.value) ? void 0 : e.contains(t.relatedTarget)) || (s.value = !1, o("blur", t), null == r || r())
				}
			}
		}
		const wC = t => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(t),
			CC = ["role"],
			SC = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"],
			OC = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"],
			TC = Ze({
				name: "ElInput",
				inheritAttrs: !1
			}),
			kC = Ze({
				...TC,
				props: vC,
				emits: mC,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t,
						o = xi().attrs,
						a = bi(),
						s = Pe((() => {
							const t = {};
							return "combobox" === r.containerRole && (t["aria-haspopup"] = o["aria-haspopup"], t["aria-owns"] = o["aria-owns"], t["aria-expanded"] = o["aria-expanded"]), t
						})),
						u = Pe((() => ["textarea" === r.type ? x.b() : b.b(), b.m(m.value), b.is("disabled", y.value), b.is("exceed", q.value), {
							[b.b("group")]: a.prepend || a.append,
							[b.bm("group", "append")]: a.append,
							[b.bm("group", "prepend")]: a.prepend,
							[b.m("prefix")]: a.prefix || r.prefixIcon,
							[b.m("suffix")]: a.suffix || r.suffixIcon || r.clearable || r.showPassword,
							[b.bm("suffix", "password-clear")]: W.value && V.value
						}, o.class])),
						h = Pe((() => [b.e("wrapper"), b.is("focus", _.value)])),
						f = ((t = {}) => {
							const {
								excludeListeners: e = !1,
								excludeKeys: n
							} = t, r = Pe((() => ((null == n ? void 0 : n.value) || []).concat(yC))), i = Fr();
							return Pe(i ? () => {
								var t;
								return Sg(Object.entries(null == (t = i.proxy) ? void 0 : t.$attrs).filter((([t]) => !(r.value.includes(t) || e && bC.test(t)))))
							} : () => ({}))
						})({
							excludeKeys: Pe((() => Object.keys(s.value)))
						}),
						{
							form: p,
							formItem: g
						} = $x(),
						{
							inputId: v
						} = tw(r, {
							formItemContext: g
						}),
						m = nw(),
						y = rw(),
						b = Dg("input"),
						x = Dg("textarea"),
						w = me(),
						C = me(),
						S = ve(!1),
						O = ve(!1),
						T = ve(!1),
						k = ve(),
						F = me(r.inputStyle),
						j = Pe((() => w.value || C.value)),
						{
							wrapperRef: A,
							isFocused: _,
							handleFocus: E,
							handleBlur: D
						} = xC(j, {
							afterBlur() {
								var t;
								r.validateEvent && (null == (t = null == g ? void 0 : g.validate) || t.call(g, "blur").catch((t => {})))
							}
						}),
						M = Pe((() => {
							var t;
							return null != (t = null == p ? void 0 : p.statusIcon) && t
						})),
						I = Pe((() => (null == g ? void 0 : g.validateState) || "")),
						R = Pe((() => I.value && dv[I.value])),
						B = Pe((() => T.value ? lv : nv)),
						N = Pe((() => [o.style, r.inputStyle])),
						L = Pe((() => [r.inputStyle, F.value, {
							resize: r.resize
						}])),
						z = Pe((() => qb(r.modelValue) ? "" : String(r.modelValue))),
						W = Pe((() => r.clearable && !y.value && !r.readonly && !!z.value && (_.value || S.value))),
						V = Pe((() => r.showPassword && !y.value && !r.readonly && !!z.value && (!!z.value || _.value))),
						U = Pe((() => r.showWordLimit && !!f.value.maxlength && ("text" === r.type || "textarea" === r.type) && !y.value && !r.readonly && !r.showPassword)),
						H = Pe((() => z.value.length)),
						q = Pe((() => !!U.value && H.value > Number(f.value.maxlength))),
						X = Pe((() => !!a.suffix || !!r.suffixIcon || W.value || r.showPassword || U.value || !!I.value && M.value)),
						[G, K] = function(t) {
							const e = ve();
							return [function() {
								if (null == t.value) return;
								const {
									selectionStart: n,
									selectionEnd: r,
									value: i
								} = t.value;
								if (null == n || null == r) return;
								const o = i.slice(0, Math.max(0, n)),
									a = i.slice(Math.max(0, r));
								e.value = {
									selectionStart: n,
									selectionEnd: r,
									value: i,
									beforeTxt: o,
									afterTxt: a
								}
							}, function() {
								if (null == t.value || null == e.value) return;
								const {
									value: n
								} = t.value, {
									beforeTxt: r,
									afterTxt: i,
									selectionStart: o
								} = e.value;
								if (null == r || null == i || null == o) return;
								let a = n.length;
								if (n.endsWith(i)) a = n.length - i.length;
								else if (n.startsWith(r)) a = r.length;
								else {
									const t = r[o - 1],
										e = n.indexOf(t, o - 1); - 1 !== e && (a = e + 1)
								}
								t.value.setSelectionRange(a, a)
							}]
						}(w);
					mg(C, (t => {
						if (Z(), !U.value || "both" !== r.resize) return;
						const e = t[0],
							{
								width: n
							} = e.contentRect;
						k.value = {
							right: `calc(100% - ${n+15+6}px)`
						}
					}));
					const Y = () => {
							const {
								type: t,
								autosize: e
							} = r;
							if (tg && "textarea" === t && C.value)
								if (e) {
									const t = P(e) ? e.minRows : void 0,
										n = P(e) ? e.maxRows : void 0,
										r = fC(C.value, t, n);
									F.value = {
										overflowY: "hidden",
										...r
									}, si((() => {
										C.value.offsetHeight, F.value = r
									}))
								} else F.value = {
									minHeight: fC(C.value).minHeight
								}
						},
						Z = (t => {
							let e = !1;
							return () => {
								var n;
								!e && r.autosize && (null === (null == (n = C.value) ? void 0 : n.offsetParent) || (t(), e = !0))
							}
						})(Y),
						J = () => {
							const t = j.value,
								e = r.formatter ? r.formatter(z.value) : z.value;
							t && t.value !== e && (t.value = e)
						},
						Q = async t => {
							G();
							let {
								value: e
							} = t.target;
							r.formatter && (e = r.parser ? r.parser(e) : e), O.value || (e !== z.value ? (n(dC, e), n("input", e), await si(), J(), K()) : J())
						}, $ = t => {
							n("change", t.target.value)
						}, tt = t => {
							n("compositionstart", t), O.value = !0
						}, et = t => {
							var e;
							n("compositionupdate", t);
							const r = null == (e = t.target) ? void 0 : e.value,
								i = r[r.length - 1] || "";
							O.value = !wC(i)
						}, nt = t => {
							n("compositionend", t), O.value && (O.value = !1, Q(t))
						}, rt = () => {
							T.value = !T.value, it()
						}, it = async () => {
							var t;
							await si(), null == (t = j.value) || t.focus()
						}, ot = t => {
							S.value = !1, n("mouseleave", t)
						}, at = t => {
							S.value = !0, n("mouseenter", t)
						}, st = t => {
							n("keydown", t)
						}, lt = () => {
							n(dC, ""), n("change", ""), n("clear"), n("input", "")
						};
					return vi((() => r.modelValue), (() => {
						var t;
						si((() => Y())), r.validateEvent && (null == (t = null == g ? void 0 : g.validate) || t.call(g, "change").catch((t => {})))
					})), vi(z, (() => J())), vi((() => r.type), (async () => {
						await si(), J(), Y()
					})), on((() => {
						!r.formatter && r.parser, J(), si(Y)
					})), e({
						input: w,
						textarea: C,
						ref: j,
						textareaStyle: L,
						autosize: ke(r, "autosize"),
						focus: it,
						blur: () => {
							var t;
							return null == (t = j.value) ? void 0 : t.blur()
						},
						select: () => {
							var t;
							null == (t = j.value) || t.select()
						},
						clear: lt,
						resizeTextarea: Y
					}), (t, e) => Sn((Jn(), er("div", vr(we(s), {
						class: we(u),
						style: we(N),
						role: t.containerRole,
						onMouseenter: at,
						onMouseleave: ot
					}), [fr(" input "), "textarea" !== t.type ? (Jn(), er(qn, {
						key: 0
					}, [fr(" prepend slot "), t.$slots.prepend ? (Jn(), er("div", {
						key: 0,
						class: l(we(b).be("group", "prepend"))
					}, [br(t.$slots, "prepend")], 2)) : fr("v-if", !0), lr("div", {
						ref_key: "wrapperRef",
						ref: A,
						class: l(we(h))
					}, [fr(" prefix slot "), t.$slots.prefix || t.prefixIcon ? (Jn(), er("span", {
						key: 0,
						class: l(we(b).e("prefix"))
					}, [lr("span", {
						class: l(we(b).e("prefix-inner"))
					}, [br(t.$slots, "prefix"), t.prefixIcon ? (Jn(), nr(we(Yg), {
						key: 0,
						class: l(we(b).e("icon"))
					}, {
						default: Ie((() => [(Jn(), nr(Vn(t.prefixIcon)))])),
						_: 1
					}, 8, ["class"])) : fr("v-if", !0)], 2)], 2)) : fr("v-if", !0), lr("input", vr({
						id: we(v),
						ref_key: "input",
						ref: w,
						class: we(b).e("inner")
					}, we(f), {
						type: t.showPassword ? T.value ? "text" : "password" : t.type,
						disabled: we(y),
						formatter: t.formatter,
						parser: t.parser,
						readonly: t.readonly,
						autocomplete: t.autocomplete,
						tabindex: t.tabindex,
						"aria-label": t.label,
						placeholder: t.placeholder,
						style: t.inputStyle,
						form: r.form,
						autofocus: r.autofocus,
						onCompositionstart: tt,
						onCompositionupdate: et,
						onCompositionend: nt,
						onInput: Q,
						onFocus: e[0] || (e[0] = (...t) => we(E) && we(E)(...t)),
						onBlur: e[1] || (e[1] = (...t) => we(D) && we(D)(...t)),
						onChange: $,
						onKeydown: st
					}), null, 16, SC), fr(" suffix slot "), we(X) ? (Jn(), er("span", {
						key: 1,
						class: l(we(b).e("suffix"))
					}, [lr("span", {
						class: l(we(b).e("suffix-inner"))
					}, [we(W) && we(V) && we(U) ? fr("v-if", !0) : (Jn(), er(qn, {
						key: 0
					}, [br(t.$slots, "suffix"), t.suffixIcon ? (Jn(), nr(we(Yg), {
						key: 0,
						class: l(we(b).e("icon"))
					}, {
						default: Ie((() => [(Jn(), nr(Vn(t.suffixIcon)))])),
						_: 1
					}, 8, ["class"])) : fr("v-if", !0)], 64)), we(W) ? (Jn(), nr(we(Yg), {
						key: 1,
						class: l([we(b).e("icon"), we(b).e("clear")]),
						onMousedown: lo(we(d), ["prevent"]),
						onClick: lt
					}, {
						default: Ie((() => [cr(we(tv))])),
						_: 1
					}, 8, ["class", "onMousedown"])) : fr("v-if", !0), we(V) ? (Jn(), nr(we(Yg), {
						key: 2,
						class: l([we(b).e("icon"), we(b).e("password")]),
						onClick: rt
					}, {
						default: Ie((() => [(Jn(), nr(Vn(we(B))))])),
						_: 1
					}, 8, ["class"])) : fr("v-if", !0), we(U) ? (Jn(), er("span", {
						key: 3,
						class: l(we(b).e("count"))
					}, [lr("span", {
						class: l(we(b).e("count-inner"))
					}, c(we(H)) + " / " + c(we(f).maxlength), 3)], 2)) : fr("v-if", !0), we(I) && we(R) && we(M) ? (Jn(), nr(we(Yg), {
						key: 4,
						class: l([we(b).e("icon"), we(b).e("validateIcon"), we(b).is("loading", "validating" === we(I))])
					}, {
						default: Ie((() => [(Jn(), nr(Vn(we(R))))])),
						_: 1
					}, 8, ["class"])) : fr("v-if", !0)], 2)], 2)) : fr("v-if", !0)], 2), fr(" append slot "), t.$slots.append ? (Jn(), er("div", {
						key: 1,
						class: l(we(b).be("group", "append"))
					}, [br(t.$slots, "append")], 2)) : fr("v-if", !0)], 64)) : (Jn(), er(qn, {
						key: 1
					}, [fr(" textarea "), lr("textarea", vr({
						id: we(v),
						ref_key: "textarea",
						ref: C,
						class: we(x).e("inner")
					}, we(f), {
						tabindex: t.tabindex,
						disabled: we(y),
						readonly: t.readonly,
						autocomplete: t.autocomplete,
						style: we(L),
						"aria-label": t.label,
						placeholder: t.placeholder,
						form: r.form,
						autofocus: r.autofocus,
						onCompositionstart: tt,
						onCompositionupdate: et,
						onCompositionend: nt,
						onInput: Q,
						onFocus: e[2] || (e[2] = (...t) => we(E) && we(E)(...t)),
						onBlur: e[3] || (e[3] = (...t) => we(D) && we(D)(...t)),
						onChange: $,
						onKeydown: st
					}), null, 16, OC), we(U) ? (Jn(), er("span", {
						key: 0,
						style: i(k.value),
						class: l(we(b).e("count"))
					}, c(we(H)) + " / " + c(we(f).maxlength), 7)) : fr("v-if", !0)], 64))], 16, CC)), [
						[ho, "hidden" !== t.type]
					])
				}
			}),
			FC = zg(Pg(kC, [
				["__file", "input.vue"]
			])),
			PC = kg({
				id: {
					type: String,
					default: void 0
				},
				step: {
					type: Number,
					default: 1
				},
				stepStrictly: Boolean,
				max: {
					type: Number,
					default: Number.POSITIVE_INFINITY
				},
				min: {
					type: Number,
					default: Number.NEGATIVE_INFINITY
				},
				modelValue: Number,
				readonly: Boolean,
				disabled: Boolean,
				size: Dm,
				controls: {
					type: Boolean,
					default: !0
				},
				controlsPosition: {
					type: String,
					default: "",
					values: ["", "right"]
				},
				valueOnClear: {
					type: [String, Number, null],
					validator: t => null === t || Rg(t) || ["min", "max"].includes(t),
					default: null
				},
				name: String,
				label: String,
				placeholder: String,
				precision: {
					type: Number,
					validator: t => t >= 0 && t === Number.parseInt(`${t}`, 10)
				},
				validateEvent: {
					type: Boolean,
					default: !0
				}
			}),
			jC = {
				[pC]: (t, e) => e !== t,
				blur: t => t instanceof FocusEvent,
				focus: t => t instanceof FocusEvent,
				[gC]: t => Rg(t) || qb(t),
				[dC]: t => Rg(t) || qb(t)
			},
			AC = 100,
			_C = 600,
			EC = {
				beforeMount(t, e) {
					const n = e.value,
						{
							interval: r = AC,
							delay: i = _C
						} = T(n) ? {} : n;
					let o, a;
					const s = () => T(n) ? n() : n.handler(),
						l = () => {
							a && (clearTimeout(a), a = void 0), o && (clearInterval(o), o = void 0)
						};
					t.addEventListener("mousedown", (t => {
						0 === t.button && (l(), s(), document.addEventListener("mouseup", (() => l()), {
							once: !0
						}), a = setTimeout((() => {
							o = setInterval((() => {
								s()
							}), r)
						}), i))
					}))
				}
			},
			DC = ["aria-label", "onKeydown"],
			MC = ["aria-label", "onKeydown"],
			IC = Ze({
				name: "ElInputNumber"
			}),
	 
			
RC = Ze({
    ...IC,
    props: PC,
    emits: jC,
    setup(t, {
        expose: e,
        emit: n
    }) {
        const r = t,
            { t: i } = Fm(),
            o = Dg("input-number"),
            a = ve(),
            s = re({
                currentValue: r.modelValue,
                userInput: null
            }),
            { formItem: c } = $x(),
            u = Pe(() => Rg(r.modelValue) && r.modelValue <= r.min),
            h = Pe(() => Rg(r.modelValue) && r.modelValue >= r.max),
            f = Pe(() => {
                const t = y(r.step);
                return Mg(r.precision) ? Math.max(y(r.modelValue), t) : (r.precision, r.precision);
            }),
            d = Pe(() => r.controls && "right" === r.controlsPosition),
            p = nw(),
            g = rw(),
            v = Pe(() => {
                if (null !== s.userInput) return s.userInput;
                let t = s.currentValue;
                if (qb(t)) return "";
                if (Rg(t)) {
                    if (Number.isNaN(t)) return "";
                    Mg(r.precision) || (t = t.toFixed(r.precision));
                }
                return t;
            }),
            m = (t, e) => {
                if (Mg(e) && (e = f.value), 0 === e) return Math.round(t);
                let n = String(t);
                const r = n.indexOf(".");
                if (-1 === r) return t;
                if (!n.replace(".", "").split("")[r + e]) return t;
                const i = n.length;
                return "5" === n.charAt(i - 1) && (n = `${n.slice(0, Math.max(0, i-1))}6`), Number.parseFloat(Number(n).toFixed(e));
            },
            y = t => {
                if (qb(t)) return 0;
                const e = t.toString(),
                    n = e.indexOf(".");
                let r = 0;
                return -1 !== n && (r = e.length - n - 1), r;
            },
            b = (t, e = 1) => Rg(t) ? m(t + r.step * e) : s.currentValue,
            x = () => {
                if (r.readonly || g.value || h.value) return;
                const t = Number(v.value) || 0,
                    e = b(t);
                S(e);
                n(gC, s.currentValue);
                // Save to local storage
                const storageKey = r.isFontSize ? "fontSize" : "strokeWidth";
                localStorage.setItem(storageKey, s.currentValue.toString());
                console.log(`Saved ${storageKey} to local storage: ${s.currentValue}`);
            },
            w = () => {
                if (r.readonly || g.value || u.value) return;
                const t = Number(v.value) || 0,
                    e = b(t, -1);
                S(e);
                n(gC, s.currentValue);
                // Save to local storage
                const storageKey = r.isFontSize ? "fontSize" : "strokeWidth";
                localStorage.setItem(storageKey, s.currentValue.toString());
                console.log(`Saved ${storageKey} to local storage: ${s.currentValue}`);
            },
            C = (t, e) => {
                const { max: i, min: o, step: a, precision: s, stepStrictly: l, valueOnClear: c } = r;
                i < o && qg("InputNumber", "min should not be greater than max.");
                let u = Number(t);
                if (qb(t) || Number.isNaN(u)) return null;
                if ("" === t) {
                    if (null === c) return null;
                    u = k(c) ? { min: o, max: i }[c] : c;
                }
                return l && (u = m(Math.round(u / a) * a, s)), Mg(s) || (u = m(u, s)), (u > i || u < o) && (u = u > i ? i : o, e && n(dC, u)), u;
            },
            S = (t, e = !0) => {
                var i;
                const o = s.currentValue,
                    a = C(t);
                e ? o !== a && (s.userInput = null, n(dC, a), n(pC, a, o), r.validateEvent && (null == (i = null == c ? void 0 : c.validate) || i.call(c, "change").catch((t => {}))), s.currentValue = a) : n(dC, a);
            },
            O = t => {
                s.userInput = t;
                const e = "" === t ? null : Number(t);
                n(gC, e);
                S(e, !1);
            },
            T = t => {
                const e = "" !== t ? Number(t) : "";
                (Rg(e) && !Number.isNaN(e) || "" === t) && S(e);
                s.userInput = null;
            },
            F = t => {
                n("focus", t);
            },
            P = t => {
                var e;
                s.userInput = null;
                n("blur", t);
                r.validateEvent && (null == (e = null == c ? void 0 : c.validate) || e.call(c, "blur").catch((t => {})));
            };

        vi(() => r.modelValue, (t, e) => {
            const n = C(t, !0);
            null === s.userInput && n !== e && (s.currentValue = n);
        }, { immediate: !0 });

        on(() => {
            var t;
            const { min: e, max: i, modelValue: o } = r,
                l = null == (t = a.value) ? void 0 : t.input;
            if (l.setAttribute("role", "spinbutton"), Number.isFinite(i) ? l.setAttribute("aria-valuemax", String(i)) : l.removeAttribute("aria-valuemax"), Number.isFinite(e) ? l.setAttribute("aria-valuemin", String(e)) : l.removeAttribute("aria-valuemin"), l.setAttribute("aria-valuenow", s.currentValue || 0 === s.currentValue ? String(s.currentValue) : ""), l.setAttribute("aria-disabled", String(g.value)), !Rg(o) && null != o) {
                let t = Number(o);
                Number.isNaN(t) && (t = null);
                n(dC, t);
            }
        });

        an(() => {
            var t, e;
            const n = null == (t = a.value) ? void 0 : t.input;
            null == n || n.setAttribute("aria-valuenow", `${null != (e = s.currentValue) ? e : ""}`);
        });

        e({
            focus: () => {
                var t, e;
                null == (e = null == (t = a.value) ? void 0 : t.focus) || e.call(t);
            },
            blur: () => {
                var t, e;
                null == (e = null == (t = a.value) ? void 0 : t.blur) || e.call(t);
            }
        });

        return (t, e) => (Jn(), er("div", {
            class: l([we(o).b(), we(o).m(we(p)), we(o).is("disabled", we(g)), we(o).is("without-controls", !t.controls), we(o).is("controls-right", we(d))]),
            onDragstart: e[1] || (e[1] = lo((() => {}), ["prevent"]))
        }, [
            t.controls ? Sn((Jn(), er("span", {
                key: 0,
                role: "button",
                "aria-label": we(i)("el.inputNumber.decrease"),
                class: l([we(o).e("decrease"), we(o).is("disabled", we(u))]),
                onKeydown: uo(w, ["enter"])
            }, [cr(we(Yg), null, {
                default: Ie(() => [we(d) ? (Jn(), nr(we(Zg), { key: 0 })) : (Jn(), nr(we(ov), { key: 1 }))]),
                _: 1
            })], 42, DC)), [[we(EC), w]]) : fr("v-if", !0),
            t.controls ? Sn((Jn(), er("span", {
                key: 1,
                role: "button",
                "aria-label": we(i)("el.inputNumber.increase"),
                class: l([we(o).e("increase"), we(o).is("disabled", we(h))]),
                onKeydown: uo(x, ["enter"])
            }, [cr(we(Yg), null, {
                default: Ie(() => [we(d) ? (Jn(), nr(we(Jg), { key: 0 })) : (Jn(), nr(we(av), { key: 1 }))]),
                _: 1
            })], 42, MC)), [[we(EC), x]]) : fr("v-if", !0),
            cr(we(FC), {
                id: t.id,
                ref_key: "input",
                ref: a,
                type: "number",
                step: t.step,
                "model-value": we(v),
                placeholder: t.placeholder,
                readonly: t.readonly,
                disabled: we(g),
                size: we(p),
                max: t.max,
                min: t.min,
                name: t.name,
                label: t.label,
                "validate-event": !1,
                onWheel: e[0] || (e[0] = lo((() => {}), ["prevent"])),
                onKeydown: [uo(lo(x, ["prevent"]), ["up"]), uo(lo(w, ["prevent"]), ["down"])],
                onBlur: P,
                onFocus: F,
                onInput: O,
                onChange: T
            }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
        ], 34));
    }
}),		
			
			
			
			BC = zg(Pg(RC, [
				["__file", "input-number.vue"]
			])),
			NC = function() {
				return Cv.Date.now()
			};
		var LC = /\s/;
		var zC = /^\s+/;
		const WC = function(t) {
			return t ? t.slice(0, function(t) {
				for (var e = t.length; e-- && LC.test(t.charAt(e)););
				return e
			}(t) + 1).replace(zC, "") : t
		};
		var VC = /^[-+]0x[0-9a-f]+$/i,
			UC = /^0b[01]+$/i,
			HC = /^0o[0-7]+$/i,
			qC = parseInt;
		const XC = function(t) {
			if ("number" == typeof t) return t;
			if (Ev(t)) return NaN;
			if (Rv(t)) {
				var e = "function" == typeof t.valueOf ? t.valueOf() : t;
				t = Rv(e) ? e + "" : e
			}
			if ("string" != typeof t) return 0 === t ? t : +t;
			t = WC(t);
			var n = UC.test(t);
			return n || HC.test(t) ? qC(t.slice(2), n ? 2 : 8) : VC.test(t) ? NaN : +t
		};
		var GC = Math.max,
			KC = Math.min;
		const YC = function(t, e, n) {
				var r, i, o, a, s, l, c = 0,
					u = !1,
					h = !1,
					f = !0;
				if ("function" != typeof t) throw new TypeError("Expected a function");

				function d(e) {
					var n = r,
						o = i;
					return r = i = void 0, c = e, a = t.apply(o, n)
				}

				function p(t) {
					var n = t - l;
					return void 0 === l || n >= e || n < 0 || h && t - c >= o
				}

				function g() {
					var t = NC();
					if (p(t)) return v(t);
					s = setTimeout(g, function(t) {
						var n = e - (t - l);
						return h ? KC(n, o - (t - c)) : n
					}(t))
				}

				function v(t) {
					return s = void 0, f && r ? d(t) : (r = i = void 0, a)
				}

				function m() {
					var t = NC(),
						n = p(t);
					if (r = arguments, i = this, l = t, n) {
						if (void 0 === s) return function(t) {
							return c = t, s = setTimeout(g, e), u ? d(t) : a
						}(l);
						if (h) return clearTimeout(s), s = setTimeout(g, e), d(l)
					}
					return void 0 === s && (s = setTimeout(g, e)), a
				}
				return e = XC(e) || 0, Rv(n) && (u = !!n.leading, o = (h = "maxWait" in n) ? GC(XC(n.maxWait) || 0, e) : o, f = "trailing" in n ? !!n.trailing : f), m.cancel = function() {
					void 0 !== s && clearTimeout(s), c = 0, r = l = i = s = void 0
				}, m.flush = function() {
					return void 0 === s ? a : v(NC())
				}, m
			},
			ZC = kg({
				color: {
					type: Object,
					required: !0
				},
				vertical: {
					type: Boolean,
					default: !1
				}
			});
		let JC = !1;

		function QC(t, e) {
			if (!tg) return;
			const n = function(t) {
					var n;
					null == (n = e.drag) || n.call(e, t)
				},
				r = function(t) {
					var i;
					document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", r), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", r), document.onselectstart = null, document.ondragstart = null, JC = !1, null == (i = e.end) || i.call(e, t)
				},
				i = function(t) {
					var i;
					JC || (t.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", r), document.addEventListener("touchmove", n), document.addEventListener("touchend", r), JC = !0, null == (i = e.start) || i.call(e, t))
				};
			t.addEventListener("mousedown", i), t.addEventListener("touchstart", i)
		}
		const $C = t => {
				let e, n;
				return "touchend" === t.type ? (n = t.changedTouches[0].clientY, e = t.changedTouches[0].clientX) : t.type.startsWith("touch") ? (n = t.touches[0].clientY, e = t.touches[0].clientX) : (n = t.clientY, e = t.clientX), {
					clientX: e,
					clientY: n
				}
			},
			tS = Ze({
				name: "ElColorAlphaSlider"
			});
		var eS = Pg(Ze({
				...tS,
				props: ZC,
				setup(t, {
					expose: e
				}) {
					const n = t,
						{
							bar: r,
							thumb: o,
							handleDrag: a,
							handleClick: s
						} = (t => {
							const e = Fr(),
								n = me(),
								r = me();

							function i(i) {
								if (!r.value || !n.value) return;
								const o = e.vnode.el.getBoundingClientRect(),
									{
										clientX: a,
										clientY: s
									} = $C(i);
								if (t.vertical) {
									let e = s - o.top;
									e = Math.max(n.value.offsetHeight / 2, e), e = Math.min(e, o.height - n.value.offsetHeight / 2), t.color.set("alpha", Math.round((e - n.value.offsetHeight / 2) / (o.height - n.value.offsetHeight) * 100))
								} else {
									let e = a - o.left;
									e = Math.max(n.value.offsetWidth / 2, e), e = Math.min(e, o.width - n.value.offsetWidth / 2), t.color.set("alpha", Math.round((e - n.value.offsetWidth / 2) / (o.width - n.value.offsetWidth) * 100))
								}
							}
							return {
								thumb: n,
								bar: r,
								handleDrag: i,
								handleClick: function(t) {
									t.target !== n.value && i(t)
								}
							}
						})(n),
						{
							rootKls: c,
							barKls: u,
							barStyle: h,
							thumbKls: f,
							thumbStyle: d,
							update: p
						} = ((t, {
							bar: e,
							thumb: n,
							handleDrag: r
						}) => {
							const i = Fr(),
								o = Dg("color-alpha-slider"),
								a = ve(0),
								s = ve(0),
								l = ve();

							function c() {
								a.value = function() {
									if (!n.value) return 0;
									if (t.vertical) return 0;
									const e = i.vnode.el,
										r = t.color.get("alpha");
									return e ? Math.round(r * (e.offsetWidth - n.value.offsetWidth / 2) / 100) : 0
								}(), s.value = function() {
									if (!n.value) return 0;
									const e = i.vnode.el;
									if (!t.vertical) return 0;
									const r = t.color.get("alpha");
									return e ? Math.round(r * (e.offsetHeight - n.value.offsetHeight / 2) / 100) : 0
								}(), l.value = function() {
									if (t.color && t.color.value) {
										const {
											r: e,
											g: n,
											b: r
										} = t.color.toRgb();
										return `linear-gradient(to right, rgba(${e}, ${n}, ${r}, 0) 0%, rgba(${e}, ${n}, ${r}, 1) 100%)`
									}
									return ""
								}()
							}
							on((() => {
								if (!e.value || !n.value) return;
								const t = {
									drag: t => {
										r(t)
									},
									end: t => {
										r(t)
									}
								};
								QC(e.value, t), QC(n.value, t), c()
							})), vi((() => t.color.get("alpha")), (() => c())), vi((() => t.color.value), (() => c()));
							const u = Pe((() => [o.b(), o.is("vertical", t.vertical)])),
								h = Pe((() => o.e("bar"))),
								f = Pe((() => o.e("thumb")));
							return {
								rootKls: u,
								barKls: h,
								barStyle: Pe((() => ({
									background: l.value
								}))),
								thumbKls: f,
								thumbStyle: Pe((() => ({
									left: Xg(a.value),
									top: Xg(s.value)
								}))),
								update: c
							}
						})(n, {
							bar: r,
							thumb: o,
							handleDrag: a
						});
					return e({
						update: p,
						bar: r,
						thumb: o
					}), (t, e) => (Jn(), er("div", {
						class: l(we(c))
					}, [lr("div", {
						ref_key: "bar",
						ref: r,
						class: l(we(u)),
						style: i(we(h)),
						onClick: e[0] || (e[0] = (...t) => we(s) && we(s)(...t))
					}, null, 6), lr("div", {
						ref_key: "thumb",
						ref: o,
						class: l(we(f)),
						style: i(we(d))
					}, null, 6)], 2))
				}
			}), [
				["__file", "alpha-slider.vue"]
			]),
			nS = Pg(Ze({
				name: "ElColorHueSlider",
				props: {
					color: {
						type: Object,
						required: !0
					},
					vertical: Boolean
				},
				setup(t) {
					const e = Dg("color-hue-slider"),
						n = Fr(),
						r = ve(),
						i = ve(),
						o = ve(0),
						a = ve(0),
						s = Pe((() => t.color.get("hue")));

					function l(e) {
						if (!i.value || !r.value) return;
						const o = n.vnode.el.getBoundingClientRect(),
							{
								clientX: a,
								clientY: s
							} = $C(e);
						let l;
						if (t.vertical) {
							let t = s - o.top;
							t = Math.min(t, o.height - r.value.offsetHeight / 2), t = Math.max(r.value.offsetHeight / 2, t), l = Math.round((t - r.value.offsetHeight / 2) / (o.height - r.value.offsetHeight) * 360)
						} else {
							let t = a - o.left;
							t = Math.min(t, o.width - r.value.offsetWidth / 2), t = Math.max(r.value.offsetWidth / 2, t), l = Math.round((t - r.value.offsetWidth / 2) / (o.width - r.value.offsetWidth) * 360)
						}
						t.color.set("hue", l)
					}

					function c() {
						o.value = function() {
							if (!r.value) return 0;
							const e = n.vnode.el;
							if (t.vertical) return 0;
							const i = t.color.get("hue");
							return e ? Math.round(i * (e.offsetWidth - r.value.offsetWidth / 2) / 360) : 0
						}(), a.value = function() {
							if (!r.value) return 0;
							const e = n.vnode.el;
							if (!t.vertical) return 0;
							const i = t.color.get("hue");
							return e ? Math.round(i * (e.offsetHeight - r.value.offsetHeight / 2) / 360) : 0
						}()
					}
					return vi((() => s.value), (() => {
						c()
					})), on((() => {
						if (!i.value || !r.value) return;
						const t = {
							drag: t => {
								l(t)
							},
							end: t => {
								l(t)
							}
						};
						QC(i.value, t), QC(r.value, t), c()
					})), {
						bar: i,
						thumb: r,
						thumbLeft: o,
						thumbTop: a,
						hueValue: s,
						handleClick: function(t) {
							t.target !== r.value && l(t)
						},
						update: c,
						ns: e
					}
				}
			}), [
				["render", function(t, e, n, r, o, a) {
					return Jn(), er("div", {
						class: l([t.ns.b(), t.ns.is("vertical", t.vertical)])
					}, [lr("div", {
						ref: "bar",
						class: l(t.ns.e("bar")),
						onClick: e[0] || (e[0] = (...e) => t.handleClick && t.handleClick(...e))
					}, null, 2), lr("div", {
						ref: "thumb",
						class: l(t.ns.e("thumb")),
						style: i({
							left: t.thumbLeft + "px",
							top: t.thumbTop + "px"
						})
					}, null, 6)], 2)
				}],
				["__file", "hue-slider.vue"]
			]);
		const rS = kg({
				modelValue: String,
				id: String,
				showAlpha: Boolean,
				colorFormat: String,
				disabled: Boolean,
				size: Dm,
				popperClass: {
					type: String,
					default: ""
				},
				label: {
					type: String,
					default: void 0
				},
				tabindex: {
					type: [String, Number],
					default: 0
				},
				predefine: {
					type: Array
				},
				validateEvent: {
					type: Boolean,
					default: !0
				}
			}),
			iS = {
				[dC]: t => k(t) || qb(t),
				[pC]: t => k(t) || qb(t),
				activeChange: t => k(t) || qb(t),
				focus: t => t instanceof FocusEvent,
				blur: t => t instanceof FocusEvent
			},
			oS = Symbol("colorPickerContextKey"),
			aS = function(t, e, n) {
				return [t, e * n / ((t = (2 - e) * n) < 1 ? t : 2 - t) || 0, t / 2]
			},
			sS = function(t, e) {
				var n;
				"string" == typeof(n = t) && n.includes(".") && 1 === Number.parseFloat(n) && (t = "100%");
				const r = function(t) {
					return "string" == typeof t && t.includes("%")
				}(t);
				return t = Math.min(e, Math.max(0, Number.parseFloat(`${t}`))), r && (t = Number.parseInt("" + t * e, 10) / 100), Math.abs(t - e) < 1e-6 ? 1 : t % e / Number.parseFloat(e)
			},
			lS = {
				10: "A",
				11: "B",
				12: "C",
				13: "D",
				14: "E",
				15: "F"
			},
			cS = t => {
				t = Math.min(Math.round(t), 255);
				const e = Math.floor(t / 16),
					n = t % 16;
				return `${lS[e]||e}${lS[n]||n}`
			},
			uS = function({
				r: t,
				g: e,
				b: n
			}) {
				return Number.isNaN(+t) || Number.isNaN(+e) || Number.isNaN(+n) ? "" : `#${cS(t)}${cS(e)}${cS(n)}`
			},
			hS = {
				A: 10,
				B: 11,
				C: 12,
				D: 13,
				E: 14,
				F: 15
			},
			fS = function(t) {
				return 2 === t.length ? 16 * (hS[t[0].toUpperCase()] || +t[0]) + (hS[t[1].toUpperCase()] || +t[1]) : hS[t[1].toUpperCase()] || +t[1]
			},
			dS = (t, e, n) => {
				t = sS(t, 255), e = sS(e, 255), n = sS(n, 255);
				const r = Math.max(t, e, n),
					i = Math.min(t, e, n);
				let o;
				const a = r,
					s = r - i,
					l = 0 === r ? 0 : s / r;
				if (r === i) o = 0;
				else {
					switch (r) {
						case t:
							o = (e - n) / s + (e < n ? 6 : 0);
							break;
						case e:
							o = (n - t) / s + 2;
							break;
						case n:
							o = (t - e) / s + 4
					}
					o /= 6
				}
				return {
					h: 360 * o,
					s: 100 * l,
					v: 100 * a
				}
			},
			pS = function(t, e, n) {
				t = 6 * sS(t, 360), e = sS(e, 100), n = sS(n, 100);
				const r = Math.floor(t),
					i = t - r,
					o = n * (1 - e),
					a = n * (1 - i * e),
					s = n * (1 - (1 - i) * e),
					l = r % 6,
					c = [n, a, o, o, s, n][l],
					u = [s, n, n, a, o, o][l],
					h = [o, o, s, n, n, a][l];
				return {
					r: Math.round(255 * c),
					g: Math.round(255 * u),
					b: Math.round(255 * h)
				}
			};
		class gS {
			constructor(t = {}) {
				this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
				for (const e in t) w(t, e) && (this[e] = t[e]);
				t.value ? this.fromString(t.value) : this.doOnChange()
			}
			set(t, e) {
				if (1 !== arguments.length || "object" != typeof t) this[`_${t}`] = e, this.doOnChange();
				else
					for (const e in t) w(t, e) && this.set(e, t[e])
			}
			get(t) {
				return "alpha" === t ? Math.floor(this[`_${t}`]) : this[`_${t}`]
			}
			toRgb() {
				return pS(this._hue, this._saturation, this._value)
			}
			fromString(t) {
				if (!t) return this._hue = 0, this._saturation = 100, this._value = 100, void this.doOnChange();
				const e = (t, e, n) => {
					this._hue = Math.max(0, Math.min(360, t)), this._saturation = Math.max(0, Math.min(100, e)), this._value = Math.max(0, Math.min(100, n)), this.doOnChange()
				};
				if (t.includes("hsl")) {
					const n = t.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((t => "" !== t)).map(((t, e) => e > 2 ? Number.parseFloat(t) : Number.parseInt(t, 10)));
					if (4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100), n.length >= 3) {
						const {
							h: t,
							s: r,
							v: i
						} = function(t, e, n) {
							n /= 100;
							let r = e /= 100;
							const i = Math.max(n, .01);
							return e *= (n *= 2) <= 1 ? n : 2 - n, r *= i <= 1 ? i : 2 - i, {
								h: t,
								s: 100 * (0 === n ? 2 * r / (i + r) : 2 * e / (n + e)),
								v: (n + e) / 2 * 100
							}
						}(n[0], n[1], n[2]);
						e(t, r, i)
					}
				} else if (t.includes("hsv")) {
					const n = t.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((t => "" !== t)).map(((t, e) => e > 2 ? Number.parseFloat(t) : Number.parseInt(t, 10)));
					4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100), n.length >= 3 && e(n[0], n[1], n[2])
				} else if (t.includes("rgb")) {
					const n = t.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((t => "" !== t)).map(((t, e) => e > 2 ? Number.parseFloat(t) : Number.parseInt(t, 10)));
					if (4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100), n.length >= 3) {
						const {
							h: t,
							s: r,
							v: i
						} = dS(n[0], n[1], n[2]);
						e(t, r, i)
					}
				} else if (t.includes("#")) {
					const n = t.replace("#", "").trim();
					if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(n)) return;
					let r, i, o;
					3 === n.length ? (r = fS(n[0] + n[0]), i = fS(n[1] + n[1]), o = fS(n[2] + n[2])) : 6 !== n.length && 8 !== n.length || (r = fS(n.slice(0, 2)), i = fS(n.slice(2, 4)), o = fS(n.slice(4, 6))), 8 === n.length ? this._alpha = fS(n.slice(6)) / 255 * 100 : 3 !== n.length && 6 !== n.length || (this._alpha = 100);
					const {
						h: a,
						s,
						v: l
					} = dS(r, i, o);
					e(a, s, l)
				}
			}
			compare(t) {
				return Math.abs(t._hue - this._hue) < 2 && Math.abs(t._saturation - this._saturation) < 1 && Math.abs(t._value - this._value) < 1 && Math.abs(t._alpha - this._alpha) < 1
			}
			doOnChange() {
				const {
					_hue: t,
					_saturation: e,
					_value: n,
					_alpha: r,
					format: i
				} = this;
				if (this.enableAlpha) switch (i) {
					case "hsl": {
						const r = aS(t, e / 100, n / 100);
						this.value = `hsla(${t}, ${Math.round(100*r[1])}%, ${Math.round(100*r[2])}%, ${this.get("alpha")/100})`;
						break
					}
					case "hsv":
						this.value = `hsva(${t}, ${Math.round(e)}%, ${Math.round(n)}%, ${this.get("alpha")/100})`;
						break;
					case "hex":
						this.value = `${uS(pS(t,e,n))}${cS(255*r/100)}`;
						break;
					default: {
						const {
							r,
							g: i,
							b: o
						} = pS(t, e, n);
						this.value = `rgba(${r}, ${i}, ${o}, ${this.get("alpha")/100})`
					}
				} else switch (i) {
					case "hsl": {
						const r = aS(t, e / 100, n / 100);
						this.value = `hsl(${t}, ${Math.round(100*r[1])}%, ${Math.round(100*r[2])}%)`;
						break
					}
					case "hsv":
						this.value = `hsv(${t}, ${Math.round(e)}%, ${Math.round(n)}%)`;
						break;
					case "rgb": {
						const {
							r,
							g: i,
							b: o
						} = pS(t, e, n);
						this.value = `rgb(${r}, ${i}, ${o})`;
						break
					}
					default:
						this.value = uS(pS(t, e, n))
				}
			}
		}
		const vS = Ze({
				props: {
					colors: {
						type: Array,
						required: !0
					},
					color: {
						type: Object,
						required: !0
					}
				},
				setup(t) {
					const e = Dg("color-predefine"),
						{
							currentColor: n
						} = We(oS),
						r = ve(i(t.colors, t.color));

					function i(t, e) {
						return t.map((t => {
							const n = new gS;
							return n.enableAlpha = !0, n.format = "rgba", n.fromString(t), n.selected = n.value === e.value, n
						}))
					}
					return vi((() => n.value), (t => {
						const e = new gS;
						e.fromString(t), r.value.forEach((t => {
							t.selected = e.compare(t)
						}))
					})), mi((() => {
						r.value = i(t.colors, t.color)
					}), null, void 0), {
						rgbaColors: r,
						handleSelect: function(e) {
							t.color.fromString(t.colors[e])
						},
						ns: e
					}
				}
			}),
			mS = ["onClick"];
		var yS = Pg(vS, [
			["render", function(t, e, n, r, o, a) {
				return Jn(), er("div", {
					class: l(t.ns.b())
				}, [lr("div", {
					class: l(t.ns.e("colors"))
				}, [(Jn(!0), er(qn, null, mr(t.rgbaColors, ((e, n) => (Jn(), er("div", {
					key: t.colors[n],
					class: l([t.ns.e("color-selector"), t.ns.is("alpha", e._alpha < 100), {
						selected: e.selected
					}]),
					onClick: e => t.handleSelect(n)
				}, [lr("div", {
					style: i({
						backgroundColor: e.value
					})
				}, null, 4)], 10, mS)))), 128))], 2)], 2)
			}],
			["__file", "predefine.vue"]
		]);
		const bS = Ze({
				name: "ElSlPanel",
				props: {
					color: {
						type: Object,
						required: !0
					}
				},
				setup(t) {
					const e = Dg("color-svpanel"),
						n = Fr(),
						r = ve(0),
						i = ve(0),
						o = ve("hsl(0, 100%, 50%)"),
						a = Pe((() => ({
							hue: t.color.get("hue"),
							value: t.color.get("value")
						})));

					function s() {
						const e = t.color.get("saturation"),
							a = t.color.get("value"),
							s = n.vnode.el,
							{
								clientWidth: l,
								clientHeight: c
							} = s;
						i.value = e * l / 100, r.value = (100 - a) * c / 100, o.value = `hsl(${t.color.get("hue")}, 100%, 50%)`
					}

					function l(e) {
						const o = n.vnode.el.getBoundingClientRect(),
							{
								clientX: a,
								clientY: s
							} = $C(e);
						let l = a - o.left,
							c = s - o.top;
						l = Math.max(0, l), l = Math.min(l, o.width), c = Math.max(0, c), c = Math.min(c, o.height), i.value = l, r.value = c, t.color.set({
							saturation: l / o.width * 100,
							value: 100 - c / o.height * 100
						})
					}
					return vi((() => a.value), (() => {
						s()
					})), on((() => {
						QC(n.vnode.el, {
							drag: t => {
								l(t)
							},
							end: t => {
								l(t)
							}
						}), s()
					})), {
						cursorTop: r,
						cursorLeft: i,
						background: o,
						colorValue: a,
						handleDrag: l,
						update: s,
						ns: e
					}
				}
			}),
			xS = [lr("div", null, null, -1)];
		var wS = Pg(bS, [
			["render", function(t, e, n, r, o, a) {
				return Jn(), er("div", {
					class: l(t.ns.b()),
					style: i({
						backgroundColor: t.background
					})
				}, [lr("div", {
					class: l(t.ns.e("white"))
				}, null, 2), lr("div", {
					class: l(t.ns.e("black"))
				}, null, 2), lr("div", {
					class: l(t.ns.e("cursor")),
					style: i({
						top: t.cursorTop + "px",
						left: t.cursorLeft + "px"
					})
				}, xS, 6)], 6)
			}],
			["__file", "sv-panel.vue"]
		]);
		const CS = new Map;
		let SS;

		function OS(t, e) {
			let n = [];
			return Array.isArray(e.arg) ? n = e.arg : Bg(e.arg) && n.push(e.arg),
				function(r, i) {
					const o = e.instance.popperRef,
						a = r.target,
						s = null == i ? void 0 : i.target,
						l = !e || !e.instance,
						c = !a || !s,
						u = t.contains(a) || t.contains(s),
						h = t === a,
						f = n.length && n.some((t => null == t ? void 0 : t.contains(a))) || n.length && n.includes(s),
						d = o && (o.contains(a) || o.contains(s));
					l || c || u || h || f || d || e.value(r, i)
				}
		}
		tg && (document.addEventListener("mousedown", (t => SS = t)), document.addEventListener("mouseup", (t => {
			for (const e of CS.values())
				for (const {
						documentHandler: n
					}
					of e) n(t, SS)
		})));
		const TS = {
				beforeMount(t, e) {
					CS.has(t) || CS.set(t, []), CS.get(t).push({
						documentHandler: OS(t, e),
						bindingFn: e.value
					})
				},
				updated(t, e) {
					CS.has(t) || CS.set(t, []);
					const n = CS.get(t),
						r = n.findIndex((t => t.bindingFn === e.oldValue)),
						i = {
							documentHandler: OS(t, e),
							bindingFn: e.value
						};
					r >= 0 ? n.splice(r, 1, i) : n.push(i)
				},
				unmounted(t) {
					CS.delete(t)
				}
			},
			kS = ["onKeydown"],
			FS = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"],
			PS = Ze({
				name: "ElColorPicker"
			}),
			jS = Ze({
				...PS,
				props: rS,
				emits: iS,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t,
						{
							t: o
						} = Fm(),
						a = Dg("color"),
						{
							formItem: s
						} = $x(),
						u = nw(),
						h = rw(),
						{
							inputId: f,
							isLabeledByFormItem: d
						} = tw(r, {
							formItemContext: s
						}),
						p = ve(),
						g = ve(),
						v = ve(),
						m = ve(),
						y = ve(),
						b = ve(),
						{
							isFocused: x,
							handleFocus: w,
							handleBlur: C
						} = xC(y, {
							beforeBlur(t) {
								var e;
								return null == (e = m.value) ? void 0 : e.isFocusInsideContent(t)
							},
							afterBlur() {
								M(!1), N()
							}
						}),
						S = t => {
							if (h.value) return X();
							w(t)
						};
					let O = !0;
					const T = re(new gS({
							enableAlpha: r.showAlpha,
							format: r.colorFormat || "",
							value: r.modelValue
						})),
						// started from here 
						
						k = ve(!1),
						F = ve(!1),
						P = ve(""),
						j = Pe((() => r.modelValue || F.value ? function(t, e) {
							if (!(t instanceof gS)) throw new TypeError("color should be instance of _color Class");
							const {
								r: n,
								g: r,
								b: i
							} = t.toRgb();
							return e ? `rgba(${n}, ${r}, ${i}, ${t.get("alpha")/100})` : `rgb(${n}, ${r}, ${i})`
						}(T, r.showAlpha) : "transparent")),
						A = Pe((() => r.modelValue || F.value ? T.value : "")),
						_ = Pe((() => d.value ? void 0 : r.label || o("el.colorpicker.defaultLabel"))),
						E = Pe((() => d.value ? null == s ? void 0 : s.labelId : void 0)),
						D = Pe((() => [a.b("picker"), a.is("disabled", h.value), a.bm("picker", u.value), a.is("focused", x.value)]));
 
						// ended here 
						
	
						

					function M(t) {
						k.value = t
					}
					const I = YC(M, 100, {
						leading: !0
					});

					function R() {
						h.value || M(!0)
					}

					function B() {
						I(!1), N()
					}

					function N() {
						si((() => {
							r.modelValue ? T.fromString(r.modelValue) : (T.value = "", si((() => {
								F.value = !1
							})))
						}))
					}

					function L() {
						h.value || I(!k.value)
					}

					function z() {
						T.fromString(P.value)
					}

					function W() {
						const t = T.value;
						n(dC, t), n("change", t), r.validateEvent && (null == s || s.validate("change").catch((t => {}))), I(!1), si((() => {
							const t = new gS({
								enableAlpha: r.showAlpha,
								format: r.colorFormat || "",
								value: r.modelValue
							});
							T.compare(t) || N()
						}))
					}

					function V() {
						I(!1), n(dC, null), n("change", null), null !== r.modelValue && r.validateEvent && (null == s || s.validate("change").catch((t => {}))), N()
					}

					function U(t) {
						if (k.value && (B(), x.value)) {
							const e = new FocusEvent("focus", t);
							C(e)
						}
					}

					function H(t) {
						t.preventDefault(), t.stopPropagation(), M(!1), N()
					}

					function q(t) {
						switch (t.code) {
							case zm:
							case Wm:
								t.preventDefault(), t.stopPropagation(), R(), b.value.focus();
								break;
							case Vm:
								H(t)
						}
					}

					function X() {
						y.value.blur()
					}
					function handleColorEvent(W) {
  localStorage.setItem("pickedColor", W);
}
					
					return on((() => {
						r.modelValue && (P.value = A.value)
					})), vi((() => r.modelValue), (t => {
						t ? t && t !== T.value && (O = !1, T.fromString(t)) : F.value = !1
					})), vi((() => A.value), (t => {
						P.value = t, O && n("activeChange", t), O = !0
					})), vi((() => T.value), (() => {
						r.modelValue || F.value || (F.value = !0)
					})), vi((() => k.value), (() => {
						si((() => {
							var t, e, n;
							null == (t = p.value) || t.update(), null == (e = g.value) || e.update(), null == (n = v.value) || n.update()
						}))
					})), ze(oS, {
						currentColor: A
					}), e({
						color: T,
						show: R,
						hide: B,
						focus: function() {
							y.value.focus()
						},
						blur: X
					}), (t, e) => (Jn(), nr(we(Zx), {
						ref_key: "popper",
						ref: m,
						visible: k.value,
						"show-arrow": !1,
						"fallback-placements": ["bottom", "top", "right", "left"],
						offset: 0,
						"gpu-acceleration": !1,
						"popper-class": [we(a).be("picker", "panel"), we(a).b("dropdown"), t.popperClass],
						"stop-popper-mouse-event": !1,
						effect: "light",
						trigger: "click",
						transition: `${we(a).namespace.value}-zoom-in-top`,
						persistent: "",
						onHide: e[2] || (e[2] = t => M(!1))
					}, {
						content: Ie((() => [Sn((Jn(), er("div", {
							onKeydown: uo(H, ["esc"])
						}, [lr("div", {
							class: l(we(a).be("dropdown", "main-wrapper"))
						}, [cr(nS, {
							ref_key: "hue",
							ref: p,
							class: "hue-slider",
							color: we(T),
							vertical: ""
						}, null, 8, ["color"]), cr(wS, {
							ref_key: "sv",
							ref: g,
							color: we(T)
						}, null, 8, ["color"])], 2), t.showAlpha ? (Jn(), nr(eS, {
							key: 0,
							ref_key: "alpha",
							ref: v,
							color: we(T)
						}, null, 8, ["color"])) : fr("v-if", !0), t.predefine ? (Jn(), nr(yS, {
							key: 1,
							ref: "predefine",
							color: we(T),
							colors: t.predefine
						}, null, 8, ["color", "colors"])) : fr("v-if", !0), lr("div", {
							class: l(we(a).be("dropdown", "btns"))
						}, [lr("span", {
							class: l(we(a).be("dropdown", "value"))
						}, [cr(we(FC), {
							ref_key: "inputRef",
							ref: b,
							modelValue: P.value,
							"onUpdate:modelValue": e[0] || (e[0] = t => P.value = t),
							"validate-event": !1,
							size: "small",
							onKeyup: uo(z, ["enter"]),
							onBlur: z
						}, null, 8, ["modelValue", "onKeyup"])], 2), cr(we(_w), {
							class: l(we(a).be("dropdown", "link-btn")),
							text: "",
							size: "small",
							onClick: V
						}, {
							default: Ie((() => [hr(c(we(o)("el.colorpicker.clear")), 1)])),
							_: 1
						}, 8, ["class"]), cr(we(_w), {
							plain: "",
							size: "small",
							class: l(we(a).be("dropdown", "btn")),
							onClick: W
						}, {
							default: Ie((() => [hr(c(we(o)("el.colorpicker.confirm")), 1)])),
							_: 1
						}, 8, ["class"])], 2)], 40, kS)), [
							[we(TS), U]
						])])),
						default: Ie((() => [lr("div", {
							id: we(f),
							ref_key: "triggerRef",
							ref: y,
							class: l(we(D)),
							role: "button",
							"aria-label": we(_),
							"aria-labelledby": we(E),
							"aria-description": we(o)("el.colorpicker.description", {
								color: t.modelValue || ""


								
							}),
							"aria-disabled": we(h),
							tabindex: we(h) ? -1 : t.tabindex,
							onKeydown: q,
							onFocus: S,
							
							onBlur: e[1] || (e[1] = (...t) => we(C) && we(C)(...t))
						}, [we(h) ? (Jn(), er("div", {
							key: 0,
							class: l(we(a).be("picker", "mask"))
						}, null, 2)) : fr("v-if", !0), lr("div", {
							class: l(we(a).be("picker", "trigger")),
							onClick: L
						}, [lr("span", {
							class: l([we(a).be("picker", "color"), we(a).is("alpha", t.showAlpha)])
						}, [lr("span", {
							class: l(we(a).be("picker", "color-inner")),
							style: i({
								backgroundColor: we(j)
							}),
							 onChange:handleColorEvent(we(j)),
						}, [Sn(cr(we(Yg), {
							class: l([we(a).be("picker", "icon"), we(a).is("icon-arrow-down")])
						}, {
							default: Ie((() => [cr(we(Zg))])),
							_: 1
						}, 8, ["class"]), [
							[ho, t.modelValue || F.value]
						]), Sn(cr(we(Yg), {
							class: l([we(a).be("picker", "empty"), we(a).is("icon-close")])
						}, {
							default: Ie((() => [cr(we(ev))])),
							_: 1
						}, 8, ["class"]), [
							[ho, !t.modelValue && !F.value]
						])], 6)], 2)], 2)], 42, FS)])),

						_: 1
					}, 8, ["visible", "popper-class", "transition"]))
				}
			}),

		

			AS = zg(Pg(jS, [
				["__file", "color-picker.vue"]
			])),
			_S = {
				vertical: {
					offset: "offsetHeight",
					scroll: "scrollTop",
					scrollSize: "scrollHeight",
					size: "height",
					key: "vertical",
					axis: "Y",
					client: "clientY",
					direction: "top"
				},
				horizontal: {
					offset: "offsetWidth",
					scroll: "scrollLeft",
					scrollSize: "scrollWidth",
					size: "width",
					key: "horizontal",
					axis: "X",
					client: "clientX",
					direction: "left"
				}
			},
			ES = Symbol("scrollbarContextKey"),
			DS = Ze({
				__name: "thumb",
				props: kg({
					vertical: Boolean,
					size: String,
					move: Number,
					ratio: {
						type: Number,
						required: !0
					},
					always: Boolean
				}),
				setup(t) {
					const e = t,
						n = We(ES),
						r = Dg("scrollbar");
					n || qg("Thumb", "can not inject scrollbar context");
					const o = ve(),
						a = ve(),
						s = ve({}),
						c = ve(!1);
					let u = !1,
						h = !1,
						f = tg ? document.onselectstart : null;
					const d = Pe((() => _S[e.vertical ? "vertical" : "horizontal"])),
						p = Pe((() => (({
							move: t,
							size: e,
							bar: n
						}) => ({
							[n.size]: e,
							transform: `translate${n.axis}(${t}%)`
						}))({
							size: e.size,
							move: e.move,
							bar: d.value
						}))),
						g = Pe((() => o.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / e.ratio / a.value[d.value.offset])),
						v = t => {
							var e;
							if (t.stopPropagation(), t.ctrlKey || [1, 2].includes(t.button)) return;
							null == (e = window.getSelection()) || e.removeAllRanges(), y(t);
							const n = t.currentTarget;
							n && (s.value[d.value.axis] = n[d.value.offset] - (t[d.value.client] - n.getBoundingClientRect()[d.value.direction]))
						},
						m = t => {
							if (!a.value || !o.value || !n.wrapElement) return;
							const e = 100 * (Math.abs(t.target.getBoundingClientRect()[d.value.direction] - t[d.value.client]) - a.value[d.value.offset] / 2) * g.value / o.value[d.value.offset];
							n.wrapElement[d.value.scroll] = e * n.wrapElement[d.value.scrollSize] / 100
						},
						y = t => {
							t.stopImmediatePropagation(), u = !0, document.addEventListener("mousemove", b), document.addEventListener("mouseup", x), f = document.onselectstart, document.onselectstart = () => !1
						},
						b = t => {
							if (!o.value || !a.value) return;
							if (!1 === u) return;
							const e = s.value[d.value.axis];
							if (!e) return;
							const r = 100 * (-1 * (o.value.getBoundingClientRect()[d.value.direction] - t[d.value.client]) - (a.value[d.value.offset] - e)) * g.value / o.value[d.value.offset];
							n.wrapElement[d.value.scroll] = r * n.wrapElement[d.value.scrollSize] / 100
						},
						x = () => {
							u = !1, s.value[d.value.axis] = 0, document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", x), w(), h && (c.value = !1)
						};
					sn((() => {
						w(), document.removeEventListener("mouseup", x)
					}));
					const w = () => {
						document.onselectstart !== f && (document.onselectstart = f)
					};
					return lg(ke(n, "scrollbarElement"), "mousemove", (() => {
						h = !1, c.value = !!e.size
					})), lg(ke(n, "scrollbarElement"), "mouseleave", (() => {
						h = !0, c.value = u
					})), (t, e) => (Jn(), nr(Hi, {
						name: we(r).b("fade"),
						persisted: ""
					}, {
						default: Ie((() => [Sn(lr("div", {
							ref_key: "instance",
							ref: o,
							class: l([we(r).e("bar"), we(r).is(we(d).key)]),
							onMousedown: m
						}, [lr("div", {
							ref_key: "thumb",
							ref: a,
							class: l(we(r).e("thumb")),
							style: i(we(p)),
							onMousedown: v
						}, null, 38)], 34), [
							[ho, t.always || c.value]
						])])),
						_: 1
					}, 8, ["name"]))
				}
			});
		var MS = Pg(DS, [
				["__file", "thumb.vue"]
			]),
			IS = Pg(Ze({
				__name: "bar",
				props: kg({
					always: {
						type: Boolean,
						default: !0
					},
					width: String,
					height: String,
					ratioX: {
						type: Number,
						default: 1
					},
					ratioY: {
						type: Number,
						default: 1
					}
				}),
				setup(t, {
					expose: e
				}) {
					const n = t,
						r = ve(0),
						i = ve(0);
					return e({
						handleScroll: t => {
							if (t) {
								const e = t.offsetHeight - 4,
									o = t.offsetWidth - 4;
								i.value = 100 * t.scrollTop / e * n.ratioY, r.value = 100 * t.scrollLeft / o * n.ratioX
							}
						}
					}), (t, e) => (Jn(), er(qn, null, [cr(MS, {
						move: r.value,
						ratio: t.ratioX,
						size: t.width,
						always: t.always
					}, null, 8, ["move", "ratio", "size", "always"]), cr(MS, {
						move: i.value,
						ratio: t.ratioY,
						size: t.height,
						vertical: "",
						always: t.always
					}, null, 8, ["move", "ratio", "size", "always"])], 64))
				}
			}), [
				["__file", "bar.vue"]
			]);
		const RS = kg({
				height: {
					type: [String, Number],
					default: ""
				},
				maxHeight: {
					type: [String, Number],
					default: ""
				},
				native: {
					type: Boolean,
					default: !1
				},
				wrapStyle: {
					type: [String, Object, Array],
					default: ""
				},
				wrapClass: {
					type: [String, Array],
					default: ""
				},
				viewClass: {
					type: [String, Array],
					default: ""
				},
				viewStyle: {
					type: [String, Array, Object],
					default: ""
				},
				noresize: Boolean,
				tag: {
					type: String,
					default: "div"
				},
				always: Boolean,
				minSize: {
					type: Number,
					default: 20
				},
				id: String,
				role: String,
				ariaLabel: String,
				ariaOrientation: {
					type: String,
					values: ["horizontal", "vertical"]
				}
			}),
			BS = {
				scroll: ({
					scrollTop: t,
					scrollLeft: e
				}) => [t, e].every(Rg)
			},
			NS = Ze({
				name: "ElScrollbar"
			}),
			LS = Ze({
				...NS,
				props: RS,
				emits: BS,
				setup(t, {
					expose: e,
					emit: n
				}) {
					const r = t,
						o = Dg("scrollbar");
					let a, s;
					const c = ve(),
						u = ve(),
						h = ve(),
						f = ve("0"),
						d = ve("0"),
						p = ve(),
						g = ve(1),
						v = ve(1),
						m = Pe((() => {
							const t = {};
							return r.height && (t.height = Xg(r.height)), r.maxHeight && (t.maxHeight = Xg(r.maxHeight)), [r.wrapStyle, t]
						})),
						y = Pe((() => [r.wrapClass, o.e("wrap"), {
							[o.em("wrap", "hidden-default")]: !r.native
						}])),
						b = Pe((() => [o.e("view"), r.viewClass])),
						x = () => {
							var t;
							u.value && (null == (t = p.value) || t.handleScroll(u.value), n("scroll", {
								scrollTop: u.value.scrollTop,
								scrollLeft: u.value.scrollLeft
							}))
						},
						w = () => {
							if (!u.value) return;
							const t = u.value.offsetHeight - 4,
								e = u.value.offsetWidth - 4,
								n = t ** 2 / u.value.scrollHeight,
								i = e ** 2 / u.value.scrollWidth,
								o = Math.max(n, r.minSize),
								a = Math.max(i, r.minSize);
							g.value = n / (t - n) / (o / (t - o)), v.value = i / (e - i) / (a / (e - a)), d.value = o + 4 < t ? `${o}px` : "", f.value = a + 4 < e ? `${a}px` : ""
						};
					return vi((() => r.noresize), (t => {
						t ? (null == a || a(), null == s || s()) : (({
							stop: a
						} = mg(h, w)), s = lg("resize", w))
					}), {
						immediate: !0
					}), vi((() => [r.maxHeight, r.height]), (() => {
						r.native || si((() => {
							var t;
							w(), u.value && (null == (t = p.value) || t.handleScroll(u.value))
						}))
					})), ze(ES, re({
						scrollbarElement: c,
						wrapElement: u
					})), on((() => {
						r.native || si((() => {
							w()
						}))
					})), an((() => w())), e({
						wrapRef: u,
						update: w,
						scrollTo: function(t, e) {
							P(t) ? u.value.scrollTo(t) : Rg(t) && Rg(e) && u.value.scrollTo(t, e)
						},
						setScrollTop: t => {
							Rg(t) && (u.value.scrollTop = t)
						},
						setScrollLeft: t => {
							Rg(t) && (u.value.scrollLeft = t)
						},
						handleScroll: x
					}), (t, e) => (Jn(), er("div", {
						ref_key: "scrollbarRef",
						ref: c,
						class: l(we(o).b())
					}, [lr("div", {
						ref_key: "wrapRef",
						ref: u,
						class: l(we(y)),
						style: i(we(m)),
						onScroll: x
					}, [(Jn(), nr(Vn(t.tag), {
						id: t.id,
						ref_key: "resizeRef",
						ref: h,
						class: l(we(b)),
						style: i(t.viewStyle),
						role: t.role,
						"aria-label": t.ariaLabel,
						"aria-orientation": t.ariaOrientation
					}, {
						default: Ie((() => [br(t.$slots, "default")])),
						_: 3
					}, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))], 38), t.native ? fr("v-if", !0) : (Jn(), nr(IS, {
						key: 0,
						ref_key: "barRef",
						ref: p,
						height: d.value,
						width: f.value,
						always: t.always,
						"ratio-x": v.value,
						"ratio-y": g.value
					}, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))], 2))
				}
			}),
			zS = zg(Pg(LS, [
				["__file", "scrollbar.vue"]
			])),
			WS = kg({
				type: {
					type: String,
					values: ["success", "info", "warning", "danger", ""],
					default: ""
				},
				closable: Boolean,
				disableTransitions: Boolean,
				hit: Boolean,
				color: {
					type: String,
					default: ""
				},
				size: {
					type: String,
					values: _m,
					default: ""
				},
				effect: {
					type: String,
					values: ["dark", "light", "plain"],
					default: "light"
				},
				round: Boolean
			}),
			VS = {
				close: t => t instanceof MouseEvent,
				click: t => t instanceof MouseEvent
			},
			US = Ze({
				name: "ElTag"
			}),
			HS = Ze({
				...US,
				props: WS,
				emits: VS,
				setup(t, {
					emit: e
				}) {
					const n = t,
						r = nw(),
						o = Dg("tag"),
						a = Pe((() => {
							const {
								type: t,
								hit: e,
								effect: i,
								closable: a,
								round: s
							} = n;
							return [o.b(), o.is("closable", a), o.m(t), o.m(r.value), o.m(i), o.is("hit", e), o.is("round", s)]
						})),
						s = t => {
							e("close", t)
						},
						c = t => {
							e("click", t)
						};
					return (t, e) => t.disableTransitions ? (Jn(), er("span", {
						key: 0,
						class: l(we(a)),
						style: i({
							backgroundColor: t.color
						}),
						onClick: c
					}, [lr("span", {
						class: l(we(o).e("content"))
					}, [br(t.$slots, "default")], 2), t.closable ? (Jn(), nr(we(Yg), {
						key: 0,
						class: l(we(o).e("close")),
						onClick: lo(s, ["stop"])
					}, {
						default: Ie((() => [cr(we(ev))])),
						_: 1
					}, 8, ["class", "onClick"])) : fr("v-if", !0)], 6)) : (Jn(), nr(Hi, {
						key: 1,
						name: `${we(o).namespace.value}-zoom-in-center`,
						appear: ""
					}, {
						default: Ie((() => [lr("span", {
							class: l(we(a)),
							style: i({
								backgroundColor: t.color
							}),
							onClick: c
						}, [lr("span", {
							class: l(we(o).e("content"))
						}, [br(t.$slots, "default")], 2), t.closable ? (Jn(), nr(we(Yg), {
							key: 0,
							class: l(we(o).e("close")),
							onClick: lo(s, ["stop"])
						}, {
							default: Ie((() => [cr(we(ev))])),
							_: 1
						}, 8, ["class", "onClick"])) : fr("v-if", !0)], 6)])),
						_: 3
					}, 8, ["name"]))
				}
			}),
			qS = zg(Pg(HS, [
				["__file", "tag.vue"]
			])),
			XS = Symbol("ElSelectGroup"),
			GS = Symbol("ElSelect"),
			KS = Ze({
				name: "ElOption",
				componentName: "ElOption",
				props: {
					value: {
						required: !0,
						type: [String, Number, Boolean, Object]
					},
					label: [String, Number],
					created: Boolean,
					disabled: Boolean
				},
				setup(t) {
					const e = Dg("select"),
						n = ox(),
						r = Pe((() => [e.be("dropdown", "item"), e.is("disabled", we(s)), {
							selected: we(a),
							hover: we(h)
						}])),
						i = re({
							index: -1,
							groupDisabled: !1,
							visible: !0,
							hitState: !1,
							hover: !1
						}),
						{
							currentLabel: o,
							itemSelected: a,
							isDisabled: s,
							select: l,
							hoverItem: c
						} = function(t, e) {
							const n = We(GS),
								r = We(XS, {
									disabled: !1
								}),
								i = Pe((() => P(t.value))),
								o = Pe((() => n.props.multiple ? h(n.props.modelValue, t.value) : f(t.value, n.props.modelValue))),
								a = Pe((() => {
									if (n.props.multiple) {
										const t = n.props.modelValue || [];
										return !o.value && t.length >= n.props.multipleLimit && n.props.multipleLimit > 0
									}
									return !1
								})),
								s = Pe((() => t.label || (i.value ? "" : t.value))),
								l = Pe((() => t.value || t.label || "")),
								c = Pe((() => t.disabled || e.groupDisabled || a.value)),
								u = Fr(),
								h = (t = [], e) => {
									if (i.value) {
										const r = n.props.valueKey;
										return t && t.some((t => ue(Cm(t, r)) === Cm(e, r)))
									}
									return t && t.includes(e)
								},
								f = (t, e) => {
									if (i.value) {
										const {
											valueKey: r
										} = n.props;
										return Cm(t, r) === Cm(e, r)
									}
									return t === e
								};
							vi((() => s.value), (() => {
								t.created || n.props.remote || n.setSelected()
							})), vi((() => t.value), ((e, r) => {
								const {
									remote: i,
									valueKey: o
								} = n.props;
								if (Object.is(e, r) || (n.onOptionDestroy(r, u.proxy), n.onOptionCreate(u.proxy)), !t.created && !i) {
									if (o && P(e) && P(r) && e[o] === r[o]) return;
									n.setSelected()
								}
							})), vi((() => r.disabled), (() => {
								e.groupDisabled = r.disabled
							}), {
								immediate: !0
							});
							const {
								queryChange: d
							} = ue(n);
							return vi(d, (r => {
								const {
									query: i
								} = we(r), o = new RegExp(((t = "") => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"))(i), "i");
								e.visible = o.test(s.value) || t.created, e.visible || n.filteredOptionsCount--
							}), {
								immediate: !0
							}), {
								select: n,
								currentLabel: s,
								currentValue: l,
								itemSelected: o,
								isDisabled: c,
								hoverItem: () => {
									t.disabled || r.disabled || (n.hoverIndex = n.optionsArray.indexOf(u.proxy))
								}
							}
						}(t, i),
						{
							visible: u,
							hover: h
						} = Oe(i),
						f = Fr().proxy;
					return l.onOptionCreate(f), sn((() => {
						const t = f.value,
							{
								selected: e
							} = l,
							n = (l.props.multiple ? e : [e]).some((t => t.value === f.value));
						si((() => {
							l.cachedOptions.get(t) !== f || n || l.cachedOptions.delete(t)
						})), l.onOptionDestroy(t, f)
					})), {
						ns: e,
						id: n,
						containerKls: r,
						currentLabel: o,
						itemSelected: a,
						isDisabled: s,
						select: l,
						hoverItem: c,
						visible: u,
						hover: h,
						selectOptionClick: function() {
							!0 !== t.disabled && !0 !== i.groupDisabled && l.handleOptionSelect(f)
						},
						states: i
					}
				}
			}),
			YS = ["id", "aria-disabled", "aria-selected"];
		var ZS = Pg(KS, [
			["render", function(t, e, n, r, i, o) {
				return Sn((Jn(), er("li", {
					id: t.id,
					class: l(t.containerKls),
					role: "option",
					"aria-disabled": t.isDisabled || void 0,
					"aria-selected": t.itemSelected,
					onMouseenter: e[0] || (e[0] = (...e) => t.hoverItem && t.hoverItem(...e)),
					onClick: e[1] || (e[1] = lo(((...e) => t.selectOptionClick && t.selectOptionClick(...e)), ["stop"]))
				}, [br(t.$slots, "default", {}, (() => [lr("span", null, c(t.currentLabel), 1)]))], 42, YS)), [
					[ho, t.visible]
				])
			}],
			["__file", "option.vue"]
		]);
		var JS = Pg(Ze({
			name: "ElSelectDropdown",
			componentName: "ElSelectDropdown",
			setup() {
				const t = We(GS),
					e = Dg("select"),
					n = Pe((() => t.props.popperClass)),
					r = Pe((() => t.props.multiple)),
					i = Pe((() => t.props.fitInputWidth)),
					o = ve("");

				function a() {
					var e;
					o.value = `${null==(e=t.selectWrapper)?void 0:e.offsetWidth}px`
				}
				return on((() => {
					a(), mg(t.selectWrapper, a)
				})), {
					ns: e,
					minWidth: o,
					popperClass: n,
					isMultiple: r,
					isFitInputWidth: i
				}
			}
		}), [
			["render", function(t, e, n, r, o, a) {
				return Jn(), er("div", {
					class: l([t.ns.b("dropdown"), t.ns.is("multiple", t.isMultiple), t.popperClass]),
					style: i({
						[t.isFitInputWidth ? "width" : "minWidth"]: t.minWidth
					})
				}, [t.$slots.header ? (Jn(), er("div", {
					key: 0,
					class: l(t.ns.be("dropdown", "header"))
				}, [br(t.$slots, "header")], 2)) : fr("v-if", !0), br(t.$slots, "default"), t.$slots.footer ? (Jn(), er("div", {
					key: 1,
					class: l(t.ns.be("dropdown", "footer"))
				}, [br(t.$slots, "footer")], 2)) : fr("v-if", !0)], 6)
			}],
			["__file", "select-dropdown.vue"]
		]);

		function QS(t) {
			var e = this.__data__ = new om(t);
			this.size = e.size
		}
		QS.prototype.clear = function() {
			this.__data__ = new om, this.size = 0
		}, QS.prototype.delete = function(t) {
			var e = this.__data__,
				n = e.delete(t);
			return this.size = e.size, n
		}, QS.prototype.get = function(t) {
			return this.__data__.get(t)
		}, QS.prototype.has = function(t) {
			return this.__data__.has(t)
		}, QS.prototype.set = function(t, e) {
			var n = this.__data__;
			if (n instanceof om) {
				var r = n.__data__;
				if (!am || r.length < 199) return r.push([t, e]), this.size = ++n.size, this;
				n = this.__data__ = new cm(r)
			}
			return n.set(t, e), this.size = n.size, this
		};
		const $S = QS;

		function tO(t) {
			var e = -1,
				n = null == t ? 0 : t.length;
			for (this.__data__ = new cm; ++e < n;) this.add(t[e])
		}
		tO.prototype.add = tO.prototype.push = function(t) {
			return this.__data__.set(t, "__lodash_hash_undefined__"), this
		}, tO.prototype.has = function(t) {
			return this.__data__.has(t)
		};
		const eO = tO,
			nO = function(t, e) {
				for (var n = -1, r = null == t ? 0 : t.length; ++n < r;)
					if (e(t[n], n, t)) return !0;
				return !1
			},
			rO = function(t, e) {
				return t.has(e)
			},
			iO = function(t, e, n, r, i, o) {
				var a = 1 & n,
					s = t.length,
					l = e.length;
				if (s != l && !(a && l > s)) return !1;
				var c = o.get(t),
					u = o.get(e);
				if (c && u) return c == e && u == t;
				var h = -1,
					f = !0,
					d = 2 & n ? new eO : void 0;
				for (o.set(t, e), o.set(e, t); ++h < s;) {
					var p = t[h],
						g = e[h];
					if (r) var v = a ? r(g, p, h, e, t, o) : r(p, g, h, t, e, o);
					if (void 0 !== v) {
						if (v) continue;
						f = !1;
						break
					}
					if (d) {
						if (!nO(e, (function(t, e) {
								if (!rO(d, e) && (p === t || i(p, t, n, r, o))) return d.push(e)
							}))) {
							f = !1;
							break
						}
					} else if (p !== g && !i(p, g, n, r, o)) {
						f = !1;
						break
					}
				}
				return o.delete(t), o.delete(e), f
			},
			oO = Cv.Uint8Array,
			aO = function(t) {
				var e = -1,
					n = Array(t.size);
				return t.forEach((function(t, r) {
					n[++e] = [r, t]
				})), n
			},
			sO = function(t) {
				var e = -1,
					n = Array(t.size);
				return t.forEach((function(t) {
					n[++e] = t
				})), n
			};
		var lO = Sv ? Sv.prototype : void 0,
			cO = lO ? lO.valueOf : void 0;
		var uO = Object.prototype.propertyIsEnumerable,
			hO = Object.getOwnPropertySymbols;
		const fO = hO ? function(t) {
				return null == t ? [] : (t = Object(t), function(t, e) {
					for (var n = -1, r = null == t ? 0 : t.length, i = 0, o = []; ++n < r;) {
						var a = t[n];
						e(a, n, t) && (o[i++] = a)
					}
					return o
				}(hO(t), (function(e) {
					return uO.call(t, e)
				})))
			} : function() {
				return []
			},
			dO = function(t) {
				return _v(t) && "[object Arguments]" == Av(t)
			};
		var pO = Object.prototype,
			gO = pO.hasOwnProperty,
			vO = pO.propertyIsEnumerable;
		const mO = dO(function() {
			return arguments
		}()) ? dO : function(t) {
			return _v(t) && gO.call(t, "callee") && !vO.call(t, "callee")
		};
		var yO = "object" == typeof exports && exports && !exports.nodeType && exports,
			bO = yO && "object" == typeof module && module && !module.nodeType && module,
			xO = bO && bO.exports === yO ? Cv.Buffer : void 0;
		const wO = (xO ? xO.isBuffer : void 0) || function() {
			return !1
		};
		var CO = /^(?:0|[1-9]\d*)$/;
		const SO = function(t, e) {
				var n = typeof t;
				return !!(e = null == e ? 9007199254740991 : e) && ("number" == n || "symbol" != n && CO.test(t)) && t > -1 && t % 1 == 0 && t < e
			},
			OO = function(t) {
				return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
			};
		var TO = {};
		TO["[object Float32Array]"] = TO["[object Float64Array]"] = TO["[object Int8Array]"] = TO["[object Int16Array]"] = TO["[object Int32Array]"] = TO["[object Uint8Array]"] = TO["[object Uint8ClampedArray]"] = TO["[object Uint16Array]"] = TO["[object Uint32Array]"] = !0, TO["[object Arguments]"] = TO["[object Array]"] = TO["[object ArrayBuffer]"] = TO["[object Boolean]"] = TO["[object DataView]"] = TO["[object Date]"] = TO["[object Error]"] = TO["[object Function]"] = TO["[object Map]"] = TO["[object Number]"] = TO["[object Object]"] = TO["[object RegExp]"] = TO["[object Set]"] = TO["[object String]"] = TO["[object WeakMap]"] = !1;
		var kO = "object" == typeof exports && exports && !exports.nodeType && exports,
			FO = kO && "object" == typeof module && module && !module.nodeType && module,
			PO = FO && FO.exports === kO && xv.process,
			jO = function() {
				try {
					return FO && FO.require && FO.require("util").types || PO && PO.binding && PO.binding("util")
				} catch (t) {}
			}(),
			AO = jO && jO.isTypedArray;
		const _O = AO ? (EO = AO, function(t) {
			return EO(t)
		}) : function(t) {
			return _v(t) && OO(t.length) && !!TO[Av(t)]
		};
		var EO, DO = Object.prototype.hasOwnProperty;
		const MO = function(t, e) {
			var n = bv(t),
				r = !n && mO(t),
				i = !n && !r && wO(t),
				o = !n && !r && !i && _O(t),
				a = n || r || i || o,
				s = a ? function(t, e) {
					for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
					return r
				}(t.length, String) : [],
				l = s.length;
			for (var c in t) !e && !DO.call(t, c) || a && ("length" == c || i && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || SO(c, l)) || s.push(c);
			return s
		};
		var IO = Object.prototype;
		const RO = function(t, e) {
			return function(n) {
				return t(e(n))
			}
		}(Object.keys, Object);
		var BO = Object.prototype.hasOwnProperty;
		const NO = function(t) {
				if (n = (e = t) && e.constructor, e !== ("function" == typeof n && n.prototype || IO)) return RO(t);
				var e, n, r = [];
				for (var i in Object(t)) BO.call(t, i) && "constructor" != i && r.push(i);
				return r
			},
			LO = function(t) {
				return null != (e = t) && OO(e.length) && !Bv(e) ? MO(t) : NO(t);
				var e
			},
			zO = function(t) {
				return function(t, e, n) {
					var r = e(t);
					return bv(t) ? r : function(t, e) {
						for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
						return t
					}(r, n(t))
				}(t, LO, fO)
			};
		var WO = Object.prototype.hasOwnProperty;
		const VO = Yv(Cv, "DataView"),
			UO = Yv(Cv, "Promise"),
			HO = Yv(Cv, "Set"),
			qO = Yv(Cv, "WeakMap");
		var XO = "[object Map]",
			GO = "[object Promise]",
			KO = "[object Set]",
			YO = "[object WeakMap]",
			ZO = "[object DataView]",
			JO = Wv(VO),
			QO = Wv(am),
			$O = Wv(UO),
			tT = Wv(HO),
			eT = Wv(qO),
			nT = Av;
		(VO && nT(new VO(new ArrayBuffer(1))) != ZO || am && nT(new am) != XO || UO && nT(UO.resolve()) != GO || HO && nT(new HO) != KO || qO && nT(new qO) != YO) && (nT = function(t) {
			var e = Av(t),
				n = "[object Object]" == e ? t.constructor : void 0,
				r = n ? Wv(n) : "";
			if (r) switch (r) {
				case JO:
					return ZO;
				case QO:
					return XO;
				case $O:
					return GO;
				case tT:
					return KO;
				case eT:
					return YO
			}
			return e
		});
		const rT = nT;
		var iT = "[object Arguments]",
			oT = "[object Array]",
			aT = "[object Object]",
			sT = Object.prototype.hasOwnProperty;
		const lT = function(t, e, n, r, i, o) {
				var a = bv(t),
					s = bv(e),
					l = a ? oT : rT(t),
					c = s ? oT : rT(e),
					u = (l = l == iT ? aT : l) == aT,
					h = (c = c == iT ? aT : c) == aT,
					f = l == c;
				if (f && wO(t)) {
					if (!wO(e)) return !1;
					a = !0, u = !1
				}
				if (f && !u) return o || (o = new $S), a || _O(t) ? iO(t, e, n, r, i, o) : function(t, e, n, r, i, o, a) {
					switch (n) {
						case "[object DataView]":
							if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
							t = t.buffer, e = e.buffer;
						case "[object ArrayBuffer]":
							return !(t.byteLength != e.byteLength || !o(new oO(t), new oO(e)));
						case "[object Boolean]":
						case "[object Date]":
						case "[object Number]":
							return em(+t, +e);
						case "[object Error]":
							return t.name == e.name && t.message == e.message;
						case "[object RegExp]":
						case "[object String]":
							return t == e + "";
						case "[object Map]":
							var s = aO;
						case "[object Set]":
							var l = 1 & r;
							if (s || (s = sO), t.size != e.size && !l) return !1;
							var c = a.get(t);
							if (c) return c == e;
							r |= 2, a.set(t, e);
							var u = iO(s(t), s(e), r, i, o, a);
							return a.delete(t), u;
						case "[object Symbol]":
							if (cO) return cO.call(t) == cO.call(e)
					}
					return !1
				}(t, e, l, n, r, i, o);
				if (!(1 & n)) {
					var d = u && sT.call(t, "__wrapped__"),
						p = h && sT.call(e, "__wrapped__");
					if (d || p) {
						var g = d ? t.value() : t,
							v = p ? e.value() : e;
						return o || (o = new $S), i(g, v, n, r, o)
					}
				}
				return !!f && (o || (o = new $S), function(t, e, n, r, i, o) {
					var a = 1 & n,
						s = zO(t),
						l = s.length;
					if (l != zO(e).length && !a) return !1;
					for (var c = l; c--;) {
						var u = s[c];
						if (!(a ? u in e : WO.call(e, u))) return !1
					}
					var h = o.get(t),
						f = o.get(e);
					if (h && f) return h == e && f == t;
					var d = !0;
					o.set(t, e), o.set(e, t);
					for (var p = a; ++c < l;) {
						var g = t[u = s[c]],
							v = e[u];
						if (r) var m = a ? r(v, g, u, e, t, o) : r(g, v, u, t, e, o);
						if (!(void 0 === m ? g === v || i(g, v, n, r, o) : m)) {
							d = !1;
							break
						}
						p || (p = "constructor" == u)
					}
					if (d && !p) {
						var y = t.constructor,
							b = e.constructor;
						y == b || !("constructor" in t) || !("constructor" in e) || "function" == typeof y && y instanceof y && "function" == typeof b && b instanceof b || (d = !1)
					}
					return o.delete(t), o.delete(e), d
				}(t, e, n, r, i, o))
			},
			cT = function t(e, n, r, i, o) {
				return e === n || (null == e || null == n || !_v(e) && !_v(n) ? e != e && n != n : lT(e, n, r, i, t, o))
			},
			uT = function(t, e) {
				return cT(t, e)
			},
			hT = function(t) {
				return t == t && !Rv(t)
			},
			fT = function(t, e) {
				return function(n) {
					return null != n && n[t] === e && (void 0 !== e || t in Object(n))
				}
			},
			dT = function(t) {
				var e = function(t) {
					for (var e = LO(t), n = e.length; n--;) {
						var r = e[n],
							i = t[r];
						e[n] = [r, i, hT(i)]
					}
					return e
				}(t);
				return 1 == e.length && e[0][2] ? fT(e[0][0], e[0][1]) : function(n) {
					return n === t || function(t, e, n, r) {
						var i = n.length,
							o = i,
							a = !r;
						if (null == t) return !o;
						for (t = Object(t); i--;) {
							var s = n[i];
							if (a && s[2] ? s[1] !== t[s[0]] : !(s[0] in t)) return !1
						}
						for (; ++i < o;) {
							var l = (s = n[i])[0],
								c = t[l],
								u = s[1];
							if (a && s[2]) {
								if (void 0 === c && !(l in t)) return !1
							} else {
								var h = new $S;
								if (r) var f = r(c, u, l, t, e, h);
								if (!(void 0 === f ? cT(u, c, 3, r, h) : f)) return !1
							}
						}
						return !0
					}(n, t, e)
				}
			},
			pT = function(t, e) {
				return null != t && e in Object(t)
			},
			gT = function(t, e) {
				return null != t && function(t, e, n) {
					for (var r = -1, i = (e = bm(e, t)).length, o = !1; ++r < i;) {
						var a = xm(e[r]);
						if (!(o = null != t && n(t, a))) break;
						t = t[a]
					}
					return o || ++r != i ? o : !!(i = null == t ? 0 : t.length) && OO(i) && SO(a, i) && (bv(t) || mO(t))
				}(t, e, pT)
			},
			vT = function(t) {
				return t
			},
			mT = function(t) {
				return Iv(t) ? (e = xm(t), function(t) {
					return null == t ? void 0 : t[e]
				}) : function(t) {
					return function(e) {
						return wm(e, t)
					}
				}(t);
				var e
			},
			yT = function(t) {
				return "function" == typeof t ? t : null == t ? vT : "object" == typeof t ? bv(t) ? (e = t[0], n = t[1], Iv(e) && hT(n) ? fT(xm(e), n) : function(t) {
					var r = Cm(t, e);
					return void 0 === r && r === n ? gT(t, e) : cT(n, r, 3)
				}) : dT(t) : mT(t);
				var e, n
			};
		const bT = function(t) {
			var e = function(t) {
					return t ? 1 / 0 === (t = XC(t)) || t === -1 / 0 ? 17976931348623157e292 * (t < 0 ? -1 : 1) : t == t ? t : 0 : 0 === t ? t : 0
				}(t),
				n = e % 1;
			return e == e ? n ? e - n : e : 0
		};
		var xT = Math.max,
			wT = Math.min;
		const CT = (t, e, n) => {
			const {
				t: r
			} = Fm(), i = Dg("select");
			Qx({
				from: "suffixTransition",
				replacement: "override style scheme",
				version: "2.3.0",
				scope: "props",
				ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
			}, Pe((() => !1 === t.suffixTransition)));
			const o = ve(null),
				a = ve(null),
				s = ve(null),
				l = ve(null),
				c = ve(null),
				u = ve(null),
				h = ve(null),
				f = ve(null),
				d = ve(),
				p = me({
					query: ""
				}),
				g = me(""),
				v = ve([]);
			let m = 0;
			const {
				form: y,
				formItem: b
			} = $x(), x = Pe((() => !t.filterable || t.multiple || !e.visible)), w = Pe((() => t.disabled || (null == y ? void 0 : y.disabled))), C = Pe((() => {
				const n = t.multiple ? Array.isArray(t.modelValue) && t.modelValue.length > 0 : void 0 !== t.modelValue && null !== t.modelValue && "" !== t.modelValue;
				return t.clearable && !w.value && e.inputHovering && n
			})), S = Pe((() => t.remote && t.filterable && !t.remoteShowSuffix ? "" : t.suffixIcon)), O = Pe((() => i.is("reverse", S.value && e.visible && t.suffixTransition))), F = Pe((() => (null == y ? void 0 : y.statusIcon) && (null == b ? void 0 : b.validateState) && dv[null == b ? void 0 : b.validateState])), j = Pe((() => t.remote ? 300 : 0)), A = Pe((() => t.loading ? t.loadingText || r("el.select.loading") : (!t.remote || "" !== e.query || 0 !== e.options.size) && (t.filterable && e.query && e.options.size > 0 && 0 === e.filteredOptionsCount ? t.noMatchText || r("el.select.noMatch") : 0 === e.options.size ? t.noDataText || r("el.select.noData") : null))), _ = Pe((() => {
				const t = Array.from(e.options.values()),
					n = [];
				return v.value.forEach((e => {
					const r = t.findIndex((t => t.currentLabel === e));
					r > -1 && n.push(t[r])
				})), n.length >= t.length ? n : t
			})), D = Pe((() => Array.from(e.cachedOptions.values()))), M = Pe((() => {
				const n = _.value.filter((t => !t.created)).some((t => t.currentLabel === e.query));
				return t.filterable && t.allowCreate && "" !== e.query && !n
			})), I = nw(), R = Pe((() => ["small"].includes(I.value) ? "small" : "default")), B = Pe({
				get: () => e.visible && !1 !== A.value,
				set(t) {
					e.visible = t
				}
			});
			vi([() => w.value, () => I.value, () => null == y ? void 0 : y.size], (() => {
				si((() => {
					N()
				}))
			})), vi((() => t.placeholder), (n => {
				e.cachedPlaceHolder = e.currentPlaceholder = n, t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (e.currentPlaceholder = "")
			})), vi((() => t.modelValue), ((n, r) => {
				t.multiple && (N(), n && n.length > 0 || a.value && "" !== e.query ? e.currentPlaceholder = "" : e.currentPlaceholder = e.cachedPlaceHolder, t.filterable && !t.reserveKeyword && (e.query = "", L(e.query))), V(), t.filterable && !t.multiple && (e.inputLength = 20), !uT(n, r) && t.validateEvent && (null == b || b.validate("change").catch((t => {})))
			}), {
				flush: "post",
				deep: !0
			}), vi((() => e.visible), (r => {
				var i, o, c, u, h;
				r ? (null == (o = null == (i = l.value) ? void 0 : i.updatePopper) || o.call(i), t.filterable && (e.filteredOptionsCount = e.optionsCount, e.query = t.remote ? "" : e.selectedLabel, null == (u = null == (c = s.value) ? void 0 : c.focus) || u.call(c), t.multiple ? null == (h = a.value) || h.focus() : e.selectedLabel && (e.currentPlaceholder = `${e.selectedLabel}`, e.selectedLabel = ""), L(e.query), t.multiple || t.remote || (p.value.query = "", xe(p), xe(g)))) : (t.filterable && (T(t.filterMethod) && t.filterMethod(""), T(t.remoteMethod) && t.remoteMethod("")), e.query = "", e.previousQuery = null, e.selectedLabel = "", e.inputLength = 20, e.menuVisibleOnFocus = !1, H(), si((() => {
					a.value && "" === a.value.value && 0 === e.selected.length && (e.currentPlaceholder = e.cachedPlaceHolder)
				})), t.multiple || (e.selected && (t.filterable && t.allowCreate && e.createdSelected && e.createdLabel ? e.selectedLabel = e.createdLabel : e.selectedLabel = e.selected.currentLabel, t.filterable && (e.query = e.selectedLabel)), t.filterable && (e.currentPlaceholder = e.cachedPlaceHolder))), n.emit("visible-change", r)
			})), vi((() => e.options.entries()), (() => {
				var n, r, i;
				if (!tg) return;
				null == (r = null == (n = l.value) ? void 0 : n.updatePopper) || r.call(n), t.multiple && N();
				const o = (null == (i = h.value) ? void 0 : i.querySelectorAll("input")) || [];
				(t.filterable || t.defaultFirstOption || Mg(t.modelValue)) && Array.from(o).includes(document.activeElement) || V(), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && W()
			}), {
				flush: "post"
			}), vi((() => e.hoverIndex), (t => {
				Rg(t) && t > -1 ? d.value = _.value[t] || {} : d.value = {}, _.value.forEach((t => {
					t.hover = d.value === t
				}))
			}));
			const N = () => {
					si((() => {
						var t, n;
						if (!o.value) return;
						const r = o.value.$el.querySelector("input");
						m = m || (r.clientHeight > 0 ? r.clientHeight + 2 : 0);
						const a = u.value,
							s = getComputedStyle(r).getPropertyValue(i.cssVarName("input-height")),
							c = Number.parseFloat(s) || (t => Em[t || "default"])(I.value || (null == y ? void 0 : y.size)),
							h = I.value || c === m || m <= 0 ? c : m;
						!(null === r.offsetParent) && (r.style.height = (0 === e.selected.length ? h : Math.max(a ? a.clientHeight + (a.clientHeight > h ? 6 : 0) : 0, h)) - 2 + "px"), e.visible && !1 !== A.value && (null == (n = null == (t = l.value) ? void 0 : t.updatePopper) || n.call(t))
					}))
				},
				L = async n => {
					e.previousQuery === n || e.isOnComposition || (null !== e.previousQuery || !T(t.filterMethod) && !T(t.remoteMethod) ? (e.previousQuery = n, si((() => {
						var t, n;
						e.visible && (null == (n = null == (t = l.value) ? void 0 : t.updatePopper) || n.call(t))
					})), e.hoverIndex = -1, t.multiple && t.filterable && si((() => {
						if (!w.value) {
							const n = 15 * a.value.value.length + 20;
							e.inputLength = t.collapseTags ? Math.min(50, n) : n, z()
						}
						N()
					})), t.remote && T(t.remoteMethod) ? (e.hoverIndex = -1, t.remoteMethod(n)) : T(t.filterMethod) ? (t.filterMethod(n), xe(g)) : (e.filteredOptionsCount = e.optionsCount, p.value.query = n, xe(p), xe(g)), t.defaultFirstOption && (t.filterable || t.remote) && e.filteredOptionsCount && (await si(), W())) : e.previousQuery = n)
				}, z = () => {
					"" !== e.currentPlaceholder && (e.currentPlaceholder = a.value.value ? "" : e.cachedPlaceHolder)
				}, W = () => {
					const t = _.value.filter((t => t.visible && !t.disabled && !t.states.groupDisabled)),
						n = t.find((t => t.created)),
						r = t[0];
					e.hoverIndex = Q(_.value, n || r)
				}, V = () => {
					var n;
					if (!t.multiple) {
						const r = U(t.modelValue);
						return (null == (n = r.props) ? void 0 : n.created) ? (e.createdLabel = r.props.value, e.createdSelected = !0) : e.createdSelected = !1, e.selectedLabel = r.currentLabel, e.selected = r, void(t.filterable && (e.query = e.selectedLabel))
					}
					e.selectedLabel = "";
					const r = [];
					Array.isArray(t.modelValue) && t.modelValue.forEach((t => {
						r.push(U(t))
					})), e.selected = r, si((() => {
						N()
					}))
				}, U = n => {
					let r;
					const i = "object" === E(n).toLowerCase(),
						o = "null" === E(n).toLowerCase(),
						a = "undefined" === E(n).toLowerCase();
					for (let o = e.cachedOptions.size - 1; o >= 0; o--) {
						const e = D.value[o];
						if (i ? Cm(e.value, t.valueKey) === Cm(n, t.valueKey) : e.value === n) {
							r = {
								value: n,
								currentLabel: e.currentLabel,
								isDisabled: e.isDisabled
							};
							break
						}
					}
					if (r) return r;
					const s = {
						value: n,
						currentLabel: i ? n.label : o || a ? "" : n
					};
					return t.multiple && (s.hitState = !1), s
				}, H = () => {
					setTimeout((() => {
						const n = t.valueKey;
						t.multiple ? e.selected.length > 0 ? e.hoverIndex = Math.min.apply(null, e.selected.map((t => _.value.findIndex((e => Cm(e, n) === Cm(t, n)))))) : e.hoverIndex = -1 : e.hoverIndex = _.value.findIndex((t => ot(t) === ot(e.selected)))
					}), 300)
				}, q = YC((() => {
					t.filterable && e.query !== e.selectedLabel && (e.query = e.selectedLabel, L(e.query))
				}), j.value), X = YC((t => {
					L(t.target.value)
				}), j.value), G = e => {
					uT(t.modelValue, e) || n.emit(pC, e)
				}, K = t => function(t, e, n) {
					var r = null == t ? 0 : t.length;
					if (!r) return -1;
					var i = r - 1;
					return void 0 !== n && (i = bT(n), i = n < 0 ? xT(r + i, 0) : wT(i, r - 1)),
						function(t, e, n, r) {
							for (var i = t.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)
								if (e(t[o], o, t)) return o;
							return -1
						}(t, yT(e), i, !0)
				}(t, (t => !e.disabledOptions.has(t))), Y = (r, i) => {
					const o = e.selected.indexOf(i);
					if (o > -1 && !w.value) {
						const e = t.modelValue.slice();
						e.splice(o, 1), n.emit(dC, e), G(e), n.emit("remove-tag", i.value)
					}
					r.stopPropagation(), nt()
				}, Z = r => {
					r.stopPropagation();
					const i = t.multiple ? [] : "";
					if (!k(i))
						for (const t of e.selected) t.isDisabled && i.push(t.value);
					n.emit(dC, i), G(i), e.hoverIndex = -1, e.visible = !1, n.emit("clear"), nt()
				}, J = r => {
					var i;
					if (t.multiple) {
						const o = (t.modelValue || []).slice(),
							s = Q(o, r.value);
						s > -1 ? o.splice(s, 1) : (t.multipleLimit <= 0 || o.length < t.multipleLimit) && o.push(r.value), n.emit(dC, o), G(o), r.created && (e.query = "", L(""), e.inputLength = 20), t.filterable && (null == (i = a.value) || i.focus())
					} else n.emit(dC, r.value), G(r.value), e.visible = !1;
					$(), e.visible || si((() => {
						tt(r)
					}))
				}, Q = (e = [], n) => {
					if (!P(n)) return e.indexOf(n);
					const r = t.valueKey;
					let i = -1;
					return e.some(((t, e) => ue(Cm(t, r)) === Cm(n, r) && (i = e, !0))), i
				}, $ = () => {
					const t = a.value || o.value;
					t && (null == t || t.focus())
				}, tt = t => {
					var e, n, r, o, a;
					const s = Array.isArray(t) ? t[0] : t;
					let c = null;
					if (null == s ? void 0 : s.value) {
						const t = _.value.filter((t => t.value === s.value));
						t.length > 0 && (c = t[0].$el)
					}
					if (l.value && c) {
						const t = null == (o = null == (r = null == (n = null == (e = l.value) ? void 0 : e.popperRef) ? void 0 : n.contentRef) ? void 0 : r.querySelector) ? void 0 : o.call(r, `.${i.be("dropdown","wrap")}`);
						t && function(t, e) {
							if (!tg) return;
							if (!e) return void(t.scrollTop = 0);
							const n = [];
							let r = e.offsetParent;
							for (; null !== r && t !== r && t.contains(r);) n.push(r), r = r.offsetParent;
							const i = e.offsetTop + n.reduce(((t, e) => t + e.offsetTop), 0),
								o = i + e.offsetHeight,
								a = t.scrollTop,
								s = a + t.clientHeight;
							i < a ? t.scrollTop = i : o > s && (t.scrollTop = o - t.clientHeight)
						}(t, c)
					}
					null == (a = f.value) || a.handleScroll()
				}, et = t => {
					if (!Array.isArray(e.selected)) return;
					const n = K(e.selected.map((t => t.value))),
						r = e.selected[n];
					return r ? !0 === t || !1 === t ? (r.hitState = t, t) : (r.hitState = !r.hitState, r.hitState) : void 0
				}, nt = () => {
					var t, n;
					e.visible ? null == (t = a.value || o.value) || t.focus() : null == (n = o.value) || n.focus()
				}, rt = () => {
					e.visible = !1
				}, it = t => {
					t && !e.mouseEnter || w.value || (e.menuVisibleOnFocus ? e.menuVisibleOnFocus = !1 : l.value && l.value.isFocusInsideContent() || (e.visible = !e.visible), nt())
				}, ot = e => P(e.value) ? Cm(e.value, t.valueKey) : e.value, at = Pe((() => _.value.filter((t => t.visible)).every((t => t.disabled)))), st = Pe((() => t.multiple ? e.selected.slice(0, t.maxCollapseTags) : [])), lt = Pe((() => t.multiple ? e.selected.slice(t.maxCollapseTags) : [])), ct = t => {
					if (e.visible) {
						if (0 !== e.options.size && 0 !== e.filteredOptionsCount && !e.isOnComposition && !at.value) {
							"next" === t ? (e.hoverIndex++, e.hoverIndex === e.options.size && (e.hoverIndex = 0)) : "prev" === t && (e.hoverIndex--, e.hoverIndex < 0 && (e.hoverIndex = e.options.size - 1));
							const n = _.value[e.hoverIndex];
							!0 !== n.disabled && !0 !== n.states.groupDisabled && n.visible || ct(t), si((() => tt(d.value)))
						}
					} else e.visible = !0
				}, ut = Pe((() => ({
					maxWidth: we(e.inputWidth) - 32 - (F.value ? 22 : 0) + "px",
					width: "100%"
				})));
			return {
				optionList: v,
				optionsArray: _,
				hoverOption: d,
				selectSize: I,
				handleResize: () => {
					var n, r;
					(() => {
						var t;
						e.inputWidth = null == (t = o.value) ? void 0 : t.$el.offsetWidth
					})(), null == (r = null == (n = l.value) ? void 0 : n.updatePopper) || r.call(n), t.multiple && N()
				},
				debouncedOnInputChange: q,
				debouncedQueryChange: X,
				deletePrevTag: r => {
					if ("Delete" !== r.code) {
						if (r.target.value.length <= 0 && !et()) {
							const e = t.modelValue.slice(),
								r = K(e);
							if (r < 0) return;
							e.splice(r, 1), n.emit(dC, e), G(e)
						}
						1 === r.target.value.length && 0 === t.modelValue.length && (e.currentPlaceholder = e.cachedPlaceHolder)
					}
				},
				deleteTag: Y,
				deleteSelected: Z,
				handleOptionSelect: J,
				scrollToOption: tt,
				readonly: x,
				resetInputHeight: N,
				showClose: C,
				iconComponent: S,
				iconReverse: O,
				showNewOption: M,
				collapseTagSize: R,
				setSelected: V,
				managePlaceholder: z,
				selectDisabled: w,
				emptyText: A,
				toggleLastOptionHitState: et,
				resetInputState: t => {
					"Backspace" !== t.code && et(!1), e.inputLength = 15 * a.value.value.length + 20, N()
				},
				handleComposition: t => {
					const n = t.target.value;
					if ("compositionend" === t.type) e.isOnComposition = !1, si((() => L(n)));
					else {
						const t = n[n.length - 1] || "";
						e.isOnComposition = !wC(t)
					}
				},
				onOptionCreate: t => {
					e.optionsCount++, e.filteredOptionsCount++, e.options.set(t.value, t), e.cachedOptions.set(t.value, t), t.disabled && e.disabledOptions.set(t.value, t)
				},
				onOptionDestroy: (t, n) => {
					e.options.get(t) === n && (e.optionsCount--, e.filteredOptionsCount--, e.options.delete(t))
				},
				handleMenuEnter: () => {
					si((() => tt(e.selected)))
				},
				handleFocus: r => {
					e.focused || ((t.automaticDropdown || t.filterable) && (t.filterable && !e.visible && (e.menuVisibleOnFocus = !0), e.visible = !0), e.focused = !0, n.emit("focus", r))
				},
				focus: nt,
				blur: () => {
					var t, n, r;
					e.visible = !1, null == (t = o.value) || t.blur(), null == (r = null == (n = s.value) ? void 0 : n.blur) || r.call(n)
				},
				handleBlur: t => {
					var r, i, o;
					(null == (r = l.value) ? void 0 : r.isFocusInsideContent(t)) || (null == (i = c.value) ? void 0 : i.isFocusInsideContent(t)) || (null == (o = h.value) ? void 0 : o.contains(t.relatedTarget)) || (e.visible && rt(), e.focused = !1, n.emit("blur", t))
				},
				handleClearClick: t => {
					Z(t)
				},
				handleClose: rt,
				handleKeydownEscape: t => {
					e.visible && (t.preventDefault(), t.stopPropagation(), e.visible = !1)
				},
				toggleMenu: it,
				selectOption: () => {
					e.visible ? _.value[e.hoverIndex] && J(_.value[e.hoverIndex]) : it()
				},
				getValueKey: ot,
				navigateOptions: ct,
				handleDeleteTooltipTag: (t, e) => {
					var n, r;
					Y(t, e), null == (r = null == (n = c.value) ? void 0 : n.updatePopper) || r.call(n)
				},
				dropMenuVisible: B,
				queryChange: p,
				groupQueryChange: g,
				showTagList: st,
				collapseTagList: lt,
				selectTagsStyle: ut,
				reference: o,
				input: a,
				iOSInput: s,
				tooltipRef: l,
				tagTooltipRef: c,
				tags: u,
				selectWrapper: h,
				scrollbar: f,
				handleMouseEnter: () => {
					e.mouseEnter = !0
				},
				handleMouseLeave: () => {
					e.mouseEnter = !1
				}
			}
		};
		var ST = Ze({
			name: "ElOptions",
			emits: ["update-options"],
			setup(t, {
				slots: e,
				emit: n
			}) {
				let r = [];
				return () => {
					var t, i;
					const o = null == (t = e.default) ? void 0 : t.call(e),
						a = [];
					return o.length && function t(e) {
							Array.isArray(e) && e.forEach((e => {
								var n, r, i, o;
								const s = null == (n = (null == e ? void 0 : e.type) || {}) ? void 0 : n.name;
								"ElOptionGroup" === s ? t(k(e.children) || Array.isArray(e.children) || !T(null == (r = e.children) ? void 0 : r.default) ? e.children : null == (i = e.children) ? void 0 : i.default()) : "ElOption" === s ? a.push(null == (o = e.props) ? void 0 : o.label) : Array.isArray(e.children) && t(e.children)
							}))
						}(null == (i = o[0]) ? void 0 : i.children),
						function(t, e) {
							if (t.length !== e.length) return !1;
							for (const [n] of t.entries())
								if (t[n] != e[n]) return !1;
							return !0
						}(a, r) || (r = a, n("update-options", a)), o
				}
			}
		});
		const OT = "ElSelect",
			TT = Ze({
				name: OT,
				componentName: OT,
				components: {
					ElInput: FC,
					ElSelectMenu: JS,
					ElOption: ZS,
					ElOptions: ST,
					ElTag: qS,
					ElScrollbar: zS,
					ElTooltip: Zx,
					ElIcon: Yg
				},
				directives: {
					ClickOutside: TS
				},
				props: {
					name: String,
					id: String,
					modelValue: {
						type: [Array, String, Number, Boolean, Object],
						default: void 0
					},
					autocomplete: {
						type: String,
						default: "off"
					},
					automaticDropdown: Boolean,
					size: {
						type: String,
						validator: t => ["", ..._m].includes(t)
					},
					effect: {
						type: String,
						default: "light"
					},
					disabled: Boolean,
					clearable: Boolean,
					filterable: Boolean,
					allowCreate: Boolean,
					loading: Boolean,
					popperClass: {
						type: String,
						default: ""
					},
					popperOptions: {
						type: Object,
						default: () => ({})
					},
					remote: Boolean,
					loadingText: String,
					noMatchText: String,
					noDataText: String,
					remoteMethod: Function,
					filterMethod: Function,
					multiple: Boolean,
					multipleLimit: {
						type: Number,
						default: 0
					},
					placeholder: {
						type: String
					},
					defaultFirstOption: Boolean,
					reserveKeyword: {
						type: Boolean,
						default: !0
					},
					valueKey: {
						type: String,
						default: "value"
					},
					collapseTags: Boolean,
					collapseTagsTooltip: Boolean,
					maxCollapseTags: {
						type: Number,
						default: 1
					},
					teleported: Pb.teleported,
					persistent: {
						type: Boolean,
						default: !0
					},
					clearIcon: {
						type: uv,
						default: tv
					},
					fitInputWidth: Boolean,
					suffixIcon: {
						type: uv,
						default: Zg
					},
					tagType: {
						...WS.type,
						default: "info"
					},
					validateEvent: {
						type: Boolean,
						default: !0
					},
					remoteShowSuffix: Boolean,
					suffixTransition: {
						type: Boolean,
						default: !0
					},
					placement: {
						type: String,
						values: xy,
						default: "bottom-start"
					},
					ariaLabel: {
						type: String,
						default: void 0
					}
				},
				emits: [dC, pC, "remove-tag", "clear", "visible-change", "focus", "blur"],
				setup(t, e) {
					const n = Dg("select"),
						r = Dg("input"),
						{
							t: i
						} = Fm(),
						o = ox(),
						a = function(t) {
							const {
								t: e
							} = Fm();
							return re({
								options: new Map,
								cachedOptions: new Map,
								disabledOptions: new Map,
								createdLabel: null,
								createdSelected: !1,
								selected: t.multiple ? [] : {},
								inputLength: 20,
								inputWidth: 0,
								optionsCount: 0,
								filteredOptionsCount: 0,
								visible: !1,
								selectedLabel: "",
								hoverIndex: -1,
								query: "",
								previousQuery: null,
								inputHovering: !1,
								cachedPlaceHolder: "",
								currentPlaceholder: e("el.select.placeholder"),
								menuVisibleOnFocus: !1,
								isOnComposition: !1,
								prefixWidth: 11,
								mouseEnter: !1,
								focused: !1
							})
						}(t),
						{
							optionList: s,
							optionsArray: l,
							hoverOption: c,
							selectSize: u,
							readonly: h,
							handleResize: f,
							collapseTagSize: d,
							debouncedOnInputChange: p,
							debouncedQueryChange: g,
							deletePrevTag: v,
							deleteTag: m,
							deleteSelected: y,
							handleOptionSelect: b,
							scrollToOption: x,
							setSelected: w,
							resetInputHeight: C,
							managePlaceholder: S,
							showClose: O,
							selectDisabled: T,
							iconComponent: k,
							iconReverse: F,
							showNewOption: P,
							emptyText: j,
							toggleLastOptionHitState: A,
							resetInputState: _,
							handleComposition: E,
							onOptionCreate: D,
							onOptionDestroy: M,
							handleMenuEnter: I,
							handleFocus: R,
							focus: B,
							blur: N,
							handleBlur: L,
							handleClearClick: z,
							handleClose: W,
							handleKeydownEscape: V,
							toggleMenu: U,
							selectOption: H,
							getValueKey: q,
							navigateOptions: X,
							handleDeleteTooltipTag: G,
							dropMenuVisible: K,
							reference: Y,
							input: Z,
							iOSInput: J,
							tooltipRef: Q,
							tagTooltipRef: $,
							tags: tt,
							selectWrapper: et,
							scrollbar: nt,
							queryChange: rt,
							groupQueryChange: it,
							handleMouseEnter: ot,
							handleMouseLeave: at,
							showTagList: st,
							collapseTagList: lt,
							selectTagsStyle: ct
						} = CT(t, a, e),
						{
							inputWidth: ut,
							selected: ht,
							inputLength: ft,
							filteredOptionsCount: dt,
							visible: pt,
							selectedLabel: gt,
							hoverIndex: vt,
							query: mt,
							inputHovering: yt,
							currentPlaceholder: bt,
							menuVisibleOnFocus: xt,
							isOnComposition: wt,
							options: Ct,
							cachedOptions: St,
							optionsCount: Ot,
							prefixWidth: Tt
						} = Oe(a),
						kt = Pe((() => {
							const e = [n.b()],
								r = we(u);
							return r && e.push(n.m(r)), t.disabled && e.push(n.m("disabled")), e
						})),
						Ft = Pe((() => [n.e("tags"), n.is("disabled", we(T))])),
						Pt = Pe((() => [n.b("tags-wrapper"), {
							"has-prefix": we(Tt) && we(ht).length
						}])),
						jt = Pe((() => [n.e("input"), n.is(we(u)), n.is("disabled", we(T))])),
						At = Pe((() => [n.e("input"), n.is(we(u)), n.em("input", "iOS")])),
						_t = Pe((() => [n.is("empty", !t.allowCreate && Boolean(we(mt)) && 0 === we(dt))])),
						Et = Pe((() => ({
							maxWidth: (we(ut) > 123 && we(ht).length > t.maxCollapseTags ? we(ut) - 123 : we(ut) - 75) + "px"
						}))),
						Dt = Pe((() => ({
							marginLeft: `${we(Tt)}px`,
							flexGrow: 1,
							width: we(ft) / (we(ut) - 32) + "%",
							maxWidth: we(ut) - 42 + "px"
						})));
					ze(GS, re({
						props: t,
						options: Ct,
						optionsArray: l,
						cachedOptions: St,
						optionsCount: Ot,
						filteredOptionsCount: dt,
						hoverIndex: vt,
						handleOptionSelect: b,
						onOptionCreate: D,
						onOptionDestroy: M,
						selectWrapper: et,
						selected: ht,
						setSelected: w,
						queryChange: rt,
						groupQueryChange: it
					})), on((() => {
						a.cachedPlaceHolder = bt.value = t.placeholder || (() => i("el.select.placeholder")), t.multiple && Array.isArray(t.modelValue) && t.modelValue.length > 0 && (bt.value = ""), mg(et, f), t.remote && t.multiple && C(), si((() => {
							const t = Y.value && Y.value.$el;
							if (t && (ut.value = t.getBoundingClientRect().width, e.slots.prefix)) {
								const e = t.querySelector(`.${r.e("prefix")}`);
								Tt.value = Math.max(e.getBoundingClientRect().width + 11, 30)
							}
						})), w()
					})), t.multiple && !Array.isArray(t.modelValue) && e.emit(dC, []), !t.multiple && Array.isArray(t.modelValue) && e.emit(dC, "");
					const Mt = Pe((() => {
						var t, e;
						return null == (e = null == (t = Q.value) ? void 0 : t.popperRef) ? void 0 : e.contentRef
					}));
					return {
						isIOS: rg,
						onOptionsRendered: t => {
							s.value = t
						},
						prefixWidth: Tt,
						selectSize: u,
						readonly: h,
						handleResize: f,
						collapseTagSize: d,
						debouncedOnInputChange: p,
						debouncedQueryChange: g,
						deletePrevTag: v,
						deleteTag: m,
						handleDeleteTooltipTag: G,
						deleteSelected: y,
						handleOptionSelect: b,
						scrollToOption: x,
						inputWidth: ut,
						selected: ht,
						inputLength: ft,
						filteredOptionsCount: dt,
						visible: pt,
						selectedLabel: gt,
						hoverIndex: vt,
						query: mt,
						inputHovering: yt,
						currentPlaceholder: bt,
						menuVisibleOnFocus: xt,
						isOnComposition: wt,
						options: Ct,
						resetInputHeight: C,
						managePlaceholder: S,
						showClose: O,
						selectDisabled: T,
						iconComponent: k,
						iconReverse: F,
						showNewOption: P,
						emptyText: j,
						toggleLastOptionHitState: A,
						resetInputState: _,
						handleComposition: E,
						handleMenuEnter: I,
						handleFocus: R,
						focus: B,
						blur: N,
						handleBlur: L,
						handleClearClick: z,
						handleClose: W,
						handleKeydownEscape: V,
						toggleMenu: U,
						selectOption: H,
						getValueKey: q,
						navigateOptions: X,
						dropMenuVisible: K,
						reference: Y,
						input: Z,
						iOSInput: J,
						tooltipRef: Q,
						popperPaneRef: Mt,
						tags: tt,
						selectWrapper: et,
						scrollbar: nt,
						wrapperKls: kt,
						tagsKls: Ft,
						tagWrapperKls: Pt,
						inputKls: jt,
						iOSInputKls: At,
						scrollbarKls: _t,
						selectTagsStyle: ct,
						nsSelect: n,
						tagTextStyle: Et,
						inputStyle: Dt,
						handleMouseEnter: ot,
						handleMouseLeave: at,
						showTagList: st,
						collapseTagList: lt,
						tagTooltipRef: $,
						contentId: o,
						hoverOption: c
					}
				}
			}),
			kT = ["disabled", "autocomplete", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"],
			FT = ["disabled"],
			PT = {
				style: {
					height: "100%",
					display: "flex",
					"justify-content": "center",
					"align-items": "center"
				}
			};
		var jT = Pg(TT, [
			["render", function(t, e, n, r, o, a) {
				const s = zn("el-tag"),
					u = zn("el-tooltip"),
					h = zn("el-icon"),
					f = zn("el-input"),
					d = zn("el-option"),
					p = zn("el-options"),
					g = zn("el-scrollbar"),
					v = zn("el-select-menu"),
					m = Un("directives", "click-outside");
				return Sn((Jn(), er("div", {
					ref: "selectWrapper",
					class: l(t.wrapperKls),
					onMouseenter: e[22] || (e[22] = (...e) => t.handleMouseEnter && t.handleMouseEnter(...e)),
					onMouseleave: e[23] || (e[23] = (...e) => t.handleMouseLeave && t.handleMouseLeave(...e)),
					onClick: e[24] || (e[24] = lo(((...e) => t.toggleMenu && t.toggleMenu(...e)), ["stop"]))
				}, [cr(u, {
					ref: "tooltipRef",
					visible: t.dropMenuVisible,
					placement: t.placement,
					teleported: t.teleported,
					"popper-class": [t.nsSelect.e("popper"), t.popperClass],
					"popper-options": t.popperOptions,
					"fallback-placements": ["bottom-start", "top-start", "right", "left"],
					effect: t.effect,
					pure: "",
					trigger: "click",
					transition: `${t.nsSelect.namespace.value}-zoom-in-top`,
					"stop-popper-mouse-event": !1,
					"gpu-acceleration": !1,
					persistent: t.persistent,
					onShow: t.handleMenuEnter
				}, {
					default: Ie((() => {
						var n, r;
						return [lr("div", {
							class: "select-trigger",
							onMouseenter: e[20] || (e[20] = e => t.inputHovering = !0),
							onMouseleave: e[21] || (e[21] = e => t.inputHovering = !1)
						}, [t.multiple ? (Jn(), er("div", {
							key: 0,
							ref: "tags",
							tabindex: "-1",
							class: l(t.tagsKls),
							style: i(t.selectTagsStyle),
							onClick: e[15] || (e[15] = (...e) => t.focus && t.focus(...e))
						}, [t.collapseTags && t.selected.length ? (Jn(), nr(Hi, {
							key: 0,
							onAfterLeave: t.resetInputHeight
						}, {
							default: Ie((() => [lr("span", {
								class: l(t.tagWrapperKls)
							}, [(Jn(!0), er(qn, null, mr(t.showTagList, (e => (Jn(), nr(s, {
								key: t.getValueKey(e),
								closable: !t.selectDisabled && !e.isDisabled,
								size: t.collapseTagSize,
								hit: e.hitState,
								type: t.tagType,
								"disable-transitions": "",
								onClose: n => t.deleteTag(n, e)
							}, {
								default: Ie((() => [lr("span", {
									class: l(t.nsSelect.e("tags-text")),
									style: i(t.tagTextStyle)
								}, c(e.currentLabel), 7)])),
								_: 2
							}, 1032, ["closable", "size", "hit", "type", "onClose"])))), 128)), t.selected.length > t.maxCollapseTags ? (Jn(), nr(s, {
								key: 0,
								closable: !1,
								size: t.collapseTagSize,
								type: t.tagType,
								"disable-transitions": ""
							}, {
								default: Ie((() => [t.collapseTagsTooltip ? (Jn(), nr(u, {
									key: 0,
									ref: "tagTooltipRef",
									disabled: t.dropMenuVisible,
									"fallback-placements": ["bottom", "top", "right", "left"],
									effect: t.effect,
									placement: "bottom",
									teleported: t.teleported
								}, {
									default: Ie((() => [lr("span", {
										class: l(t.nsSelect.e("tags-text"))
									}, "+ " + c(t.selected.length - t.maxCollapseTags), 3)])),
									content: Ie((() => [lr("div", {
										class: l(t.nsSelect.e("collapse-tags"))
									}, [(Jn(!0), er(qn, null, mr(t.collapseTagList, (e => (Jn(), er("div", {
										key: t.getValueKey(e),
										class: l(t.nsSelect.e("collapse-tag"))
									}, [cr(s, {
										class: "in-tooltip",
										closable: !t.selectDisabled && !e.isDisabled,
										size: t.collapseTagSize,
										hit: e.hitState,
										type: t.tagType,
										"disable-transitions": "",
										style: {
											margin: "2px"
										},
										onClose: n => t.handleDeleteTooltipTag(n, e)
									}, {
										default: Ie((() => [lr("span", {
											class: l(t.nsSelect.e("tags-text")),
											style: i({
												maxWidth: t.inputWidth - 75 + "px"
											})
										}, c(e.currentLabel), 7)])),
										_: 2
									}, 1032, ["closable", "size", "hit", "type", "onClose"])], 2)))), 128))], 2)])),
									_: 1
								}, 8, ["disabled", "effect", "teleported"])) : (Jn(), er("span", {
									key: 1,
									class: l(t.nsSelect.e("tags-text"))
								}, "+ " + c(t.selected.length - t.maxCollapseTags), 3))])),
								_: 1
							}, 8, ["size", "type"])) : fr("v-if", !0)], 2)])),
							_: 1
						}, 8, ["onAfterLeave"])) : fr("v-if", !0), t.collapseTags ? fr("v-if", !0) : (Jn(), nr(Hi, {
							key: 1,
							onAfterLeave: t.resetInputHeight
						}, {
							default: Ie((() => [lr("span", {
								class: l(t.tagWrapperKls),
								style: i(t.prefixWidth && t.selected.length ? {
									marginLeft: `${t.prefixWidth}px`
								} : "")
							}, [(Jn(!0), er(qn, null, mr(t.selected, (e => (Jn(), nr(s, {
								key: t.getValueKey(e),
								closable: !t.selectDisabled && !e.isDisabled,
								size: t.collapseTagSize,
								hit: e.hitState,
								type: t.tagType,
								"disable-transitions": "",
								onClose: n => t.deleteTag(n, e)
							}, {
								default: Ie((() => [lr("span", {
									class: l(t.nsSelect.e("tags-text")),
									style: i({
										maxWidth: t.inputWidth - 75 + "px"
									})
								}, c(e.currentLabel), 7)])),
								_: 2
							}, 1032, ["closable", "size", "hit", "type", "onClose"])))), 128))], 6)])),
							_: 1
						}, 8, ["onAfterLeave"])), t.filterable && !t.selectDisabled ? Sn((Jn(), er("input", {
							key: 2,
							ref: "input",
							"onUpdate:modelValue": e[0] || (e[0] = e => t.query = e),
							type: "text",
							class: l(t.inputKls),
							disabled: t.selectDisabled,
							autocomplete: t.autocomplete,
							style: i(t.inputStyle),
							role: "combobox",
							"aria-activedescendant": (null == (n = t.hoverOption) ? void 0 : n.id) || "",
							"aria-controls": t.contentId,
							"aria-expanded": t.dropMenuVisible,
							"aria-label": t.ariaLabel,
							"aria-autocomplete": "none",
							"aria-haspopup": "listbox",
							onFocus: e[1] || (e[1] = (...e) => t.handleFocus && t.handleFocus(...e)),
							onBlur: e[2] || (e[2] = (...e) => t.handleBlur && t.handleBlur(...e)),
							onKeyup: e[3] || (e[3] = (...e) => t.managePlaceholder && t.managePlaceholder(...e)),
							onKeydown: [e[4] || (e[4] = (...e) => t.resetInputState && t.resetInputState(...e)), e[5] || (e[5] = uo(lo((e => t.navigateOptions("next")), ["prevent"]), ["down"])), e[6] || (e[6] = uo(lo((e => t.navigateOptions("prev")), ["prevent"]), ["up"])), e[7] || (e[7] = uo(((...e) => t.handleKeydownEscape && t.handleKeydownEscape(...e)), ["esc"])), e[8] || (e[8] = uo(lo(((...e) => t.selectOption && t.selectOption(...e)), ["stop", "prevent"]), ["enter"])), e[9] || (e[9] = uo(((...e) => t.deletePrevTag && t.deletePrevTag(...e)), ["delete"])), e[10] || (e[10] = uo((e => t.visible = !1), ["tab"]))],
							onCompositionstart: e[11] || (e[11] = (...e) => t.handleComposition && t.handleComposition(...e)),
							onCompositionupdate: e[12] || (e[12] = (...e) => t.handleComposition && t.handleComposition(...e)),
							onCompositionend: e[13] || (e[13] = (...e) => t.handleComposition && t.handleComposition(...e)),
							onInput: e[14] || (e[14] = (...e) => t.debouncedQueryChange && t.debouncedQueryChange(...e))
						}, null, 46, kT)), [
							[oo, t.query]
						]) : fr("v-if", !0)], 6)) : fr("v-if", !0), t.isIOS && !t.multiple && t.filterable && t.readonly ? (Jn(), er("input", {
							key: 1,
							ref: "iOSInput",
							class: l(t.iOSInputKls),
							disabled: t.selectDisabled,
							type: "text"
						}, null, 10, FT)) : fr("v-if", !0), cr(f, {
							id: t.id,
							ref: "reference",
							modelValue: t.selectedLabel,
							"onUpdate:modelValue": e[16] || (e[16] = e => t.selectedLabel = e),
							type: "text",
							placeholder: "function" == typeof t.currentPlaceholder ? t.currentPlaceholder() : t.currentPlaceholder,
							name: t.name,
							autocomplete: t.autocomplete,
							size: t.selectSize,
							disabled: t.selectDisabled,
							readonly: t.readonly,
							"validate-event": !1,
							class: l([t.nsSelect.is("focus", t.visible)]),
							tabindex: t.multiple && t.filterable ? -1 : void 0,
							role: "combobox",
							"aria-activedescendant": (null == (r = t.hoverOption) ? void 0 : r.id) || "",
							"aria-controls": t.contentId,
							"aria-expanded": t.dropMenuVisible,
							label: t.ariaLabel,
							"aria-autocomplete": "none",
							"aria-haspopup": "listbox",
							onFocus: t.handleFocus,
							onBlur: t.handleBlur,
							onInput: t.debouncedOnInputChange,
							onPaste: t.debouncedOnInputChange,
							onCompositionstart: t.handleComposition,
							onCompositionupdate: t.handleComposition,
							onCompositionend: t.handleComposition,
							onKeydown: [e[17] || (e[17] = uo(lo((e => t.navigateOptions("next")), ["stop", "prevent"]), ["down"])), e[18] || (e[18] = uo(lo((e => t.navigateOptions("prev")), ["stop", "prevent"]), ["up"])), uo(lo(t.selectOption, ["stop", "prevent"]), ["enter"]), uo(t.handleKeydownEscape, ["esc"]), e[19] || (e[19] = uo((e => t.visible = !1), ["tab"]))]
						}, yr({
							suffix: Ie((() => [t.iconComponent && !t.showClose ? (Jn(), nr(h, {
								key: 0,
								class: l([t.nsSelect.e("caret"), t.nsSelect.e("icon"), t.iconReverse])
							}, {
								default: Ie((() => [(Jn(), nr(Vn(t.iconComponent)))])),
								_: 1
							}, 8, ["class"])) : fr("v-if", !0), t.showClose && t.clearIcon ? (Jn(), nr(h, {
								key: 1,
								class: l([t.nsSelect.e("caret"), t.nsSelect.e("icon")]),
								onClick: t.handleClearClick
							}, {
								default: Ie((() => [(Jn(), nr(Vn(t.clearIcon)))])),
								_: 1
							}, 8, ["class", "onClick"])) : fr("v-if", !0)])),
							_: 2
						}, [t.$slots.prefix ? {
							name: "prefix",
							fn: Ie((() => [lr("div", PT, [br(t.$slots, "prefix")])]))
						} : void 0]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "aria-activedescendant", "aria-controls", "aria-expanded", "label", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])], 32)]
					})),
					content: Ie((() => [cr(v, null, yr({
						default: Ie((() => [Sn(cr(g, {
							id: t.contentId,
							ref: "scrollbar",
							tag: "ul",
							"wrap-class": t.nsSelect.be("dropdown", "wrap"),
							"view-class": t.nsSelect.be("dropdown", "list"),
							class: l(t.scrollbarKls),
							role: "listbox",
							"aria-label": t.ariaLabel,
							"aria-orientation": "vertical"
						}, {
							default: Ie((() => [t.showNewOption ? (Jn(), nr(d, {
								key: 0,
								value: t.query,
								created: !0
							}, null, 8, ["value"])) : fr("v-if", !0), cr(p, {
								onUpdateOptions: t.onOptionsRendered
							}, {
								default: Ie((() => [br(t.$slots, "default")])),
								_: 3
							}, 8, ["onUpdateOptions"])])),
							_: 3
						}, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
							[ho, t.options.size > 0 && !t.loading]
						]), t.emptyText && (!t.allowCreate || t.loading || t.allowCreate && 0 === t.options.size) ? (Jn(), er(qn, {
							key: 0
						}, [t.$slots.empty ? br(t.$slots, "empty", {
							key: 0
						}) : (Jn(), er("p", {
							key: 1,
							class: l(t.nsSelect.be("dropdown", "empty"))
						}, c(t.emptyText), 3))], 64)) : fr("v-if", !0)])),
						_: 2
					}, [t.$slots.header ? {
						name: "header",
						fn: Ie((() => [br(t.$slots, "header")]))
					} : void 0, t.$slots.footer ? {
						name: "footer",
						fn: Ie((() => [br(t.$slots, "footer")]))
					} : void 0]), 1024)])),
					_: 3
				}, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])], 34)), [
					[m, t.handleClose, t.popperPaneRef]
				])
			}],
			["__file", "select.vue"]
		]);
		var AT = Pg(Ze({
			name: "ElOptionGroup",
			componentName: "ElOptionGroup",
			props: {
				label: String,
				disabled: Boolean
			},
			setup(t) {
				const e = Dg("select"),
					n = ve(!0),
					r = Fr(),
					i = ve([]);
				ze(XS, re({
					...Oe(t)
				}));
				const o = We(GS);
				on((() => {
					i.value = a(r.subTree)
				}));
				const a = t => {
						const e = [];
						return Array.isArray(t.children) && t.children.forEach((t => {
							var n;
							t.type && "ElOption" === t.type.name && t.component && t.component.proxy ? e.push(t.component.proxy) : (null == (n = t.children) ? void 0 : n.length) && e.push(...a(t))
						})), e
					},
					{
						groupQueryChange: s
					} = ue(o);
				return vi(s, (() => {
					n.value = i.value.some((t => !0 === t.visible))
				}), {
					flush: "post"
				}), {
					visible: n,
					ns: e
				}
			}
		}), [
			["render", function(t, e, n, r, i, o) {
				return Sn((Jn(), er("ul", {
					class: l(t.ns.be("group", "wrap"))
				}, [lr("li", {
					class: l(t.ns.be("group", "title"))
				}, c(t.label), 3), lr("li", null, [lr("ul", {
					class: l(t.ns.b("group"))
				}, [br(t.$slots, "default")], 2)])], 2)), [
					[ho, t.visible]
				])
			}],
			["__file", "option-group.vue"]
		]);
		const _T = zg(jT, {
				Option: ZS,
				OptionGroup: AT
			}),
			ET = Wg(ZS);
		Wg(AT);
		var DT = {
				key: 0,
				class: "cut-off"
			},
			MT = {
				key: 1,
				class: "cut-off"
			},
			IT = {
				class: "cut-off"
			},
			RT = {
				key: 2,
				class: "cut-off"
			};
		const BT = {
				__name: "paint-select",
				props: ["color", "width", "all", "activeObj", "fontFam", "textbgColor"],
				emits: ["changeWidth", "changeColor", "changeSquare", "changeFontFamily", "changebgColor", "update:fontfam"],
				setup: function(t, e) {
					var n = e.emit,
						r = (t.color, t.width, t.all, t.activeObj, t.fontFam, t.textbgColor, n),
						o = function(t, e) {
							r("changeWidth", t)
						},
						a = function(t) {
							r("changeColor", t)
						},
						s = function(t) {
							r("changeFontFamily", t)
						},
						c = function(t) {
							r("changebgColor", t)
						};
					return function(e, n) {
						var u = _w,
							h = Zx,
							f = ET,
							d = _T,
							p = AS,
							g = BC;
						return Jn(), er(qn, null, [t.all ? (Jn(), er("div", DT, [(Jn(!0), er(qn, null, mr(t.all, (function(e) {
							return Jn(), nr(h, {
								key: e.content,
								enterable: !1,
								effect: "dark",
								content: e.content,
								placement: "bottom"
							}, {
								default: Ie((function() {
									return [cr(u, {
										text: "",
										size: "small",
										type: "info",
										class: l(t.activeObj.active.content === e.content ? "is-active" : ""),
										onClick: function(t) {
											return function(t) {
												r("changeSquare", t)
											}(e)
										}
									}, {
										default: Ie((function() {
											return [lr("i", {
												class: l(["iconfont", e.icon])
											}, null, 2)]
										})),
										_: 2
									}, 1032, ["class", "onClick"])]
								})),
								_: 2
							}, 1032, ["content"])
						})), 128))])) : fr("", !0), t.activeObj && t.activeObj.fontFmaily ? (Jn(), er("div", MT, [cr(d, {
							size: "small",
							modelValue: t.fontFam,
							onChange: s
						}, {
							default: Ie((function() {
								return [(Jn(!0), er(qn, null, mr(t.activeObj.fontFmaily, (function(t) {
									return Jn(), nr(f, {
										class: "",
										style: i({
											"--font-fam": t
										}),
										key: t,
										label: t,
										value: t
									}, null, 8, ["style", "label", "value"])
								})), 128))]
							})),
							_: 1
						}, 8, ["modelValue"])])) : fr("", !0), lr("div", IT, [cr(p, {
							modelValue: t.color,
							onChange: a
						}, null, 8, ["modelValue"]), t.activeObj && "step" !== t.activeObj.key ? (Jn(), nr(g, {
							key: 0,
							modelValue: t.width,
							min: 1,
							max: 99,
							onChange: o,
							isFontSize: t.activeObj.key === "text" // Pass isFontSize prop
						}, null, 8, ["modelValue"])) : fr("", !0)]), t.activeObj && void 0 !== t.activeObj.textbgColor ? (Jn(), er("div", RT, [cr(p, {
							"show-alpha": "true",
							modelValue: t.textbgColor,
							onChange: c
						}, null, 8, ["modelValue"])])) : fr("", !0)], 64)
					}
				}
			},
			NT = BT;
		var LT = {
				class: "emojs"
			},
			zT = ["src", "alt", "data-key", "onClick"];
		const WT = {
			__name: "paint-emoj",
			emits: ["changeShowTools"],
			setup: function(t, e) {
				var n = e.emit,
					r = ["amazed", "angry", "cross", "cry", "cursor", "cursor-click", "cursor-hand", "cursor-hand-black", "dog", "forbidden", "heart", "like", "q-mark", "rain", "smile", "star", "tick-off", "warning", "windows-cursor", "beard", "crying-1", "crying", "dead", "disappointed", "embarrassed-1", "evil", "friendly", "happiness", "happy-1", "happy", "hilarious", "in-love", "indifferent", "kiss", "laughing", "moustache", "muted", "quiet", "sad", "scared", "sunglasses-1", "surprised-1", "thief", "basketball", "beer", "building1", "building2", "car", "cloud", "fish", "fish2", "package", "sun", "tent", "thunder", "tree1", "tree2", "umbrella"];
				return function(t, e) {
					return Jn(), er("div", LT, [(Jn(), er(qn, null, mr(r, (function(t) {
						return lr("img", {
							key: t,
							src: "../assets/emoj/" + t + ".svg",
							alt: t,
							class: "imgiconnf",
							"data-key": t,
							onClick: function(e) {
								return function(t) {
									(0, _o.publish)("addemojObject", document.querySelector(".emojs img[data-key=" + t + "]")), n("changeShowTools")
								}(t)
							}
						}, null, 8, zT)
					})), 64))])
				}
			}
		};
		var VT = n(21);
		const UT = (0, VT.Z)(WT, [
			["__scopeId", "data-v-64e54079"]
		]);
		var HT = {
				class: "paint-scale"
			},
			qT = {
				class: "content"
			};
		const XT = {
				__name: "paint-scale",
				props: ["modelValue", "maxScale", "minScale", "step"],
				emits: ["update:modelValue"],
				setup: function(t, e) {
					var n = e.emit,
						r = t,
						i = n,
						o = Pe((function() {
							return 100 * r.modelValue + "%"
						})),
						a = function() {
							i("update:modelValue", Math.max(r.minScale, r.modelValue - r.step))
						},
						s = function() {
							i("update:modelValue", Math.min(r.maxScale, r.modelValue + r.step))
						};
					return function(t, e) {
						return Jn(), er("div", HT, [lr("div", qT, [lr("button", {
							class: "decrement",
							onClick: a
						}, " - "), lr("span", null, c(o.value), 1), lr("button", {
							class: "increment",
							onClick: s
						}, " + ")])])
					}
				}
			},
			GT = (0, VT.Z)(XT, [
				["__scopeId", "data-v-0dbcb1ca"]
			]);
		var KT = n(563),
			YT = {
				key: 0,
				class: "header container"
			},
			ZT = {
				class: "operate"
			},
			JT = {
				class: "draw"
			},
			QT = {
				class: "button"
			},
			$T = {
				key: 1,
				class: "crop"
			};
const tk = {
    __name: "header",
    props: ["drawToolsShow", "imgRef", "cPaint"],
    emits: ["changePaint", "changeDrawTools", "changeScale"],
    setup: function(t, e) {
        var n = e.emit,
            r = t,
            i = ve(1),
            o = function(t) {
                return chrome.i18n.getMessage(t)
            };

        var f = ve([{
            key: "paintfree",
            active: {
                key: "paint",
                content: o("editor_pencil"),
                icon: "icon-pencil"
            },
            all: [{
                key: "paint",
                content: o("editor_pencil"),
                icon: "icon-pencil"
            }, {
                key: "mark",
                content: o("editor_mark_pencil"),
                icon: "icon-mark-pen"
            }, {
                key: "mosaic",
                content: o("editor_mosaic"),
                icon: "icon-mosaic"
            }, {
                key: "circle",
                content: o("editor_circle"),
                icon: "icon-circle"
            }],
            color: "#FF0000",
            width: 8
        }, {
            key: "square",
            active: {
                key: "strokeRect",
                content: o("editor_rectangle"),
                icon: "icon-rect-stroke"
            },
            all: [{
                key: "strokeRect",
                content: o("editor_rectangle"),
                icon: "icon-rect-stroke"
            }, {
                key: "strokeEllipse",
                content: o("editor_Ellipse"),
                icon: "icon-ellipse"
            }, {
                key: "fillRect",
                content: o("editor_fill_rectangle"),
                icon: "icon-rect-fill"
            }],
            color: "#FF0000",
            width: 8
        }, {
            key: "aline",
            active: {
                key: "arrow",
                content: o("editor_arrow"),
                icon: "icon-arrow"
            },
            all: [{
                key: "line",
                content: o("editor_line"),
                icon: "icon-line"
            }, {
                key: "arrow",
                content: o("editor_arrow"),
                icon: "icon-arrow"
            }, {
                key: "arrow_style2",
                content: o("editor_arrow2"),
                icon: "icon-arrow2"
            }, {
                key: "arrow_style3",
                content: o("editor_arrow3"),
                icon: "icon-arrow2"
            }
	/* 		, {
                key: "arrow_style_multi",
                content: o("editor_arrow4"),
                icon: "icon-arrow77"
            } */
			
			, {
                key: "arrow_style4",
                content: o("editor_arrow4"),
                icon: "icon-arrow4"
            }
			, {
                key: "arrow_style17",
                content: o("editor_arrow17"),
                icon: "icon-arrow"
            }	
			, {
                key: "arrow_style18",
                content: o("editor_arrow18"),
                icon: "icon-arrow"
            }			
			
			, {
                key: "arrow_style5",
                content: o("editor_arrow5"),
                icon: "icon-arrow5"
            }
			, {
                key: "arrow_style6",
                content: o("editor_arrow6"),
                icon: "icon-arrow6"
            }
			, {
                key: "arrow_style7",
                content: o("editor_arrow7"),
                icon: "icon-arrow7"
            }
				, {
                key: "arrow_style8",
                content: o("editor_arrow8"),
                icon: "icon-arrow8"
            }
				, {
                key: "arrow_style9",
                content: o("editor_arrow9"),
                icon: "icon-arrow9"
            }
			, {
                key: "arrow_style10",
                content: o("editor_arrow10"),
                icon: "icon-arrow10"
            }
				, {
                key: "arrow_style11",
                content: o("editor_arrow11"),
                icon: "icon-arrow11"
            }
				, {
                key: "arrow_style12",
                content: o("editor_arrow12"),
                icon: "icon-arrow12"
            }
			
			, {
                key: "arrow_style13",
                content: o("editor_arrow13"),
                icon: "icon-arrow13"
            }
				, {
                key: "arrow_style14",
                content: o("editor_arrow14"),
                icon: "icon-arrow14"
            }
				, {
                key: "arrow_style15",
                content: o("editor_arrow15"),
                icon: "icon-arrow15"
            }
			
		, {
                key: "arrow_style16",
                content: o("editor_arrow16"),
                icon: "icon-arrow16"
            }	
			, {
                key: "arrow_style19",
                content: o("editor_arrow19"),
                icon: "icon-arrow19"
            }		
		, {
                key: "arrow_style20",
                content: o("editor_arrow20"),
                icon: "icon-arrow20"
            }		
			
		, {
                key: "arrow_style21",
                content: o("editor_arrow21"),
                icon: "icon-arrow21"
            }		
			
			
			],
            color: "#FF0000",
            width: 8
        }, {
            key: "text",
            active: {
                key: "text",
                content: o("editor_content"),
                icon: "icon-text"
            },
            all: null,
            fontFmaily: ["Roboto", "Bitter", "Titillium_Web", "Amatic_SC", "Arizonia", "Cookie", "Courgette", "Grape_Nuts", "Great_Vibes", "Luckiest_Guy", "Macondo", "Rancho", "Satisfy", "Monoton", "Permanent_Marker", "Press_Start_2P", "NotoSansArabic"],
            fontFam: "Roboto",
            color: "#FF0000",
            width: 16,
            textbgColor: "#00000000"
        }, {
            key: "step",
            active: {
                key: "step",
                content: o("editor_step"),
                icon: "icon-step"
            },
            all: null,
            color: "#FF0000",
            width: 40
        }, {
            key: "emoj",
            active: {
                key: "emoj",
                content: o("editor_Emoji"),
                icon: "icon-emoj"
            },
            width: 8
        }, {
            key: "watermark",
            active: {
                key: "watermark",
                content: o("editor_add_image"),
                icon: "icon-add-image"
            }
        }, {
            key: "crop",
            active: {
                key: "crop",
                content: o("editor_crop"),
                icon: "icon-crop"
            }
        }]);

        var a = ve(null);

        vi(f, (newF) => {
            if (newF && newF.length > 0 && !a.value) {
                a.value = newF[0];
            }
        });

        vi(a, (function(t, e) {
            if (t) {
                n("changePaint", {
                    color: t.color,
                    strokeWidth: t.width,
                    squareType: t.active.key,
                    fontFamily: t.fontFam || "Roboto",
                    textbgColor: t.textbgColor,
                    isTrusted: t.isTrusted
                });
            }
        }), { deep: !0 });

        vi(i, (function(t) {
            n("changeScale", t)
        }));

        var s = ve(""),
            u = ve(null),
            h = ve([{
                key: "back",
                content: "back",
                icon: "icon-back",
                disabled: !0
            }, {
                key: "forward",
                content: "forward",
                icon: "icon-forward",
                disabled: !0
            }, {
                key: "clear-all",
                content: o("editor_clear_all"),
                icon: "icon-clear-all",
                disabled: !0
            }, {
                key: "delete-selected",
                content: o("editor_delete_selected"),
                icon: "icon-eraser",
                disabled: !0
            }]),
            d = ve(!1),
            p = f.value.map((function(t) {
                return [t.key, (t.all || []).map((function(t) {
                    return t.key
                }))]
            }));

        (0, _o.subscribe)("activeObjectChange", (function(t, e) {
            var n = Yd(e, 5),
                r = n[0],
                i = n[1],
                o = n[2],
                s = n[3],
                l = n[4];
            if (r) try {
                var c = p.find((function(t) {
                    return t[0] === r || t[1].find((function(t) {
                        return t === r
                    }))
                })),
                u = c[0],
                h = document.querySelector(".draw button.el-button[data-key=".concat(u, "]")),
                d = f.value.find((function(t) {
                    return t.key === c[0]
                }));
                if (h.click(), d.all) {
                    var g = d.all.find((function(t) {
                        return t.key === r
                    }));
                    w(g, !1)
                } else w(d.active, !1);
                a.value.color = i || "#FF0000", a.value.width = o, a.value.fontFamily = l, a.value.textbgColor = s
            } catch (t) {}
        })), (0, _o.subscribe)("abledUndo", (function(t, e) {
            h.value.find((function(t) {
                return "back" === t.key
            })).disabled = e
        })), (0, _o.subscribe)("abledRedo", (function(t, e) {
            h.value.find((function(t) {
                return "forward" === t.key
            })).disabled = e
        })), (0, _o.subscribe)("abledClear", (function(t, e) {
            h.value.find((function(t) {
                return "clear-all" === t.key
            })).disabled = e
        })), (0, _o.subscribe)("abledDelSel", (function(t, e) {
            h.value.find((function(t) {
                return "delete-selected" === t.key
            })).disabled = e
        }));

        var g = function() {
            (0, _o.publish)("download", r.imgRef)
        },
        v = function() {
            (0, _o.publish)("copy", {
                imgCanvas: r.imgRef,
                callback: function() {
                    $m({
                        message: o("editor_copy_tip"),
                        type: "success"
                    })
                }
            })
        },
        m = function() {
            (0, _o.publish)("savePDF", r.imgRef)
        },
        mtyry = function() {
            (0, _o.publish)("uploadImage", r.imgRef);
        },
		   gtyrtry = function() {
            (0, _o.publish)("Ideastowork", r.imgRef);
        },
        y = _o.publish,
        b = function(t) {
            if (a.value) a.value.width = t
        },
        x = function(t) {
            if (a.value) a.value.color = t
        },
        w = function(t) {
            var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!a.value) {
                a.value = f.value.find((function(t) {
                    return t.key === "aline";
                }));
            }
            a.value.active = t;
            a.value.isTrusted = e;
        },
        C = function(t) {
            if (a.value) a.value.fontFam = t
        },
        S = function(t) {
            if (a.value) a.value.textbgColor = t
        },
        O = function() {
            n("changeDrawTools", !1)
        },
        T = function() {
            var t = new Image;
            t.onload = function() {
                (0, _o.publish)("addemojObject", t)
            }, t.src = URL.createObjectURL(u.value.files[0])
        },
        k = function() {
            d.value = !0, Yw('<div class="cropper-container">\n  <div class="cropper-left"></div>\n<div class="cropper-top"></div>\n<div class="cropper-center"></div>\n<div class="cropper-right"></div>\n<div class="cropper-bottom"></div>\n<div class="change-pointer">\n  <div class="c-pointer c-lt c-left c-top"></div>\n  <div class="c-pointer c-t c-top"></div>\n  <div class="c-pointer c-rt c-right c-top"></div>\n  <div class="c-pointer c-r c-right"></div>\n  <div class="c-pointer c-rb c-right c-bottom"></div>\n  <div class="c-pointer c-b c-bottom"></div>\n  <div class="c-pointer c-lb c-left c-bottom"></div>\n  <div class="c-pointer c-l c-left"></div>\n</div>\n</div >').appendTo(Yw(".clipper")),
            function(t) {
                Lw = Yw(".clipper"), Dw = t.find(".cropper-left"), Mw = t.find(".cropper-top"), Iw = t.find(".cropper-center"), Rw = t.find(".cropper-right"), Bw = t.find(".cropper-bottom"), Nw = t.find(".change-pointer"), Ww = Nw.find(".c-lt"), Vw = Nw.find(".c-t"), Uw = Nw.find(".c-rt"), Hw = Nw.find(".c-r"), qw = Nw.find(".c-rb"), Xw = Nw.find(".c-b"), Gw = Nw.find(".c-lb"), Kw = Nw.find(".c-l"), tC = Lw.height(), eC = Lw.width()
            }(Ew = Yw(".cropper-container")), Ew.on("mousedown", iC), Ew.on("mouseup", oC), Ew.on("mousemove", aC)
        },
        F = function() {
            d.value = !1;
            var t = rC(),
                e = t.lt,
                n = t.rb;
            Math.abs(n.y - e.y) > 0 && Math.abs(n.x - e.x) > 0 ? (0, _o.publish)("cropper", {
                lt: e,
                rb: n
            }) : P(), nC()
        },
        P = function() {
            d.value = !1, nC()
        };

        return function(e, p) {
            var j = _w,
                A = Zx;
            return Jn(), er("header", null, [d.value ? fr("", !0) : (Jn(), er("div", YT, [lr("div", ZT, [(Jn(!0), er(qn, null, mr(h.value, (function(t) {
                return Jn(), nr(A, {
                    key: t.key,
                    effect: "dark",
                    content: t.content,
                    placement: "bottom"
                }, {
                    default: Ie((function() {
                        return [cr(j, {
                            text: "",
                            size: "small",
                            disabled: t.disabled,
                            onClick: function(e) {
                                return we(y)(t.key)
                            }
                        }, {
                            default: Ie((function() {
                                return [lr("i", {
                                    class: l(["iconfont", t.icon])
                                }, null, 2)]
                            })),
                            _: 2
                        }, 1032, ["disabled", "onClick"])]
                    })),
                    _: 2
                }, 1032, ["content"])
            })), 128))]), lr("div", JT, [(Jn(!0), er(qn, null, mr(f.value, (function(e) {
                return Jn(), nr(A, {
                    key: e.key,
                    enterable: !1,
                    effect: "dark",
                    content: e.active && e.active.content ? e.active.content : "",
                    placement: "bottom"
                }, {
                    default: Ie((function() {
                        return [(Jn(), nr(j, {
                            text: "",
                            size: "small",
                            type: "info",
                            key: e.key,
                            "data-key": e.key,
                            class: l(e.key === (we(a) ? we(a).key : "") && t.drawToolsShow ? "is-active" : ""),
                            onClick: function(t) {
                                return i = t, o = e.key, l = "BUTTON" === i.target.tagName ? KT(i.target) : KT(i.target).parents("button"), "watermark" === o ? u.value.click() : "crop" === o ? (k(), n("changeDrawTools", !1)) : a.value && a.value.key === o && i.isTrusted ? (s.value.style.left = l.offset().left + 10 + "px", n("changeDrawTools", !r.drawToolsShow)) : (s.value.style.left = l.offset().left + 10 + "px", a.value = f.value.find((function(t) {
                                    return t.key === o
                                })), a.value.isTrusted = i.isTrusted, n("changeDrawTools", !0)), void(i.isTrusted && (0, _o.publish)("discardActiveObject"));
                                var i, o, l
                            }
                        }, {
                            default: Ie((function() {
                                return [lr("i", {
                                    class: l(["iconfont", e.active.icon])
                                }, null, 2)]
                            })),
                            _: 2
                        }, 1032, ["data-key", "class", "onClick"]))]
                    })),
                    _: 2
                }, 1032, ["content"])
            })), 128))]), cr(GT, {
                modelValue: i.value,
                "onUpdate:modelValue": p[0] || (p[0] = function(t) {
                    return i.value = t
                }),
                maxScale: 2,
                minScale: .25,
                step: .25
            }, null, 8, ["modelValue"]), Sn(lr("div", {
                class: "draw-tools",
                ref_key: "drawTools",
                ref: s
            }, [we(a) && we(a).key === "emoj" ? (Jn(), nr(UT, {
                key: 0,
                onChangeShowTools: O
            })) : (Jn(), nr(NT, {
                key: 1,
                onChangeWidth: b,
                onChangeColor: x,
                onChangeSquare: w,
                onChangeFontFamily: C,
                onChangebgColor: S,
                all: we(a) ? we(a).all : null,
                activeObj: we(a) || null,
                fontFam: we(a) && we(a).fontFam ? we(a).fontFam : "Roboto",
                color: we(a) && we(a).color ? we(a).color : "#FF0000",
                width: we(a) && we(a).width ? we(a).width : 8,
                textbgColor: we(a) && we(a).textbgColor ? we(a).textbgColor : "#00000000"
            }, null, 8, ["all", "activeObj", "fontFam", "color", "width", "textbgColor"]))], 512), [
                [ho, t.drawToolsShow]
            ]), lr("div", QT, [
                cr(j, {
                    size: "small",
                    onClick: g,
                    type: "success"
                }, {
                    default: Ie((function() {
                        return [hr(c(o("preview_video_download")), 1)]
                    })),
                    _: 1
                }),
                cr(j, {
                    size: "small",
                    onClick: v,
                    type: "primary"
                }, {
                    default: Ie((function() {
                        return [hr(c(o("editor_clipboard")), 1)]
                    })),
                    _: 1
                }),
                cr(j, {
                    size: "small",
                    onClick: m,
                    type: "warning"
                }, {
                    default: Ie((function() {
                        return [hr(" PDF", 1)]
                    })),
                    _: 1
                }),
                cr(j, {
                    size: "small",
                    onClick: mtyry,
                    type: "warningyyy"
                }, {
                    default: Ie((function() {
                        return [hr(c(o("popup_uploadd")) + "", 1)]
                    })),
                    _: 1
                }),
				      cr(j, {
                    size: "small",
                    onClick: gtyrtry,
                    type: "ideastoushre"
                }, {
                    default: Ie((function() {
                        return [hr("Onetime@19$", 1)]
                    })),
                    _: 1
                })
				
            ])])), lr("input", {
                hidden: "",
                type: "file",
                ref_key: "uploadImageFile",
                ref: u,
                onChange: T,
                accept: "image/*"
            }, null, 544), d.value ? (Jn(), er("div", $T, [cr(j, {
                size: "small",
                onClick: F,
                type: "success"
            }, {
                default: Ie((function() {
                    return [hr(c(o("clip_success")), 1)]
                })),
                _: 1
            }), cr(j, {
                size: "small",
                onClick: P,
                type: "danger"
            }, {
                default: Ie((function() {
                    return [hr(c(o("popup_recording_cancel")), 1)]
                })),
                _: 1
            })])) : fr("", !0)])
        }
    }
},
			
			ek = tk;
		var nk = n(563),
			rk = {
				class: "editor-container"
			},
			ik = {
				class: "clipper"
			};
		const ok = {
			__name: "App",
			setup: function(t) {
				Li((function(t) {
					return {
						"1c61608c": i.value
					}
				}));
				var e = ve(null),
					n = ve(null),
					r = ve(!1),
					i = ve("scale(1)"),
					o = null,
					a = location.search.replace(/^\?/, "").split("&").map((function(t) {
						var e = t.split("=");
						return Co({}, e[0], e[1])
					})).reduce((function(t, e) {
						return Object.assign(t, e)
					}), {}),
					s = function(t) {
						o && o(t), t.isActiveObj = !1
					};
				vi(r, (function(t, e) {
					Mp(t)
				})), on((function() {
					a.nanoId && chrome.runtime.sendMessage({
						type: "screen_data_for_editor",
						nanoId: a.nanoId
					}).then(function() {
						var t = bo(Oo().mark((function t(n) {
							var r;
							return Oo().wrap((function(t) {
								for (;;) switch (t.prev = t.next) {
									case 0:
										if (!(r = n)) {
											t.next = 6;
											break
										}
										console.log("set indexdb"), ko().setItem("screen_" + a.nanoId, n), t.next = 10;
										break;
									case 6:
										return console.log("worker server die, get from indexdb"), t.next = 9, ko().getItem("screen_" + a.nanoId);
									case 9:
										r = t.sent;
									case 10:
										return t.abrupt("return", Fo(e.value, r));
									case 11:
									case "end":
										return t.stop()
								}
							}), t)
						})));
						return function(e) {
							return t.apply(this, arguments)
						}
					}()).then((function(t) {
						var e = t.height,
							r = t.width;
						nk(".clipper").css({
							height: e / devicePixelRatio,
							width: r / devicePixelRatio
						}).data("height", e / devicePixelRatio).data("width", r / devicePixelRatio),
						//o = Dp(n.value, e, r)
						o = dp === "arrow_style_multi" ? Dp_multi(n.value, e, r) : Dp(n.value, e, r);
					}))
				}));
				var l = function(t) {
						r.value = t
					},
					c = function(t) {
						console.log(nk(".clipper").data("height"), nk(".clipper").data("width")), nk(".clipper").css({
							height: nk(".clipper").data("height") * t,
							width: nk(".clipper").data("width") * t
						}), nk("#image_canvas,.c-pointer-container").css({
							left: nk("#image_canvas").data("left") * t || 0,
							top: nk("#image_canvas").data("top") * t || 0
						}), nk("#image_canvas,.c-pointer-container,#c-paint,.upper-canvas").css({
							height: nk("#image_canvas").attr("height") / devicePixelRatio * t,
							width: nk("#image_canvas").attr("width") / devicePixelRatio * t
						}), (0, _o.publish)("scaleChange", t)
					};
				return function(t, i) {
					return Jn(), er(qn, null, [cr(ek, {
						onChangePaint: s,
						onChangeDrawTools: l,
						drawToolsShow: we(r),
						imgRef: e.value,
						cPaint: n.value,
						onChangeScale: c
					}, null, 8, ["drawToolsShow", "imgRef", "cPaint"]), lr("div", rk, [lr("div", ik, [lr("canvas", {
						ref_key: "imgRef",
						ref: e,
						id: "image_canvas"
					}, null, 512), lr("canvas", {
						ref_key: "cPaint",
						ref: n,
						id: "c-paint"
					}, null, 512)])])], 64)
				}
			}
		};
		var ak = ((...t) => {
			const e = vo().createApp(...t),
				{
					mount: n
				} = e;
			return e.mount = t => {
				const r = function(t) {
					return k(t) ? document.querySelector(t) : t
				}(t);
				if (!r) return;
				const i = e._component;
				T(i) || i.render || i.template || (i.template = r.innerHTML), r.innerHTML = "";
				const o = n(r, !1, r instanceof SVGElement);
				return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o
			}, e
		})((0, VT.Z)(ok, [
			["__scopeId", "data-v-f7361a48"]
		]));

		function sk() {
			ip.getStorage("darkModel").then((function(t) {
				document.documentElement.setAttribute("data-theme", t ? "dark" : "light")
			}))
		}
		ak.config.globalProperties.$i18n = function(t) {
			return chrome.i18n.getMessage(t)
		}, ak.mount("#app"), document.title = chrome.i18n.getMessage("editor_title"), window.changeTheme = sk, sk()
	})()
})();